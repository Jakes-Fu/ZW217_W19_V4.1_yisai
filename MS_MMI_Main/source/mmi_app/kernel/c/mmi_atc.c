/******************************************************************************
 ** File Name:      mmi_nmcmd.c                                                   *
 ** Author:         Jassmine.Meng                                             *
 ** DATE:           2003.05.29                                                *
 ** Copyright:      2002 Spreadtrum, Incorporated. All Rights Reserved.         *
 ** Description:    define the AT cmd , SMS net manage command , cryptogram   *
 **                 cmd , and the handling function
 ******************************************************************************

 ******************************************************************************
 **                        Edit History                                       *
 ** ------------------------------------------------------------------------- *
 ** DATE           NAME             DESCRIPTION                               *
 ** 05/29/2003    Jassmine.Meng       Create.                                   *
 ******************************************************************************/
//#include "std_header.h"
//#include    "sci_types.h"
//#include    "tb_hal.h"
#include "mmi_app_kernel_trc.h"
#include "mmi_nv.h"
#ifdef MMI_SYNCTOOL_V3
#include    "mmi_atc.h"
#include    "mmk_type.h"
#include    "mmi_appmsg.h"
#include    "mmisms_export.h"
#include    "mmipb_atc.h"
#include  "mmischedule_atc.h"
#include    "mmialarm_export.h"
//#include	"mmimultim.h"
#include	"tb_hal.h"
#include	"mmidc_export.h"
//#include    "mmiudisk.h"
#include	"mmiphone_export.h"
#include "mmiudisk_export.h"
#include "mmimms_export.h"
#include "mmi_nv.h"
//mod by shuyanhu for at+sytin
#ifdef BROWSER_SUPPORT
#include "mmibrowser_export.h"
#endif
#include "gui_ucs2b_converter.h"
#include "mmieng_nv.h"
#include "mmiconnection_export.h"
//#include "mmieng.h"

//add by shuyanhu for at+sytin---start
#include "mmifmm_export.h"
#include "mmifmm_export.h"
#include "mmipb_adapt.h"
#include "mmi_mainmenu_export.h"
#ifdef PUSH_EMAIL_SUPPORT
#include "mmimail_export.h"
#endif /* PUSH_EMAIL_SUPPORT */
#ifdef VT_SUPPORT
#include "mmivt_export.h"
#endif 
//#include "mmiset.h"
#include "mmiset_export.h"
#ifdef MMI_KEY_LOCK_SUPPORT
#include "Mmikl_export.h"
#endif
#include "mmipb_export.h"
//add by shuyanhu for at+sytin---end 
#include "mmiset_func.h"
#ifdef ENG_SUPPORT
#include "mmieng_export.h"
#include "mmieng_win.h"
#include "mmieng_main.h"
#endif
//add by xiaolei.zheng for gui control test ---start
#ifdef ATEST_SUPPORT
#include "mmk_kbd.h"
#include "mmk_app.h"
#include "mmiset_func.h"
#include "mmk_tree.h"
#include "mmk_msg.h"
#include "sci_api.h"
#include "guirichtext.h"
#include "guidropdownlist.h"
#include "guimenu.h"
#include "guitips.h"
#include "guibutton.h"
#include "guititle.h"
#include "guitoolbar.h"
#include "guiscrollkey.h"
#include "guitab.h"
#include "guilcd.h"
#include "guistatusbar.h"
#include "guistatusbar_data.h"
#include "guilistbox.h"
#include "guianim.h"
#include "guiimg.h"
#include "guitext.h"
#include "guiprgbox.h"
#include "guiownerdraw.h"
#include "guisetlist.h"
#include "guiim.h"
#include "guilabel.h"
#include "guiform.h"
#include "guimsgbox.h"
#include "guiiconlist.h"
#include "mmk_window_internal.h"
#include "ctrltitle.h"
#include "ctrltab.h"
#include "ctrlim.h"
#include "mmiim_touch_common.h"
#include "mmiset_export.h"
#include "mmialarm_export.h"
#include "mmicalendar_export.h"
#include "Mmi_mainmenu_istyle.h"
#include "ctrldropdownlist.h"
#include "ctrlmenu.h"
#include "Ctrlanim.h"
#include "Ctrlstatusbar.h"
#include "ctrlownerdraw.h"
#include "Ctrltext.h"
#include "Ctrlform.h"
#include "Ctrliconlist.h"
#include "Ctrltips.h"
#include "Ctrlscrollkey.h"
#include "Ctrlrichtext.h"
#include "Ctrltext.h"
#include "Ctrlprogressbar.h"
#include "Ctrlmsgbox.h"
#include "Ctrlbutton.h"
#include "Ctrliconlist.h"
//#include "Ctrltoolbar.h"
#include "Ctrlsetlist.h"
#include "Ctrlbaseedit.h"
#include "ctrllistedit.h"
#include "Ctrldropdownlist.h"
#include "Ctrlsoftkey.h"
#include "Ctrllistbox.h"
#include "Ctrlprogress.h"
#include "Ctrliconfolder.h"
#include "ctrlmainmenu.h"
#include "Mmi_link.h"
#include "ctrllabel.h"
#include "mmi_mainmenu_sweets.h"
#include "mmi_mainmenu_slide_page.h"
#include "mmi_mainmenu_matrix.h"
#include "mmi_mainmenu_qbtheme.h"
#endif // ATEST_SUPPORT
//add by xiaolei.zheng for gui control test ---end
#ifdef DCD_SUPPORT
#include "mmidcd_export.h"
#endif
#ifdef PLATFORM_UWS6121E
#include "env_atc_signal.h"
#endif
/**--------------------------------------------------------------------------*
 **                         MACRO DEFINITION                                 *
 **--------------------------------------------------------------------------*/
#define PB_ITEM_READ_MAX_NUM 100
#define PBGROUP_ITEM_READ_MAX_NUM 30

#define SMS_DELETE_PARAM_NUM 3

#define PHOTO_DIRECTORY     "photo"
#define PICTURE_DIRECTORY   "picture"
#define DIRECTORY_SYMBOL    '/'

#define MAX_RESCMD_LEN      2048
#define PB_ENTRY_ID_MAX_LEN 4

#ifdef ATEST_SUPPORT
// add by xiaolei.zheng for gui control test
#define ATEST_MAX_SEND_LEN   256

// add by lin.chen for gui search control item
#define ATEST_MAX_STR_LEN	250	
#define ATEST_RECT_LIMIT	100
#endif

/**-------------------------------------------------------------------------*
**                         GLOBAL DEFINITION                                *
**--------------------------------------------------------------------------*/
#if 0//ndef _WIN32
LOCAL BOOLEAN s_atc_is_run = FALSE;
#endif

//add by shuyan.hu for Atest pb create 
LOCAL uint8 *s_pb_name = NULL;
LOCAL uint8 *s_pb_number = NULL;
LOCAL MMIPB_HANDLE_T s_handle_pb = NULL;
LOCAL uint16 s_MMIPB_Create_ID  = MN_DUAL_SYS_1;
LOCAL BOOLEAN s_pbcreatesim = FALSE;

//extern MMIPB_SORT_AND_ENTRY_ID_T   g_mmipb_entry_list;
#ifndef WIN32
extern BOOLEAN ATC_WriteCmdRsp(uint8 * buf_ptr, uint32 len);
#ifdef DM_SUPPORT
extern void MMIDM_SetDmRegSwitchState(BOOLEAN mode);
#endif
#ifdef DSP_USB_LOG
extern void REFPARAM_SetDspDebugPortPhyNo(uint8 phy_port);
#endif
#endif

typedef struct _PB_NUMBER_PARSE_STRUCT_
{
    PB_NUMBER_TYPE_E number_type;
    char* type_tag;
}PB_NUMBER_PARSE_STRUCT_T;

PB_NUMBER_PARSE_STRUCT_T s_pb_number_tag[]={
    {PB_MOBILE_NUMBER,PB_MOBILE_TAG},
    {PB_WORK_NUMBER,PB_WORK_TAG},
    {PB_HOME_NUMBER,PB_HOME_TAG},
    {PB_FAX_NUMBER,PB_FAX_TAG},
};
//add by lin.chen for return cur language ---start
#ifdef ATEST_SUPPORT
#ifdef MATRIX_MAIN_MENU_SUPPORT
typedef struct
{
    MMI_HANDLE_T                win_handle;                             //window handle
    MMI_HANDLE_T                ctrl_handle;

    GUIMENU_ICONMENU_DATA_T     icon_data;

    GUIMENU_STATE_T             menu_state;
    BOOLEAN                     is_static;                              //is static menu
    BOOLEAN                     is_focus_title;                         //title is focus for option page
    BOOLEAN                     is_title_style;

    uint16                      cur_page_index;                         //default 0,from 0 to max-1
    uint16                      cur_item_index;                         //current selected menu index. in option page style, it is also item index
    uint16                      first_item_index;                       //item index at the top
    int16                       offset_y;                               //offset y
    uint16                      pre_cur_item_index;                     //previous current index
    uint16                      item_total_num;                         //current total visible item number. in option page style, it is page count.

    BOOLEAN                     is_need_prgbox;                         //is need prgbox or not
    BOOLEAN                     is_revise_rect;                         //is need revise rect or not，当增加滚动条的时候，需要重新调整区域
    IGUICTRL_T                  *prgbox_ctrl_ptr;                       //progress box control pointer

    MMITHEME_MAINMENU_COMMON_T  main_menu_theme;                        //main menu theme

    MMIMAINEMENU_ITEM_LIST_T    menu_list_info;                         //menu list information

    MMK_TP_SLIDE_E              slide_state;
    BOOLEAN                     is_move_state;                          //item是否在抖动
    BOOLEAN                     is_moving;                              //item是否被拖动
    BOOLEAN                     is_item_pressed;                        //tp down时，是否在item上
    BOOLEAN                     is_tp_pressed;                          //is tp down?

    float                       fling_velocity;                         //滑动速度
    GUIMENU_ENTER_ANIM_TYPE_E   enter_anim_type;                        // 进入时的动画类型

    // mainmenu button
    MMI_HANDLE_T                button_handle[GUIMENU_BUTTON_NUM];      // button控件
    GUI_RECT_T                  writeback_rect;//双buffer回写

    GUIMENU_SOFTKEY_STATE_T     softkey_state;                          //softkey的状态，目前只有主菜单使用

    GUI_LCD_DEV_INFO            highlight_layer_handle;
    GUI_LCD_DEV_INFO            icon_move_layer_handle;
    uint32                      start_item_index;
    uint16                      tmp_cur_item_index;                     //移动的时候使用
    GUI_RECT_T                  move_rect;
    CONTINUE_MOVE_TYPE_E        continue_move_type;

    GUI_POINT_T                 slide_start_point;                      //Slide时候使用
    GUI_POINT_T                 slide_pre_point;                        //Slide时候使用

    MMK_TP_SLIDE_E              tpdown_slide_state;                     //slide state when tp down

    uint16                      tmp_width;                              //移动的时候使用
    uint16                      tmp_height;                             //移动的时候使用

    uint16                      tmp_first_item_index;                   //移动的时候使用

    uint8                       slide_timer_id;                         // 滑动时，slide和fling状态下，画图的timer
    uint16                      pre_msg_loop_page_index;                // 每次消息循环后，focus page index
    uint16                      pre_msg_loop_item_index;                // 每次消息循环后，focus项index
    uint16                      pre_msg_loop_menu_level;                // 每次消息循环后，focus项的level
    uint16                      menu_level;                             //menu level
    
} MMIMAINMENU_MATRIX_DATA_T;
#endif

#ifdef QBTHEME_SUPPORT
typedef struct
{
    MMI_HANDLE_T                win_handle;                             //window handle
    MMI_HANDLE_T                ctrl_handle;

    MMITHEME_MAINMENU_COMMON_T  main_menu_theme;                        //main menu theme
    GUIMENU_QBTHEME_DATA_T      qbtheme_menu_data;                      //千变主题菜单数据以及排版 

    MMIMAINEMENU_PAGE_LIST_T    menu_page_info;                         //menu list information
    MMIMAINEMENU_ITEM_LIST_T    menu_bar_info;                          //menu bar information

    GUIMENU_STATE_T             menu_state;

    uint16                      cur_page_index;                         //default 0,from 0 to max-1
    uint16                      cur_item_index;                         //current selected menu index. in option page style, it is also item index
    uint16                      first_item_index;                       //item index at the top
    uint16                      pre_cur_item_index;                     //previous current index
    uint16                      page_total_num;                         //TODO: total_page_num;

    BOOLEAN                     is_active;                              //
    BOOLEAN                     is_delete_state;                        //item是否在抖动
    BOOLEAN                     is_move_state;                          //item是否在抖动
    BOOLEAN                     is_moving;                              //item是否被拖动
    BOOLEAN                     is_empty_space;                         //tp up时，是否在item上
    BOOLEAN                     is_item_pressed;                        //tp down时，是否在item上
    BOOLEAN                     is_tp_pressed;                          //is tp down?
    BOOLEAN                     is_bar_item;                            //is bar item

    uint16                      tmp_cur_item_index;                     //移动的时候使用
    uint16                      tmp_first_item_index;                   //移动的时候使用
    uint16                      tmp_page_item_index;                    //移动到时候使用
    BOOLEAN                     tmp_is_bar_item;                        //移动的时候使用
    uint16                      move_item_index;                        //移动的item项，用于给idle和删除用

    uint16                      tmp_width;                              //移动的时候使用
    uint16                      tmp_height;                             //移动的时候使用
    
    CONTINUE_MOVE_TYPE_E 	    continue_move_type;	                    // 连续移动的类型
    uint8                       tp_timer_id;				            // 为支持TP连续移动而加的timer
    uint8                       redrew_timer_id;				        // 滑动时，slide和fling状态下，画图的timer
    uint8                       start_move_timer_id;				    // 进入抖动状态的定时器
    uint8                       shake_icon_timer_id;				    // 进入抖动状态时，每次抖动的间隔
    uint8                       user_timer_id;				            // 应用自定义的timer
    uint8                       highlight_timer_id;				        // 

    BOOLEAN                     is_display_item_layer;                  // 是否画item layer的数据

    GUI_LCD_DEV_INFO            highlight_layer_handle;                 //高亮层
    GUI_LCD_DEV_INFO            icon_move_layer_handle;                 //图标移动层
	GUI_LCD_DEV_INFO			to_idle_layer_handle;                   //到主菜单图层

    MMK_TP_SLIDE_E              slide_state;                            //current slide state
    MMI_MENU_ID_T               delete_menu_id;                         //组织状态下使用,要删除的menu_id
    GUI_POINT_T                 slide_start_point;                      //Slide时候使用
    GUI_POINT_T                 slide_pre_point;                        //Slide时候使用
    GUI_POINT_T                 pre_tp_point;                           //上一次tp move的坐标
    GUI_LCD_DEV_INFO            page_layer_handle[GUIMENU_SLIDE_PAGE_NUM]; //页面移动层1
    GUI_LCD_DEV_INFO            titleidx_layer_handle;                  // 页面索引层
    // end

    float                       fling_velocity;                         //滑动速度
    GUIMENU_GO_SLIDE_TYPE_E      support_slide_type;                    //主菜单支持的滑动类型
    GUI_LCD_DEV_INFO            layer_bg; 

    GUIMENU_ENTER_ANIM_TYPE_E   enter_anim_type;                        // 进入时的动画类型
    uint8  init_item_timer_id;
    GUI_LCD_DEV_INFO			delete_layer_handle;                    //删除图层
// 以下应该用控件的数据
    GUI_LCD_DEV_INFO            lcd_dev_info;                           // 页面索引层
    GUI_RECT_T                  rect;
} MMIMAINMENU_QBTHEME_DATA_T;
#endif

#ifdef PDA_UI_SUPPORT_MANIMENU_GO
typedef struct
{
    MMI_HANDLE_T                win_handle;                             //window handle
    MMI_HANDLE_T                ctrl_handle;

    GUIMENU_STATE_T             menu_state;
    GUIMENU_SLIDEMENU_DATA_T    slide_data;
    MMITHEME_MAINMENU_COMMON_T  main_menu_theme;                        // main menu theme
    MMIMAINEMENU_ITEM_LIST_T    menu_list_info;                         // menu list information

    MMI_HANDLE_T                button_handle[GUIMENU_BUTTON_NUM];      // button控件

    GUI_LCD_DEV_INFO            page_layer_handle[GUIMENU_SLIDE_PAGE_NUM];    //页面移动层1
    GUI_LCD_DEV_INFO            titleidx_layer_handle;                  // 页面索引层
    GUI_LCD_DEV_INFO            highlight_layer_handle;                 // 高亮层
    GUI_LCD_DEV_INFO            icon_move_layer_handle;                 // 图标移动层
    GUI_LCD_DEV_INFO            cube_layer_handle;                      //  立方体层
    GUI_LCD_DEV_INFO			to_idle_layer_handle;                   //到主菜单图层
    GUI_LCD_DEV_INFO			delete_layer_handle;                    //删除图层
    MMIMAINEMENU_PAGE_LIST_T    menu_page_info;                         //menu list information

    BOOLEAN                     is_move_state;                          // item是否在抖动
    BOOLEAN                     is_delete_state;                        // item是否在抖动
    BOOLEAN                     is_active;                              // is active
    BOOLEAN                     is_tp_pressed;                          // is tp down
    BOOLEAN                     is_item_pressed;                        // tp down时，是否在item上
    BOOLEAN                     is_empty_space;                         //tp up时，是否在item上

    MMK_TP_SLIDE_E              slide_state;                            // current slide state
    GUI_POINT_T                 slide_start_point;                      // Slide时候使用
    GUI_POINT_T                 slide_pre_point;                        // Slide时候使用
    GUI_POINT_T                 pre_tp_point;                           // 上一次tp move的坐标
    CONTINUE_MOVE_TYPE_E        continue_move_type;                     // 连续移动的类型

    uint8                       redrew_timer_id;                        // 滑动时，slide和fling状态下，画图的timer
    uint8                       init_item_timer_id;
    uint8                       shake_icon_timer_id;
    uint8                       start_move_timer_id;
    MMI_MENU_ID_T               delete_menu_id;                         // 组织状态下使用,要删除的menu_id

    uint16                      pre_cur_item_index;                     // previous current index
    uint16                      first_item_index;                       // item index at the top
    uint16                      tmp_width;                              // 移动的时候使用
    uint16                      tmp_height;                             // 移动的时候使用
    uint16                      tmp_cur_item_index;                     // 移动的时候使用
    uint16                      tmp_first_item_index;                   // 移动的时候使用
    uint16                      tmp_page_item_index;                    // 移动到时候使用

    float                       fling_velocity;                         // 滑动速度

    BOOLEAN                     is_display_title;                       // 是否显示title
    BOOLEAN                     is_display_item_layer;

    uint16                      item_total_num;
    uint16                      cur_page_index;                         // default 0,from 0 to max-1
    uint16                      cur_item_index;                         // current selected menu index. in option page style, it is also item index
#if defined(PDA_UI_SUPPORT_MANIMENU_GO)
    GUI_LCD_DEV_INFO            layer_bg;
    GUIMENU_GO_SLIDE_TYPE_E     support_slide_type;                     // 主菜单支持的滑动类型
    uint8                       highlight_timer_id;                     //  highlight显示的timer ID
#endif
    uint16                      pre_msg_loop_page_index;                // 每次消息循环后，focus page index
    uint16                      pre_msg_loop_item_index;                // 每次消息循环后，focus项index
    uint16                      pre_msg_loop_menu_level;                // 每次消息循环后，focus项的level
    uint16                      menu_level;                             //menu level

} MMIMAINMENU_SLIDEPAGE_DATA_T;
#endif

#ifdef MENU_SWEETS_SUPPORT
typedef struct
{

    MMI_HANDLE_T                win_handle;                             //window handle
    MMI_HANDLE_T                ctrl_handle;

    GUIMENU_STATE_T             menu_state;
    BOOLEAN                     is_active;
    
    uint16                      cur_page_index;                         //default 0,from 0 to max-1
    uint16                      cur_item_index;                         //current selected menu index. in option page style, it is also item index
    uint16                      item_total_num;                         //current total visible item number. in option page style, it is page count.

    MMI_MENU_GROUP_ID_T         cur_group_id;                           //current menu group id
 

    MMITHEME_MAINMENU_COMMON_T  main_menu_theme;                        //main menu theme

    MMIMAINEMENU_ITEM_LIST_T    menu_list_info;                         //menu list information
    uint32                      start_item_index;

    BOOLEAN                     is_move_state;                          //item是否在抖动
    BOOLEAN                     is_moving;                              //item是否被拖动
    BOOLEAN                     is_item_pressed;                        //tp down时，是否在item上
    BOOLEAN                     is_tp_pressed;                          //is tp down?

    
    //CONTINUE_MOVE_TYPE_E 	    continue_move_type;	                    // 连续移动的类型
    uint8                       redrew_timer_id;				        // 滑动时，slide和fling状态下，画图的timer

    BOOLEAN                     is_display_title;                       // 是否显示title

    MMK_TP_SLIDE_E              slide_state;                            //current slide state
    GUI_POINT_T                 slide_start_point;                      //Slide时候使用
    GUI_POINT_T                 slide_pre_point;                        //Slide时候使用

    GUI_LCD_DEV_INFO            titleidx_layer_handle;                  // 页面索引层

    float                       fling_velocity;                         //滑动速度
    GUIMENU_ENTER_ANIM_TYPE_E   enter_anim_type;                        // 进入时的动画类型

    uint16                      pre_msg_loop_page_index;                // 每次消息循环后，focus page index
    uint16                      pre_msg_loop_item_index;                // 每次消息循环后，focus项index
    uint16                      pre_msg_loop_menu_level;                // 每次消息循环后，focus项的level

    uint32			            icon_shake_period;	                    // icon 震动时间间隔
    uint32			            auto_move_period;	                    // 支持连续移动的时间间隔
} MMIMAINMENU_SWEETS_DATA_T;
#endif

extern int stricmp (const char *a, const char *b);

uint8 *receive_data_arr = PNULL;

ATEST_CUR_LANG_T cur_lang[]= 
{
#ifdef MMI_SIM_LANGUAGE_SUPPORT
    	{MMISET_LANGUAGE_AUTO, "AUTO"},     
#endif
	{MMISET_LANGUAGE_ENGLISH,"ENGLISH"},
 	{MMISET_LANGUAGE_SIMP_CHINESE,"SIMP_CHINESE"},
	{MMISET_LANGUAGE_TRAD_CHINESE,"TRAD_CHINESE"},
	{MMISET_LANGUAGE_ARABIC,"ARABIC"},    
	{MMISET_LANGUAGE_FRENCH,"FRENCH"},    
	{MMISET_LANGUAGE_HINDI,"HINDI"},      
	{MMISET_LANGUAGE_HUNGARIAN,"HUNGARIAN"},     
	{MMISET_LANGUAGE_INDONESIAN,"INDONESIAN"},   
	{MMISET_LANGUAGE_MALAY,"MALAY"},     
	{MMISET_LANGUAGE_PORTUGUESE,"PORTUGUESE"},   
	{MMISET_LANGUAGE_RUSSIAN,"RUSSIAN"},   
	{MMISET_LANGUAGE_SPANISH,"SPANISH"},    
	{MMISET_LANGUAGE_TAGALOG,"TAGALOG"},   
	{MMISET_LANGUAGE_THAI,"THAI"},         
	{MMISET_LANGUAGE_VIETNAMESE,"VIETNAMESE"},   
	{MMISET_LANGUAGE_URDU,"URDU"},          
   	{MMISET_LANGUAGE_ITALIAN,"ITALIAN"},    
    {MMISET_LANGUAGE_PERSIAN,"PERSIAN"},    
    {MMISET_LANGUAGE_TURKISH,"TURKISH"},    
    {MMISET_LANGUAGE_GERMAN,"GERMAN"},      
    {MMISET_LANGUAGE_GREEK,"GREEK"},        
    {MMISET_LANGUAGE_HEBREW,"HEBREW"},      
	{MMISET_LANGUAGE_BENGALI,"BENGALI"},    
	{MMISET_LANGUAGE_CZECH,"CZECH"},        
    {MMISET_LANGUAGE_SLOVENIAN,"SLOVENIAN"},
	{MMISET_LANGUAGE_ROMANIAN,"ROMANIAN"},  
    {MMISET_LANGUAGE_TELUGU,"TELUGU"},
	{MMISET_LANGUAGE_MARATHI,"MARATHI"},
	{MMISET_LANGUAGE_TAMIL,"TAMIL"},
	{MMISET_LANGUAGE_GUJARATI,"GUJARATI"},
	{MMISET_LANGUAGE_KANNADA,"KANNADA"},
    {MMISET_LANGUAGE_MALAYALAM,"MALAYALAM"},
    {MMISET_LANGUAGE_ORIYA,"ORIYA"},
    {MMISET_LANGUAGE_PUNJABI,"PUNJABI"},
    {MMISET_LANGUAGE_AFRIKAANS,"AFRIKAANS"},
    {MMISET_LANGUAGE_ALBANIAN,"ALBANIAN"},
    {MMISET_LANGUAGE_ARMENIAN,"ARMENIAN"},
    {MMISET_LANGUAGE_AZERBAIJANI,"AZERBAIJANI"},
    {MMISET_LANGUAGE_BASQUE,"BASQUE"},
    {MMISET_LANGUAGE_BULGARIAN,"BULGARIAN"},
    {MMISET_LANGUAGE_CATALAN,"CATALAN"},
    {MMISET_LANGUAGE_CROATIAN,"CROATIAN"},
    {MMISET_LANGUAGE_DANISH,"DANISH"},
 	{MMISET_LANGUAGE_DUTCH,"DUTCH"},
 	{MMISET_LANGUAGE_ESTONIAN,"ESTONIAN"},
 	{MMISET_LANGUAGE_FILIPINO,"FILIPINO"},
 	{MMISET_LANGUAGE_FINNISH,"FINNISH"},
    {MMISET_LANGUAGE_GALICIAN,"GALICIAN"},
    {MMISET_LANGUAGE_GEORGIAN,"GEORGIAN"},
    {MMISET_LANGUAGE_HAUSA,"HAUSA"},
    {MMISET_LANGUAGE_ICELANDIC,"ICELANDIC"},
    {MMISET_LANGUAGE_IGBO,"IGBO"},
    {MMISET_LANGUAGE_IRISH,"IRISH"},
    {MMISET_LANGUAGE_KAZAKH,"KAZAKH"},
    {MMISET_LANGUAGE_LATVIAN,"LATVIAN"},
    {MMISET_LANGUAGE_LITHUANIAN,"LITHUANIAN"},
    {MMISET_LANGUAGE_MACEDONIAN,"MACEDONIAN"},
    {MMISET_LANGUAGE_MOLDOVAN,"MOLDOVAN"},
    {MMISET_LANGUAGE_NORWEGIAN,"NORWEGIAN"},
    {MMISET_LANGUAGE_POLISH,"POLISH"},
    {MMISET_LANGUAGE_SERBIAN,"SERBIAN"},
    {MMISET_LANGUAGE_SESOTHO,"SESOTHO"},
    {MMISET_LANGUAGE_SLOVAK,"SLOVAK"},
    {MMISET_LANGUAGE_SWEDISH,"SWEDISH"},
    {MMISET_LANGUAGE_UKRAINIAN,"UKRAINIAN"},
    {MMISET_LANGUAGE_YORUBA,"YORUBA"},
    {MMISET_LANGUAGE_XHOSA,"XHOSA"},
    {MMISET_LANGUAGE_ZULU,"ZULU"},
    {MMISET_LANGUAGE_ASSAMESE,"ASSAMESE"},
    {MMISET_LANGUAGE_SWAHILI,"SWAHILI"},
    {MMISET_LANGUAGE_MYANMAR,"MYANMAR"},
    {MMISET_LANGUAGE_AMHARIC,"AMHARIC"},
    {MMISET_LANGUAGE_KHMER,"KHMER"},
    {MMISET_LANGUAGE_LAO,"LAO"},
	{MMISET_MAX_LANGUAGE,"others"}
};
#endif  //ATEST_SUPPORT

/*---------------------------------------------------------------------------*/
/*                          LOCAL FUNCTION DECLARE                           */
/*---------------------------------------------------------------------------*/
/*****************************************************************************/
// 	Description : If the cmd is match the indication
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN IsMatchIndication(
				                uint8 *cmd,  // Point to the command infomation buffer
				                uint32 len,   // The length of command infomation buffer
                                const char* ind_ptr //the indication
				                );

/*****************************************************************************/
// 	Description : This function parse at cmd wich from sync tool
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN ParseSyncAtCmd(
					      uint8 *cmd,  // Point to the command infomation buffer
					      uint32 len   // The length of command infomation buffer
					      );

/*****************************************************************************/
// 	Description : This function parse at atuo test cmd
//	Global resource dependence : none
//  Author:      
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN ParseSyncUTAtCmd(
					      uint8 *cmd,  // Point to the command infomation buffer
					      uint32 len   // The length of command infomation buffer
					      );
/*****************************************************************************/
// 	Description : This function handle the pb getinfo command
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandlePbGetInfo(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );

/*****************************************************************************/
// 	Description : This function handle the pb get one item command
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandlePbReadItem(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );

/*****************************************************************************/
// 	Description : This function handle the pb add command
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandlePbAdd(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );
/*****************************************************************************/
// 	Description : This function handle the pb delete command
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandlePbDelete(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );
/*****************************************************************************/
// 	Description : This function handle the pb modify command
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandlePbModify(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );
/*****************************************************************************/
// 	Description : This function getentry id from cmd string,there may be more
//  than one entry id
//	Global resource dependence : none
//  Author: Xiaohua.liu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN GetMoreThanOneEntryId(char* cmd, uint16 len,uint16* id_out,uint16 max_id);
/*****************************************************************************/
// 	Description : This function get pb entry id from cmd string,there may be more
//  than one entry id
//	Global resource dependence : none
//  Author: Xiaohua.liu
//	Note:
/*****************************************************************************/
LOCAL uint16* GetPbEntryIdFromIntervalStr(char* interval_str_ptr, 
    char* separa_pos,uint16* id_out,uint16 max_id,BOOLEAN* result);

/*****************************************************************************/
// 	Description : This function handle the sms deletecommand
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleSmsDelete(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );

/*****************************************************************************/
// 	Description : This function handle the sms deletecommand
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleSmsSendMsg(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );
#ifdef PUSH_EMAIL_SUPPORT
/*****************************************************************************/
// 	Description : send Input string  message
//	Global resource dependence : none
//  Author: Jiaoyou.wu
//	Note:   codeformat(1 byte) + message string
/*****************************************************************************/
LOCAL BOOLEAN HandlePushMailSendMsg(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );
#endif
/*****************************************************************************/
// 	Description : send sms message
//	Global resource dependence : none
//  Author:     
//	Note:   codeformat(1 byte) + message string
/*****************************************************************************/
LOCAL BOOLEAN HandleMMSSendMsg(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );

/*****************************************************************************/
// 	Description : send sms message
//	Global resource dependence : none
//  Author:     
//	Note:   codeformat(1 byte) + message string
/*****************************************************************************/
LOCAL BOOLEAN HandleWAPInputURL(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );

/*****************************************************************************/
// 	Description : connection setting
//	Global resource dependence : none
//  Author:     
//	Note:   codeformat(1 byte) + message string
/*****************************************************************************/
LOCAL BOOLEAN HandleConnection(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );

/*****************************************************************************/
// 	Description : send string or struct from cmd
//	Global resource dependence : none
//  Author:     
//	Note:   
/*****************************************************************************/
LOCAL void* GetATCParameter(uint32 text_format,
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 cmd_len,   // The length of command infomation buffer
								uint32 struct_size//if text_format is MMI_ATC_STRUCT, this size must be input
                                );

/*****************************************************************************/
// 	Description : get next string from cmd
//	Global resource dependence : none
//  Author:     
//	Note:   
/*****************************************************************************/
LOCAL BOOLEAN GetATCNextString( uint8 *cmd,  // Point to the command infomation buffer
					            uint32 cmd_len,   // The length of command infomation buffer
								uint8 *next_str_ptr,//OUT
								uint8 next_str_max_len//IN
                                );

/*****************************************************************************/
// 	Description : This function get string finished by finish_char
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
//LOCAL BOOLEAN GetString(
//                        uint8* dest_str_ptr, 
//                        uint32 max_len, 
//                        uint8* src_str_ptr, 
//                        uint32 src_str_len,
//                        uint8 finish_char
//                         );

/*****************************************************************************/
// 	Description : This function return response to at
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL void ReturnResponse(
                            uint8* res_ptr,
                            uint16 len
                            );
/*****************************************************************************/
// 	Description : This function judge pb paramter
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN GetPbStorage(
                     uint8 *pos, 
                     uint8 cmd_char
                     );
/*****************************************************************************/
// 	Description : This function get pb entry id from cmd string
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL uint32 GetEntryId(
                    char* cmd, 
                    uint16 len);

/*****************************************************************************/
// 	Description : This function handle the group getinfo command
//	Global resource dependence : none
//  Author:      liqing.peng
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleGroupGetInfo(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );

/*****************************************************************************/
// 	Description : This function handle the group get one item command
//	Global resource dependence : none
//  Author:      liqing.peng
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleGroupReadItem(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );

/*****************************************************************************/
// 	Description : This function handle the group add command
//	Global resource dependence : none
//  Author:      liqing.peng
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleGroupAdd(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );
/*****************************************************************************/
// 	Description : This function handle the group delete command
//	Global resource dependence : none
//  Author:      liqing.peng
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleGroupDelete(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );
/*****************************************************************************/
// 	Description : This function handle the group modify command
//	Global resource dependence : none
//  Author:      liqing.peng
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleGroupModify(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );

/*****************************************************************************/
// 	Description : This function handle the schedule getinfo command
//	Global resource dependence : none
//  Author:    xiaohua.liu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleScheduleGetInfo();

/*****************************************************************************/
// 	Description : This function handle the group get one item command
//	Global resource dependence : none
//  Author:      liqing.peng
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleScheduleReadItem(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );

/*****************************************************************************/
// 	Description : This function handle the group add command
//	Global resource dependence : none
//  Author:      xiaohua.liu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleScheduleAdd(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );
/*****************************************************************************/
// 	Description : This function handle the group delete command
//	Global resource dependence : none
//  Author:      xiaohua.liu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleScheduleDelete(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );
/*****************************************************************************/
// 	Description : This function handle the schedule modify command
//	Global resource dependence : none
//  Author:      xiaohua.liu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleScheduleModify(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );

/*****************************************************************************/
// 	Description : 
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL uint16 CompressCmdStr(
							  uint8 *cmd_in,	//cmd str, in
							  uint16 len,		//cmd str len
							  uint8	*cmd_out	//out
							  );

/*****************************************************************************/
// 	Description : 
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL uint16 DecompressCmdStr(
							  uint8 *cmd_in,	//cmd str, in
							  uint16 len,		//cmd str len
							  uint8	*cmd_out,	//out
                              uint16 out_buf_max_len//IN:
							  );




/*---------------------------------------------------------------------------*/
/*****************************************************************************/
/*                                    Begin of Atest  Function Declare                                                     */
/* Description:  Hanlde at cmd for auto test cases                                                                    */
/* Author: Shuyan.hu                                                                                                          */
/* Date: 30/12/2010                                                                                                           */ 
/*****************************************************************************/
/*---------------------------------------------------------------------------*/

/*****************************************************************************/
// 	Description : This function handle Atest at cmd
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleAtMMI(
	                                                        uint8 * cmd,            //point to the at information buffer
                                                               uint32 len                  //length of information
	                                                             );

/*****************************************************************************/
// 	Description : This function  handle st at cmd
//	Global resource dependence : none
//  Author:       shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleStAtMMI(
 								uint8 *cmd,                   //point to the at information buffer
 								uint32 len                       //length of information
                                                               );

/*****************************************************************************/
// 	Description : This function handle ft connect gatewayinput at cmd 
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleConnectGatewayDNS(
                                                             uint8 * cmd,                 //point to the connection IP information buffer    
                                                             uint32 len                    //length of information
                                                           );


/*****************************************************************************/
// 	Description : This function  handle ft at cmd
//	Global resource dependence : none
//  Author:       shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleFtAtMMI(
 								uint8 *cmd,            //point to the at information buffer
 								uint32 len              //length of information  
                                                               );
/*****************************************************************************/
// 	Description : This function handle st sms at cmd 
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleSMS(
                                                             uint8 * cmd,                    //point to the sms information buffer
                                                             uint32 len                        //length of information
                                                           );
/*****************************************************************************/
// 	Description : This function handle URL sms at cmd 
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleURL(
                                                            uint8 * cmd,                        //point to the URL information buffer
                                                             uint32 len                             //length of information
                                                           );

/*****************************************************************************/
// 	Description : This function  handle ft connetion input at cmd
//	Global resource dependence : none
//  Author:       shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleConnection(
 								uint8 *cmd,                 //point to the connection  information buffer
 								uint32 len                    //length of information
                                                            );

/*****************************************************************************/
// 	Description : This function handle ft connect paraments at cmd 
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleConnectOther(
                                                             uint8 * cmd,               //point to the connection IP information buffer
                                                             uint32 len                   //length of information
                                                           );

/*****************************************************************************/
// 	Description : This function handle ft bookmark at cmd 
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleBookmark(
                                                             uint8 * cmd,                //point to the bookmark  information buffer
                                                             uint32 len                     //length of information
                                                           );
/*****************************************************************************/
// 	Description : This function handle ft bookmark title input at cmd 
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleBmTitle(
                                                             uint8 * cmd,              //point to the bookmark title information buffer
                                                             uint32 len                  //length of information
                                                           );
/*****************************************************************************/
// 	Description : This function handle ft bookmark URL input at cmd 
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleBmURL(
                                                             uint8 * cmd,            //point to the bookmark url information buffer
                                                             uint32 len                //length of information
                                                           );


/*****************************************************************************/
// 	Description : This function handle URL sms at cmd 
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleFolder(
                                                            uint8 * cmd,                        //point to the folder information buffer
                                                             uint32 len                             //length of information
                                                           );
/*****************************************************************************/
// 	Description : This function handle URL sms at cmd 
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleFolderHori(
                                                            uint8 * cmd,                        //point to the folder information buffer
                                                             uint32 len                             //length of information
                                                           );
/*****************************************************************************/
// 	Description : This function handle URL sms at cmd 
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleFolderVerti(
                                                            uint8 * cmd,                        //point to the folder information buffer
                                                             uint32 len                             //length of information
                                                           );

/*****************************************************************************/
// 	Description : This function is a call back of pb create
//	Global resource dependence : s_pb_name, s_pb_number
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL void Atest_pbcreate_callback(MMIPB_HANDLE_T handle,           //ponit to pb
	                                                        MMIPB_ERROR_E error               // value for result
	                                                        );

/*****************************************************************************/
// 	Description : This function get sim status  
//	Global resource dependence :  
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_CheckSim(uint16 sim_id );

/*****************************************************************************/
// 	Description : This function handle ateat pb create in internal storage  
//	Global resource dependence : s_pb_name, s_pb_number, s_handle_pb
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandlePbPhone(uint16 create_id);

/*****************************************************************************/
// 	Description : This function get pb name and phone number
//	Global resource dependence : s_pb_name, s_pb_number
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetPbPara(
	                                                        uint8 * cmd,                             //input at cmd
                                                               uint32 len                                 //input at length
	                                                             );

/*****************************************************************************/
// 	Description : This function  handle pb create in internal storage 
//	Global resource dependence : none
//  Author:       shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandlePbNv(
 								uint8 *cmd,                   //point to the at information buffer
 								uint32 len                       //length of information
                                                               );

/*****************************************************************************/
// 	Description : This function  handle atest pb create from at+sytin  at cmd
//	Global resource dependence : none
//  Author:       shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandlePhoneBook(
 								uint8 *cmd,                   //point to the at information buffer
 								uint32 len                       //length of information
                                                               );


/*****************************************************************************/
// 	Description : This function  handle pb create in sim card
//	Global resource dependence : none
//  Author:       shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandlePbSim(
 								uint8 *cmd,                   //point to the at information buffer
 								uint32 len                       //length of information
                                                               );


// 控件输入自动测试
#ifdef ATEST_SUPPORT
#ifdef MMI_ISTYLE_SUPPORT
extern BOOLEAN IStyleGetItemData(
    MMIMAINMENU_ISTYLE_DATA_T *menu_ctrl_ptr,
    uint32 menu_id,
    uint32 group_id,
    CTRLMAINMENU_ITEM_T *item_ptr
);
#endif

extern PUBLIC void Atest_GetPopmenuItemTextRect(
                                         uint16         item_index,
                                         CTRLMENU_OBJ_T *menu_ctrl_ptr,
                                         GUI_RECT_T     *item_rect
                                         );

/*****************************************************************************/
//  Description: 将字符串从手机端传回PC端
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL int32 Atest_TransmitATString( // 返回校验码: 传输的数据部分的累加，参数is_need_check=TRUE有效
    uint8 *data_ptr,                // 传输的数据部分
    uint16 data_len,                // 传输数据长度
    BOOLEAN is_unicode,             // 判定是否需要将Unicode码转换为AT字符串
    BOOLEAN is_need_checksum);      // 判定是否需要计算校验和

/*****************************************************************************/
//  Description: 获取控件属性
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetControlProperty(
    IGUICTRL_T *ctrl_ptr,   // 控件指针
    BOOLEAN is_mark_end,    // 控件遍历结束标记
    uint8 *data_ptr,        // 需要传输的控件属性数据
    uint32 *data_size_ptr); // 传输数据大小

/*****************************************************************************/
//  Description: 解析PC端发过来的消息内容: 窗体ID，长度，位置等
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL uint32 Atest_GetTestMessageId( // 返回消息内容: 窗体ID，长度，位置
    char separator,                  // ID分隔符
    uint8 **message_pptr);           // 返回指向下一个要解析的位置

/*****************************************************************************/
//  Description: 解析PC端指令，填充控件数据，返回填充结果
//               AT+SFTIN="IFCD,393435,31002D4E" -> 10,20
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_FillControlData( // 填充失败，返回FALSE
    uint8 *user_data_ptr);           // 用户填充指令和数据

/*****************************************************************************/
//  Description:一次性删除edit输入的数据
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_ClearAllStr(  uint8 *user_data_ptr);

/*****************************************************************************/
//  Description: 遍历控件树，提取控件属性描述，传回PC端
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL void Atest_TravelControlTree(
    MMI_TREE_NODE_T *root_ptr,  // 控件树根节点
    uint8 *data_ptr,            // 传回PC端的数据
    uint32 *data_size_ptr);     // 累计传输的数据大小

/*****************************************************************************/
//  Description: 获取指定控件的数据，返回满足客户端要求的内容、长度和校验信息
//               AT+SFTIN="IGCD,393435,0,20" -> 00314E2D,4,16
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetControlData( // 提取控件数据失败，返回FALSE
    uint8 *user_data_ptr);          // 客户端发出的提取指令

/*****************************************************************************/
//  Description: 遍历窗体
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL void Atest_TravelWindowTree(
    MMI_TREE_NODE_T *root_ptr, // 窗体树根节点
    MMI_TREE_NODE_T *next_ptr,
    uint8 *data_ptr,           // 传回PC端的数据
    uint32 *data_size_ptr);     // 累计传输的数据大小

/*****************************************************************************/
//  Description: 递归焦点窗体控件树，获取控件属性，传回PC端，加上总长度校验
//               AT+SFTIN="IGCT" -> <EDITBOX id='393435' type='TEXT' maxLen='612' maxNum='0'></EDITBOX>,67
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetControlTree( // 取到控件内容，返回TRUE
    uint8 *user_data_ptr);          // 客户端的提取控件属性指令


/*****************************************************************************/
//  Description: 解析客户端AT指令，调用不同处理逻辑
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleControlInput( // 用户命令处理无错，返回TRUE
    uint8 *user_data_ptr,               // 用户发过来的AT命令
    uint32 len);						// 用户发过来的AT命令的长度

/*****************************************************************************/
//  Description: 获取控件RichText描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetRichTextControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取控件Anim描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetAnimControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取PrgBox控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetPrgBoxControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取Text控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetTextControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取Lable控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetLableControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取MsgBox控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetMsgBoxControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取Punctuation控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetPunctuationControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取Button控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetButtonControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取Iconlist控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetIconlistControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取TAB控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetTabControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取Edit控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetStatusBarControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取im控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetIMControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取SetList控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetSetListControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取Form控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetFormControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取Owndraw控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetOwndrawControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取Toolbar控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetToolbarControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取Edit控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetEditControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text
/*****************************************************************************/
//  Description: 获取Edit控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetTextEditControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text
/*****************************************************************************/
//  Description: 获取DropList控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetDropListControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取softkey控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetsoftkeyControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取Tips控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetTipsControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取Title控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetTitleControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取List控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetListControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取MainMenu控件描述
//  Global resource dependence :none
//  Author: 
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetMainMenuControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text 		
 										 
#ifdef MENU_SWEETS_SUPPORT
/*****************************************************************************/
//  Description: 获取SweetMainMenu控件描述
//  Global resource dependence :none
//  Author: 
/*****************************************************************************/
LOCAL void Atest_GetSweetMainMenuControlProperty( 
										 CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,//MENU指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr);			//传输的数据text
#endif

#ifdef PDA_UI_SUPPORT_MANIMENU_GO										 
/*****************************************************************************/
//  Description: 获取SlideMainMenu控件描述
//  Global resource dependence :none
//  Author: 
/*****************************************************************************/
LOCAL void Atest_GetSlideMainMenuControlProperty( 
										 CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,//MENU指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr);			//传输的数据text
#endif

#ifdef QBTHEME_SUPPORT 							
/*****************************************************************************/
//  Description: 获取QbMainMenu控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_SECOND\GUIMENU_STYLE_THIRD\GUIMENU_STYLE_POPUP  
// 	      GUIMENU_STYLE_POPUP_AUTO\GUIMENU_STYLE_POPUP_RECT
//		  GUIMENU_STYLE_POPUP_RADIO\GUIMENU_STYLE_POPUP_CHECK
/*****************************************************************************/
LOCAL void Atest_GetQbMainMenuControlProperty( 
										 CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,//MENU指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr);			//传输的数据text
#endif 										 

#ifdef MMI_ISTYLE_SUPPORT
/*****************************************************************************/
//  Description: 获取IStyleMainMenu控件描述
//  Global resource dependence :none
//  Author: 
/*****************************************************************************/
LOCAL void Atest_GetIStyleMainMenuControlProperty( 
										 CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,//MENU指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr);			//传输的数据text
#endif

#ifdef MATRIX_MAIN_MENU_SUPPORT
/*****************************************************************************/
//  Description: 获取MaxtricMainMenu控件描述
//  Global resource dependence :none
//  Author:
/*****************************************************************************/
LOCAL void Atest_GetMatrixMainMenuControlProperty( 
										 CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,//MENU指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr);			//传输的数据text
#endif 										 
/*****************************************************************************/
//  Description: 获取Menu控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetMenuControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取PopMenu控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_SECOND\GUIMENU_STYLE_THIRD、GUIMENU_STYLE_POPUP  
// 	      GUIMENU_STYLE_POPUP_AUTO\GUIMENU_STYLE_POPUP_RECT
//		  GUIMENU_STYLE_POPUP_RADIO\GUIMENU_STYLE_POPUP_CHECK
/*****************************************************************************/
LOCAL void Atest_GetPopMenuControlProperty( 
										 CTRLMENU_OBJ_T  *menu_ctrl_ptr,//menu指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr);			//传输的数据text

/*****************************************************************************/
//  Description: 获取IconMenu控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_ICO\GUIMENU_STYLE_CYCLONE
/*****************************************************************************/
LOCAL void Atest_GetIconMenuControlProperty( 
										 CTRLMENU_OBJ_T  *menu_ctrl_ptr,//menu指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr);			//传输的数据text


/*****************************************************************************/
//  Description: 获取OptionMenu控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_OPTIONS
/*****************************************************************************/
LOCAL void Atest_GetOptionMenuControlProperty( 
										 CTRLMENU_OBJ_T  *menu_ctrl_ptr,//menu指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr);			//传输的数据text
 										 
#ifdef PDA_UI_SUPPORT_MANIMENU_GO										  										 
/*****************************************************************************/
//  Description: 获取SlideMenu控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_SLIDE_PAGE\GUIMENU_STYLE_TRAPEZOID
//		 GUIMENU_STYLE_SPHERE\GUIMENU_STYLE_CYLINDER
//		 GUIMENU_STYLE_BINARY_STAR\GUIMENU_STYLE_SHUTTER
//	     GUIMENU_STYLE_CHARIOT\GUIMENU_STYLE_CUBE
//		 GUIMENU_ISTYLEGUIMENU_STYLE_QBTHEME
/*****************************************************************************/
LOCAL void Atest_GetSlideMenuControlProperty( 
										 CTRLMENU_OBJ_T  *menu_ctrl_ptr,//menu指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr);			//传输的数据text
#endif

/*****************************************************************************/
//  Description: 获取CrystalMenu控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_CRYSTAL_CUBE
/*****************************************************************************/
LOCAL void Atest_GetCrystalMenuControlProperty( 
										 CTRLMENU_OBJ_T  *menu_ctrl_ptr,//menu指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr);			//传输的数据text								 
 										 
/*****************************************************************************/
//  Description: 获取Scrollkey控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetScrollkeyControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text
 										 
/*****************************************************************************/
//  Description: 获取Iconfolder控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetIconfolderControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description:点击对应的控件
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_ClickControl(uint8 *user_data_ptr);

/*****************************************************************************/
//  Description:解析命令,获取内容
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetMessageContent( 
									uint8 *message_content,		// 解析的内容
								    char separator,             // ID分隔符
								    uint8 **message_pptr);      // 返回指向下一个要解析的位置

/*****************************************************************************/
//  Description:查找对应的控件，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_SearchControlPosition(
										ATEST_ID_TYPE_E id_type,	//查找类型
										uint8 *find_data_ptr,		//所需查找的数据
										uint16 *rect_x,				//返回的坐标
										uint16 *rect_y);			//返回的坐标

/*****************************************************************************/
//  Description: 查找窗体
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_SearchWindowTree(
									MMI_TREE_NODE_T *root_ptr,	//窗体的根节点指针
									MMI_TREE_NODE_T *next_ptr,	//窗体根节点的兄弟指针
									ATEST_ID_TYPE_E id_type,	//查找类型
									uint8 *find_data_ptr,		//所需查找的数据
									uint16 *rect_x,				//返回的坐标
									uint16 *rect_y);			//返回的坐标
	
/*****************************************************************************/
//  Description:遍历该窗口的控件，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/  
LOCAL BOOLEAN Atest_SearchControlTree(
								    MMI_TREE_NODE_T *root_ptr,	//控件树根节点
								    ATEST_ID_TYPE_E id_type,	//查找类型
								    uint8 *user_data_ptr,		//所需查找的数据
								    uint16 *rect_x,				//返回的坐标
									uint16 *rect_y);			//返回的坐标

/*****************************************************************************/
//  Description:查找各控件，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchControlProperty(
	IGUICTRL_T *ctrl_ptr,
    ATEST_ID_TYPE_E id_type,
    uint8 *user_data_ptr,
    uint16 *rect_x,
	uint16 *rect_y);

/*****************************************************************************/
//  Description:根据坐标，发送触屏事件
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL void Atest_SendTouchMessage(
									MMI_TP_STATUS_E tp_type,	//TP类型
									uint16 rect_x,				//TP 坐标x
									uint16 rect_y);				//TP 坐标y


/*****************************************************************************/
//  Description:根据rotate lcd对按键事件进行转换
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL void Atest_KbdConvert(uint32 *signal_keycode); //按键事件类型


/*****************************************************************************/
//  Description:处理atc按键消息
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL void Atest_ResolveKbdSignal(
								uint32 signal_keycode,
								uint8 *use_data_ptr,
								uint32 reserved_data);

/*****************************************************************************/
//  Description:根据坐标，发送按键事件
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL void Atest_SendKbdMessage(
								uint32 signal_keycode);	 //按键事件类型


/*****************************************************************************/
//  Description: 将消息发送到APP task处理
//  Global resource dependence :none
//  Author: linchen
//  Note:缓解P_ATC压力，开一块内存，扔给P_APP处理
/*****************************************************************************/
LOCAL void Atest_SendSignalToAppTask( 
								uint8 *user_data_ptr,	 // 用户发过来的AT命令
								uint32 len,				 // 用户发过来的AT命令的长度
								uint32 reserved_data,	 // 发送时附加的数据
								uint16 signalType);		 // 发送到APP的消息类型

/*****************************************************************************/
//  Description: 根据当前lcd旋转的情况，对坐标进行转换
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_ConvertPositionByLcd(	uint16 *rect_x,		//需要转换的坐标x
											uint16 *rect_y);	//需要转换的坐标y

/*****************************************************************************/
//  Description: 获得当前的分辨率
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetCurResolution(void);


/*****************************************************************************/
//  Description: 获取当前语言
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetCurLang(void);

/*****************************************************************************/
//  Description: 获取当前list或icon list的总个数
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetListNum(uint8 *user_data_ptr);

/*****************************************************************************/
//  Description: 获取当前主题
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetCurStyle(uint8 *user_data_ptr);

/*****************************************************************************/
//  Description: 触笔对应的坐标
//  Global resource dependence :
//  Author:linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_TouchPanelPoint( uint8 *user_data_ptr);

/*****************************************************************************/
//  Description: 触笔down
//  Global resource dependence :
//  Author:linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_TouchPanelDown( uint8 *user_data_ptr);


/*****************************************************************************/
//  Description: 按键down
//  Global resource dependence :
//  Author:linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_KBDown( uint8 *user_data_ptr);

/*****************************************************************************/
//  Description: 触笔move
//  Global resource dependence :
//  Author:linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_TouchPanelMove( uint8 *user_data_ptr);

/*****************************************************************************/
//  Description: 触笔up
//  Global resource dependence :
//  Author:linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_TouchPanelUp( uint8 *user_data_ptr);

/*****************************************************************************/
//  Description:比较AT发送过来的数据和从控件取到的数据
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_Compare_content(ATEST_ID_TYPE_E id_type,	//查找类型
									MMI_HANDLE_T ctrl_handle,	//控件handle
									MMI_STRING_T ctrl_str,	    //遍历控件的字符串数据
									uint8 *at_data,			    //AT收到的字符串数据
									uint32 id_data);			//遍历控件的id数据

/*****************************************************************************/
//  Description:计算宽字符的长度
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL uint16 Atest_wcslen(	wchar *s,			//宽字符串
							uint16 limit_len);	//限制长度

/*****************************************************************************/
//  Description:根据item所在的控件的位置，返回对应的触笔坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:主要针对list，pop menu
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_GetValidTPPoint(	GUI_RECT_T item_rect,	//item的区域
										GUI_RECT_T ctrl_rect,	//item所在的控件的区域
										uint16 *rect_x,			//out:坐标x
										uint16 *rect_y);		//out:坐标y
										
/*****************************************************************************/
//  Description:查找控件LABLE，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchLableControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件EditBbox，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchEditBoxControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件SoftKey，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchSoftKeyControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件Menu，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchMenuControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y
/*****************************************************************************/
//  Description:查找控件Menu，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchMainMenuControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y
#ifdef QBTHEME_SUPPORT
/*****************************************************************************/
//  Description:查找控件QbMenu的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:GUIMENU_STYLE_QBTHEME
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchQbMainMenuControlItem(
										CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										MMI_CTRL_ID_T ctrl_id,		//控件id
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y);				//out,查找到的控件坐标y
#endif
/*****************************************************************************/
//  Description:查找控件CycloneMenu的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:GUIMENU_STYLE_CYCLONE
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchCycloneMenuControlItem(
										CTRLMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										IGUICTRL_T *ctrl_ptr,			//控件指针
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y);				//out,查找到的控件坐标y

/*****************************************************************************/
//  Description:查找控件CrystalMenu的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:GUIMENU_STYLE_CRYSTAL_CUBE
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchCrystalMenuControlItem(
										CTRLMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										IGUICTRL_T *ctrl_ptr,			//控件指针
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y);				//out,查找到的控件坐标y
										
#ifdef PDA_UI_SUPPORT_MANIMENU_GO										 
/*****************************************************************************/
//  Description: 获取SlideMenu每页的item数
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_SLIDE_PAGE 
/*****************************************************************************/
LOCAL uint16 Atest_GetSlideMenuPageItemNum( MMIMAINMENU_SLIDEPAGE_DATA_T  *menu_ctrl_ptr);


/*****************************************************************************/
//  Description:查找控件SlideMenu的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:针对slide menu
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchSlideMainMenuControlItem(
										CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										MMI_CTRL_ID_T ctrl_id,		//控件id
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y);				//out,查找到的控件坐标y
#endif

#ifdef MMI_ISTYLE_SUPPORT
/*****************************************************************************/
//  Description:查找控件SlideMenu的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:针对slide menu
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchIStyleMainMenuControlItem(
										CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										MMI_CTRL_ID_T ctrl_id,		//控件id
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y);				//out,查找到的控件坐标y
#endif

#ifdef MATRIX_MAIN_MENU_SUPPORT
/*****************************************************************************/
//  Description:查找控件SlideMenu的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:针对slide menu
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchMatrixMainMenuControlItem(
										CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										MMI_CTRL_ID_T ctrl_id,		//控件id,			//控件指针
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y);				//out,查找到的控件坐标y
#endif										

#ifdef MENU_SWEETS_SUPPORT
/*****************************************************************************/
//  Description:查找控件SlideMenu的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:针对slide menu
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchSweetMainMenuControlItem(
										CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										MMI_CTRL_ID_T ctrl_id,		//控件id
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y);				//out,查找到的控件坐标y
#endif

/*****************************************************************************/
//  Description:查找控件PopMenu的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:针对second，third，pop menu
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchPopMenuControlItem(
										CTRLMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										IGUICTRL_T *ctrl_ptr,			//控件指针
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16  item_height,			//item高度
										uint16  item_space,				//item之间的距离
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y);				//out,查找到的控件坐标y




/*****************************************************************************/
//  Description:查找控件OptionMenu的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_OPTIONS
/*****************************************************************************/
LOCAL BOOLEAN Atest_SearchOptionMenuControlItem( 
										CTRLMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										IGUICTRL_T *ctrl_ptr,			//控件指针
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y);				//out,查找到的控件坐标y

/*****************************************************************************/
//  Description:查找控件list 的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note: byIndex
/*****************************************************************************/
LOCAL BOOLEAN Atest_SearchListByIndex(
									    CTRLLIST_OBJ_T *list_ctrl_ptr,	//list控件指针
									    MMI_HANDLE_T ctrl_handle,		//控件handle
									    uint16 page_item_num,			//每页的item数
									    uint8 *user_data_ptr,			//查找数据
									    uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y);				//out,查找到的控件坐标y

/*****************************************************************************/
//  Description:查找控件list 的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note: byimgIndex
/*****************************************************************************/
LOCAL BOOLEAN Atest_SearchListByImgIndex(
										    CTRLLIST_OBJ_T *list_ctrl_ptr,	//list控件指针
										    MMI_HANDLE_T ctrl_handle,		//控件handle
										    MMI_CTRL_ID_T ctrl_id,			//控件id
										    uint16 page_item_num,			//每页的item数
										    uint8 *user_data_ptr,			//查找数据
										    uint16 *rect_x,					//out,查找到的控件坐标x
											uint16 *rect_y);				//out,查找到的控件坐标y


/*****************************************************************************/
//  Description:查找控件list 的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note: bytextimg
/*****************************************************************************/
LOCAL BOOLEAN Atest_SearchListByTextImg(
										    CTRLLIST_OBJ_T *list_ctrl_ptr,	//list控件指针
										    MMI_HANDLE_T ctrl_handle,		//控件handle
										    MMI_CTRL_ID_T ctrl_id,			//控件id
										    uint16 page_item_num,			//每页的item数
										    uint8 *user_data_ptr,			//查找数据
										    uint16 *rect_x,					//out,查找到的控件坐标x
											uint16 *rect_y);				//out,查找到的控件坐标y

/*****************************************************************************/
//  Description:查找控件list 的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note: bytext imgid
/*****************************************************************************/
LOCAL BOOLEAN Atest_SearchListByTextAndImgID(
										    CTRLLIST_OBJ_T *list_ctrl_ptr,	//list控件指针
										    MMI_HANDLE_T ctrl_handle,		//控件handle
										    MMI_CTRL_ID_T ctrl_id,			//控件id
										    ATEST_ID_TYPE_E id_type,		//查找类型
										    uint16 page_item_num,			//每页的item数
										    uint8 *user_data_ptr,			//查找数据
										    uint16 *rect_x,					//out,查找到的控件坐标x
											uint16 *rect_y);				//out,查找到的控件坐标y
											
/*****************************************************************************/
//  Description:查找控件list，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchListControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件Setlist，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持控件id查找
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchSetlistControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件Button，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持控件id查找
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchButtonControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y
	
/*****************************************************************************/
//  Description:查找控件tab，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持id查找
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchTabControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件RichText，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持all
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchRichTextControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件Anim，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持控件ID
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchAnimControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件Msgbox，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持控件ID
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchMsgboxControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件Dropdownlist，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持控件ID
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchDropdownlistControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y


/*****************************************************************************/
//  Description:查找控件Iconlist，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持控件ID
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchIconlistControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件Title，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持文本ID，image id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchTitleControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件Textbox，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持控件ID
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchTextboxControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件IM，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持按键code
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchIMControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件ToolBar，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持文本ID，image id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchToolBarControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件Tips，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持文本,控件id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchTipsControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件Statusbar，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持文本,image id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchStatusbarControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件Owndraw，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持control id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchOwndrawControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件Prgbox，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持control id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchPrgboxControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件Form，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持control id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchFormControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件Iconfolder，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持control id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchIconfolderControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y


 /*****************************************************************************/
//  Description: 设置闹钟时间
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_SetAlarmTime(uint8 *user_data_ptr);

/*****************************************************************************/
//  Description: 获取下个闹钟的时间
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetLatestAlarmTime(uint8 *user_data_ptr);

/*****************************************************************************/
//  Description: 获取当前手机的时间
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetCurSysTime(uint8 *user_data_ptr);

/*****************************************************************************/
//  Description: 获得前日历的焦点日期
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetCalendarCurDate(uint8 *user_data_ptr);

/*****************************************************************************/
//  Description: 进入日历上的某个日期
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_ClickCalendarDate(uint8 *user_data_ptr);

#endif // ATEST_SUPPORT
/*---------------------------------------------------------------------------*/
/*****************************************************************************/
/*                                    End of Atest  Function Declare                                                       */
/* Description:  Hanlde at cmd for auto test cases                                                                    */
/* Author: Shuyan.hu                                                                                                          */
/* Date: 30/12/2010                                                                                                           */ 
/*****************************************************************************/
/*---------------------------------------------------------------------------*/




/*-------------------------------------------------------------------------*/
/*                         FUNCTIONS                                       */
/*-------------------------------------------------------------------------*/
/*****************************************************************************/
// 	Description : This function call parse function to get result of command response
//	Global resource dependence : none
//  Author:       Jassmine.Meng
//  Modify: baokun.yin
//	Note:
/*****************************************************************************/
uint32 ATC_ExtCmd(DPARAM param)
{
	AT_AUTO_TEST_CMD_IND_T *atc_cmd_str = (AT_AUTO_TEST_CMD_IND_T*)param;
	uint8 *cmd = PNULL;  // Point to the command infomation buffer
	uint32 len ;  // The length of command infomation buffer	
	uint16 ind_len = 0;
	MN_DUAL_SYS_E sim_type =  MN_DUAL_SYS_1; 
	uint8      atc_str[MMI_SIM_VERSION_LEN] = {0};
    uint8      sim_valid_flag = 0x00;
	
	if(atc_cmd_str == PNULL || atc_cmd_str->data == PNULL || atc_cmd_str->len == 0)
	{
		SCI_TRACE_LOW("[mmi_atc.c] ATC_ExtCmd atc_cmd_str %d !", atc_cmd_str);
		//parameter error
		ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
		return 0;
	}
    cmd = atc_cmd_str->data;
	len = atc_cmd_str->len;
    SCI_TRACE_LOW("mmi_atc.c: ATC_ExtCmd(), received AT command %s, len = %d",cmd, len);
    //SCI_TRACE_LOW:"mmi_atc.c: ATC_ExtCmd(), received AT command , len = %d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_1904_112_2_18_1_59_28_11,(uint8*)"d", len);
    
    if(IsMatchIndication(cmd, len, (char*)AT_SYNC_INDICATE))
    {
        ind_len = strlen((char *)AT_SYNC_INDICATE);
        cmd += ind_len;
        len -= ind_len;
		
        if(!ParseSyncAtCmd(cmd, len))
        {
            ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
        }
    }
    else if(IsMatchIndication(cmd, len, (char *)MMI_SYNC_INDICATE))
    {
        ind_len = strlen((char *)MMI_SYNC_INDICATE);
        cmd += ind_len;
        len -= ind_len;
		
		if(IsMatchIndication(cmd, len, (char*)MMI_SYNC_START))
		{
			//	if (MMIAPIUdisk_VUARTIsRun())
			{
#if 0//ndef _WIN32
				s_atc_is_run = TRUE;
#endif
				for(sim_type = MN_DUAL_SYS_1; sim_type < MMI_DUAL_SYS_MAX; sim_type++)
				{
					if(MMIAPIPHONE_GetSimExistedStatus(sim_type))
					{
						sim_valid_flag += 0x01 << sim_type;
					}
				}
				//	if(sim_valid_flag > 0)
				{
					//exist valid sim 
					MMIAPIUDISK_HandleATCExtCmd();
					sprintf((char *)atc_str, "%s%02d%s",MMI_SYNC_VERSION, sim_valid_flag, MMI_TO_SYNC_OK_SYMBOL);
					ReturnResponse((uint8 *)atc_str, (uint16)strlen((char*)atc_str));
					
				}
				//	else
				//	{
#if 0//ndef _WIN32
				s_atc_is_run = FALSE;
#endif
				//		ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
				//	}
            }
			//    else
			//     {
#if 0//ndef _WIN32
			s_atc_is_run = FALSE;
#endif
			//           ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
			//   }
        }
        else
        {
            if(!ParseSyncAtCmd(cmd, len))
            {
                ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
            }
        }
    }
	else if(IsMatchIndication(cmd, len, (char *)MMI_SYNC_UT_INDICATE_UP) || IsMatchIndication(cmd, len, (char *)MMI_SYNC_UT_INDICATE_LOW))
	{
		//auto test
        ind_len = strlen((char *)MMI_SYNC_UT_INDICATE_UP);
        cmd += ind_len;
        len -= ind_len;
		//Auto Test ATC
		if(!ParseSyncUTAtCmd(cmd, len))
		{
			ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
		}
		else
		{
			//ok
			ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_OK_SYMBOL));
		}
	}
#ifdef ATEST_SUPPORT
	else if(IsMatchIndication(cmd, len, (char *)MMI_AT_TEST) )
	{  
	       //atest for at+sytin and at+ftin
		ind_len = strlen((char *)MMI_AT_TEST);
		cmd += ind_len;
		len -= ind_len;
		if(Atest_HandleAtMMI(cmd, len))
		{
			ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_OK_SYMBOL));
		}
		else
		{
			ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
		}
	}
#endif
	/*+cr251711,for TD UEIT auto test*/
	else if(IsMatchIndication(cmd, len, (char *)UEIT_TEST_INDICATE) )
	{  
#ifdef ENG_SUPPORT
		BOOLEAN is_on = FALSE;
		MMINV_WRITE(MMIENG_NV_CALLFORWARD_QUERY_ID, &is_on);//close call forward query
		
		is_on = TRUE;
		MMINV_WRITE(MMINV_ENG_USBLOG,&is_on);//open usb log
#endif
		
#ifdef DCD_SUPPORT
		MMIAPIDCD_SetDCDEnable(FALSE);		//close DCD
#endif
		
#ifdef MMI_GPRS_SUPPORT
		MMIAPICONNECTION_SetGPRSStatus(MMICONNECTION_GPRS_ALWAYS); //set GPRS alwarys connection
#endif
		
#ifdef DM_SUPPORT
		MMIDM_SetDmRegSwitchState(FALSE);  //Automatic Software update switch (close)
#endif
		
#ifdef DSP_USB_LOG
		REFPARAM_SetDspDebugPortPhyNo(2);   //dsp log: usb
#endif
		
		ReturnResponse((uint8 *)UEIT_TEST_OK_SYMBOL, (uint16)strlen((char*)UEIT_TEST_OK_SYMBOL));
	}
	/*-cr251711*/	
	//bruce, add , for compile
	else
	{
		ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
	}
    
    //释放数据
    SCI_FREE(atc_cmd_str->data);
	return 0;
}



/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/*                                    Start of Atest  Function                                                                */
/* Description:  Hanlde at cmd for auto test cases                                                                    */
/* Author: Shuyan.hu                                                                                                          */
/* Date: 30/12/2010                                                                                                           */ 
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

/*****************************************************************************/
// 	Description : This function  handle atest pb create from at+sytin  at cmd
//	Global resource dependence : none
//  Author:       shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandlePhoneBook(
 								uint8 *cmd,                   //point to the at information buffer
 								uint32 len                       //length of information
                                                               )
{
	uint8 pb_type = 0;
     BOOLEAN res= FALSE;

     //check input at cmd  
     if(NULL == cmd)
     {
          return FALSE;
     }
     //get the handle connection configuration type
     pb_type = *(cmd++);
     len = len -1;

      
     switch(pb_type)
     {
          //handle internal memory pb create
          case 'n':
          case 'N':
	       res = Atest_HandlePbNv(cmd, len);
	       break;
          //handle sim pb create
          case 's':
          case 'S':
	       res = Atest_HandlePbSim(cmd, len);
	       break;
       default:
	       //SCI_TRACE_LOW:"[ATC:][ATEST:][Atest_HandlePhoneBook:] %c"
	       SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_2264_112_2_18_1_59_29_12,(uint8*)"c", (char)pb_type);
	       break;
     }
     return res;

}



/*****************************************************************************/
// 	Description : This function get sim status  
//	Global resource dependence :  
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_CheckSim(uint16 sim_id )
{  
    uint16 item;  

   if(sim_id > MMIPB_STORAGE_SIM4)//MMIPB_Create_ID
   {
        return FALSE;  //MN_DUAL_SYS_1
   }
   item =sim_id;
   for(; item<MMI_DUAL_SYS_MAX; item++)
   {
        if( SIM_STATUS_OK != MMIAPIPHONE_GetSimStatus((MN_DUAL_SYS_E) item))
        {
              continue;
        }
	  else
	  {
	       s_MMIPB_Create_ID = item;
		return TRUE;
	  }
	  	
   }
   return FALSE;      	 
    
}


/*****************************************************************************/
// 	Description : This function  handle creat pb in sim from at cmd
//	Global resource dependence : g_mmipb_entry_list
//  Author:       shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandlePbSim(
 								uint8 *cmd,                   //point to the at information buffer
 								uint32 len                       //length of information
                                                               )
{
   
           if(NULL != cmd)
	{
	      Atest_GetPbPara(cmd, len);
		s_pbcreatesim = TRUE;
		if(Atest_CheckSim(MN_DUAL_SYS_1))
		{
		      Atest_HandlePbPhone(s_MMIPB_Create_ID);
		  	return TRUE;
		}
        }
        return  FALSE;		   

}



/*****************************************************************************/
// 	Description : This function get pb name and phone number
//	Global resource dependence : s_pb_name, s_pb_number
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetPbPara(
	                                                        uint8 * cmd,                             //input at cmd
                                                               uint32 len                                 //input at length
	                                                             )
{
     char *tmp_ptr= NULL;
     uint16 name_len, number_len;	 


      if(NULL == cmd)
      {
      		return FALSE;
      }
      tmp_ptr = strchr((char *)cmd, '#');
       if(NULL == tmp_ptr)
	{
		return FALSE;
	}
	
       name_len = tmp_ptr - (char *)cmd;
	number_len = len -name_len -1;
       //if the name length or number length more than max length
	if(name_len > MMI_SYNC_PB_NAME_MAX_LEN ||number_len > MMI_SYNC_PB_NUM_MAX_LEN)
	{
		return FALSE;
	}

	//get space for name and number  
       s_pb_name =  (uint8 *)SCI_ALLOC_APP(MMI_SYNC_PB_NAME_MAX_LEN*sizeof(uint8)+1);
	if(NULL == s_pb_name)
	{
		return FALSE;
	}
	s_pb_number = (uint8 *)SCI_ALLOC_APP(MMI_SYNC_PB_NUM_MAX_LEN*sizeof(uint8)+1);
       if(NULL == s_pb_number)
       {
       		return FALSE;
       }
	
	//copy name and number from at cmd
	SCI_MEMSET(s_pb_name, 0, MMI_SYNC_PB_NAME_MAX_LEN*sizeof(uint8) + 1);
	SCI_MEMSET(s_pb_number, 0, MMI_SYNC_PB_NUM_MAX_LEN*sizeof(uint8) + 1);

	SCI_MEMCPY(s_pb_name, cmd, name_len);
	s_pb_name[name_len] = '\0';
	SCI_MEMCPY(s_pb_number, tmp_ptr+1, number_len);
	s_pb_number[number_len] = '\0';
	
       return TRUE;
	
}




/*****************************************************************************/
// 	Description : This function handle ateat pb create in internal storage  from at cmd
//	Global resource dependence : g_mmipb_entry_list
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandlePbNv(
	                                                        uint8 * cmd,                             //input at cmd
                                                               uint32 len                                 //input at length
	                                                             )
{
    	if(NULL != cmd)
	{
	      Atest_GetPbPara(cmd, len);
	      s_MMIPB_Create_ID  = MMIPB_STORAGE_PHONE;
		s_pbcreatesim = FALSE;
	      Atest_HandlePbPhone(s_MMIPB_Create_ID);	 
		return TRUE;  
	}
	return FALSE;	
}  


/*****************************************************************************/
// 	Description : This function handle ateat pb create in internal storage  
//	Global resource dependence : s_pb_name, s_pb_number, s_handle_pb
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandlePbPhone(uint16 create_id )
{  
     MMIPB_CONTACT_T *contact_ptr = NULL;	 
     uint16 i;
     uint8 ftinput_arr[MAX_CMD_LEN] = {0};
     uint8 tmp[CMD_TEM_LEN];
     uint32 ilen;
     wchar *pb_name_ptr;
     MMI_PARTY_NUMBER_T  party_num = {MN_NUM_TYPE_UNKNOW, 0, 0};
      MMIPB_ERROR_E iret;	 

   s_handle_pb = MMIAPIPB_CreateHandle();
   contact_ptr = (MMIPB_CONTACT_T *)SCI_ALLOC_APP(sizeof(MMIPB_CONTACT_T));

   if(NULL != contact_ptr && NULL != s_handle_pb)
   {   
         SCI_MEMSET(ftinput_arr, 0, MAX_CMD_LEN);
	   SCI_MEMSET(tmp, 0, CMD_TEM_LEN);	 
	   SCI_MEMSET(contact_ptr, 0, sizeof(MMIPB_CONTACT_T));
	   for(i=0; i<strlen((char *)s_pb_name); i++)
	   {	
		   _snprintf((char *)tmp, sizeof(tmp),  "%2x", s_pb_name[i]);
		   strncat((char *)ftinput_arr, (char *)tmp, 2);
		   SCI_MEMSET(tmp, 0, CMD_TEM_LEN);
		   
	   }
	   ilen = SCI_STRLEN((char *)ftinput_arr);
	   if(s_pbcreatesim)
	   {
	        contact_ptr->storage_id = create_id + MMIPB_STORAGE_SIM1;
	   }
	   else
	   {
	         contact_ptr->storage_id = create_id;
	   }  
	  
         pb_name_ptr = (wchar *)GetATCParameter(MMI_UT_UTF8, ftinput_arr, ilen, 0);
         MMIAPICOM_Wstrncpy(contact_ptr->name.wstr, pb_name_ptr, MMIAPICOM_Wstrlen(pb_name_ptr));
	  contact_ptr->name.wstr_len = MMIAPICOM_Wstrlen(pb_name_ptr);
	  if (strlen((char *)s_pb_number)>0  && MMIAPICOM_GenPartyNumber(s_pb_number, strlen((char *)s_pb_number), &party_num))
        {
                contact_ptr->number[0].npi_ton = (uint8)((party_num.number_type << 0X04) | MMIPB_DEFAULT_NPI);
                contact_ptr->number[0].number_len = (uint8)MIN(MMIPB_BCD_NUMBER_MAX_LEN, party_num.num_len);
                SCI_MEMCPY(contact_ptr->number[0].number, party_num.bcd_num, contact_ptr->number[0].number_len);
        }
	   iret =  MMIAPIPB_AddContactAsyn(s_handle_pb, contact_ptr, Atest_pbcreate_callback);
         SCI_FREE(contact_ptr);
         contact_ptr = NULL;
	  if(MMIPB_ERROR_PENDING != iret)
	  {   
	       if(s_pbcreatesim)
	       {
	               if(Atest_CheckSim(s_MMIPB_Create_ID+1))
	              {
	                   Atest_HandlePbPhone(s_MMIPB_Create_ID);
	              }
		            else
		            {
		                 SCI_TRACE_LOW("[att][pbcreate]---!= MMIPB_ERROR_PENDING!");
			              if(NULL != s_pb_name)
			              {
			                  SCI_FREE(s_pb_name);
				                s_pb_name = NULL;
			               }
					if(NULL != s_pb_number)
				     {
						SCI_FREE(s_pb_number);
						s_pb_number = NULL;
				     }
				 if(NULL != s_handle_pb)
				 {
				     MMIAPIPB_CloseHandle(s_handle_pb);
				     s_handle_pb = NULL;
				 }
				 return FALSE;
		        }
				   
	       }
		else
		{
		      SCI_TRACE_LOW("[att][pbcreate]--Not In sim  MMIPB_ERROR_PENDING!");
		       if(NULL != s_pb_name)
		       {
		           SCI_FREE(s_pb_name);
			     s_pb_name = NULL;
		       }
			 if(NULL != s_pb_number)
			 {
			      SCI_FREE(s_pb_number);
				    s_pb_number = NULL;
			 }
			 if(NULL != s_handle_pb)
			 {
			     MMIAPIPB_CloseHandle(s_handle_pb);
			     s_handle_pb = NULL;
			 }
			return FALSE;
		}	      
	       
	  }
	  else
	  {	       
		   SCI_TRACE_LOW("[att][pbcreate]---MMIPB_ERROR_PENDING!");
		   
	  }
	  return TRUE;
   }     	 
    return FALSE;
}


/*****************************************************************************/
// 	Description : This function handle ateat pb create in internal storage  
//	Global resource dependence : s_pb_name, s_pb_number, s_handle_pb
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL void Atest_pbcreate_callback(MMIPB_HANDLE_T handle, MMIPB_ERROR_E error)
{
	
     if(NULL != s_handle_pb)
     {
           MMIAPIPB_CloseHandle(s_handle_pb);
           s_handle_pb = NULL;	
     }     
    switch(error)
    {
        case MMIPB_ERROR_SUCCESS:
        {    

	          Atest_HandlePbPhone(s_MMIPB_Create_ID);

         }
         break;
            
        case MMIPB_ERROR_ERROR:
        {

		   if(NULL != s_pb_name)
		   {
		         SCI_FREE(s_pb_name);
			      s_pb_name = NULL;
		   }
	          if(NULL != s_pb_number)
	         {
			  SCI_FREE(s_pb_number);
		         s_pb_number = NULL;
		   }	
                SCI_TRACE_LOW("[ATEST] mmipb_create_callback error!");
               
         }
         break;
            
         default:
         {               
               if(NULL != s_pb_name)
		   {
		         SCI_FREE(s_pb_name);
			   s_pb_name = NULL;
		   }
	          if(NULL != s_pb_number)
	         {
			  SCI_FREE(s_pb_number);
		         s_pb_number = NULL;
		   }	
	        SCI_TRACE_LOW("[ATEST] mmipb_create_callback default!");		   
         }            
         break;
            
   }	
	
}


/*****************************************************************************/
// 	Description : This function  handle  URL input from at+sytin cmd
//	Global resource dependence : none
//  Author:       shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleURL(
	                                                 uint8 *cmd,                               //input at cmd for Bookmark url
 								uint32 len                                //input at cmd length
 								)
{
    #ifdef BROWSER_SUPPORT
     wchar *urlinput_ptr  = NULL;
     uint32 txt_type;
     BOOLEAN res= FALSE;
     uint8 urlinput_arr[MAX_CMD_LEN] = {0};
     uint8 tmp[CMD_TEM_LEN];	  
     uint32 i, ilen;  

	  
     if(NULL == cmd)
     {
		return FALSE;
     }

     //set the transform type
     txt_type = MMI_UT_UTF8;
     SCI_MEMSET(urlinput_arr, 0, MAX_CMD_LEN);

     //SCI_TRACE_LOW:"[MMIATC]:Atest_HandleURL:%s"
     SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_2539_112_2_18_1_59_29_14,(uint8*)"s", (char *)cmd);
     //transform to 16 hex
     for(i=0; i<len; i++)
     {	
		_snprintf((char *)tmp, sizeof(tmp), "%2x", cmd[i]);
		strncat((char *)urlinput_arr, (char *)tmp, 2);
		
		SCI_MEMSET(tmp, 0, CMD_TEM_LEN);
		
     }
     ilen = SCI_STRLEN((char *)urlinput_arr);
     //SCI_TRACE_LOW:"[MMIATC]:Atest_HandleURL2:%s, %d"
     SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_2550_112_2_18_1_59_29_15,(uint8*)"sd", (char *)urlinput_arr, ilen);
     if(len > 0)
     {    
	       //transform to wchar
		urlinput_ptr = (wchar *)GetATCParameter(txt_type, urlinput_arr, ilen, 0);
		if(NULL != urlinput_ptr)
		{     
		       //insert to URL editbox
		       res = Atest_BROWSERInsertURL(urlinput_ptr, MMIAPICOM_Wstrlen(urlinput_ptr));
			//SCI_TRACE_LOW:"[ATC:][ATEST:][ST:]Atest_HandleURL:url_input:%x, %x, %d"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_2559_112_2_18_1_59_29_16,(uint8*)"ddd", urlinput_ptr[0], urlinput_ptr[1], res);
			SCI_FREE(urlinput_ptr);
			
		}
		else
		{
			return FALSE;
			
		}
     }
     //handle the result
     if(res)
     {
		ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)(strlen((char*)MMI_TO_SYNC_OK_SYMBOL)));
		return TRUE;
     }
     else
     {
		ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16) (strlen((char *)MMI_TO_SYNC_ERROR_SYMBOL)));
		return FALSE;
     }
     #else
         return FALSE;
     #endif//BROWSER_SUPPORT
	
}


/*****************************************************************************/
// 	Description : This function handle ft connect gatewayinput at cmd 
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleConnectGatewayDNS(
                                                             uint8 * cmd,                     //point ot input IP buffer
                                                             uint32 len                        //length of information buffer
                                                           )
{    
     BOOLEAN res = FALSE;

     //check input parameter   
     if(NULL == cmd)
     {
	    return FALSE;
     }
     if(len > 0)
     {  
	    //input ip address to editbox
	    res = Atest_CONNECTIONGATEWAY_DNS_InsertStr(cmd);
	    //SCI_TRACE_LOW:"[ATC:][ATEST:][FT:]Atest_HandleConnectGatewayDNS:%x, %x"
	    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_2607_112_2_18_1_59_29_17,(uint8*)"dd", cmd[0], cmd[1]);

     }
     //handle the result
     if(res)
     {
	    ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)(strlen((char*)MMI_TO_SYNC_OK_SYMBOL)));
	    return TRUE;
     }
     else
     {
	    ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16) (strlen((char *)MMI_TO_SYNC_ERROR_SYMBOL)));
	    return FALSE;
     }

}



/*****************************************************************************/
// 	Description : This function handle connection configuration from at+ftin cmd 
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleConnectOther(
                                                                  uint8 * cmd,                    //point to input connection information buffer
                                                                  uint32 len                        //length of  information buffer
                                                                  )
{
     wchar *conninput_ptr = NULL;
     uint32 txt_type;
     BOOLEAN res= FALSE;
     uint8 ftinput_arr[MAX_CMD_LEN] = {0};
     uint8 tmp[CMD_TEM_LEN];	  
     uint32 i, ilen;  

	  
     if(NULL == cmd)
     {
	   return FALSE;
     }

     //set the transform type
     txt_type = MMI_UT_UTF8;
     SCI_MEMSET(ftinput_arr, 0, MAX_CMD_LEN);

     //transform to the 16 hex
     for(i=0; i<len; i++)
     {	
	   _snprintf((char *)tmp, sizeof(tmp), "%2x", cmd[i]);
	   strncat((char *)ftinput_arr, (char *)tmp, 2);
	   SCI_MEMSET(tmp, 0, CMD_TEM_LEN);
		
     }
     ilen = SCI_STRLEN((char *)ftinput_arr);
     if(len > 0)
     {         
          //transform to wchar
          conninput_ptr = (wchar *)GetATCParameter(txt_type, ftinput_arr, ilen, 0);
          if(NULL != conninput_ptr)
          {    
	        //insert string to mmi editbox
	        res = MMIAPICONNECTION_InsertStr(conninput_ptr, MMIAPICOM_Wstrlen(conninput_ptr));
	        //SCI_TRACE_LOW:"[ATC:][ATEST:][FT:]Atest_HandleConnectOther:conne_input:%x, %x"
	        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_2669_112_2_18_1_59_29_18,(uint8*)"dd", conninput_ptr[0], conninput_ptr[1]);
	        SCI_FREE(conninput_ptr);
			
          }
          else
          {
	        return FALSE;
			
          }
     }

     // handle the result 
     if(res)
     {
          ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)(strlen((char*)MMI_TO_SYNC_OK_SYMBOL)));
          return TRUE;
     }
     else
     {
          ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16) (strlen((char *)MMI_TO_SYNC_ERROR_SYMBOL)));
          return FALSE;
     }
	
	
}


/*****************************************************************************/
// 	Description : This function handle ft connection information
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleConnection(
	                                              uint8 * cmd,           //point to input connection information buffer
	                                              uint32 len               //length of  information buffer
	                                              )       
{
	
     uint8 con_type = 0;
     BOOLEAN res= FALSE;

     //check input at cmd  
     if(NULL == cmd)
     {
          return FALSE;
     }
     //get the handle connection configuration type
     con_type = *(cmd++);
     len = len -1;

      
     switch(con_type)
     {
          //handle gateway and dns ip address input
          case 'g':
          case 'G':
	       res = Atest_HandleConnectGatewayDNS(cmd, len);
	       break;
          //handle connection other page string input
          case 'p':
          case 'P':
	       res = Atest_HandleConnectOther(cmd, len);
	       break;
          //error type
          default:
	       //SCI_TRACE_LOW:"[ATC:][ATEST:][Atest_HandleConnection:] %c"
	       SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_2733_112_2_18_1_59_29_19,(uint8*)"c", (char)con_type);
	       break;
     }
     return res;
}


/*****************************************************************************/
// 	Description : This function handle  at cmd  from at+ftin
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleFtAtMMI(
 								uint8 *cmd,                               //input at cmd
 								uint32 len                                  //input at length
  								)
{
     uint8 funtype = 0;
     BOOLEAN res_code = FALSE;
	 
     funtype = *(cmd++);
     len = len -1;
	 
     switch(funtype)
     {     
           //connection configuration input
          case 'c':
          case 'C':
	       res_code = Atest_HandleConnection(cmd, len);
	       break;
          //bookmark configuration input		 
          case 'B':
          case 'b':
	       res_code = Atest_HandleBookmark(cmd, len);
	       break;

#ifdef ATEST_SUPPORT	       
        case 'I':
        case 'i':
            res_code = Atest_HandleControlInput(cmd, len);
        break;	    
#endif // ATEST_SUPPORT
           
          //error switch		 
          default:
	       //SCI_TRACE_LOW:"[ATC:][FT:][Atest_HandleFtAtMMI:]connection input type error!"
	       SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_2777_112_2_18_1_59_30_20,(uint8*)"");
	       break;
     }
     return res_code;

}



/*****************************************************************************/
// 	Description : This function handle ft bookmark title  input from at+ftin cmd 
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleBmTitle(
                                                             uint8 * cmd,      //at input title cmd
                                                             uint32 len         //input at length
                                                           )
{   
     #ifdef BROWSER_SUPPORT
     wchar *conninput_ptr = NULL;
     uint32 txt_type = 0;
     BOOLEAN res= FALSE;

	  
     if(NULL == cmd  )
     {
          return FALSE;
     }

     //set the transform type
     txt_type =  MMI_UT_UTF8;	
			
     if(len > 0)
     {     
          //transform to wchar
          conninput_ptr = (wchar *)GetATCParameter(txt_type, cmd, len, 0);
          if(NULL != conninput_ptr)
          {            
	       //input string to bookmark title editbox
	       res = Atest_BROWSERBookmarkTitleInput(conninput_ptr, MMIAPICOM_Wstrlen(conninput_ptr));
	       //SCI_TRACE_LOW:"[ATC:][ATEST:][FT:]Atest_HandleBmTitle:conne_input:%x, %x, %d"
	       SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_2817_112_2_18_1_59_30_21,(uint8*)"ddd", conninput_ptr[0], conninput_ptr[1], (int)txt_type);
	       SCI_FREE(conninput_ptr);
			
          }
          else
          {
	       return FALSE;
			
          }
     }
     //handle the result
     if(res)
     {
          ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)(strlen((char*)MMI_TO_SYNC_OK_SYMBOL)));
          return TRUE;
     }
     else
     {
          ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16) (strlen((char *)MMI_TO_SYNC_ERROR_SYMBOL)));
          return FALSE;
     }
     #else
         return FALSE;
     #endif //BROWSER_SUPPORT
	
	
}


/*****************************************************************************/
// 	Description : This function handle ft bookmark URL input  from at+ftin cmd  
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleBmURL(
                                                             uint8 * cmd,                  //input at cmd for bookmark url                     
                                                             uint32 len                     //input at length
                                                           )
{
     #ifdef BROWSER_SUPPORT	
     wchar *conninput_ptr = NULL;
     uint32 txt_type;
     BOOLEAN res= FALSE;

	  
     if(NULL == cmd )
     {
          return FALSE;
     }

     //set the transform type 
     txt_type = MMI_UT_UTF8;	
     if(len > 0)
     {      
          //transform to wchar
          conninput_ptr = (wchar *)GetATCParameter(txt_type, cmd, len, 0);
          if(NULL != conninput_ptr)
          {    
	       //input string to bookmark url editbox
	       res = Atest_BROWSERBookmarkURLInput(conninput_ptr, MMIAPICOM_Wstrlen(conninput_ptr));
	       //SCI_TRACE_LOW:"[ATC:][ATEST:][FT:]Atest_HandleBmURL:conne_input:%x, %x, %d"
	       SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_2876_112_2_18_1_59_30_22,(uint8*)"ddd", conninput_ptr[0], conninput_ptr[1], (int)txt_type);
	       SCI_FREE(conninput_ptr);
			
          }
          else
          {
	       return FALSE;
			
          }
     }
     //handle the result
     if(res)
     {
          ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)(strlen((char*)MMI_TO_SYNC_OK_SYMBOL)));
          return TRUE;
     }
     else
     {   
          ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16) (strlen((char *)MMI_TO_SYNC_ERROR_SYMBOL)));
          return FALSE;
     }
     #else
         return FALSE;
     #endif //BROWSER_SUPPORT
	
}




/*****************************************************************************/
// 	Description : This function handle  bookmark input from at+ftin cmd 
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleBookmark(
                                                             uint8 * cmd,                          //point to input connection information buffer
                                                             uint32 len                               //length of  information buffer
                                                             )
{    
     uint8 bm_type = 0;
     BOOLEAN res= FALSE;
     uint8 bm_arr[MAX_CMD_LEN] = {0};
     uint8 bm_tmp[CMD_TEM_LEN];
     uint32 i, ilen;
	  
     if(NULL == cmd)
     {
          return FALSE;
     }
     //get the book mark handle type
     bm_type = *(cmd++);
     len = len -1;

     SCI_MEMSET(bm_arr, 0, MAX_CMD_LEN);

     //transform to the 16 hex
     for(i=0; i<len; i++)
     {	
          _snprintf((char *)bm_tmp, sizeof(bm_tmp), "%2x", cmd[i]);
          strncat((char *)bm_arr, (char *)bm_tmp, 2);
          SCI_MEMSET(bm_tmp, 0, CMD_TEM_LEN);
		
     }
     ilen = SCI_STRLEN((char *)bm_arr);
     
     switch(bm_type)
     {
          //input bookmark title
          case 't':
          case 'T':
	       res = Atest_HandleBmTitle(bm_arr, ilen);
	       break;
          //input bookmark url
          case 'u':
          case 'U':
	       res = Atest_HandleBmURL(bm_arr, ilen);
	       break;
          default:
	       //SCI_TRACE_LOW:"[ATC:][ATEST:][Atest_HandleBookmark:] %c"
	       SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_2954_112_2_18_1_59_30_23,(uint8*)"c", (char)bm_type);
	       res = FALSE;
	       break;
     }
     return res;
	
}



/*****************************************************************************/
// 	Description : This function  handle  SMS input from at+sytin cmd
//	Global resource dependence : none
//  Author:       shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleSMS(
	                                                 uint8 *cmd,                                              //input at cmd for sms
 								uint32 len                                               //input at length 
 								)
{
     wchar *smsinput_ptr = NULL;
     uint32 txt_type;
     BOOLEAN res= FALSE;

	  
     if(NULL == cmd)
     {
          return FALSE;
     }

     //set the transform type
     txt_type = MMI_UT_UNICODE;
     if(len > 0)
     {     
          //transform to wchar
          smsinput_ptr = (wchar *)GetATCParameter(txt_type, cmd, len, 0);
          if(NULL != smsinput_ptr)
          {     
	       //insert to SMS editbox
	       res = MMIAPISMS_InsertMessage(smsinput_ptr, MMIAPICOM_Wstrlen(smsinput_ptr));
	       //SCI_TRACE_LOW:"[ATC:][ATEST:][ST:]Atest_HandleSMS:sms_input:%x, %x"
	       SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_2993_112_2_18_1_59_30_24,(uint8*)"dd", smsinput_ptr[0], smsinput_ptr[1]);
	       SCI_FREE(smsinput_ptr);
			
          }
          else
          {
	       return FALSE;
			
          }
     }
     //handle the result
     if(res)
     {
          ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)(strlen((char*)MMI_TO_SYNC_OK_SYMBOL)));
          return TRUE;
     }
     else
     {
          ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16) (strlen((char *)MMI_TO_SYNC_ERROR_SYMBOL)));
          return FALSE;
     }
	
}




/*****************************************************************************/
// 	Description : This function handle create vertilcal folder from at+sytin cmd
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleFolderVerti(
                                                            uint8 * cmd,                        //point to the folder information buffer
                                                             uint32 len                             //length of information
                                                           )
{   
     uint8 txt_type;
     uint16 folder_num;
     BOOLEAN res= FALSE;

	  
     if(NULL == cmd )
     {
          return FALSE;
     }

     //check the input is digit
     txt_type = *cmd;
     if(txt_type<'0' || txt_type>'9')
     {
          return FALSE;
     }
     if(len > 0)
     {
          //get the folder number
          folder_num = atoi((char *)cmd);
          if(folder_num>MMIFMM_PATH_DEPTH)
          {
	       return FALSE;
           }
          //create the folder
          res = Atest_FMMCreateFolderVerti( folder_num);
     }
     //handle the result
     if(res)
     {
          ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)(strlen((char*)MMI_TO_SYNC_OK_SYMBOL)));
          return TRUE;
     }
     else
     {
          ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16) (strlen((char *)MMI_TO_SYNC_ERROR_SYMBOL)));
          return FALSE;
     }
}


/*****************************************************************************/
// 	Description : This function handle create horizontal folder from at+sytin cmd
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleFolderHori(
                                                            uint8 * cmd,                        //point to the folder information buffer
                                                             uint32 len                             //length of information
                                                           )
{
     uint8 txt_type;
     uint16 folder_num;
     BOOLEAN res= FALSE;

     if(NULL == cmd )
     {
          return FALSE;
     }

     //check the input is digit
     txt_type = *cmd;
     if(txt_type<'0' || txt_type>'9')
     {
          return FALSE;
     }
     if(len > 0)
     {     
          //get the folder number
          folder_num = atoi((char *)cmd);
          if(folder_num>MMIFMM_FILE_NUM)
          {
	       return FALSE;
          }
          //create the horizontal folder
          res = Atest_FMMCreateFolderHori(folder_num);
     }
     //handle the result
     if(res)
     {
          ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)(strlen((char*)MMI_TO_SYNC_OK_SYMBOL)));
          return TRUE;
     }
     else
     {
          ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16) (strlen((char *)MMI_TO_SYNC_ERROR_SYMBOL)));
          return FALSE;
     }
}



/*****************************************************************************/
// 	Description : This function handle create folder creat from at+sytin cmd
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleFolder(
                                                            uint8 * cmd,                        //point to the folder information buffer
                                                             uint32 len                             //length of information
                                                           )
{
     uint8 bm_type = 0;
     BOOLEAN res= FALSE;
	  
     if(NULL == cmd)
     {
		return FALSE;
     }
     //get the create folder type
     bm_type = *(cmd++);
     len = len -1;

     
     switch(bm_type)
     {     
          //create horizontal folder
          case 'h':
          case 'H':
	       res = Atest_HandleFolderHori(cmd, len);
	       break;
          //create vertical folder
          case 'v':
          case 'V':
	       res = Atest_HandleFolderVerti(cmd, len);
	       break;
          //error switch
          default:
	       //SCI_TRACE_LOW:"[ATC:][ATEST:][Atest_HandleFolder:] %c"
	       SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_3155_112_2_18_1_59_30_25,(uint8*)"c", (char)bm_type);
	       res = FALSE;
	       break;
     }
     return res;

	
}



/*****************************************************************************/
// 	Description : This function  handle cmd  from at+sytin cmd
//	Global resource dependence : none
//  Author:       shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleStAtMMI(
 								uint8 *cmd,                                      //input st at cmd
 								uint32 len                                        //input at cmd length 
                                                               )
{
     uint8 funtype = 0;
     BOOLEAN res_code = FALSE;

     if(NULL == cmd)
     {
          return FALSE;
     }
     //get the funtion type	 
     funtype = *(cmd++);
     len = len -1;
     switch(funtype)
     {
          //handle sms input
          case 'S':
          case 's':
	       res_code = Atest_HandleSMS(cmd, len);
	       break;
          //handle url input
          case 'U':
          case 'u':
	       res_code = Atest_HandleURL(cmd, len);
	       break;
          //handle folder create
          case 'F':
          case 'f':
	       res_code = Atest_HandleFolder(cmd, len);
	       break;
	   //handle pb create
          case 'p':
	   case 'P':
	   	 res_code = Atest_HandlePhoneBook(cmd, len);
	   	 break;
          //erro switch
          default:
	       //SCI_TRACE_LOW:"[ATC:][FT:][Atest_HandleStAtMMI:]connection input type error!"
	       SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_3209_112_2_18_1_59_30_26,(uint8*)"");
	       res_code = FALSE;
	       break;
     }
     return res_code;

}



/*****************************************************************************/
// 	Description : This function handle Atest at cmd
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleAtMMI(
	                                                        uint8 * cmd,                             //input at cmd
                                                               uint32 len                                 //input at length
	                                                             )
{
     uint8 test_type = 0;
     BOOLEAN res = FALSE;

     //get the function type    
     test_type = *(cmd++);
     len = len - 1;
     switch(test_type)
     {     
          //handle at cmd from at+ftin
          case 'f':
          case 'F':
	       res = Atest_HandleFtAtMMI(cmd, len);
	       break;
          //handle at cmd from at+sytin
          case 's':
          case 'S':
	       res = Atest_HandleStAtMMI(cmd, len);
	       break;
          //erro switch
          default:
	       res = FALSE;
	       //SCI_TRACE_LOW:"[ATC:][MMI:][Atest_HandleAtMMI]input test type error!"
	       SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_3249_112_2_18_1_59_31_27,(uint8*)"");
	       break;
     }
     return res;
	
}

#ifdef ATEST_SUPPORT
// 控件输入自动测试
/*****************************************************************************/
// 	Description : ATEST拦截外部消息并处理
//	Global resource dependence : none
//  Author: xiaolei.zheng
//	Note:
/*****************************************************************************/
PUBLIC void ATest_DispatchExtSig(MmiSignalS **signal_pptr)
{   
	uint8 *user_data_ptr = PNULL;
	uint8 *start_ptr = PNULL;
	BOOLEAN result = FALSE;
	uint32 reseved_data = 0;
	uint32 rect_x = 0;
	uint32 rect_y = 0;
	uint32 rect_data = 0;	

	MmiOtherTaskMsgS* signal_ptr =  (MmiOtherTaskMsgS*)(*signal_pptr);
	user_data_ptr = (uint8 *)(signal_ptr->param_ptr);
	reseved_data = (signal_ptr->msg_id);


	switch((*signal_pptr)->SignalCode)
	{
		case ATEST_SIGNAL_IGCT:
			result = Atest_GetControlTree(user_data_ptr);
			SCI_FREE(user_data_ptr);
			break;

		case ATEST_SIGNAL_IGCD:
			result = Atest_GetControlData(user_data_ptr);
			SCI_FREE(user_data_ptr);
			break;

		case ATEST_SIGNAL_IFCD:
			result = Atest_FillControlData(user_data_ptr);
			SCI_FREE(user_data_ptr);
			break;

		case ATEST_SIGNAL_ISCP:
			result = Atest_ClickControl(user_data_ptr);	
			SCI_FREE(user_data_ptr);
			break;

		case ATEST_SIGNAL_IGCL:
			result = Atest_GetCurLang();
			SCI_FREE(user_data_ptr);
			break;

		case ATEST_SIGNAL_IGCR:
			result = Atest_GetCurResolution();	
			SCI_FREE(user_data_ptr);
			break;	

		case ATEST_SIGNAL_KB_DOWN:
			Atest_ResolveKbdSignal(SCI_VK_DOWN,user_data_ptr,reseved_data);	
			SCI_FREE(user_data_ptr);
			break;

		case ATEST_SIGNAL_KB_UP:
			Atest_ResolveKbdSignal(SCI_VK_UP,user_data_ptr,reseved_data);			
			SCI_FREE(user_data_ptr);
			break;

		case ATEST_SIGNAL_KB_RIGHT:
			Atest_ResolveKbdSignal(SCI_VK_RIGHT,user_data_ptr,reseved_data);			
			SCI_FREE(user_data_ptr);
			break;

		case ATEST_SIGNAL_KB_LEFT:
			Atest_ResolveKbdSignal(SCI_VK_LEFT,user_data_ptr,reseved_data);			
			SCI_FREE(user_data_ptr);
			break;

		case ATEST_SIGNAL_IGLN:
			result = Atest_GetListNum(user_data_ptr);
			SCI_FREE(user_data_ptr);
			break;
			
		case ATEST_SIGNAL_TPLONG:
			if(PNULL != user_data_ptr)
			{
				start_ptr = user_data_ptr;
				rect_x = Atest_GetTestMessageId(',',&start_ptr);
				rect_y = Atest_GetTestMessageId(',',&start_ptr);
			}
			rect_data = rect_x<<16|rect_y;
			#ifdef TOUCH_PANEL_SUPPORT
			MMK_DispatchMSGTpLong(rect_x, rect_y);
			#endif
			SCI_FREE(user_data_ptr);
			break;
			
		case ATEST_SIGNAL_IRIW:
			MMK_ReturnIdleWin();
			SCI_FREE(user_data_ptr);
			break;
			
		case ATEST_SIGNAL_ICES:
			Atest_ClearAllStr(user_data_ptr);
			SCI_FREE(user_data_ptr);
			break;

		case ATEST_SIGNAL_ITPR:
			Atest_TouchPanelPoint(user_data_ptr);
			SCI_FREE(user_data_ptr);
			break;
		case ATEST_SIGNAL_ITPD:
			Atest_TouchPanelDown(user_data_ptr);
			SCI_FREE(user_data_ptr);
			break;
		case ATEST_SIGNAL_ITPM:
			Atest_TouchPanelMove(user_data_ptr);
			SCI_FREE(user_data_ptr);
			break;
		case ATEST_SIGNAL_ITPU:
			Atest_TouchPanelUp(user_data_ptr);
			SCI_FREE(user_data_ptr);
			break;
		case ATEST_SIGNAL_IKBD:
			Atest_KBDown(user_data_ptr);
			SCI_FREE(user_data_ptr);
			break;
		case ATEST_SIGNAL_IGCS:
			result = Atest_GetCurStyle(user_data_ptr);			 
			SCI_FREE(user_data_ptr);
			break;		
			
		case ATEST_SIGNAL_IGST:
			result = Atest_GetCurSysTime(user_data_ptr);			 
			SCI_FREE(user_data_ptr);
			break;

		case ATEST_SIGNAL_ISAT:
			result = Atest_SetAlarmTime(user_data_ptr);			 
			SCI_FREE(user_data_ptr);
			break;

		case ATEST_SIGNAL_IGAT:
			result = Atest_GetLatestAlarmTime(user_data_ptr);			 
			SCI_FREE(user_data_ptr);
			break;
			
		case ATEST_SIGNAL_ICCD:
			result = Atest_ClickCalendarDate(user_data_ptr);			 
			SCI_FREE(user_data_ptr);
			break;

		default:
			break;
	}

	if((*signal_pptr)->SignalCode >= ATEST_SIGNAL_KB_DOWN && (*signal_pptr)->SignalCode < ATEST_SIGNAL_MAX)
	{
		//SCI_TRACE_LOW:"[AT][ATEST]:ATest_DispatchExtSig--signalType=0x%x,handleresult=%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_3380_112_2_18_1_59_31_28,(uint8*)"dd",(*signal_pptr)->SignalCode,result);
	}
    return;    
}

/*****************************************************************************/
//  Description: 将十六进制字符串从手机端传回PC端
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL int32 Atest_TransmitATString( // 返回校验码: 传输的数据部分的累加，参数is_need_check=TRUE有效
    uint8 *data_ptr,                // 传输的数据
    uint16 data_len,                // 传输的数据长度
    BOOLEAN is_unicode,             // 判定是否需要将Unicode编码转换为十六进制字符串
    BOOLEAN is_need_checksum)       // 判定是否需要计算校验和
{
    uint16 max_trans_len = 0, trans_data_len = 0, code_convert_len = 0, data_index = 0;
    uint8 *code_convert_ptr = PNULL, *trans_data_ptr = PNULL;
    int32 data_checksum = 0;

    // 传输数据超过一次能传输的最大长度，按照最大长度分段传输
    while (data_len > 0)
    {
        if (data_len > ATEST_MAX_SEND_LEN)
        {
            max_trans_len = ATEST_MAX_SEND_LEN;
        }
        else // 传输最后一段
        {
            max_trans_len = data_len;
        }

        // 如果是Unicode，则需要转换为十六进制字符，因为AT只能传输ASCII字符
        if (is_unicode)
        {
            // 按照最大传输长度转换Unciode编码
            if (PNULL == code_convert_ptr)
            {
                code_convert_ptr = (uint8 *)SCI_ALLOC_APP(ATEST_MAX_SEND_LEN * 2 + 1);
                SCI_MEMSET(code_convert_ptr, 0, ATEST_MAX_SEND_LEN *2 + 1);
            }

            MMIAPICOM_BinaryToHexChar(data_ptr, max_trans_len, code_convert_ptr, &code_convert_len);

            // 修正传输数据为编码转换后的数据，长度为编码转换后长度
            trans_data_ptr = code_convert_ptr;
            trans_data_len = code_convert_len;
        }
        else // 不需要编码转换的，直接传回
        {
            trans_data_ptr = data_ptr;
            trans_data_len = max_trans_len;
        }

        if (is_need_checksum) // 生成数据校验和，将各个字符编码值累加
        {
            for (data_index = 0; data_index < trans_data_len; data_index++)
            {
                data_checksum += trans_data_ptr[data_index];
            }
        }

         ReturnResponse(trans_data_ptr, trans_data_len);
        // 用AT通道传回
        //SIO_ATC_WriteCmdRes(trans_data_ptr, trans_data_len);

        // 修正剩余长度，和下一次传输位置
        data_ptr += max_trans_len;
        data_len -= max_trans_len;
    };

    if (code_convert_ptr)
    {
        SCI_FREE(code_convert_ptr);
    }
	
#ifndef WIN32
	SCI_SLEEP(1);
#endif //WIN32

    return data_checksum;
}
/*****************************************************************************/
//  Description: 获取控件属性
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetControlProperty(
    IGUICTRL_T *ctrl_ptr,    
    BOOLEAN is_mark_end,    // 控件遍历结束标记: </CONTROL>
    uint8 *data_ptr,        // 需要传输的控件属性数据
    uint32 *data_size_ptr)  // 传输数据大小
{
    char *ctrl_name_ptr = PNULL;
	wchar *user_item_ptr = NULL;
    uint16 data_len = 0;

    // 根据GUID判定控件类型
    CAF_GUID_T ctrl_guid = GUICTRL_GetCtrlGuid((IGUICTRL_T *)ctrl_ptr);
	
	// 根据控件指针获取控件handle，根据handle获取控件id 
	MMI_HANDLE_T ctrl_handle = GUICTRL_GetCtrlHandle((IGUICTRL_T *)ctrl_ptr);
    MMI_CTRL_ID_T ctrl_id = MMK_GetCtrlId(ctrl_handle);
	if(!ctrl_id)
	{
		return;
	}

	ctrl_ptr = MMK_GetCtrlPtrByWin(MMK_GetFocusWinHandle(), ctrl_id);
    if (PNULL == ctrl_ptr)
    {
        return;
    }

	user_item_ptr = (wchar *)SCI_ALLOC_APP(8192);
    if (user_item_ptr == PNULL)
    {
        return;    
    }
	SCI_MEMSET(user_item_ptr, 0, 8192);
   
    switch (ctrl_guid)
    {
        case SPRD_GUI_RICHTEXT_ID :
        {
            ctrl_name_ptr = "richtext";        
    		if (is_mark_end)
    		{
    			break;
    		}
			Atest_GetRichTextControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }
        break;
        
        case SPRD_GUI_EDITBOX_ID : // 处理编辑框
        {
            ctrl_name_ptr = "editbox";                
    		if (is_mark_end)
    		{
    			break;
    		}
			Atest_GetEditControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }
        break;
	  case SPRD_GUI_TEXTEDIT_ID : // 处理编辑框
        {
            ctrl_name_ptr = "editbox";                
    		if (is_mark_end)
    		{
    			break;
    		}
			Atest_GetTextEditControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }
        break;
	 case SPRD_GUI_PHONENUMEDIT_ID : // 处理编辑框
        {
            ctrl_name_ptr = "editbox";                
    		if (is_mark_end)
    		{
    			break;
    		}
			Atest_GetTextEditControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }
        break;
	case SPRD_GUI_DIGITALEDIT_ID : // 处理编辑框
        {
            ctrl_name_ptr = "editbox";                
    		if (is_mark_end)
    		{
    			break;
    		}
			Atest_GetTextEditControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }
        break;
	case SPRD_GUI_PSWEDIT_ID : // 处理编辑框
        {
            ctrl_name_ptr = "editbox";                
    		if (is_mark_end)
    		{
    			break;
    		}
			Atest_GetTextEditControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }
        break;

        case SPRD_GUI_DROPDOWNLIST_ID : // 处理下拉列表
        {
            ctrl_name_ptr = "dropdownlist";
    		if (is_mark_end)
    		{
    			break;
    		}
			Atest_GetDropListControlProperty( ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }
        break;
	 case SPRD_GUI_LISTEDIT_ID:
        case SPRD_GUI_LIST_ID :
        {                       
            ctrl_name_ptr = "list";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetListControlProperty( ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
	    }
        break;

        case SPRD_GUI_ANIM_ID :
        {   
			ctrl_name_ptr = "anim";
			if (is_mark_end)
			{
				break;
			} 
			Atest_GetAnimControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }
		break;
        case SPRD_GUI_MAINMENU_ID:
	{
			ctrl_name_ptr = "mainmenu";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetMainMenuControlProperty( ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }
	break;

        case SPRD_GUI_MENU_ID :
        {
			ctrl_name_ptr = "menu";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetMenuControlProperty( ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }	
        break;

        case SPRD_GUI_MSGBOX_ID :
        {
			ctrl_name_ptr = "msgbox";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetMsgBoxControlProperty( ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }
        break;

        case SPRD_GUI_PRGBOX_ID :
        {    ctrl_name_ptr = "prgbox";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetPrgBoxControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }
		break;

        case SPRD_GUI_TEXTBOX_ID :
        {    ctrl_name_ptr = "textbox";
			if (is_mark_end)
			{
				break;
			} 
			Atest_GetTextControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }
        break;

        case SPRD_GUI_LABEL_ID :
         {   ctrl_name_ptr = "label";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetLableControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        
		}
		break;
        
        case SPRD_GUI_PUNCTUATION_ID :
        {    ctrl_name_ptr = "punctuation";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetPunctuationControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }   
        break;            

        case SPRD_GUI_BUTTON_ID :
        {    ctrl_name_ptr = "button";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetButtonControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }	
        break;

        case SPRD_GUI_ICONLIST_ID :
        {    
			ctrl_name_ptr = "iconlist";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetIconlistControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }	
        break;

        case SPRD_GUI_TAB_ID :
         {
		 	ctrl_name_ptr = "tab";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetTabControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }	
        break;

        case SPRD_GUI_STATUSBAR_ID :
        {    ctrl_name_ptr = "statusbar";
			if (is_mark_end)
			{
				break;
			} 
			Atest_GetStatusBarControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }
        break;

        case SPRD_GUI_SOFTKEY_ID :
        {    ctrl_name_ptr = "softkey";
			if (is_mark_end)
			{
				break;
			}
            Atest_GetsoftkeyControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);		
        }
		break;

        case SPRD_GUI_TIPS_ID :            
		{	ctrl_name_ptr = "tips";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetTipsControlProperty( ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
		}	
	    break;

	    case SPRD_GUI_TITLE_ID :
	    {
			ctrl_name_ptr = "title";
			if (is_mark_end)
			{
				break;
			} 
			Atest_GetTitleControlProperty( ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);				
	    }    
	    break;

	    case SPRD_GUI_IM_ID :
	     {
		 	ctrl_name_ptr = "im";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetIMControlProperty( ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);	
	    }
	    break;

	    case SPRD_GUI_SETLIST_ID :
	    {
			ctrl_name_ptr = "setlist";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetSetListControlProperty( ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
	    }
		break;

	    case SPRD_GUI_FORM_ID :
	    {
			ctrl_name_ptr = "form";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetFormControlProperty( ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
	    }
		break;

        case SPRD_GUI_OWNDRAW_ID :
        {
			ctrl_name_ptr = "owndraw";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetOwndrawControlProperty( ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }	
        break;

        case SPRD_GUI_TOOLBAR_ID :
		{
			ctrl_name_ptr = "toolbar";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetToolbarControlProperty( ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }			
        break;

		case SPRD_GUI_ICONFOLDER_ID:
		{
			ctrl_name_ptr = "iconfolder";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetIconfolderControlProperty( ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }			
        break;
			
#ifdef GUI_CTRL_SCROLL_KEY
		case SPRD_GUI_SCROLLKEY_ID:
		{
			ctrl_name_ptr = "scrollkey";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetScrollkeyControlProperty( ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }			
        break;
#endif
       
        default : 
            ctrl_name_ptr = "unknown";
			if (is_mark_end)
			{
				break;
			}            
            data_len = sprintf((char *)data_ptr, "<%s>", ctrl_name_ptr);
            Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
            *data_size_ptr += data_len;        
        break;
    }

    if (is_mark_end) // 结束标签
    {
        data_len = sprintf((char *)data_ptr, "</%s>", ctrl_name_ptr);
        // 累计传输数据长度
        *data_size_ptr += data_len;
        // 将XML数据传回，这些数据都是ASCII，不需要Unciode转换，不存在数据错误，不需要校验
        Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
    }
	
    SCI_FREE(user_item_ptr);
}

/*****************************************************************************/
//  Description: 解析PC端发过来的消息内容: 窗体ID，长度，位置等，用逗号分隔
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL uint32 Atest_GetTestMessageId( // 返回消息内容: 窗体ID，长度，位置
    char separator,                  // ID分隔符
    uint8 **message_pptr)            // 返回指向下一个要解析的位置
{
    uint8 mssage_id_arr[16] = { 0 }, *start_ptr = *message_pptr, *end_ptr = PNULL;
    uint32 mssage_id = 0;

    // 解析两个逗号之间的部分，为mssage_id
    while ( ('\0' != *start_ptr) && (*start_ptr != separator) )
    {
        start_ptr++;
    }

    end_ptr = ++start_ptr;
    start_ptr = mssage_id_arr;

    while ( ('\0' != *end_ptr) && (*end_ptr != separator) )
    {
        *start_ptr++ = *end_ptr++;
    }

    mssage_id = atoi((char *)mssage_id_arr);

    // *message_pptr指向下一个待解析的消息
    *message_pptr = end_ptr;

    return mssage_id;
}

/*****************************************************************************/
//  Description: 解析PC端指令，填充控件数据，返回填充结果
//               AT+SFTIN="IFCD,393435,31002D4E" -> 10,20
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_FillControlData( // 填充失败，返回FALSE
    uint8 *user_data_ptr)            // 用户填充指令和数据
{
    uint16 fill_str_len = 0, data_len = 0, max_len = 0, max_num = 0, year;
    uint8 month, day, hour, minute, second;
    uint32 ip_addr;
    wchar *fill_str_ptr = PNULL;
    char *special_str_ptr = PNULL;
    uint8 *start_ptr = user_data_ptr;
    uint8 *end_ptr = user_data_ptr + strlen((char *)user_data_ptr);
    uint8 special_data[16] = { 0 };
    MMI_CTRL_ID_T ctrl_id;
    CAF_GUID_T ctrl_guid;
    MMI_HANDLE_T win_handle;
	MMI_HANDLE_T ctrl_handle;

    IGUICTRL_T *ctrl_ptr = PNULL;
    CTRLBASEEDIT_OBJ_T *edit_ctrl_ptr = PNULL;
    CTRLDROPDOWNLIST_OBJ_T *dropdownlist_ctrl_ptr = PNULL;	

    // 解析控件ID，计算要填充的控件数据长度
    ctrl_id = Atest_GetTestMessageId(',', &start_ptr);
    // 跳过分隔符，指向数据部分
    if (end_ptr > start_ptr)
    {
        start_ptr++;
    }
    // 计算数据部分的长度
    fill_str_len = end_ptr - start_ptr;

    // 获取焦点窗体handle
    win_handle = MMK_GetFocusWinHandle();
    // 从焦点窗体搜索与客户端控件ID相同的控件
    ctrl_ptr = MMK_GetCtrlPtrByWin(win_handle, ctrl_id);
    if (PNULL == ctrl_ptr)
    {
        return FALSE;
    }

	ctrl_handle = GUICTRL_GetCtrlHandle(ctrl_ptr);

    // 客户端传回的是十六进制UNICODE字符，转换为UNICODE编码，再填充目标控件
    fill_str_ptr = (wchar *)GetATCParameter(MMI_UT_UNICODE, start_ptr, fill_str_len, 0);
    if (PNULL == fill_str_ptr)
    {
        return FALSE;
    }

    ctrl_guid = GUICTRL_GetCtrlGuid(ctrl_ptr);
    // 根据控件GUID判定要处理的目标控件
    if (SPRD_GUI_EDITBOX_ID == ctrl_guid
	|| (SPRD_GUI_TEXTEDIT_ID == ctrl_guid) 
		|| (SPRD_GUI_PHONENUMEDIT_ID == ctrl_guid) 
		|| (SPRD_GUI_DIGITALEDIT_ID == ctrl_guid) 
		|| (SPRD_GUI_PSWEDIT_ID == ctrl_guid) 
		|| (SPRD_GUI_LISTEDIT_ID == ctrl_guid) ) // 处理编辑框
    {
        edit_ctrl_ptr = (CTRLBASEEDIT_OBJ_T *)ctrl_ptr;

        // 列表类型，列表项最大长度即为边界，逐项添加
        switch (edit_ctrl_ptr->type)
        {
            case GUIEDIT_TYPE_LIST :
            {
                GUIEDIT_AddListItem(ctrl_id, fill_str_ptr, fill_str_len);
                max_len = edit_ctrl_ptr->str_max_len;
                max_num = edit_ctrl_ptr->total_line_num;
            }
            break;

            // 对于时间的数据，由H，M，S构成
            case GUIEDIT_TYPE_TIME :
            case GUIEDIT_TYPE_TOUCH_TIME :
            // 对于日期的数据，由Y，M，D构成
            case GUIEDIT_TYPE_DATE :
            case GUIEDIT_TYPE_TOUCH_DATE :
            // IP是一个uint32类型
            case GUIEDIT_TYPE_IP :
            {
                special_str_ptr = GetATCParameter(MMI_UT_STRUCT, start_ptr, fill_str_len, fill_str_len);
                if (PNULL == special_str_ptr)
                {
                    return FALSE;
                }

                start_ptr = (uint8 *)special_str_ptr;

                if (GUIEDIT_TYPE_IP == edit_ctrl_ptr->type)
                {
                    ip_addr = (uint32)Atest_GetTestMessageId(',', &start_ptr);
                    GUIEDIT_SetIP(ctrl_handle, ip_addr);
                }
                else if (GUIEDIT_TYPE_DATE == edit_ctrl_ptr->type
                    || GUIEDIT_TYPE_TOUCH_DATE == edit_ctrl_ptr->type)
                {
                    year = (uint16)Atest_GetTestMessageId(',', &start_ptr);
                    month = (uint8)Atest_GetTestMessageId(',', &start_ptr);
                    day = (uint8)Atest_GetTestMessageId(',', &start_ptr);
                    GUIEDIT_SetDate(ctrl_handle, year, month, day);
                }
                else
                {
                    hour = (uint8)Atest_GetTestMessageId(',', &start_ptr);
                    minute = (uint8)Atest_GetTestMessageId(',', &start_ptr);
                    second = (uint8)Atest_GetTestMessageId(',', &start_ptr);
                    GUIEDIT_SetTime(ctrl_handle, hour, minute, second);
                }

                SCI_FREE(special_str_ptr);
            }
            break;

            // 缺省按照文本类型，直接输入字符
            default :
            {
                GUIEDIT_InsertString(ctrl_handle, fill_str_ptr, fill_str_len);
               	max_len = edit_ctrl_ptr->str_max_len-edit_ctrl_ptr->str_len;
            }
            break;
        }

        // 设置为Active，重画
        GUICTRL_SetActive((IGUICTRL_T *)edit_ctrl_ptr, TRUE);
        GUICTRL_Redraw((IGUICTRL_T *)edit_ctrl_ptr);
        SCI_FREE(fill_str_ptr);
    }
    else if (SPRD_GUI_DROPDOWNLIST_ID == ctrl_guid) // 处理下拉列表框
    {
        dropdownlist_ctrl_ptr = (CTRLDROPDOWNLIST_OBJ_T *)ctrl_ptr;
        // 获取下拉列表总长度和最大长度
		switch (dropdownlist_ctrl_ptr->ctrl_type_info.ctrl_type)
		{
			case GUIDNLIST_EDITABLE_TEXT:
			case GUIDNLIST_EDITABLE_NUMLIST:
			case GUIDNLIST_EDITABLE_PHONENUM:		
				max_len = dropdownlist_ctrl_ptr->ctrl_type_info.editable_max_text_num;
				max_num = dropdownlist_ctrl_ptr->ctrl_type_info.editable_max_listitem_num;
				if (0 != fill_str_len)
				{
					ctrl_ptr = (IGUICTRL_T *)MMK_GetCtrlPtr(dropdownlist_ctrl_ptr->edit_handle);
					edit_ctrl_ptr = (CTRLBASEEDIT_OBJ_T *)ctrl_ptr;
					
					GUIEDIT_InsertString(dropdownlist_ctrl_ptr->edit_handle, fill_str_ptr, fill_str_len);
					max_len = max_len-edit_ctrl_ptr->str_len;
				}				
				break;
			case GUIDNLIST_NORMAL:
				max_len = dropdownlist_ctrl_ptr->max_item_num;
				max_num = dropdownlist_ctrl_ptr->total_item_num;
				
				if (0 == fill_str_len) // 下界测试
				{
					GUIDROPDOWNLIST_SetMaxItem(ctrl_handle, max_len);
				}
				else // 添加列表项
				{
					//modify by linchen
					GUIEDIT_InsertString(dropdownlist_ctrl_ptr->edit_handle, fill_str_ptr, fill_str_len);
					//	GUIEDIT_MoveCursor( (CTRLBASEEDIT_OBJ_T  *)MMK_GetCtrlPtr(dropdownlist_ctrl_ptr->edit_handle),GUIEDIT_CURSOR_MOVE_RIGHT);
				}
				break;
			default:
				break;		
        }

        // 设置Active
        GUICTRL_SetActive((IGUICTRL_T *)dropdownlist_ctrl_ptr, TRUE);
    }

    // 将控件允许输入的最大长度和最多项目传回，客户端判定是否需要调整传输量
    data_len = sprintf((char *)special_data, "0,%d,%d", max_len, max_num);
    Atest_TransmitATString(special_data, data_len, FALSE, FALSE);

    return TRUE;
}

/*****************************************************************************/
//  Description:一次性删除edit输入的数据
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_ClearAllStr(  uint8 *user_data_ptr)
{
	uint8 *start_ptr = user_data_ptr;
	uint32 ctrl_id;
	MMI_HANDLE_T win_handle;
	MMI_HANDLE_T ctrl_handle;	
	CAF_GUID_T ctrl_guid;
	IGUICTRL_T *ctrl_ptr = PNULL;
	CTRLDROPDOWNLIST_OBJ_T *dropdownlist_ctrl_ptr = PNULL;
	
    ctrl_id = Atest_GetTestMessageId(',', &start_ptr);
	
    // 获取焦点窗体handle
    win_handle = MMK_GetFocusWinHandle();
    // 从焦点窗体搜索与客户端控件ID相同的控件
    ctrl_ptr = MMK_GetCtrlPtrByWin(win_handle, ctrl_id);
    if (PNULL == ctrl_ptr)
    {
        return;
    }

	ctrl_handle = GUICTRL_GetCtrlHandle(ctrl_ptr);
	ctrl_guid = GUICTRL_GetCtrlGuid(ctrl_ptr);

	if ((SPRD_GUI_EDITBOX_ID == ctrl_guid) 
		|| (SPRD_GUI_TEXTEDIT_ID == ctrl_guid) 
		|| (SPRD_GUI_PHONENUMEDIT_ID == ctrl_guid) 
		|| (SPRD_GUI_DIGITALEDIT_ID == ctrl_guid) 
		|| (SPRD_GUI_PSWEDIT_ID == ctrl_guid) 
		|| (SPRD_GUI_LISTEDIT_ID == ctrl_guid) )// 处理编辑框
    {
    	if(!GUIEDIT_ClearAllStr(ctrl_handle))
		{
			return;
		}
	}
	else if (SPRD_GUI_DROPDOWNLIST_ID == ctrl_guid)
	{
		
		dropdownlist_ctrl_ptr = (CTRLDROPDOWNLIST_OBJ_T *)ctrl_ptr;
		if(!GUIEDIT_ClearAllStr(dropdownlist_ctrl_ptr->edit_handle))
		{
			return;
		}
	}
	else
	{
		return;
	}	
}

/*****************************************************************************/
//  Description: 遍历控件树，提取控件属性描述，传回PC端
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL void Atest_TravelControlTree(
    MMI_TREE_NODE_T *root_ptr, // 控件树根节点
    uint8 *data_ptr,           // 传回PC端的数据
    uint32 *data_size_ptr)     // 累计传输的数据大小
{
    IGUICTRL_T *ctrl_ptr = PNULL;
    MMI_TREE_NODE_T *find_node_ptr = root_ptr;

    // 从控件树根开始搜索
    if (PNULL == root_ptr)
    {
        return ;
    }

    // 递归遍历窗体控件
    do {
        // 通过控件节点获取控件指针
        ctrl_ptr = MMK_GetCtrlPtr(find_node_ptr->data);
        // 控件起始属性标记 <EDITBOX>
        Atest_GetControlProperty(ctrl_ptr, FALSE, data_ptr, data_size_ptr);

        // 先遍历子节点
        if (PNULL != find_node_ptr->child_ptr)
        {
            Atest_TravelControlTree(find_node_ptr->child_ptr, data_ptr, data_size_ptr);
            // 获取控件结束标记 </EDITBOX>
            Atest_GetControlProperty(ctrl_ptr, TRUE, data_ptr, data_size_ptr);
        }
        else
        {
            // 获取控件结束标记 </EDITBOX>
            Atest_GetControlProperty(ctrl_ptr, TRUE, data_ptr, data_size_ptr);
        }

        // 再遍历兄弟节点
        find_node_ptr = find_node_ptr->next_ptr;
    } while (find_node_ptr != root_ptr);
}

/*****************************************************************************/
//  Description: 获取指定控件的数据，返回满足客户端要求的内容、长度和校验信息
//               AT+SFTIN="IGCD,393435,0,20" -> 00314E2D,4,16
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetControlData( // 提取控件数据失败，返回FALSE
    uint8 *user_data_ptr)           // 客户端发出的提取指令
{
    uint16 trans_start = 0, trans_len = 0, check_len = 0, list_item_num = 0, year;
    uint8 special_data[16] = { 0 }, *start_ptr = user_data_ptr;
    uint8 month, day, hour, miniute, second;
    int32 check_sum = 0;
    MMI_STRING_T ctrl_str = { 0 };

    MMI_CTRL_ID_T ctrl_id;
    CAF_GUID_T ctrl_guid;
    MMI_HANDLE_T win_handle;
	MMI_HANDLE_T ctrl_handle;

    IGUICTRL_T *ctrl_ptr = PNULL;
    CTRLBASEEDIT_OBJ_T *edit_ctrl_ptr = PNULL;
    CTRLDROPDOWNLIST_OBJ_T *dropdownlist_ctrl_ptr = PNULL;
    GUIEDIT_LIST_ITEM_STR_T *item_array_ptr = PNULL;
	CTRLLIST_OBJ_T *list_ctrl_ptr = PNULL;
	GUILIST_ITEM_DATA_T* item_data_ptr = PNULL;
	const CTRLLIST_ITEM_T *list_item_ptr = PNULL;
	CTRLLABEL_OBJ_T *label_ctrl_ptr = PNULL;


    // 获取需要传输控件ID，数据传输起点，数据传输长度
    ctrl_id = Atest_GetTestMessageId(',', &start_ptr);
    trans_start = Atest_GetTestMessageId(',', &start_ptr);
    trans_len = Atest_GetTestMessageId(',', &start_ptr);

    // 从焦点窗体查指定ID的目标控件
    win_handle = MMK_GetFocusWinHandle();
    ctrl_ptr = MMK_GetCtrlPtrByWin(win_handle, ctrl_id);
    if (PNULL == ctrl_ptr)
    {
        return FALSE;
    }

	ctrl_handle = GUICTRL_GetCtrlHandle(ctrl_ptr);
    ctrl_guid = GUICTRL_GetCtrlGuid(ctrl_ptr);
    // 通过GUID判定需要处理的目标控件
    if (SPRD_GUI_TEXTEDIT_ID == ctrl_guid) // 处理编辑框
    {
        edit_ctrl_ptr = (CTRLBASEEDIT_OBJ_T *)ctrl_ptr;

        switch (edit_ctrl_ptr->type)
        {
            // 处理列表类型
			case GUIEDIT_TYPE_TEXT:
            case GUIEDIT_TYPE_LIST :
            {
                // 判定传输起点是否超越列表项目边界
                list_item_num = edit_ctrl_ptr->total_line_num;
                if (trans_start >= list_item_num)
                {
                    return FALSE;
                }

                // 存放所有列表项的结构
                item_array_ptr = (GUIEDIT_LIST_ITEM_STR_T *)SCI_ALLOC_APP(
                    sizeof(GUIEDIT_LIST_ITEM_STR_T) * list_item_num);
                SCI_MEMSET(item_array_ptr, 0, sizeof(GUIEDIT_LIST_ITEM_STR_T) * list_item_num);
                // 取回所有列表项
                GUIEDIT_GetListItemString(ctrl_handle, list_item_num, item_array_ptr);
                // 返回客户指定的列表项
                ctrl_str.wstr_ptr = item_array_ptr[trans_start].str_ptr;
                ctrl_str.wstr_len = item_array_ptr[trans_start].str_len;
                trans_len = ctrl_str.wstr_len;
                // 每个列表项的数据都是从0开始传，所以trans_start=0
                trans_start = 0;
            }
            break;

            // 对于时间的数据，由H，M，S构成
            case GUIEDIT_TYPE_TIME :
            case GUIEDIT_TYPE_TOUCH_TIME :
            // 对于日期的数据，由Y，M，D构成
            case GUIEDIT_TYPE_DATE :
            case GUIEDIT_TYPE_TOUCH_DATE :
            // IP是一个uint32类型
            case GUIEDIT_TYPE_IP :
            {
                if (GUIEDIT_TYPE_IP == edit_ctrl_ptr->type)
                {
                    trans_len = sprintf((char *)special_data, "%u", GUIEDIT_GetIP(ctrl_id));
                }
                else if ( (GUIEDIT_TYPE_DATE == edit_ctrl_ptr->type)
                    || (GUIEDIT_TYPE_TOUCH_DATE == edit_ctrl_ptr->type) )
                {
                    GUIEDIT_GetDate(ctrl_handle, &year, &month, &day);
                    trans_len = sprintf((char *)special_data, "%d,%d,%d", year, month, day);
                }
                else
                {
                    GUIEDIT_GetTime(ctrl_handle, &hour, &miniute, &second);
                    trans_len = sprintf((char *)special_data, "%d,%d,%d", hour, miniute, second);
                }
            }
            break;

            default :
            {
                GUIEDIT_GetString(ctrl_handle, &ctrl_str);
                // 如果传输起点超过文本长度，则返回失败
                if (trans_start > ctrl_str.wstr_len)
                {
                    return FALSE;
                }
                else if (trans_start + trans_len > ctrl_str.wstr_len)
                {   // 如果“传输起点 + 传输长度”超过文本长度则截断，只传输有数据的部分
                    trans_len = ctrl_str.wstr_len - trans_start;
                }
            }
            break;
        }

        // 设置传回客户端的文本数据起点
        ctrl_str.wstr_ptr = ctrl_str.wstr_ptr + trans_start;
    }
    else if (SPRD_GUI_DROPDOWNLIST_ID == ctrl_guid) // 处理下拉列表
    {
        dropdownlist_ctrl_ptr = (CTRLDROPDOWNLIST_OBJ_T *)ctrl_ptr;	
		switch (dropdownlist_ctrl_ptr->ctrl_type_info.ctrl_type)
		{
			case GUIDNLIST_NORMAL:
				ctrl_str.wstr_ptr = (dropdownlist_ctrl_ptr->all_item_ptr+trans_start)->wstr_ptr;
				ctrl_str.wstr_len = (dropdownlist_ctrl_ptr->all_item_ptr+trans_start)->wstr_len;
        		// 处理无效传输起点
				if ( trans_start > dropdownlist_ctrl_ptr->total_item_num )
        		{
           			 return FALSE;
       			 }
        		else // 设置传输长度为文本长度，因为列表项长度有限
       			{
            		trans_len = ctrl_str.wstr_len;
       			}
				break;
			case GUIDNLIST_EDITABLE_TEXT:
			case GUIDNLIST_EDITABLE_NUMLIST:
			case GUIDNLIST_EDITABLE_PHONENUM:		
				GUIEDIT_GetString(dropdownlist_ctrl_ptr->edit_handle, &ctrl_str);
				// 如果传输起点超过文本长度，则返回失败
				if (trans_start > ctrl_str.wstr_len)
				{
					return FALSE;
				}
				else if (trans_start + trans_len > ctrl_str.wstr_len)
				{   // 如果“传输起点 + 传输长度”超过文本长度则截断，只传输有数据的部分
					trans_len = ctrl_str.wstr_len - trans_start;
				}
				// 设置传回客户端的文本数据起点
				ctrl_str.wstr_ptr = ctrl_str.wstr_ptr + trans_start;
				break;
			default:
				break;		
		} 
	}
	else if(SPRD_GUI_LIST_ID == ctrl_guid)	//add by lin.chen
	{
	//	trans_start为index; trans_len为content index;			
		list_ctrl_ptr = (CTRLLIST_OBJ_T *)ctrl_ptr;

		if(trans_start >= list_ctrl_ptr->total_item_num)
		{
			return FALSE;		
		}	
		
		list_item_ptr = CTRLLIST_GetItem(ctrl_handle, trans_start);
		if (PNULL == list_item_ptr)
		{
			return FALSE;
		}
		
		item_data_ptr = list_item_ptr->data_ptr;
		if(PNULL == item_data_ptr)
		{
			return FALSE;
		}
		
		if(GUIITEM_DATA_TEXT_ID == item_data_ptr->item_content[trans_len].item_data_type)
		{
			MMITHEME_GetResText(item_data_ptr->item_content[trans_len].item_data.text_id, ctrl_handle, &ctrl_str);
		}
		else if(GUIITEM_DATA_TEXT_BUFFER == item_data_ptr->item_content[trans_len].item_data_type)
		{
			ctrl_str.wstr_ptr = item_data_ptr->item_content[trans_len].item_data.text_buffer.wstr_ptr;
			ctrl_str.wstr_len = item_data_ptr->item_content[trans_len].item_data.text_buffer.wstr_len;
		}
		else
		{
			return FALSE;
		}
		trans_len = ctrl_str.wstr_len;
	}
	else if(SPRD_GUI_LABEL_ID == ctrl_guid) //add by lin.chen
	{
		label_ctrl_ptr = (CTRLLABEL_OBJ_T	*)ctrl_ptr;
		GUILABEL_GetText(ctrl_handle,&ctrl_str);
		trans_len = ctrl_str.wstr_len;
	}

    if (ctrl_str.wstr_len > 0)  // 传输需要转码的部分
    {
        // 转为UNICODE传输，因为数据存在转码，长度较大，所以需要校验正确性
        // 一个UNICODE编码2个字节，转换为十六进制字符4个字节，乘以2
        check_sum = Atest_TransmitATString((uint8 *)ctrl_str.wstr_ptr, trans_len << 1, TRUE, TRUE);
        // 一个UNICODE字符转换为4个十六进制字符，宽字符长乘以4
        check_len = sprintf((char *)special_data, ",%d,%d,%d", ctrl_str.wstr_len, trans_len << 2, check_sum);
        // 传输长度不需要转换为UNICODE和校验
        Atest_TransmitATString((uint8 *)special_data, check_len, FALSE, FALSE);
    }
    else // 传输不需要转码的数据
    {
        // 需要校验数据正确性
        check_sum = Atest_TransmitATString(special_data, trans_len, FALSE, TRUE);
        check_len = sprintf((char *)special_data, ",%d,%d", trans_len, check_sum);
        Atest_TransmitATString(special_data, check_len, FALSE, FALSE);
    }

    if (item_array_ptr)
    {
        SCI_FREE(item_array_ptr);
    }

    return TRUE;
}

/*****************************************************************************/
//  Description: 遍历窗体
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL void Atest_TravelWindowTree(
    MMI_TREE_NODE_T *root_ptr, // 窗体树根节点
    MMI_TREE_NODE_T *next_ptr,
    uint8 *data_ptr,           // 传回PC端的数据
    uint32 *data_size_ptr)     // 累计传输的数据大小
{
    MMI_TREE_NODE_T *find_node_ptr = root_ptr;
    MMI_TREE_NODE_T *ctrl_tree_root_ptr = PNULL;
    uint16 data_len = 0;
    GUI_RECT_T rect = { 0 };

    // 从树根开始搜索
    if (PNULL == root_ptr)
    {
        return;
    }

    // 递归遍历窗体
    do {
        ctrl_tree_root_ptr = MMK_GetCtrlTreeRootByWin(find_node_ptr->data);

		rect = MMITHEME_GetClientRectEx(find_node_ptr->data);
        data_len = sprintf((char *)data_ptr, "<window id='%d' rect='%d %d %d %d'>",
            MMK_GetWinId(find_node_ptr->data), rect.left, rect.top, rect.right, rect.bottom);
        Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	*data_size_ptr += data_len;
		if (ctrl_tree_root_ptr)
		{
			// 存在子控件的情况下，遍历控件树
			Atest_TravelControlTree(ctrl_tree_root_ptr, data_ptr, data_size_ptr);
		}

        // 先遍历子节点
        if (PNULL != find_node_ptr->child_ptr)
        {
            Atest_TravelWindowTree(find_node_ptr->child_ptr, next_ptr, data_ptr, data_size_ptr);
        }

		data_len = sprintf((char *)data_ptr, "</window>");
		Atest_TransmitATString(data_ptr, 9, FALSE, FALSE);
		*data_size_ptr += 9;

        // 再遍历兄弟节点
        find_node_ptr = find_node_ptr->next_ptr;

        if (next_ptr == find_node_ptr)
        {
            break;
        }
    } while (find_node_ptr != root_ptr);
}

/*****************************************************************************/
//  Description: 递归焦点窗体控件树，获取控件属性，传回PC端，加上总长度校验
//               AT+SFTIN="IGCT" -> <EDITBOX id='393435' type='TEXT' maxLen='612' maxNum='0'></EDITBOX>,67
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetControlTree( // 取到控件内容，返回TRUE
    uint8 *user_data_ptr)           // 客户端的提取控件属性指令
{
	uint8 *data_ptr = PNULL;
    uint16 trans_size = 0;
    uint32 total_trans_size = 0;

    MMI_HANDLE_T win_handle = 0;
	MMI_TREE_NODE_T *win_tree_ptr = PNULL;

	//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_GetControlTree"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_4298_112_2_18_1_59_33_29,(uint8*)"");

    // 传输控件树的缓冲区，最大设置为4KB，输入控件量不大
    data_ptr = (uint8 *)SCI_ALLOC_APP(4096);
    if (PNULL == data_ptr)
    {
        return FALSE;
    }

    SCI_MEMSET(data_ptr, 0, 4096);

	win_handle = MMK_GetTopmostWindow();
    win_tree_ptr = MMK_GetWinTreeNode(win_handle);
    Atest_TravelWindowTree(win_tree_ptr, win_tree_ptr->next_ptr, data_ptr, &total_trans_size);

    // 因为传输数据量较大，传回总长度，进行数据传输校验
    trans_size = sprintf((char *)data_ptr, ",%d", total_trans_size);
    // 不需要UNICODE转换和逐个数据校验
    Atest_TransmitATString(data_ptr, trans_size, FALSE, FALSE);

    SCI_FREE(data_ptr);

    return TRUE;
}
/*****************************************************************************/
//  Description: 解析客户端AT指令，调用不同处理逻辑
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note: 
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleControlInput( // 用户命令处理无错，返回TRUE
    uint8 *user_data_ptr,               // 用户发过来的AT命令
    uint32 len)
{
	ATEST_SIGNAL_TYPE_E signalType = ATEST_SIGNAL_NONE;
	
	if (strncmp((char *)user_data_ptr, "GCT", 3) == 0)
    {
        signalType = ATEST_SIGNAL_IGCT;
    }
    else if (strncmp((char *)user_data_ptr, "GCD", 3) == 0)
    {
        signalType = ATEST_SIGNAL_IGCD;
    }
    else if (strncmp((char *)user_data_ptr, "FCD", 3) == 0)	
    {
       	signalType = ATEST_SIGNAL_IFCD;
    }
	else if (strncmp((char *)user_data_ptr, "SCP", 3) == 0) //add by lin.chen
    {
		signalType = ATEST_SIGNAL_ISCP;
    }
	else if (strncmp((char *)user_data_ptr, "GCR", 3) == 0)//add by lin.chen
    {
		signalType = ATEST_SIGNAL_IGCR;
	}
	else if (strncmp((char *)user_data_ptr, "GCL", 3) == 0)//add by lin.chen
    {
		signalType = ATEST_SIGNAL_IGCL;
    }
	else if (strncmp((char *)user_data_ptr, "GLN", 3) == 0)//add by lin.chen
    {
		signalType = ATEST_SIGNAL_IGLN;
    }
	else if (strncmp((char *)user_data_ptr, "RIW", 3) == 0)//add by lin.chen
    {
		signalType = ATEST_SIGNAL_IRIW;		
	}
	else if (strncmp((char *)user_data_ptr, "CES", 3) == 0)//add by lin.chen
    {
		signalType = ATEST_SIGNAL_ICES;		
	}
	else if (strncmp((char *)user_data_ptr, "TPR", 3) == 0)//add by lin.chen
    {
		signalType = ATEST_SIGNAL_ITPR;		
	}
	else if (strncmp((char *)user_data_ptr, "TPD", 3) == 0)//add by lin.chen
    {
		signalType = ATEST_SIGNAL_ITPD;		
	}
	else if (strncmp((char *)user_data_ptr, "TPM", 3) == 0)//add by lin.chen
    {
		signalType = ATEST_SIGNAL_ITPM;		
	}
	else if (strncmp((char *)user_data_ptr, "TPU", 3) == 0)//add by lin.chen
    {
		signalType = ATEST_SIGNAL_ITPU;		
	}
	else if (strncmp((char *)user_data_ptr, "KBD", 3) == 0)//add by lin.chen
    {
		signalType = ATEST_SIGNAL_IKBD;		
	}
	else if (strncmp((char *)user_data_ptr, "GCS", 3) == 0)//add by lin.chen
    {
		signalType = ATEST_SIGNAL_IGCS;			
	}
	else if (strncmp((char *)user_data_ptr, "SAT", 3) == 0)//在闹钟时间设置界面，设置闹钟时间
	{
		signalType = ATEST_SIGNAL_ISAT;			
	}
	else if (strncmp((char *)user_data_ptr, "GST", 3) == 0)//获得当前手机的系统时间
	{
		signalType = ATEST_SIGNAL_IGST;			
	}
	else if (strncmp((char *)user_data_ptr, "GAT", 3) == 0)//获得最近的闹钟时间
	{
		signalType = ATEST_SIGNAL_IGAT;			
	}
	else if (strncmp((char *)user_data_ptr, "CCD", 3) == 0)//点击日历上的某个日期
	{
		signalType = ATEST_SIGNAL_ICCD;		
	}
	else if (strncmp((char *)user_data_ptr, "CAL", 3) == 0)//获得计算器计算数据
	{
		signalType = ATEST_SIGNAL_ICAL;		
	}	
    else
    {
        return FALSE;
    }

	//SCI_TRACE_LOW:"[AT][ATEST]:Atest_HandleControlInput--signalType=0x%x"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_4391_112_2_18_1_59_33_30,(uint8*)"d",signalType);
	Atest_SendSignalToAppTask(user_data_ptr,len,0,signalType);
	return TRUE;	
}

/*****************************************************************************/
//  Description: 获取控件RichText描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetRichTextControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	uint16 i,data_len = 0; 
	uint16 user_data_len = 0;
	wchar *user_data_ptr = NULL;
	GUIRICHTEXT_ITEM_T richedit_item = { 0 };
	CTRLRICHTEXT_OBJ_T *richtext_ptr = PNULL;
	
	richtext_ptr = (CTRLRICHTEXT_OBJ_T *)ctrl_ptr;
	if(PNULL == richtext_ptr)
	{
		return;
	}
	
	for (i = 0; ; i++)
    {
        if(!CTRLRICHTEXT_GetItem(ctrl_handle, i, &richedit_item))
        {
			break;
		}
		
		if ( (GUIRICHTEXT_TEXT_INVALID == richedit_item.text_type ) && (GUIRICHTEXT_IMAGE_INVALID == richedit_item.img_type) )
        {
            break;
        }		
	}
	
	data_len = sprintf((char *)data_ptr, 
		"<%s id='%d' totalnum='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr, ctrl_id,i,
		richtext_ptr->base_ctrl.rect.left,richtext_ptr->base_ctrl.rect.top,
		richtext_ptr->base_ctrl.rect.right,richtext_ptr->base_ctrl.rect.bottom);
    Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
    *data_size_ptr += data_len;
	
    for (i = 0; ; i++)
    {
		SCI_MEMSET(&richedit_item, 0, sizeof(GUIRICHTEXT_ITEM_T));
        if(!CTRLRICHTEXT_GetItem(ctrl_handle, i, &richedit_item))
        {
			break;
		}
		
		if ( (GUIRICHTEXT_TEXT_INVALID == richedit_item.text_type ) && (GUIRICHTEXT_IMAGE_INVALID == richedit_item.img_type) )
        {
            break;
        }
		
		data_len = sprintf((char *)data_ptr,"<item imgid='%d' index='%d'>",richedit_item.img_data.res.id,i);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
        
		if(GUIRICHTEXT_TEXT_RES == richedit_item.text_type || GUIRICHTEXT_TEXT_BUF == richedit_item.text_type)
		{
			user_data_ptr = richedit_item.text_data.buf.str_ptr;
			user_data_len = richedit_item.text_data.buf.len;	     
			
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';	    
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;
		}
		
		data_len = sprintf((char *)data_ptr, "</item>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
    }
}

/*****************************************************************************/
//  Description: 获取控件Anim描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetAnimControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	uint16 data_len = 0; 
	CTRLANIM_OBJ_T  *anim_ctrl_ptr = PNULL;
	MMI_IMAGE_ID_T user_data_id = 0;

	anim_ctrl_ptr = (CTRLANIM_OBJ_T  *)ctrl_ptr;
	if(PNULL == anim_ctrl_ptr)
	{
		return;
	}

	if(anim_ctrl_ptr->data_info.anim_id)
	{
		 user_data_id = anim_ctrl_ptr->data_info.anim_id;
	}
	else
	{
		 user_data_id = anim_ctrl_ptr->data_info.img_id;
	}

	data_len = sprintf((char *)data_ptr,
		"<%s id='%d' visible='%d' focus='%d' type='%d' imgid='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr,ctrl_id,
		anim_ctrl_ptr->is_visible,anim_ctrl_ptr->is_focus,
		anim_ctrl_ptr->type,user_data_id,
		anim_ctrl_ptr->base_ctrl.rect.left,anim_ctrl_ptr->base_ctrl.rect.top,
		anim_ctrl_ptr->base_ctrl.rect.right,anim_ctrl_ptr->base_ctrl.rect.bottom);
	  Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	  *data_size_ptr += data_len;
}


/*****************************************************************************/
//  Description: 获取PrgBox控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetPrgBoxControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	 uint16 j,data_len = 0; 
	 uint16 user_data_len = 0;
	 wchar *user_data_ptr = NULL;
	 CTRLPROGRESSBAR_OBJ_T *prgbox_ctrl_ptr = PNULL;
	 wchar letter_arr[MAX_CMD_LEN] = { 0 };

	 prgbox_ctrl_ptr = (CTRLPROGRESSBAR_OBJ_T *)ctrl_ptr;
	 if (PNULL == prgbox_ctrl_ptr)
	 {
		 return;
	 }

     data_len = sprintf((char *)data_ptr, 
		"<%s id='%d' style='%d' themetype='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr,ctrl_id,prgbox_ctrl_ptr->prgbox_style,
		prgbox_ctrl_ptr->theme_type,
		prgbox_ctrl_ptr->base_ctrl.rect.left,prgbox_ctrl_ptr->base_ctrl.rect.top,
		prgbox_ctrl_ptr->base_ctrl.rect.right,prgbox_ctrl_ptr->base_ctrl.rect.bottom);
     Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
     *data_size_ptr += data_len;

	switch (prgbox_ctrl_ptr->prgbox_style)
	{
		case GUIPRGBOX_STYLE_VERTICAL_SCROLL:       /*!< 纵向滚动条 */
			data_len = sprintf((char *)data_ptr, 
				"<ver_scroll is_loop='%d' upid='%d' upfocusid='%d' downid='%d' downfocusid='%d' barid='%d' grooveid='%d'></ver_scroll>", 
				prgbox_ctrl_ptr->is_loop_scroll,
				prgbox_ctrl_ptr->ver_scroll_theme.up_arrow_id,
				prgbox_ctrl_ptr->ver_scroll_theme.up_focus_arrow_id,
				prgbox_ctrl_ptr->ver_scroll_theme.down_arrow_id,
				prgbox_ctrl_ptr->ver_scroll_theme.down_focus_arrow_id,
				prgbox_ctrl_ptr->ver_scroll_theme.scroll_bar_id,
				prgbox_ctrl_ptr->ver_scroll_theme.groove_bg_id);
	        Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	        *data_size_ptr += data_len;					
			break;
	    case GUIPRGBOX_STYLE_HORIZONTAL_SCROLL:      /*!< 横向滚动条 */ 
			data_len = sprintf((char *)data_ptr, 
				"<hor_scroll isloop='%d' leftid='%d' leftfocusid='%d' rightid='%d' rightfocusid='%d' barid='%d' grooveid='%d'></hor_scroll>", 
				prgbox_ctrl_ptr->is_loop_scroll,
				prgbox_ctrl_ptr->hor_scroll_theme.left_arrow_id,
				prgbox_ctrl_ptr->hor_scroll_theme.left_focus_arrow_id,
				prgbox_ctrl_ptr->hor_scroll_theme.right_arrow_id,
				prgbox_ctrl_ptr->hor_scroll_theme.right_focus_arrow_id,
				prgbox_ctrl_ptr->hor_scroll_theme.scroll_bar_id,
				prgbox_ctrl_ptr->hor_scroll_theme.groove_bg_id);
	        Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	        *data_size_ptr += data_len;	
			break; 
	    case GUIPRGBOX_STYLE_VERTICAL_PROCESS:  
	    case GUIPRGBOX_STYLE_HORIZONTAL_PROCESS:     /*!<进度条 */ 
			data_len = sprintf((char *)data_ptr, 
				"<process_theme bgtype='%d' fgcolor='%d' bgcolor='%d'></process_theme>", 
				prgbox_ctrl_ptr->process_theme.bg_type,
				prgbox_ctrl_ptr->process_theme.fg_color,
				prgbox_ctrl_ptr->process_theme.bg_color);
	        Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	        *data_size_ptr += data_len;	
			break; 
	    case GUIPRGBOX_STYLE_VERTICAL_WINDOWS:       /*!< 保留 */ 
	    case GUIPRGBOX_STYLE_HORIZONTAL_WINDOWS:     /*!< 保留 */
			break;
		case GUIPRGBOX_STYLE_LETTERS_SCROLL:     /*字母滚动条*/
			data_len = sprintf((char *)data_ptr, 
				"<letter totalnum='%d' curindex='%d' postion='%d'></letter>", 
				prgbox_ctrl_ptr->total_item_num,
				prgbox_ctrl_ptr->cur_item_index,
				*(prgbox_ctrl_ptr->letter_postion_table));
	        Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	        *data_size_ptr += data_len;

			for(j=0;j<prgbox_ctrl_ptr->total_item_num;j++)
			{
				letter_arr[j]=GUIPRGBOX_GetWcharByPos((IGUICTRL_T *)prgbox_ctrl_ptr, j);
			}
			letter_arr[j]=L'\0';

			user_data_ptr = letter_arr;
			user_data_len = j;
			if (user_data_len != 0)
			{
		    	SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;									
			break;
		default:
			break;
	}
}

/*****************************************************************************/
//  Description: 获取Text控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetTextControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	uint16 data_len = 0; 
	uint16 user_data_len = 0;
	wchar *user_data_ptr = NULL;
	MMI_STRING_T text_ptr = { 0 };
	CTRLTEXT_OBJ_T	*text_ctrl_ptr = PNULL;

	text_ctrl_ptr = (CTRLTEXT_OBJ_T *)ctrl_ptr;
	if(PNULL == text_ctrl_ptr)
	{
		return;
	}	

    data_len = sprintf((char *)data_ptr,
		"<%s id='%d' active='%d' pagelinenum='%d' totallinenum='%d' topline='%d' bottomline='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr,ctrl_id,text_ctrl_ptr->base_ctrl.is_active,
		text_ctrl_ptr->page_line_num,text_ctrl_ptr->total_line_num,
		text_ctrl_ptr->top_line_index,text_ctrl_ptr->bottom_line_index,
		text_ctrl_ptr->base_ctrl.rect.left,text_ctrl_ptr->base_ctrl.rect.top,
		text_ctrl_ptr->base_ctrl.rect.right,text_ctrl_ptr->base_ctrl.rect.bottom);
    Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
    *data_size_ptr += data_len;

	GUITEXT_GetString(ctrl_handle,&text_ptr);
	user_data_ptr = text_ptr.wstr_ptr;
	user_data_len = text_ptr.wstr_len;
	
	if (user_data_len != 0)
	{
		SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
	}
	user_item_ptr[user_data_len] = L'\0';
	Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
	*data_size_ptr += user_data_len * 4;
}

/*****************************************************************************/
//  Description: 获取Lable控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetLableControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	 uint16 data_len = 0; 
	 uint16 user_data_len = 0;
	 wchar 	*user_data_ptr = NULL;
	 MMI_STRING_T text_ptr = {0};
	 CTRLLABEL_OBJ_T *label_ctrl_ptr = PNULL;
	 
	 label_ctrl_ptr = (CTRLLABEL_OBJ_T	*)ctrl_ptr;
	 if(PNULL == label_ctrl_ptr)
	 {
		return;
	 }

     data_len = sprintf((char *)data_ptr, 
		"<%s id='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr,ctrl_id,
		label_ctrl_ptr->base_ctrl.rect.left,label_ctrl_ptr->base_ctrl.rect.top,
		label_ctrl_ptr->base_ctrl.rect.right,label_ctrl_ptr->base_ctrl.rect.bottom);
     Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
     *data_size_ptr += data_len;

	 GUILABEL_GetText(ctrl_handle,&text_ptr);
	 user_data_ptr = text_ptr.wstr_ptr;
	 user_data_len = text_ptr.wstr_len;	
	 if (user_data_len != 0)
	 {
	 	SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
	 }
	 user_item_ptr[user_data_len] = L'\0';
	 Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
	 *data_size_ptr += user_data_len * 4;                                
}

/*****************************************************************************/
//  Description: 获取MsgBox控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetMsgBoxControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	uint16 data_len = 0; 
	wchar *user_data_ptr = NULL;
	uint16 user_data_len = 0;

	CTRLMSGBOX_OBJ_T* msgbox_ptr = PNULL;
	uint32 i=0;
	uint32 image_id = 0;

	msgbox_ptr = (CTRLMSGBOX_OBJ_T*)ctrl_ptr;
	if(PNULL == msgbox_ptr)
	{
		return;
	}

	data_len = sprintf((char *)data_ptr, 
		"<%s id='%d' focus='%d' active='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr,ctrl_id,msgbox_ptr->is_focus,msgbox_ptr->is_active,
		msgbox_ptr->base_ctrl.rect.left,msgbox_ptr->base_ctrl.rect.top,
		msgbox_ptr->base_ctrl.rect.right,msgbox_ptr->base_ctrl.rect.bottom);
    Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
    *data_size_ptr += data_len;

	data_len = sprintf((char *)data_ptr,"<item>");
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	*data_size_ptr += data_len;

	if(GUIMSGBOX_IMAGE_ANIMA == msgbox_ptr->image_type || 
		GUIMSGBOX_IMAGE_BMP == msgbox_ptr->image_type)
	{
	 	if(GUIMSGBOX_IMAGE_ANIMA == msgbox_ptr->image_type)
		{
			image_id = msgbox_ptr->anim_id;
		}
		else 
		{
			image_id = msgbox_ptr->image_id;
		}
		data_len = sprintf((char *)data_ptr,
			"<image id='%d' rect='%d %d %d %d'></image>",
			msgbox_ptr->anim_id,
			msgbox_ptr->image_rect.left,msgbox_ptr->image_rect.bottom,
			msgbox_ptr->image_rect.right,msgbox_ptr->image_rect.top);
	     Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	     *data_size_ptr += data_len;
	}

	if(PNULL != msgbox_ptr->text_info.string.wstr_ptr)
	{
		data_len = sprintf((char *)data_ptr,
			"<text rect='%d %d %d %d'>",
			msgbox_ptr->text_info.text_rect.left,
			msgbox_ptr->text_info.text_rect.bottom,
			msgbox_ptr->text_info.text_rect.right,
			msgbox_ptr->text_info.text_rect.top);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
		
		user_data_ptr = msgbox_ptr->text_info.string.wstr_ptr;
		user_data_len = msgbox_ptr->text_info.string.wstr_len;
		if (user_data_len != 0)
		{
			SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
		}
		user_item_ptr[user_data_len] = L'\0';
		Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
		*data_size_ptr += user_data_len * 4; 
		data_len = sprintf((char *)data_ptr,"</text>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
	}

	if(msgbox_ptr->title_text_id)
	{
		data_len = sprintf((char *)data_ptr,
			"<title id='%d'></title>",
			msgbox_ptr->title_text_id);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
	}

	for(i=0;i<GUISOFTKEY_BUTTON_NUM;i++)
	{
		if(msgbox_ptr->softkey_id[i])
		{
			data_len = sprintf((char *)data_ptr,
				"<softkey id='%d' rect='%d %d %d %d'></softkey>",
				msgbox_ptr->softkey_id[i],
				msgbox_ptr->sk_rect.left,
				msgbox_ptr->sk_rect.bottom,
				msgbox_ptr->sk_rect.right,
				msgbox_ptr->sk_rect.top);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
		}
	}

	data_len = sprintf((char *)data_ptr,"</item>");
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	*data_size_ptr += data_len;
}

/*****************************************************************************/
//  Description: 获取Punctuation控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetPunctuationControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	 uint16 data_len = 0; 

	 data_len = sprintf((char *)data_ptr, "<%s id='%d'>", ctrl_name_ptr,ctrl_id);
     Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
     *data_size_ptr += data_len;
}

/*****************************************************************************/
//  Description: 获取Button控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetButtonControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	uint16 data_len = 0; 
	uint16 user_data_len = 0;
	wchar *user_data_ptr = PNULL;

	CTRLBUTTON_OBJ_T  *button_ctrl_ptr = PNULL;
	MMI_STRING_T    str_info = {0};

    button_ctrl_ptr = (CTRLBUTTON_OBJ_T *)ctrl_ptr;
	if(PNULL == button_ctrl_ptr)
	{
		return;
	}
	
    data_len = sprintf((char *)data_ptr,
		//"<%s id='%d' type='%d' gray='%d' rect='%d %d %d %d'>",
		"<%s id='%d' gray='%d' rect='%d %d %d %d'>",
		ctrl_name_ptr,ctrl_id,
		//button_ctrl_ptr->type,button_ctrl_ptr->is_gray,
		button_ctrl_ptr->is_gray,
		button_ctrl_ptr->base_ctrl.display_rect.left,button_ctrl_ptr->base_ctrl.display_rect.top,
		button_ctrl_ptr->base_ctrl.display_rect.right,button_ctrl_ptr->base_ctrl.display_rect.bottom);
    Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
    *data_size_ptr += data_len;

	if (GUISTR_TEXT_ID == button_ctrl_ptr->text_info.text_type)
    {
        MMITHEME_GetResText( button_ctrl_ptr->text_info.text_id, button_ctrl_ptr->win_handle, &str_info );
		user_data_ptr = str_info.wstr_ptr;
		user_data_len = str_info.wstr_len;	
	}
    else if (GUISTR_TEXT_BUFFER == button_ctrl_ptr->text_info.text_type)
    {
        user_data_ptr = button_ctrl_ptr->text_info.str_info.wstr_ptr;
        user_data_len = button_ctrl_ptr->text_info.str_info.wstr_len;
    }

	if(PNULL != user_data_ptr)
	{
		if (user_data_len != 0)
		{
			SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
		}
		user_item_ptr[user_data_len] = L'\0';
		Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
		*data_size_ptr += user_data_len * 4;
	}
}

/*****************************************************************************/
//  Description: 获取Iconlist控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetIconlistControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	uint16 data_len = 0; 
	uint16 user_data_len = 0;
	uint16 index_ptr = 0;
	wchar *user_data_ptr = NULL;

	CTRLICONLIST_OBJ_T  *iconlist_ctrl_ptr = PNULL;
	GUIICONLIST_ITEM_T  *item_ptr = PNULL;
	GUI_RECT_T   icon_rect={0};

	iconlist_ctrl_ptr = (CTRLICONLIST_OBJ_T  *)ctrl_ptr;
	if(PNULL == iconlist_ctrl_ptr)
	{
		return;
	}
	
    data_len = sprintf((char *)data_ptr, 
    "<%s id='%d' loadingicon='%d' totalnum='%d' selectednum='%d' rect='%d %d %d %d'>", 
    ctrl_name_ptr,ctrl_id,iconlist_ctrl_ptr->is_loading_icon,
    iconlist_ctrl_ptr->total_num,iconlist_ctrl_ptr->selected_num,
    iconlist_ctrl_ptr->base_ctrl.rect.left,iconlist_ctrl_ptr->base_ctrl.rect.top,
	iconlist_ctrl_ptr->base_ctrl.rect.right,iconlist_ctrl_ptr->base_ctrl.rect.bottom);
    Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
    *data_size_ptr += data_len;

	item_ptr = iconlist_ctrl_ptr->item_ptr;
	for(index_ptr = 0; index_ptr < iconlist_ctrl_ptr->total_num; index_ptr++)
	{
		if(PNULL == item_ptr)
		{
			break;
		}

		icon_rect = ICONLIST_GetItemRect(index_ptr,iconlist_ctrl_ptr);
		data_len = sprintf((char *)data_ptr,
			"<item selected='%d' index='%d'>",
			item_ptr->is_selected,index_ptr);
	    Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	    *data_size_ptr += data_len;

		user_data_ptr = item_ptr->text.display.name_str.wstr_ptr;
		user_data_len = item_ptr->text.display.name_str.wstr_len;
		if (user_data_len != 0)
		{
			SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
		}
		user_item_ptr[user_data_len] = L'\0';
		Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
		*data_size_ptr += user_data_len * 4;

		data_len = sprintf((char *)data_ptr,"</item>");
	    Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	    *data_size_ptr += data_len;

		item_ptr++;
	}
}

/*****************************************************************************/
//  Description: 获取TAB控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetTabControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	uint16 data_len = 0; 
	uint16 user_data_len = 0; 
	uint16 index = 0; 
	wchar *user_data_ptr = NULL;
	CTRLTAB_OBJ_T *tab_ptr = NULL;
	GUITAB_ITEM_T *item_ptr = PNULL;
	BOOL is_select = FALSE;
	MMI_IMAGE_ID_T image_id = 0;

	tab_ptr = (CTRLTAB_OBJ_T *)ctrl_ptr;
	if (PNULL == tab_ptr)
	{
		 return;
	} 
	
    data_len = sprintf((char *)data_ptr, 
		"<%s id='%d' totalnum='%d' maxnum='%d' shownum='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr,ctrl_id,tab_ptr->total_item_num,
		tab_ptr->max_item_num,tab_ptr->show_item_num,
		tab_ptr->base_ctrl.rect.left,tab_ptr->base_ctrl.rect.top,
		tab_ptr->base_ctrl.rect.right,tab_ptr->base_ctrl.rect.bottom);
    Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
    *data_size_ptr += data_len;

	item_ptr = tab_ptr->valid_item_list.item_ptr;
	if(PNULL == item_ptr)
	{
		return;
	}

	for(index=0;index<tab_ptr->valid_item_list.item_num;index++)
	{
		if(tab_ptr->cur_sel_item_index == index)
		{
			is_select = TRUE;		
		}
		else
		{
			is_select = FALSE;	
		}

		switch (item_ptr->item_data_ptr->image_data.image_data_type)
		{
			case TABITEM_DATA_IMAGE_ID:		/*!< 图片资源ID*/
				image_id = item_ptr->item_data_ptr->image_data.image_data_u.anim_data.img_id;
				break;						
		    case TABITEM_DATA_ANIM_ID:			/*!< 动画资源ID*/
				image_id = item_ptr->item_data_ptr->image_data.image_data_u.anim_data.anim_id;
				break;						
		    case TABITEM_DATA_ANIM_DATA:	/*!< 动画数据*/
		    case TABITEM_DATA_ANIM_PATH:/*!< 动画路径*/
			default:
				break;
		}

		data_len = sprintf((char *)data_ptr,
			"<item select='%d' imgid='%d' rect='%d %d %d %d'>", 
			is_select,image_id,
			item_ptr->rect.left,item_ptr->rect.top,
			item_ptr->rect.right,item_ptr->rect.bottom);
	     Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	     *data_size_ptr += data_len;
		 
		user_data_ptr = item_ptr->item_data_ptr->text_data.text.text_buffer.wstr;
		user_data_len = item_ptr->item_data_ptr->text_data.text.text_buffer.wstr_len;
		if (user_data_len != 0)
		{
			SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
		}
		user_item_ptr[user_data_len] = L'\0';
		Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
		*data_size_ptr += user_data_len * 4;

		data_len = sprintf((char *)data_ptr,"</item>");
	     Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	     *data_size_ptr += data_len;

		 item_ptr = item_ptr->next_ptr;
	}
}

/*****************************************************************************/
//  Description: 获取Edit控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetStatusBarControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	 uint16 data_len = 0; 
	 uint16 user_data_len = 0;
	 wchar *user_data_ptr = NULL;
	 uint16 item_total_num = 0;
	 uint16 item_index = 0;
	 BOOLEAN is_visible = FALSE;
	 CTRLSTATUSBAR_OBJ_T *statusbar_ptr = PNULL;
	 GUISTBDATA_ITEM_DATA_T *stb_item_ptr = PNULL;

	 statusbar_ptr = (CTRLSTATUSBAR_OBJ_T *)ctrl_ptr;
	 if (PNULL == statusbar_ptr)
	 {
		 return;
	 } 
	 item_total_num = GUISTBDATA_GetItemTotalNum();
			
     data_len = sprintf((char *)data_ptr, 
		"<%s id='%d' state='%d' shown='%d' totalnum='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr,ctrl_id,statusbar_ptr->ctrl_state,
		statusbar_ptr->is_shown,item_total_num,
		statusbar_ptr->base_ctrl.rect.left,statusbar_ptr->base_ctrl.rect.top,
		statusbar_ptr->base_ctrl.rect.right,statusbar_ptr->base_ctrl.rect.bottom);
     Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
     *data_size_ptr += data_len;
	   
	 if(statusbar_ptr->is_shown)
	 {
		 for(item_index=0;item_index<item_total_num;item_index++)
		 {
			is_visible = GUISTBDATA_IsItemVisible(item_index);
			if(is_visible)
			{
				stb_item_ptr = GUISTBDATA_GetItemData(item_index);
				if (PNULL == stb_item_ptr)
				 {
					 return;
				 } 

				data_len = sprintf((char *)data_ptr,
					"<item type='%d' imgid='%d' rect='%d %d %d %d'>",
					statusbar_ptr->ctrl_type,
					stb_item_ptr->icon_info.icon_array[stb_item_ptr->cur_frame],
					stb_item_ptr->item_rect.left,stb_item_ptr->item_rect.bottom,
					stb_item_ptr->item_rect.right,stb_item_ptr->item_rect.top);
		        Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			    *data_size_ptr += data_len;

				user_data_ptr = stb_item_ptr->text_info.wstr_ptr;
				user_data_len = stb_item_ptr->text_info.wstr_len;
				if (user_data_len != 0)
				{
					SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
				}
				user_item_ptr[user_data_len] = L'\0';
				Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
				*data_size_ptr += user_data_len * 4;
				data_len = sprintf((char *)data_ptr,"</item>");
		        Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			    *data_size_ptr += data_len;
			}
		}
	}
}

/*****************************************************************************/
//  Description: 获取im控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetIMControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
#if defined (MMI_IM_PDA_SUPPORT)
	uint16 data_len = 0; 
	CTRLIM_OBJ_T *im_ptr = PNULL;
	GUI_RECT_T  rect_ptr = {0};
	int32 key_idx = 0;
	IM_DATA_T *im_data_ptr = PNULL;
	uint16 user_data_len = 0;
	wchar *user_data_ptr = NULL;

	im_ptr = (CTRLIM_OBJ_T *)ctrl_ptr;
	if (PNULL == im_ptr)
	{
		return;
	}

	GUIIM_GetImRect(ctrl_handle,&rect_ptr);
	
	data_len = sprintf((char *)data_ptr, 
		"<%s id='%d' method='%d' lang='%d' type='%d' input='%d' capital='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr,ctrl_id,im_ptr->method_param.im_set.method,
		im_ptr->method_param.im_set.lang,im_ptr->method_param.im_set.type,
		im_ptr->method_param.im_set.input,im_ptr->method_param.im_set.capital,
		rect_ptr.left,rect_ptr.bottom,rect_ptr.right,rect_ptr.top);
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	*data_size_ptr += data_len;
	
	im_data_ptr = im_ptr->im_handle;
	if (PNULL == im_data_ptr)
	{
		return;
	}

	for (key_idx = 0; key_idx < im_data_ptr->vkb.key_cnt; key_idx++)
    {
		if(!im_data_ptr->vkb.keys[key_idx].is_hide)
		{
			data_len = sprintf((char *)data_ptr,
				"<key code='%d' imgid='%d' rect='%d %d %d %d'>",
				im_data_ptr->vkb.keys[key_idx].code,im_data_ptr->vkb.keys[key_idx].icon,
				im_data_ptr->vkb.keys[key_idx].rect.left,im_data_ptr->vkb.keys[key_idx].rect.top,
				im_data_ptr->vkb.keys[key_idx].rect.right,im_data_ptr->vkb.keys[key_idx].rect.bottom);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;

			user_data_ptr = im_data_ptr->vkb.keys[key_idx].text;
			user_data_len = im_data_ptr->vkb.keys[key_idx].text_len;			
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;
			data_len = sprintf((char *)data_ptr,"</key>");
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
		}
	}
#endif
}

/*****************************************************************************/
//  Description: 获取SetList控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetSetListControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	 uint16 data_len = 0; 
	 uint16 user_data_len = 0;
	 wchar *user_data_ptr = NULL;
	 
	 CTRLSETLIST_OBJ_T *setlist_ptr = PNULL;
	 MMI_LINK_NODE_T *next_item_info_ptr = PNULL;


	 setlist_ptr = (CTRLSETLIST_OBJ_T *)ctrl_ptr;
	 if (PNULL == setlist_ptr)
	 {
		return;
	 }
	
	 data_len = sprintf((char *)data_ptr, 
		"<%s id='%d' type='%d' valid='%d' totalnum='%d' selectedcnt='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr,ctrl_id,setlist_ptr->list_type,setlist_ptr->is_valid,
		setlist_ptr->item_info.item_total_num,setlist_ptr->selected_cnt,
		setlist_ptr->base_ctrl.rect.left,setlist_ptr->base_ctrl.rect.top,
		setlist_ptr->base_ctrl.rect.right,setlist_ptr->base_ctrl.rect.bottom);
	 Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	 *data_size_ptr += data_len;

	 next_item_info_ptr = setlist_ptr->item_info.item_head_ptr;
	 if (PNULL == next_item_info_ptr)
	 {
		return;
	 }

	user_data_ptr = setlist_ptr->disp_str.wstr_ptr;
	user_data_len = setlist_ptr->disp_str.wstr_len;
	if (user_data_len != 0)
	{
		SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
	}
	user_item_ptr[user_data_len] = L'\0';
	Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
	*data_size_ptr += user_data_len * 4;
}

/*****************************************************************************/
//  Description: 获取Form控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetFormControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	 uint16 data_len = 0; 
	 	 
	 CTRLFORM_OBJ_T  *form_ctrl_ptr = PNULL;

	 form_ctrl_ptr = (CTRLFORM_OBJ_T *)ctrl_ptr;
	 if (PNULL == form_ctrl_ptr)
	 {
		return;
	 }
	
	  data_len = sprintf((char *)data_ptr, 
		"<%s id='%d' type='%d' style='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr,ctrl_id,form_ctrl_ptr->type,form_ctrl_ptr->style,
		form_ctrl_ptr->base_ctrl.rect.left,form_ctrl_ptr->base_ctrl.rect.top,
		form_ctrl_ptr->base_ctrl.rect.right,form_ctrl_ptr->base_ctrl.rect.bottom);
	  Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	  *data_size_ptr += data_len;
}

/*****************************************************************************/
//  Description: 获取Owndraw控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetOwndrawControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	uint16 data_len = 0; 
	CTRLOWNERDRAW_OBJ_T  *owndraw_ctrl_ptr = PNULL;

    owndraw_ctrl_ptr = (CTRLOWNERDRAW_OBJ_T *)ctrl_ptr;
    if (PNULL == owndraw_ctrl_ptr)
    {
		return;
	}

	data_len = sprintf((char *)data_ptr, 
		"<%s id='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr,ctrl_id,
		owndraw_ctrl_ptr->base_ctrl.rect.left,owndraw_ctrl_ptr->base_ctrl.rect.top,
		owndraw_ctrl_ptr->base_ctrl.rect.right,owndraw_ctrl_ptr->base_ctrl.rect.bottom);
	 Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	 *data_size_ptr += data_len;
}

/*****************************************************************************/
//  Description: 获取Toolbar控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetToolbarControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
#ifdef GUIF_TOOLBAR
	uint16 data_len = 0; 
	 uint16 index = 0;
	 GUITOOLBAR_ITEM_T* toolbar_item_ptr = PNULL;
	 CTRLTOOLBAR_OBJ_T* toolbar_ptr = PNULL;
	 GUITOOLBAR_ITEM_INFO_T* item_info_ptr = PNULL;
	 MMI_STRING_T text_ptr = { 0 };
	 uint16 user_data_len = 0;
	 wchar *user_data_ptr = NULL;
	 
	 toolbar_ptr = (CTRLTOOLBAR_OBJ_T*)ctrl_ptr;
	 if(PNULL == toolbar_ptr)
	 {
		return;
	 }

	 data_len = sprintf((char *)data_ptr, 
		"<%s id='%d' showtype='%d' totalnum='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr,ctrl_id,toolbar_ptr->show_type,toolbar_ptr->total_num,
		toolbar_ptr->rect.left,toolbar_ptr->rect.top,
		toolbar_ptr->rect.right,toolbar_ptr->rect.bottom);
      Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
      *data_size_ptr += data_len;

	index = toolbar_ptr->click_index;
	item_info_ptr = toolbar_ptr->item_info_ptr;
	for(toolbar_ptr->click_index=0;toolbar_ptr->click_index<toolbar_ptr->total_num;toolbar_ptr->click_index++)
	{
		if(PNULL == item_info_ptr)
		{
			break;
		}

		toolbar_item_ptr = &(item_info_ptr->item);

		data_len = sprintf((char *)data_ptr, 
			"<item imgid='%d' textid='%d' rect='%d %d %d %d'>",
			toolbar_item_ptr->image_id, toolbar_item_ptr->text_id,
			item_info_ptr->rect.left,item_info_ptr->rect.top,
			item_info_ptr->rect.right,item_info_ptr->rect.bottom);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;

		if(toolbar_item_ptr->text_id)
		{
			MMITHEME_GetResText(toolbar_item_ptr->text_id, toolbar_ptr->win_handle,&text_ptr);
			user_data_ptr = text_ptr.wstr_ptr;
			user_data_len = text_ptr.wstr_len;
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;
		}
		data_len = sprintf((char *)data_ptr,"</item>");
 		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);            
 		*data_size_ptr += data_len; 
		
		item_info_ptr = item_info_ptr + 1;
	}
	toolbar_ptr->click_index = index;
#endif
}

/*****************************************************************************/
//  Description: 获取Edit控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetTextEditControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	uint16 data_len = 0; 
	uint16 user_data_len = 0;
	wchar *user_data_ptr = NULL;

	CTRLBASEEDIT_OBJ_T *edit_ctrl_ptr = PNULL;
	uint8 hour_ptr = 0;
	uint8 minute_ptr = 0;
	uint8 second_ptr = 0;
	uint16 year_ptr = 0;
	
	edit_ctrl_ptr = (CTRLBASEEDIT_OBJ_T *)ctrl_ptr;
	if (PNULL == edit_ctrl_ptr)
	{
		return;
	}

	switch (edit_ctrl_ptr->type)
	{
		case GUIEDIT_TYPE_TEXT:      /*!<文本编辑框*/
    	case GUIEDIT_TYPE_PHONENUM:  /*!<电话号码编辑框,[0-9,*,#]*/
    	case GUIEDIT_TYPE_DIGITAL:   /*!<数字编辑框,[0-9]*/
    	case GUIEDIT_TYPE_PASSWORD:  /*!<密码编辑框,[0-9,*,#]*/
			data_len = sprintf((char *)data_ptr, 
		     "<%s id='%d' type='%d' focus='%d' style='%d' im='%d' maxLen='%d' rect='%d %d %d %d'>",
		         ctrl_name_ptr, ctrl_id, edit_ctrl_ptr->type, edit_ctrl_ptr->base_ctrl.is_active,
		          edit_ctrl_ptr->style,
				  //edit_ctrl_ptr->add_theme.text.im.allow_im,
				  edit_ctrl_ptr->is_create_im_active,
				  edit_ctrl_ptr->str_max_len,
		         edit_ctrl_ptr->original_rect.left,edit_ctrl_ptr->original_rect.top,
		         edit_ctrl_ptr->original_rect.right,edit_ctrl_ptr->original_rect.bottom);            
		     Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);            
		     *data_size_ptr += data_len;

			 if(0 != edit_ctrl_ptr->str_len)
			 {
				 data_len = sprintf((char *)data_ptr,"<text>");
				 Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);            
				 *data_size_ptr += data_len;
				 user_data_ptr = edit_ctrl_ptr->str_ptr;
				 user_data_len = edit_ctrl_ptr->str_len;
				 if (user_data_len != 0)
				 {
				 	SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
				 }
				 user_item_ptr[user_data_len] = L'\0';

				 Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
				 *data_size_ptr += user_data_len * 4;
				 data_len = sprintf((char *)data_ptr,"</text>");
				 Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);            
				 *data_size_ptr += data_len;
			}
			break;			
		case GUIEDIT_TYPE_IP:        /*!<IP编辑框*/	
			data_len = sprintf((char *)data_ptr, 
		     "<%s id='%d' type='%d' focus='%d' style='%d' IP='%d' rect='%d %d %d %d'>",
		         ctrl_name_ptr, ctrl_id, edit_ctrl_ptr->type, edit_ctrl_ptr->base_ctrl.is_active,
		          edit_ctrl_ptr->style,GUIEDIT_GetIP(ctrl_handle),
		         edit_ctrl_ptr->original_rect.left,edit_ctrl_ptr->original_rect.top,
		         edit_ctrl_ptr->original_rect.right,edit_ctrl_ptr->original_rect.bottom);            
		     Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);            
		     *data_size_ptr += data_len;
			break;
    	case GUIEDIT_TYPE_DATE:      /*!<日期编辑框*/
			GUIEDIT_GetDate(ctrl_handle,&year_ptr,&minute_ptr,&second_ptr);
			data_len = sprintf((char *)data_ptr, 
		     "<%s id='%d' type='%d' focus='%d' style='%d' Date='%d %d %d' rect='%d %d %d %d'>",
		         ctrl_name_ptr, ctrl_id, edit_ctrl_ptr->type, edit_ctrl_ptr->base_ctrl.is_active,
		          edit_ctrl_ptr->style,hour_ptr,minute_ptr,second_ptr,
		         edit_ctrl_ptr->original_rect.left,edit_ctrl_ptr->original_rect.top,
		         edit_ctrl_ptr->original_rect.right,edit_ctrl_ptr->original_rect.bottom);            
		     Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);            
		     *data_size_ptr += data_len;
			 break;
    	case GUIEDIT_TYPE_TIME:      /*!<时间编辑框*/
			GUIEDIT_GetTime(ctrl_handle,&hour_ptr,&minute_ptr,&second_ptr);
			data_len = sprintf((char *)data_ptr, 
		     "<%s id='%d' type='%d' focus='%d' style='%d' time='%d %d %d' rect='%d %d %d %d'>",
		         ctrl_name_ptr, ctrl_id, edit_ctrl_ptr->type, edit_ctrl_ptr->base_ctrl.is_active,
		          edit_ctrl_ptr->style,hour_ptr,minute_ptr,second_ptr,
		         edit_ctrl_ptr->original_rect.left,edit_ctrl_ptr->original_rect.top,
		         edit_ctrl_ptr->original_rect.right,edit_ctrl_ptr->original_rect.bottom);            
		     Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);            
		     *data_size_ptr += data_len;
			 break;					 
		case GUIEDIT_TYPE_TOUCH_DATE:/*!<全触摸屏日期*/
    	case GUIEDIT_TYPE_TOUCH_TIME:/*!<全触摸屏时间*/
			 //GUIEDIT_GetTouchTime(edit_ctrl_ptr,&hour_ptr,&minute_ptr,&second_ptr);
			 data_len = sprintf((char *)data_ptr, 
		     "<%s id='%d' type='%d' focus='%d' style='%d' time='%d %d %d' rect='%d %d %d %d'>",
		         ctrl_name_ptr, ctrl_id, edit_ctrl_ptr->type, edit_ctrl_ptr->base_ctrl.is_active,
		          edit_ctrl_ptr->style,hour_ptr,minute_ptr,second_ptr,
		         edit_ctrl_ptr->original_rect.left,edit_ctrl_ptr->original_rect.top,
		         edit_ctrl_ptr->original_rect.right,edit_ctrl_ptr->original_rect.bottom);            
		     Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);            
		     *data_size_ptr += data_len;
			 break;
			default:
				break;
	}
}
/*****************************************************************************/
//  Description: 获取Edit控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetEditControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	uint16 data_len = 0,i; 
	uint16 user_data_len = 0;
	wchar *user_data_ptr = NULL;
	uint16 max_len = 0;
	uint16 item_num = 0;

	CTRLLISTEDIT_OBJ_T *edit_ctrl_ptr = PNULL;
	GUIEDIT_OBJ_INFO_T *obj_info_ptr = PNULL;
	//uint8 hour_ptr = 0;
	//uint8 minute_ptr = 0;
	//uint8 second_ptr = 0;
	//uint16 year_ptr = 0;
	
	edit_ctrl_ptr = (CTRLLISTEDIT_OBJ_T *)ctrl_ptr;
	if (PNULL == edit_ctrl_ptr)
	{
		return;
	}


	// 如果是编辑框中的列表类型，max_len为列表项的最大文本长度，max_num为列表最大长度
	max_len = edit_ctrl_ptr->item_max_len;
	//max_num = edit_ctrl_ptr->add_data.list.total_line_num;
	item_num = edit_ctrl_ptr->max_num;
	data_len = sprintf((char *)data_ptr, 
		//"<%s id='%d' type='%d' focus='%d' style='%d' im='%d' totalnum='%d' maxLen='%d' maxNum='%d' rect='%d %d %d %d'>",
		"<%s id='%d'  focus='%d'  totalnum='%d' maxLen='%d' rect='%d %d %d %d'>",
		ctrl_name_ptr, ctrl_id, edit_ctrl_ptr->baseflex_ctrl.baseedit_ctrl.base_ctrl.is_active,
		//edit_ctrl_ptr->style,
		//edit_ctrl_ptr->add_theme.text.im.allow_im, 
		item_num,max_len, 
		//max_num,
		edit_ctrl_ptr->baseflex_ctrl.baseedit_ctrl.base_ctrl.rect.left,edit_ctrl_ptr->baseflex_ctrl.baseedit_ctrl.base_ctrl.rect.top,
		edit_ctrl_ptr->baseflex_ctrl.baseedit_ctrl.base_ctrl.rect.right,edit_ctrl_ptr->baseflex_ctrl.baseedit_ctrl.base_ctrl.rect.bottom);            
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);            
	*data_size_ptr += data_len;
	
	for(i=0;i<item_num;i++)
	{	
		obj_info_ptr = edit_ctrl_ptr->obj_info_ptr + i;
		if(obj_info_ptr->user_data.wstr_len)
		{
			data_len = sprintf((char *)data_ptr,"<item>");
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);            
			*data_size_ptr += data_len;			 
			
			user_data_ptr = obj_info_ptr->user_data.wstr_ptr;
			user_data_len = obj_info_ptr->user_data.wstr_len;
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;
			data_len = sprintf((char *)data_ptr,"</item>");
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);            
			*data_size_ptr += data_len;
		}
	}				

}

/*****************************************************************************/
//  Description: 获取DropList控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetDropListControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	uint16 data_len = 0,j; 
	uint16 user_data_len = 0;
	wchar *user_data_ptr = NULL;
	BOOL is_show = FALSE;
	CTRLDROPDOWNLIST_OBJ_T *dropdownlist_ctrl_ptr = PNULL;
	MMI_STRING_T ctrl_str = { 0 };
	
	dropdownlist_ctrl_ptr = (CTRLDROPDOWNLIST_OBJ_T *)ctrl_ptr;
	if (PNULL == dropdownlist_ctrl_ptr)
	{
		return;
	}
	
	switch (dropdownlist_ctrl_ptr->ctrl_type_info.ctrl_type)
	{
		case GUIDNLIST_EDITABLE_TEXT:
		case GUIDNLIST_EDITABLE_NUMLIST:
		case GUIDNLIST_EDITABLE_PHONENUM:
			// totalNum:总长度 maxNum:最大长度
			data_len = sprintf((char *)data_ptr, 
				"<%s id='%d' focus='%d' type='%d' active='%d' totalNum='%d' maxNum='%d' show_type='%d' cur_status='%d' rect='%d %d %d %d'>",
				ctrl_name_ptr, ctrl_id, dropdownlist_ctrl_ptr->is_focus,
				dropdownlist_ctrl_ptr->ctrl_type_info.ctrl_type,
				dropdownlist_ctrl_ptr->base_ctrl.is_active,
				dropdownlist_ctrl_ptr->ctrl_type_info.editable_max_text_num,
				dropdownlist_ctrl_ptr->ctrl_type_info.editable_max_listitem_num,
				dropdownlist_ctrl_ptr->show_type,dropdownlist_ctrl_ptr->cur_status,
				dropdownlist_ctrl_ptr->orig_rect.left,dropdownlist_ctrl_ptr->orig_rect.top,
				dropdownlist_ctrl_ptr->orig_rect.right,dropdownlist_ctrl_ptr->orig_rect.bottom);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;

			GUIEDIT_GetString(dropdownlist_ctrl_ptr->edit_handle, &ctrl_str);
			user_data_ptr = ctrl_str.wstr_ptr;
			user_data_len = ctrl_str.wstr_len;
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;
			break;
		case GUIDNLIST_NORMAL:	
			// totalNum:总长度 maxNum:最大长度
			data_len = sprintf((char *)data_ptr, 
				"<%s id='%d' focus='%d' type='%d' active='%d' totalNum='%d' maxNum='%d' show_type='%d' cur_status='%d' rect='%d %d %d %d'>",
				ctrl_name_ptr, ctrl_id, dropdownlist_ctrl_ptr->is_focus,
				dropdownlist_ctrl_ptr->ctrl_type_info.ctrl_type,
				dropdownlist_ctrl_ptr->base_ctrl.is_active,
				dropdownlist_ctrl_ptr->max_item_num,
				dropdownlist_ctrl_ptr->total_item_num,
				dropdownlist_ctrl_ptr->show_type,dropdownlist_ctrl_ptr->cur_status,
				dropdownlist_ctrl_ptr->orig_rect.left,dropdownlist_ctrl_ptr->orig_rect.top,
				dropdownlist_ctrl_ptr->orig_rect.right,dropdownlist_ctrl_ptr->orig_rect.bottom);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
			
			for(j=0;j<dropdownlist_ctrl_ptr->total_item_num;j++)
			{
				if(dropdownlist_ctrl_ptr->current_index == j)
				{
					is_show = TRUE;
				}
				else
				{
					is_show = FALSE;
				}
				
				data_len = sprintf((char *)data_ptr, "<item shown='%d'>",is_show);
				Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
				*data_size_ptr += data_len;	
				
				user_data_ptr = (dropdownlist_ctrl_ptr->all_item_ptr+j)->wstr_ptr;
				user_data_len = (dropdownlist_ctrl_ptr->all_item_ptr+j)->wstr_len;
				if (user_data_len != 0)
				{
					SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
				}
				user_item_ptr[user_data_len] = L'\0';
				
				Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
				*data_size_ptr += user_data_len * 4;
				
				data_len = sprintf((char *)data_ptr, "</item>");
				Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
				*data_size_ptr += data_len;
			}
			break;
		default:
			break;		
	}	
}

/*****************************************************************************/
//  Description: 获取softkey控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetsoftkeyControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	 uint16 data_len = 0,j; 
	 uint16 user_data_len = 0;
	 wchar *user_data_ptr = NULL;
	 
	 CTRLSOFTKEY_OBJ_T	*softkey_ptr = PNULL;
	 MMI_STRING_T text_ptr = { 0 };

	 softkey_ptr = (CTRLSOFTKEY_OBJ_T*)ctrl_ptr;
	 if (PNULL == softkey_ptr)
	 {
		return;
	 }

	 data_len = sprintf((char *)data_ptr, 
		"<%s id='%d' style='%d' visible='%d' bgtype='%d' bgid='%d' bgcolor='%d'>", 
		ctrl_name_ptr,ctrl_id,softkey_ptr->style,softkey_ptr->is_visible,
		softkey_ptr->bg_type,softkey_ptr->bg_image,softkey_ptr->bg_color);
     Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
     *data_size_ptr += data_len;

	for(j=0;j < GUISOFTKEY_BUTTON_NUM;j++)
	{
		if(softkey_ptr->button_arr[j].is_show)
		{
			switch(softkey_ptr->button_arr[j].content.data_type)
			{	
				case GUISK_DATA_TEXT_ID:
				case GUISK_DATA_TEXT_BUFFER:
					data_len = sprintf((char *)data_ptr,
						"<text id='%d' fontcolor='%d' font='%d' gray='%d' rect='%d %d %d %d'>",
						softkey_ptr->button_arr[j].content.data_u.text_id,
						softkey_ptr->font_color,softkey_ptr->font,
						softkey_ptr->button_arr[j].is_gray,
						softkey_ptr->button_arr[j].rect.left,
						softkey_ptr->button_arr[j].rect.top,
						softkey_ptr->button_arr[j].rect.right,
						softkey_ptr->button_arr[j].rect.bottom);
					Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	        		*data_size_ptr += data_len;	
					
					SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
					if(GUISK_DATA_TEXT_ID == softkey_ptr->button_arr[j].content.data_type)
					{
						MMITHEME_GetResText(softkey_ptr->button_arr[j].content.data_u.text_id, softkey_ptr->win_handle, &text_ptr);
					}
					else
					{
						text_ptr.wstr_ptr = softkey_ptr->button_arr[j].content.data_u.text_buffer.wstr_ptr;
						text_ptr.wstr_len = softkey_ptr->button_arr[j].content.data_u.text_buffer.wstr_len;
					}

					user_data_ptr = text_ptr.wstr_ptr;
					user_data_len = text_ptr.wstr_len;
					if (user_data_len != 0)
					{
			    		SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
					}
					user_item_ptr[user_data_len] = L'\0';
					Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
					*data_size_ptr += user_data_len * 4;
					data_len = sprintf((char *)data_ptr,"</text>");
					Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			        *data_size_ptr += data_len;
					break;
				case GUISK_DATA_IMAGE_ID:
					data_len = sprintf((char *)data_ptr,
						"<img id='%d' gray='%d' rect='%d %d %d %d'/>",
						softkey_ptr->button_arr[j].content.data_u.image_id,
						softkey_ptr->button_arr[j].is_gray,
						softkey_ptr->button_arr[j].rect.left,
						softkey_ptr->button_arr[j].rect.top,
						softkey_ptr->button_arr[j].rect.right,
						softkey_ptr->button_arr[j].rect.bottom);
					Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	        		*data_size_ptr += data_len;
					break;
				default:
						break;
			}			
		}
	}			
}

/*****************************************************************************/
//  Description: 获取Tips控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetTipsControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	uint16 data_len = 0;
	uint16 user_data_len = 0;
	wchar *user_data_ptr = NULL;
		
	TIPS_OBJ_T *tips_ptr  = PNULL;

	tips_ptr  = (TIPS_OBJ_T *)ctrl_ptr;
	if (PNULL == tips_ptr)
	{
		return;
	}
	
	data_len = sprintf((char *)data_ptr, 
		"<%s id='%d' valid='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr,ctrl_id,tips_ptr->is_valid,
		tips_ptr->base_ctrl.rect.left,tips_ptr->base_ctrl.rect.top,
		tips_ptr->base_ctrl.rect.right,tips_ptr->base_ctrl.rect.bottom);
	   Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	   *data_size_ptr += data_len;

	if(tips_ptr->is_valid) //tip是否有效
	{
		data_len = sprintf((char *)data_ptr, 
			"<text fonttype='%d' fontcolor='%d' align='%d' strstate='%d'>", 
			tips_ptr->style_info.text_style.font_type,
			tips_ptr->style_info.text_style.font_color,
			tips_ptr->style_info.text_style.align,
			tips_ptr->style_info.text_style.str_state);
	      Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	      *data_size_ptr += data_len;

		user_data_ptr = tips_ptr->text_info.wstr_ptr;
		user_data_len = tips_ptr->text_info.wstr_len;
		if (user_data_len != 0)
		{
			SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
		}
		user_item_ptr[user_data_len] = L'\0';
		Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
		*data_size_ptr += user_data_len * 4;
		data_len = sprintf((char *)data_ptr, "</text>");
	      Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	      *data_size_ptr += data_len;
	}
}

/*****************************************************************************/
//  Description: 获取Title控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetTitleControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	uint16 i,data_len = 0; 
	uint16 user_data_len = 0;
	wchar *user_data_ptr = NULL;
	CTRLTITLE_OBJ_T  *title_ptr = PNULL;
	MMI_STRING_T  text_ptr = {0};

	title_ptr = (CTRLTITLE_OBJ_T  *)ctrl_ptr;
	if (PNULL == title_ptr)
	{
		return;
	}

	 data_len = sprintf((char *)data_ptr, 
	 	"<%s id='%d' rect='%d %d %d %d'>",
	 	ctrl_name_ptr,ctrl_id,
		title_ptr->base_ctrl.rect.left,title_ptr->base_ctrl.rect.top,
		title_ptr->base_ctrl.rect.right,title_ptr->base_ctrl.rect.bottom);
	 Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	 *data_size_ptr += data_len;

	//文本内容
	data_len = sprintf((char *)data_ptr, 
	"<text id='%d' aligntype='%d' font='%d' fontcolor='%d' charspace='%d'>",
		title_ptr->text_id,title_ptr->str_style.align,title_ptr->str_style.font,
		title_ptr->str_style.font_color,title_ptr->str_style.char_space);
	 Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	 *data_size_ptr += data_len;

	if(!title_ptr->title_str.wstr_len)
	{
		MMITHEME_GetResText(title_ptr->text_id, title_ptr->win_handle, &text_ptr);
		user_data_ptr = text_ptr.wstr_ptr;
		user_data_len = text_ptr.wstr_len;;
	}
	else
	{
		user_data_ptr = title_ptr->title_str.wstr_ptr;
		user_data_len = title_ptr->title_str.wstr_len;
	}	
	 
	if (user_data_len != 0)
	{
		SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
	}
	user_item_ptr[user_data_len] = L'\0';
	Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
	*data_size_ptr += user_data_len * 4;

	data_len = sprintf((char *)data_ptr, "</text>");
	 Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	 *data_size_ptr += data_len;

	//背景图片
	if(title_ptr->is_need_bg)
	{
		data_len = sprintf((char *)data_ptr, "<bg id='%d'/>",
		title_ptr->bg_image);
	    Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	    *data_size_ptr += data_len;
	}

	if(title_ptr->icon_id)
	{
		//小图标
		data_len = sprintf((char *)data_ptr, "<icon id='%d'/>",title_ptr->icon_id);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
	}

	//子字符串
	if(title_ptr->is_need_sub_text)
	{
		data_len = sprintf((char *)data_ptr,
			"<sub_text font='%d' subalign='%d' rect='%d %d %d %d'>",
		title_ptr->sub_font,title_ptr->sub_align,
		title_ptr->sub_text_rect.left,title_ptr->sub_text_rect.top,
		title_ptr->sub_text_rect.right,title_ptr->sub_text_rect.bottom);
	    Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	    *data_size_ptr += data_len;

		user_data_ptr = title_ptr->sub_str;
		user_data_len = title_ptr->sub_str_len;		
		if (user_data_len != 0)
		{
			SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
		}
		user_item_ptr[user_data_len] = L'\0';
		Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
		*data_size_ptr += user_data_len * 4;

		data_len = sprintf((char *)data_ptr, "</sub_text>");
	    Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	    *data_size_ptr += data_len;
	}

	//箭头
	if(title_ptr->is_need_button)
	{
		for(i=0;i<GUITITLE_BUTTON_NUM;i++)
		{
			if(!title_ptr->button_state[i])
			{
				data_len = sprintf((char *)data_ptr, 
					"<button state='%d' imgid='%d' textid='%d' rect='%d %d %d %d'>",
				title_ptr->button_state[i],title_ptr->button_info[i].image_id,
				title_ptr->button_info[i].text_id,
				title_ptr->button_rect[i].left,title_ptr->button_rect[i].top,
				title_ptr->button_rect[i].right,title_ptr->button_rect[i].bottom);
			    Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			    *data_size_ptr += data_len;

				if(GUITITLE_DATA_TEXT_ID == title_ptr->button_info[i].text_type)
				{
					MMITHEME_GetResText(title_ptr->button_info[i].text_id, title_ptr->win_handle, &text_ptr);
					user_data_ptr = text_ptr.wstr_ptr;
					user_data_len = text_ptr.wstr_len;
				}
				else if(GUITITLE_DATA_TEXT_BUFFER == title_ptr->button_info[i].text_type)
				{
					user_data_ptr = title_ptr->button_info[i].icon_str_ptr;
					user_data_len = title_ptr->button_info[i].str_len;
				}
				 
				if (user_data_len != 0)
				{
					SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
				}
				user_item_ptr[user_data_len] = L'\0';
				Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
				*data_size_ptr += user_data_len * 4;
				data_len = sprintf((char *)data_ptr, "</button>");
			    Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			    *data_size_ptr += data_len;
			}
		}
	}
}

/*****************************************************************************/
//  Description: 获取List控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetListControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	 uint16 j,data_len = 0;
	 uint16 user_data_len = 0;
	 uint16  item_index = 0;
	 GUI_RECT_T  rect_ptr = {0};
	 MMI_STRING_T text_ptr = {0};
	 MMI_IMAGE_ID_T user_data_id = 0;
	 wchar *user_data_ptr = NULL;
	 BOOL is_focus = FALSE;
	 
	 CTRLLIST_OBJ_T *list_ctrl_ptr = PNULL;
	 GUILIST_ITEM_DATA_T* item_data_ptr = PNULL;
	 const CTRLLIST_ITEM_T *list_item_ptr = PNULL;

	 list_ctrl_ptr = (CTRLLIST_OBJ_T *)ctrl_ptr;
	 if (PNULL == list_ctrl_ptr)
	 {
		 return;
	 }

	// totalNum:总长度 maxNum:最大长度
	 data_len = sprintf((char *)data_ptr, 
	 "<%s id='%d' type='%d' totalnum='%d' rect='%d %d %d %d'>",
	     ctrl_name_ptr, ctrl_id,list_ctrl_ptr->mark_type,
	     list_ctrl_ptr->total_item_num,
	     list_ctrl_ptr->base_ctrl.rect.left,list_ctrl_ptr->base_ctrl.rect.top,
		 list_ctrl_ptr->base_ctrl.rect.right,list_ctrl_ptr->base_ctrl.rect.bottom);
	 Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	 *data_size_ptr += data_len;

	if(list_ctrl_ptr->total_item_num >0)
	{
		for(item_index = 0; item_index < list_ctrl_ptr->total_item_num; item_index++)
		{
			list_item_ptr = CTRLLIST_GetItem(ctrl_handle, item_index);
			if (PNULL == list_item_ptr)
			{
				 break;
			}

			item_data_ptr = list_item_ptr->data_ptr;
			if(PNULL == item_data_ptr)
			{
				continue;
			}

			if(list_ctrl_ptr->cur_item_idx == item_index)
			{
				is_focus = TRUE;
			}
			else
			{
				is_focus = FALSE;
			}

			if(!GUILIST_GetItemRect(ctrl_handle,item_index,&rect_ptr))
			{
				break;
			}

			data_len = sprintf((char *)data_ptr, 
				"<item focus='%d' index='%d' rect='%d %d %d %d'>",
				is_focus,item_index,
				rect_ptr.left,rect_ptr.top,
				rect_ptr.right,rect_ptr.bottom);
			 Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			 *data_size_ptr += data_len;	

			 for (j = 0; j < GUIITEM_CONTENT_MAX_NUM; j++)
			 {
				switch (item_data_ptr->item_content[j].item_data_type)
				{
					case GUIITEM_DATA_IMAGE_ID:						
						user_data_id = item_data_ptr->item_content[j].item_data.image_id;
						if(user_data_id == list_ctrl_ptr->display_style.radio_unselected_image_id)
						{
							data_len = sprintf((char *)data_ptr, "<image id='%d'/>",list_ctrl_ptr->display_style.radio_unselected_image_id);
						}
						else if(user_data_id == list_ctrl_ptr->display_style.radio_selected_image_id)
						{
							data_len = sprintf((char *)data_ptr, "<image id='%d' selected_id='%d'/>",
								list_ctrl_ptr->display_style.radio_unselected_image_id,list_ctrl_ptr->display_style.radio_selected_image_id);
						}
						else if(user_data_id == list_ctrl_ptr->display_style.check_unselected_image_id)
						{
							data_len = sprintf((char *)data_ptr, "<image id='%d'/>",list_ctrl_ptr->display_style.check_unselected_image_id);
						}
				 		else if(user_data_id == list_ctrl_ptr->display_style.check_selected_image_id)
						{
							data_len = sprintf((char *)data_ptr, "<image id='%d' selected_id='%d'/>",
								list_ctrl_ptr->display_style.check_unselected_image_id,list_ctrl_ptr->display_style.check_selected_image_id);
						}
						else
						{
							data_len = sprintf((char *)data_ptr, "<image id='%d'/>",user_data_id);
						}
					    Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
					    *data_size_ptr += data_len;
					break;

					case GUIITEM_DATA_TEXT_ID:
					case GUIITEM_DATA_TEXT_BUFFER:
						user_data_id = item_data_ptr->item_content[j].item_data.text_id;
					    data_len = sprintf((char *)data_ptr, "<text id='%d'>",
				   		user_data_id);
					    Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
					    *data_size_ptr += data_len;

						if(GUIITEM_DATA_TEXT_ID == item_data_ptr->item_content[j].item_data_type)
						{
							SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
							MMITHEME_GetResText(item_data_ptr->item_content[j].item_data.text_id, ctrl_handle, &text_ptr);
						}
						else if(GUIITEM_DATA_TEXT_BUFFER == item_data_ptr->item_content[j].item_data_type)
						{
							text_ptr.wstr_ptr = item_data_ptr->item_content[j].item_data.text_buffer.wstr_ptr;
							text_ptr.wstr_len = item_data_ptr->item_content[j].item_data.text_buffer.wstr_len;
						}

					    user_data_ptr = text_ptr.wstr_ptr;
						user_data_len = text_ptr.wstr_len;
						if (user_data_len != 0)
						{
							SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
						}
						user_item_ptr[user_data_len] = L'\0';
						
						Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
						*data_size_ptr += user_data_len * 4;
					    data_len = sprintf((char *)data_ptr, "</text>");
						Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
						*data_size_ptr += data_len;	
						break;

					case GUIITEM_DATA_ANIM_DATA:
						data_len = sprintf((char *)data_ptr, "<anim id='%d'/>",item_data_ptr->item_content[j].item_data.anim_data_ptr->anim_id);
					   Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
					   *data_size_ptr += data_len;
					   break;
					 case GUIITEM_DATA_ANIM_PATH:
						data_len = sprintf((char *)data_ptr, "<anim></anim>");
						Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
						*data_size_ptr += data_len;
						break;
					default:
					   break;
				}
			 }
			 data_len = sprintf((char *)data_ptr, "</item>");
			 Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			 *data_size_ptr += data_len;	
		}
	}
}


/*****************************************************************************/
//  Description: 获取MainMenu控件描述
//  Global resource dependence :none
//  Author: 
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetMainMenuControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr = PNULL;
	uint16 data_len=0;
	
	menu_ctrl_ptr = (CTRLMAINMENU_OBJ_T *)ctrl_ptr;
	if (PNULL == menu_ctrl_ptr)
	{
		return;
	}

	switch (menu_ctrl_ptr->type)
	{   
		#ifdef MATRIX_MAIN_MENU_SUPPORT
	 	case MMIMAINMENU_MATRIX_E :  
		case MMIMAINMENU_MATRIX_TITLE_E :  
			Atest_GetMatrixMainMenuControlProperty	( menu_ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);		
    		break;
		#endif
		#ifdef QBTHEME_SUPPORT
	 	case MMIMAINMENU_QBTHEME_E : 			
			Atest_GetQbMainMenuControlProperty	( menu_ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);		
			break;
		#endif
	    #ifdef MMI_ISTYLE_SUPPORT
	    case MMIMAINMENU_ISTYLE_E : 
			
			Atest_GetIStyleMainMenuControlProperty	( menu_ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);		
			break;
	   #endif
		#ifdef PDA_UI_SUPPORT_MANIMENU_GO										 
		case MMIMAINMENU_GO_SLIDE_E :
			Atest_GetSlideMainMenuControlProperty	( menu_ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);		
			break;
		#endif
	   #ifdef MENU_SWEETS_SUPPORT
	    case MMIMAINMENU_SWEETS_E :
			Atest_GetSweetMainMenuControlProperty	( menu_ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);		
			break;
	   #endif
		default:
			data_len = sprintf((char *)data_ptr,"<%s style='%d'>",ctrl_name_ptr,menu_ctrl_ptr->type);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
			break;
	}
	
}

#ifdef MENU_SWEETS_SUPPORT
/*****************************************************************************/
//  Description: 获取SweetMainMenu控件描述
//  Global resource dependence :none
//  Author: 
/*****************************************************************************/
LOCAL void Atest_GetSweetMainMenuControlProperty( 
										 CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,//MENU指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr)			//传输的数据text
{
	uint16 data_len = 0;
	uint16 item_index = 0;
	uint16 user_data_len = 0;
	MMI_STRING_T text_ptr = { 0 };
    	//MMI_IMAGE_ID_T  icon_id_ptr = { 0 };
    	BOOLEAN  is_grayed_ptr = FALSE;
	BOOLEAN  is_focus_icon = FALSE;
	wchar *user_data_ptr = NULL;
	MMIMAINMENU_SWEETS_DATA_T *mainmenu = NULL;
	MMIMAINMENU_ITEM_INFO_T item_ptr = {0};
    	CTRLMAINMENU_ITEM_T item_info = {0};
	mainmenu =  (MMIMAINMENU_SWEETS_DATA_T*)menu_ctrl_ptr->pm_data_ptr;

	data_len = sprintf((char *)data_ptr,
		"<%s id='%d' style='%d' totalnum='%d' rect='%d %d %d %d'>",
		ctrl_name_ptr,ctrl_id,menu_ctrl_ptr->type,/*mainmenu->is_static,menu_ctrl_ptr->is_transparent,*/mainmenu->item_total_num,
		menu_ctrl_ptr->base_ctrl.rect.left,menu_ctrl_ptr->base_ctrl.rect.top,
		menu_ctrl_ptr->base_ctrl.rect.right,menu_ctrl_ptr->base_ctrl.rect.bottom);
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	*data_size_ptr += data_len;

	for (item_index = 0; item_index < mainmenu->item_total_num; item_index++)
	{
		MMIMAINMENU_GetItem(&mainmenu->menu_list_info, item_index, &item_ptr);
		MMIMAINMENU_GetItemData(item_ptr.menu_id, item_ptr.group_id, &item_info);

		if(item_index == mainmenu->cur_item_index)
		{
			is_focus_icon = 1;
		}
		else
		{
			is_focus_icon = 0;
		}
		
		data_len = sprintf((char *)data_ptr,
			"<item focus='%d' grayed='%d'>",
			is_focus_icon,is_grayed_ptr);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;	
  
		//title
	/*
		if(menu_ctrl_ptr->title_len != 0)
		{
			data_len = sprintf((char *)data_ptr, 
				"<title rect='%d %d %d %d'>",
				menu_ctrl_ptr->title_rect.left,menu_ctrl_ptr->title_rect.bottom,
				menu_ctrl_ptr->title_rect.right,menu_ctrl_ptr->title_rect.top);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;

			user_data_ptr = menu_ctrl_ptr->title_wstr;
			user_data_len = menu_ctrl_ptr->title_len;
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;
			data_len = sprintf((char *)data_ptr, "</title>");
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
		}
*/


		//图片
		data_len = sprintf((char *)data_ptr, "<image id='%d'/>", item_info.icon.data.icon_id);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
		

		//文本
		
		data_len = sprintf((char *)data_ptr, "<text>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
			
		if (CTRL_TEXT_ID == item_info.text.type )
            {
            	   	MMITHEME_GetResText(item_info.text.data.text_id, mainmenu->win_handle, &text_ptr);	
            }
            else
            {
                text_ptr.wstr_ptr = item_info.text.data.str_info.wstr_ptr;
                text_ptr.wstr_len = item_info.text.data.str_info.wstr_len;
            }
		user_data_ptr = text_ptr.wstr_ptr;
		user_data_len = text_ptr.wstr_len;
		if (user_data_len != 0)
		{
			SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
		}
		user_item_ptr[user_data_len] = L'\0';
		Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
		*data_size_ptr += user_data_len * 4;	
		data_len = sprintf((char *)data_ptr, "</text>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;

						
		data_len = sprintf((char *)data_ptr, "</item>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;	
	}
}
#endif

#ifdef PDA_UI_SUPPORT_MANIMENU_GO										 
/*****************************************************************************/
//  Description: 获取SlideMainMenu控件描述
//  Global resource dependence :none
//  Author: 
/*****************************************************************************/
LOCAL void Atest_GetSlideMainMenuControlProperty( 
										 CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,//MENU指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr)			//传输的数据text
{
	uint16 data_len = 0;
	uint16 item_index = 0;
	uint16 user_data_len = 0;
	MMI_STRING_T text_ptr = { 0 };
    	//MMI_IMAGE_ID_T  icon_id_ptr = { 0 };
    	BOOLEAN  is_grayed_ptr = FALSE;
	BOOLEAN  is_focus_icon = FALSE;
	wchar *user_data_ptr = NULL;
	MMIMAINMENU_ITEM_INFO_T *item_ptr = {0};
	CTRLMAINMENU_ITEM_T item_info = {0};
	MMIMAINEMENU_ITEM_LIST_T  *page_item_info_ptr = PNULL;
	MMIMAINMENU_SLIDEPAGE_DATA_T* mainmenu = NULL;
	mainmenu =  (MMIMAINMENU_SLIDEPAGE_DATA_T*)menu_ctrl_ptr->pm_data_ptr;
	if(PNULL == mainmenu)
	{
	    return;
	}
	page_item_info_ptr = Atest_GetSlidePageMenuLinkListPtr(mainmenu, mainmenu->cur_page_index);
	if (PNULL == page_item_info_ptr)
	{
	    return;
       }

	data_len = sprintf((char *)data_ptr,
		"<%s id='%d' style='%d' totalnum='%d' rect='%d %d %d %d'>",
		ctrl_name_ptr,ctrl_id,menu_ctrl_ptr->type,/*mainmenu->is_static,menu_ctrl_ptr->is_transparent,*/page_item_info_ptr->item_count,
		menu_ctrl_ptr->base_ctrl.rect.left,menu_ctrl_ptr->base_ctrl.rect.top,
		menu_ctrl_ptr->base_ctrl.rect.right,menu_ctrl_ptr->base_ctrl.rect.bottom);
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	*data_size_ptr += data_len;
	
	for (item_index = 0; item_index < page_item_info_ptr->item_count; item_index++)
	{
	       item_ptr = Atest_SlidePageMenuGetItemInfoByIndex(page_item_info_ptr, item_index);

	        if (PNULL != item_ptr)
	        {
	            	MMIMAINMENU_GetItemData(item_ptr->menu_id,item_ptr->group_id,&item_info);
	        }

		if(item_index == mainmenu->cur_item_index)
		{
			is_focus_icon = 1;
		}
		else
		{
			is_focus_icon = 0;
		}
		
		data_len = sprintf((char *)data_ptr,
			"<item focus='%d' grayed='%d'>",
			is_focus_icon,is_grayed_ptr);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;	
  
		//title
	/*
		if(menu_ctrl_ptr->title_len != 0)
		{
			data_len = sprintf((char *)data_ptr, 
				"<title rect='%d %d %d %d'>",
				menu_ctrl_ptr->title_rect.left,menu_ctrl_ptr->title_rect.bottom,
				menu_ctrl_ptr->title_rect.right,menu_ctrl_ptr->title_rect.top);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;

			user_data_ptr = menu_ctrl_ptr->title_wstr;
			user_data_len = menu_ctrl_ptr->title_len;
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;
			data_len = sprintf((char *)data_ptr, "</title>");
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
		}
*/


		//图片
		data_len = sprintf((char *)data_ptr, "<image id='%d'/>", item_info.icon.data.icon_id);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
		

		//文本
		
		data_len = sprintf((char *)data_ptr, "<text>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;

		if (CTRL_TEXT_ID == item_info.text.type )
            {
			MMITHEME_GetResText(item_info.text.data.text_id, mainmenu->win_handle, &text_ptr);
            }
            else
            {
                text_ptr.wstr_ptr = item_info.text.data.str_info.wstr_ptr;
                text_ptr.wstr_len = item_info.text.data.str_info.wstr_len;
            }
		user_data_ptr = text_ptr.wstr_ptr;
		user_data_len = text_ptr.wstr_len;
		if (user_data_len != 0)
		{
			SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
		}
		user_item_ptr[user_data_len] = L'\0';
		Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
		*data_size_ptr += user_data_len * 4;	
		data_len = sprintf((char *)data_ptr, "</text>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;

						
		data_len = sprintf((char *)data_ptr, "</item>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;	
	}
}
#endif
#ifdef QBTHEME_SUPPORT
/*****************************************************************************/
//  Description: 获取QbMainMenu控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_SECOND\GUIMENU_STYLE_THIRD\GUIMENU_STYLE_POPUP  
// 	      GUIMENU_STYLE_POPUP_AUTO\GUIMENU_STYLE_POPUP_RECT
//		  GUIMENU_STYLE_POPUP_RADIO\GUIMENU_STYLE_POPUP_CHECK
/*****************************************************************************/
LOCAL void Atest_GetQbMainMenuControlProperty( 
										 CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,//MENU指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr)			//传输的数据text
{
	uint16 data_len = 0;
	uint16 item_index = 0;
	uint16 user_data_len = 0;
	uint16 item_total_num = 0;
	MMI_STRING_T text_ptr = { 0 };
	//MMI_IMAGE_ID_T  icon_id_ptr = { 0 };
	BOOLEAN  is_grayed_ptr = FALSE;
	BOOLEAN  is_focus_icon = FALSE;
	wchar *user_data_ptr = NULL;
	//MMIMAINMENU_ITEM_INFO_T *item_ptr = {0};
	CTRLMAINMENU_ITEM_T item_info = {0};
	MMIMAINMENU_QBTHEME_DATA_T *mainmenu = NULL;
	GUIMENU_ITEM_POSITION_E position = GUIMENU_ITEM_IN_PAGE;
	 MMIMAINEMENU_ITEM_LIST_T  *page_item_info_ptr = PNULL;
	mainmenu =  (MMIMAINMENU_QBTHEME_DATA_T*)menu_ctrl_ptr->pm_data_ptr;


    if ( mainmenu->is_bar_item  )
    {
        return ;
    }

       page_item_info_ptr = MMIMENU_GetItemList(&mainmenu->menu_page_info, mainmenu->cur_page_index);


	item_total_num = Atest_GetSlideMenuPageItemNum((MMIMAINMENU_SLIDEPAGE_DATA_T *)mainmenu);

	data_len = sprintf((char *)data_ptr,
		"<%s id='%d' style='%d' totalnum='%d' rect='%d %d %d %d'>",
		ctrl_name_ptr,ctrl_id,menu_ctrl_ptr->type,/*mainmenu->is_static,menu_ctrl_ptr->is_transparent,*/page_item_info_ptr->item_count,
		menu_ctrl_ptr->base_ctrl.rect.left,menu_ctrl_ptr->base_ctrl.rect.top,
		menu_ctrl_ptr->base_ctrl.rect.right,menu_ctrl_ptr->base_ctrl.rect.bottom);
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	*data_size_ptr += data_len;
	
	for (item_index = 0; item_index < page_item_info_ptr->item_count; item_index++)
	{		
		if ( mainmenu->is_bar_item )
		{
			position = GUIMENU_ITEM_IN_BAR;
		}
		else
		{
			position = GUIMENU_ITEM_IN_PAGE;
		}
		Atest_QbThemeMenuGetItemInfo(mainmenu, position, mainmenu->cur_page_index, item_index, &item_info);

		if(item_index == mainmenu->cur_item_index)
		{
			is_focus_icon = 1;
		}
		else
		{
			is_focus_icon = 0;
		}
		
		data_len = sprintf((char *)data_ptr,
			"<item focus='%d' grayed='%d'>",
			is_focus_icon,is_grayed_ptr);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;	
  
		//title
	/*
		if(menu_ctrl_ptr->title_len != 0)
		{
			data_len = sprintf((char *)data_ptr, 
				"<title rect='%d %d %d %d'>",
				menu_ctrl_ptr->title_rect.left,menu_ctrl_ptr->title_rect.bottom,
				menu_ctrl_ptr->title_rect.right,menu_ctrl_ptr->title_rect.top);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;

			user_data_ptr = menu_ctrl_ptr->title_wstr;
			user_data_len = menu_ctrl_ptr->title_len;
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;
			data_len = sprintf((char *)data_ptr, "</title>");
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
		}
*/


		//图片
		data_len = sprintf((char *)data_ptr, "<image id='%d'/>", item_info.icon.data.icon_id);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
		

		//文本
		
		data_len = sprintf((char *)data_ptr, "<text>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
		
		if (CTRL_TEXT_ID == item_info.text.type )
            {
		  MMITHEME_GetResText(item_info.text.data.text_id, mainmenu->win_handle, &text_ptr);
            }
            else
            {
                text_ptr.wstr_ptr = item_info.text.data.str_info.wstr_ptr;
                text_ptr.wstr_len = item_info.text.data.str_info.wstr_len;
            }
		user_data_ptr = text_ptr.wstr_ptr;
		user_data_len = text_ptr.wstr_len;
		
		if (user_data_len != 0)
		{
			SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
		}
		user_item_ptr[user_data_len] = L'\0';
		Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
		*data_size_ptr += user_data_len * 4;	
		data_len = sprintf((char *)data_ptr, "</text>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;

						
		data_len = sprintf((char *)data_ptr, "</item>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;	
	}
}
#endif

#ifdef MMI_ISTYLE_SUPPORT
/*****************************************************************************/
//  Description: 获取IStyleMainMenu控件描述
//  Global resource dependence :none
//  Author: 
/*****************************************************************************/
LOCAL void Atest_GetIStyleMainMenuControlProperty( 
										 CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,//MENU指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr)			//传输的数据text
{
	uint16 data_len = 0;
	uint16 item_index = 0;
	uint16 user_data_len = 0;
	MMI_STRING_T text_ptr = { 0 };
    	//MMI_IMAGE_ID_T  icon_id_ptr = { 0 };
    	BOOLEAN  is_grayed_ptr = FALSE;
	BOOLEAN  is_focus_icon = FALSE;
	wchar *user_data_ptr = NULL;
	MMIMAINMENU_ITEM_INFO_T *item_ptr = {0};
    	CTRLMAINMENU_ITEM_T item_info = {0};
	MMIMAINMENU_ISTYLE_DATA_T *mainmenu = NULL;
	mainmenu =  (MMIMAINMENU_ISTYLE_DATA_T*)menu_ctrl_ptr->pm_data_ptr;

	
	data_len = sprintf((char *)data_ptr,
		"<%s id='%d' style='%d' totalnum='%d' rect='%d %d %d %d'>",
		ctrl_name_ptr,ctrl_id,menu_ctrl_ptr->type, mainmenu->page_info.page[mainmenu->cur_page_index].cnt,
		menu_ctrl_ptr->base_ctrl.rect.left,menu_ctrl_ptr->base_ctrl.rect.top,
		menu_ctrl_ptr->base_ctrl.rect.right,menu_ctrl_ptr->base_ctrl.rect.bottom);
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	*data_size_ptr += data_len;

	for (item_index = 0; item_index < mainmenu->page_info.page[mainmenu->cur_page_index].cnt; item_index++)
	{
		item_ptr = mainmenu->page_info.page[mainmenu->cur_page_index].item + item_index;
		if(!IStyleGetItemData(mainmenu, item_ptr->menu_id, item_ptr->group_id, &item_info))
		{
			break;
		}

		if(item_index == mainmenu->cur_item_index)
		{
			is_focus_icon = 1;
		}
		else
		{
			is_focus_icon = 0;
		}
		
		data_len = sprintf((char *)data_ptr,
			"<item focus='%d' grayed='%d'>",
			is_focus_icon,is_grayed_ptr);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;	
  
		//title
	/*
		if(menu_ctrl_ptr->title_len != 0)
		{
			data_len = sprintf((char *)data_ptr, 
				"<title rect='%d %d %d %d'>",
				menu_ctrl_ptr->title_rect.left,menu_ctrl_ptr->title_rect.bottom,
				menu_ctrl_ptr->title_rect.right,menu_ctrl_ptr->title_rect.top);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;

			user_data_ptr = menu_ctrl_ptr->title_wstr;
			user_data_len = menu_ctrl_ptr->title_len;
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;
			data_len = sprintf((char *)data_ptr, "</title>");
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
		}
*/


		//图片
		data_len = sprintf((char *)data_ptr, "<image id='%d'/>", item_info.icon.data.icon_id);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
		

		//文本

		data_len = sprintf((char *)data_ptr, "<text>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;

		if (CTRL_TEXT_ID == item_info.text.type )
            {
			MMITHEME_GetResText(item_info.text.data.text_id, mainmenu->win_handle, &text_ptr);
            }
            else
            {
                text_ptr.wstr_ptr = item_info.text.data.str_info.wstr_ptr;
                text_ptr.wstr_len = item_info.text.data.str_info.wstr_len;
            }
		user_data_ptr = text_ptr.wstr_ptr;
		user_data_len = text_ptr.wstr_len;
		if (user_data_len != 0)
		{
			SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
		}
		user_item_ptr[user_data_len] = L'\0';
		Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
		*data_size_ptr += user_data_len * 4;	
		data_len = sprintf((char *)data_ptr, "</text>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;

						
		data_len = sprintf((char *)data_ptr, "</item>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;	
	}
}
#endif

 #ifdef MATRIX_MAIN_MENU_SUPPORT
/*****************************************************************************/
//  Description: 获取MaxtricMainMenu控件描述
//  Global resource dependence :none
//  Author:
/*****************************************************************************/
LOCAL void Atest_GetMatrixMainMenuControlProperty( 
										 CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,//MENU指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr)			//传输的数据text
{
	uint16 data_len = 0;
	uint16 item_index = 0;
	uint16 user_data_len = 0;
	MMI_STRING_T text_ptr = { 0 };
    	//MMI_IMAGE_ID_T  icon_id_ptr = { 0 };
    	BOOLEAN  is_grayed_ptr = FALSE;
	BOOLEAN  is_focus_icon = FALSE;
	wchar *user_data_ptr = NULL;
	MMIMAINMENU_ITEM_INFO_T item_ptr = {0};
    	CTRLMAINMENU_ITEM_T item_info = {0};

	MMIMAINMENU_MATRIX_DATA_T *mainmenu = NULL;
	mainmenu = (MMIMAINMENU_MATRIX_DATA_T *)menu_ctrl_ptr->pm_data_ptr;

	data_len = sprintf((char *)data_ptr,
		"<%s id='%d' style='%d' static='%d' totalnum='%d' rect='%d %d %d %d'>",
		ctrl_name_ptr,ctrl_id,menu_ctrl_ptr->type,mainmenu->is_static,/*menu_ctrl_ptr->is_transparent,*/mainmenu->item_total_num,
		menu_ctrl_ptr->base_ctrl.rect.left,menu_ctrl_ptr->base_ctrl.rect.top,
		menu_ctrl_ptr->base_ctrl.rect.right,menu_ctrl_ptr->base_ctrl.rect.bottom);
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	*data_size_ptr += data_len;

	for (item_index = 0; item_index < mainmenu->item_total_num; item_index++)
	{
		MMIMAINMENU_GetItem(&mainmenu->menu_list_info, item_index, &item_ptr);
		MMIMAINMENU_GetItemData(item_ptr.menu_id, item_ptr.group_id, &item_info);

		if(item_index == mainmenu->cur_item_index)
		{
			is_focus_icon = 1;
		}
		else
		{
			is_focus_icon = 0;
		}
		
		data_len = sprintf((char *)data_ptr,
			"<item focus='%d' grayed='%d'>",
			is_focus_icon,is_grayed_ptr);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;	
  
		//title
	/*
		if(menu_ctrl_ptr->title_len != 0)
		{
			data_len = sprintf((char *)data_ptr, 
				"<title rect='%d %d %d %d'>",
				menu_ctrl_ptr->title_rect.left,menu_ctrl_ptr->title_rect.bottom,
				menu_ctrl_ptr->title_rect.right,menu_ctrl_ptr->title_rect.top);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;

			user_data_ptr = menu_ctrl_ptr->title_wstr;
			user_data_len = menu_ctrl_ptr->title_len;
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;
			data_len = sprintf((char *)data_ptr, "</title>");
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
		}
*/


		//图片
		data_len = sprintf((char *)data_ptr, "<image id='%d'/>", item_info.icon.data.icon_id);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
		

		//文本
		
		data_len = sprintf((char *)data_ptr, "<text>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
		
		if (CTRL_TEXT_ID == item_info.text.type )
            {
			MMITHEME_GetResText(item_info.text.data.text_id, mainmenu->win_handle, &text_ptr);
            }
            else
            {
                text_ptr.wstr_ptr = item_info.text.data.str_info.wstr_ptr;
                text_ptr.wstr_len = item_info.text.data.str_info.wstr_len;
            }
		user_data_ptr = text_ptr.wstr_ptr;
		user_data_len = text_ptr.wstr_len;
		if (user_data_len != 0)
		{
			SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
		}
		user_item_ptr[user_data_len] = L'\0';
		Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
		*data_size_ptr += user_data_len * 4;	
		data_len = sprintf((char *)data_ptr, "</text>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;

						
		data_len = sprintf((char *)data_ptr, "</item>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;	
	}
}
#endif

/*****************************************************************************/
//  Description: 获取Menu控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetMenuControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	CTRLMENU_OBJ_T  *menu_ctrl_ptr = PNULL;
	uint16 data_len=0;
	
	menu_ctrl_ptr = (CTRLMENU_OBJ_T *)ctrl_ptr;
	if (PNULL == menu_ctrl_ptr)
	{
		return;
	}

	switch (menu_ctrl_ptr->cur_style)
	{
	    case GUIMENU_STYLE_SECOND :      /* 1 !< 二级菜单风格，显示为列表形式，多用于由主菜单进入的二级菜单 */
	    //case GUIMENU_STYLE_THIRD: 		 /* 2 !< 已去掉此风格，其显示同GUIMENU_STYLE_SECOND */
		case GUIMENU_STYLE_POPUP :       /* 6 !< 弹出式菜单，由系统统一计算它的位置和宽度，用户不能设置 */
	    case GUIMENU_STYLE_POPUP_AUTO :  /* 11 !< 弹出式菜单，其坐标可由用户设置，且会根据文本自适应宽度 */
	    case GUIMENU_STYLE_POPUP_RECT :  /* 12 !< 弹出式菜单，其坐标和宽度可由用户设置，系统不会做自适应 */
		case GUIMENU_STYLE_POPUP_RADIO : /* 7 !< 弹出式菜单，菜单项带有单选的radio风格 */
	    case GUIMENU_STYLE_POPUP_CHECK : /* 8 !< 弹出式菜单，菜单项带有多选的check风格 */
			{
				Atest_GetPopMenuControlProperty( menu_ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
			}
			break;

		case GUIMENU_STYLE_OPTIONS  :    /* 15 !< OptionsMenu */
			{
				Atest_GetOptionMenuControlProperty( menu_ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
			}
			break;

		default:
			data_len = sprintf((char *)data_ptr,"<%s style='%d'>",ctrl_name_ptr,menu_ctrl_ptr->cur_style);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
			break;
	}
}

/*****************************************************************************/
//  Description: 获取PopMenu控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_SECOND\GUIMENU_STYLE_THIRD\GUIMENU_STYLE_POPUP  
// 	      GUIMENU_STYLE_POPUP_AUTO\GUIMENU_STYLE_POPUP_RECT
//		  GUIMENU_STYLE_POPUP_RADIO\GUIMENU_STYLE_POPUP_CHECK
/*****************************************************************************/
LOCAL void Atest_GetPopMenuControlProperty( 
										 CTRLMENU_OBJ_T  *menu_ctrl_ptr,//MENU指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr)			//传输的数据text
{
	uint16 data_len = 0;
	uint16 item_index = 0;
	uint16 user_data_len = 0;
	MMI_STRING_T text_ptr = { 0 };
    MMI_IMAGE_ID_T  icon_id_ptr = { 0 };
    BOOLEAN  is_grayed_ptr = FALSE;
	BOOLEAN  is_focus_icon = FALSE;
	wchar *user_data_ptr = NULL;

	data_len = sprintf((char *)data_ptr,
		"<%s id='%d' style='%d' static='%d' transparent='%d' totalnum='%d' rect='%d %d %d %d'>",
		ctrl_name_ptr,ctrl_id,menu_ctrl_ptr->cur_style,menu_ctrl_ptr->is_static,menu_ctrl_ptr->is_transparent,menu_ctrl_ptr->item_total_num,
		menu_ctrl_ptr->base_ctrl.rect.left,menu_ctrl_ptr->base_ctrl.rect.top,
		menu_ctrl_ptr->base_ctrl.rect.right,menu_ctrl_ptr->base_ctrl.rect.bottom);
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	*data_size_ptr += data_len;

	for (item_index = 0; item_index < menu_ctrl_ptr->item_total_num; item_index++)
	{
		if(!CTRLMENU_GetItem(menu_ctrl_ptr,item_index,&text_ptr,&icon_id_ptr,&is_grayed_ptr))
		{
			break;
		}

		if(item_index == menu_ctrl_ptr->cur_item_index)
		{
			is_focus_icon = 1;
		}
		else
		{
			is_focus_icon = 0;
		}
		
		data_len = sprintf((char *)data_ptr,
			"<item focus='%d' grayed='%d'>",
			is_focus_icon,is_grayed_ptr);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;	

		//title
		if(menu_ctrl_ptr->title_len != 0)
		{
			data_len = sprintf((char *)data_ptr, 
				"<title rect='%d %d %d %d'>",
				menu_ctrl_ptr->title_rect.left,menu_ctrl_ptr->title_rect.bottom,
				menu_ctrl_ptr->title_rect.right,menu_ctrl_ptr->title_rect.top);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;

			user_data_ptr = menu_ctrl_ptr->title_wstr;
			user_data_len = menu_ctrl_ptr->title_len;
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;
			data_len = sprintf((char *)data_ptr, "</title>");
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
		}


		if(icon_id_ptr)
		{
			//图片
			data_len = sprintf((char *)data_ptr, "<image id='%d'/>",icon_id_ptr);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
		}

		if(PNULL != text_ptr.wstr_ptr)
		{
			//文本
			data_len = sprintf((char *)data_ptr, "<text fontcolor='%d'>",menu_ctrl_ptr->font_color);
				Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
				*data_size_ptr += data_len;
				
			user_data_ptr = text_ptr.wstr_ptr;
			user_data_len = text_ptr.wstr_len;
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;	
			data_len = sprintf((char *)data_ptr, "</text>");
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
		}
						
		data_len = sprintf((char *)data_ptr, "</item>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;	
	}
}

/*****************************************************************************/
//  Description: 获取SlideMenu控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_SLIDE_PAGE\GUIMENU_STYLE_TRAPEZOID
//		 GUIMENU_STYLE_SPHERE\GUIMENU_STYLE_CYLINDER
//		 GUIMENU_STYLE_BINARY_STAR\GUIMENU_STYLE_SHUTTER
//	     GUIMENU_STYLE_CHARIOT\GUIMENU_STYLE_CUBE
//		 GUIMENU_ISTYLEGUIMENU_STYLE_QBTHEME
/*****************************************************************************/
LOCAL void Atest_GetSlideMenuControlProperty(
										 CTRLMENU_OBJ_T  *menu_ctrl_ptr,//MENU指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr)			//传输的数据text
{
#if 0 
	uint16 data_len = 0;
	uint16 item_index = 0;
	uint16 user_data_len = 0;
	uint16 page_item_num = 0;
	MMI_STRING_T text_ptr = { 0 };
       MMI_IMAGE_ID_T  icon_id_ptr = { 0 };
       BOOLEAN  is_grayed_ptr  = FALSE;
	BOOLEAN is_focus_icon = FALSE;
	wchar *user_data_ptr = NULL;	
	uint32 text_id = 0;

	CTRLMAINMENU_ITEM_T cur_item_info = {0};

	page_item_num = Atest_GetSlideMenuPageItemNum(menu_ctrl_ptr);//获得该page的所显示的item的个数:page_item_num

	data_len = sprintf((char *)data_ptr,
		"<%s id='%d' style='%d' static='%d' itemnum='%d' curpage ='%d' totalpage='%d' rect='%d %d %d %d'>",
		ctrl_name_ptr,ctrl_id,menu_ctrl_ptr->cur_style,menu_ctrl_ptr->is_static,
		page_item_num,menu_ctrl_ptr->cur_page_index,menu_ctrl_ptr->item_total_num,
		menu_ctrl_ptr->base_ctrl.rect.left,menu_ctrl_ptr->base_ctrl.rect.top,
		menu_ctrl_ptr->base_ctrl.rect.right,menu_ctrl_ptr->base_ctrl.rect.bottom);
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	*data_size_ptr += data_len;

	item_index = menu_ctrl_ptr->cur_item_index;//焦点所在的item
	for (menu_ctrl_ptr->cur_item_index = 0; menu_ctrl_ptr->cur_item_index < page_item_num; menu_ctrl_ptr->cur_item_index++)
	{
		if(item_index == menu_ctrl_ptr->cur_item_index)
		{
			is_focus_icon = 1;
		}
		else
		{
			is_focus_icon = 0;
		}

		data_len = sprintf((char *)data_ptr, 
			"<item focus='%d' grayed='%d'>",
			is_focus_icon,is_grayed_ptr);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;

		//title
		if(menu_ctrl_ptr->title_len != 0)
		{
			data_len = sprintf((char *)data_ptr, 
				"<title rect='%d %d %d %d'>",
				menu_ctrl_ptr->title_rect.left,menu_ctrl_ptr->title_rect.bottom,
				menu_ctrl_ptr->title_rect.right,menu_ctrl_ptr->title_rect.top);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;

			user_data_ptr = menu_ctrl_ptr->title_wstr;
			user_data_len = menu_ctrl_ptr->title_len;
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;
			data_len = sprintf((char *)data_ptr, "</title>");
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
		}

		if (PNULL == ((GUIMENU_PROCESS_T*)(menu_ctrl_ptr->process_func[menu_ctrl_ptr->cur_style]))->GetItemPtr)
	 	{
			break;
		}
		else
		{
			((GUIMENU_PROCESS_T*)(menu_ctrl_ptr->process_func[menu_ctrl_ptr->cur_style]))->GetItemPtr(menu_ctrl_ptr, menu_ctrl_ptr->cur_page_index, menu_ctrl_ptr->cur_item_index,&cur_item_info);
		}
		
		switch (cur_item_info.menu_data_type)
		{
			case GUIMENU_MAINMENU_DATA_TYPE_STATIC: //静态菜单信息
				if(cur_item_info.menu_data.static_menu_ptr->unselect_icon_id)
				{
					data_len = sprintf((char *)data_ptr,"<icon id='%d'/>",								
					cur_item_info.menu_data.static_menu_ptr->unselect_icon_id);
					Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
					*data_size_ptr += data_len;
				}

				text_id = cur_item_info.menu_data.static_menu_ptr->text_str_id;
				data_len = sprintf((char *)data_ptr,"<text id='%d'>",text_id);
				Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
				*data_size_ptr += data_len;
				break;
			case GUIMENU_MAINMENU_DATA_TYPE_DYNAMIC:
			    /* ERROR+++++++++++++++++++++++++++++++++++++++++++
				if(cur_item_info.menu_data.dynamic_menu_ptr->ori_data_ptr->dynamic_menu_info.has_icon)
				{
					data_len = sprintf((char *)data_ptr,"<icon id='%d'/>",								
					*(cur_item_info.menu_data.dynamic_menu_ptr->ori_data_ptr->dynamic_menu_info.icon_ptr));
					Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
					*data_size_ptr += data_len;
				}
				data_len = sprintf((char *)data_ptr,"<text>");
				Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
				*data_size_ptr += data_len;*/
				break;
			case GUIMENU_MAINMENU_DATA_TYPE_FILEFOLD:
			    /* ERROR+++++++++++++++++++++++++++++++++++++++++++
				text_id = cur_item_info.menu_data.filefold_menu_ptr->text_str_id;
				data_len = sprintf((char *)data_ptr,"<text id='%d'>",text_id);
				Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
				*data_size_ptr += data_len;*/
				break;
			default:
				break;
		}
		SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
		CTRLMENU_GetItem(menu_ctrl_ptr,item_index,&text_ptr,&icon_id_ptr,&is_grayed_ptr);
		if(!text_ptr.wstr_len)
		{
			MMITHEME_GetResText(text_id, menu_ctrl_ptr->win_handle, &text_ptr);
		}
		
		user_data_ptr = text_ptr.wstr_ptr;
		user_data_len = text_ptr.wstr_len;						
		if (user_data_len != 0)
		{
			SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
		}
		user_item_ptr[user_data_len] = L'\0';
		Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
		*data_size_ptr += user_data_len * 4;
		data_len = sprintf((char *)data_ptr,"</text>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
		
		data_len = sprintf((char *)data_ptr, "</item>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;	
	}
	menu_ctrl_ptr->cur_item_index = item_index;	
#endif
}

/*****************************************************************************/
//  Description: 获取IconMenu控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_ICON \GUIMENU_STYLE_CYCLONE
/*****************************************************************************/
LOCAL void Atest_GetIconMenuControlProperty( 
										 CTRLMENU_OBJ_T  *menu_ctrl_ptr,//MENU指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr)			//传输的数据text
{
	uint16 data_len = 0;
	uint16 item_index = 0;
	uint16 user_data_len = 0;
	MMI_STRING_T text_ptr = { 0 };
    MMI_IMAGE_ID_T  icon_id_ptr = { 0 };
    BOOLEAN  is_grayed_ptr = FALSE;
	BOOLEAN  is_focus_icon = FALSE;
	wchar *user_data_ptr = NULL;
	//CTRLMAINMENU_ITEM_T cur_item_info = {0};

	data_len = sprintf((char *)data_ptr,
		"<%s id='%d' style='%d' static='%d' transparent='%d' totalnum='%d' rect='%d %d %d %d'>",
		ctrl_name_ptr,ctrl_id,menu_ctrl_ptr->cur_style,menu_ctrl_ptr->is_static,menu_ctrl_ptr->is_transparent,menu_ctrl_ptr->item_total_num,
		menu_ctrl_ptr->base_ctrl.rect.left,menu_ctrl_ptr->base_ctrl.rect.top,
		menu_ctrl_ptr->base_ctrl.rect.right,menu_ctrl_ptr->base_ctrl.rect.bottom);
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	*data_size_ptr += data_len;

	item_index = menu_ctrl_ptr->cur_item_index;

	for (menu_ctrl_ptr->cur_item_index = 0; menu_ctrl_ptr->cur_item_index < menu_ctrl_ptr->item_total_num; menu_ctrl_ptr->cur_item_index++)
	{
		if(!CTRLMENU_GetItem(menu_ctrl_ptr,menu_ctrl_ptr->cur_item_index,&text_ptr,&icon_id_ptr,&is_grayed_ptr))
		{
			break;
		}
		if(item_index == menu_ctrl_ptr->cur_item_index)
		{
			is_focus_icon = 1;
		}
		else
		{
			is_focus_icon = 0;
		}

		data_len = sprintf((char *)data_ptr, 
			"<item focus='%d' grayed='%d'>",
			is_focus_icon,is_grayed_ptr);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;

		//title
		if(menu_ctrl_ptr->title_len != 0)
		{
			data_len = sprintf((char *)data_ptr, 
				"<title rect='%d %d %d %d'>",
				menu_ctrl_ptr->title_rect.left,menu_ctrl_ptr->title_rect.bottom,
				menu_ctrl_ptr->title_rect.right,menu_ctrl_ptr->title_rect.top);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;

			user_data_ptr = menu_ctrl_ptr->title_wstr;
			user_data_len = menu_ctrl_ptr->title_len;
			 
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;
			data_len = sprintf((char *)data_ptr, "</title>");
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
		}

		/*
		if (PNULL == ((GUIMENU_PROCESS_T*)(menu_ctrl_ptr->process_func[menu_ctrl_ptr->cur_style]))->GetItemPtr)
	 	{
			break;
		}
		else
		{
			((GUIMENU_PROCESS_T*)(menu_ctrl_ptr->process_func[menu_ctrl_ptr->cur_style]))->GetItemPtr(menu_ctrl_ptr, menu_ctrl_ptr->cur_page_index, menu_ctrl_ptr->cur_item_index,&cur_item_info);
		}*/
		
		if(is_focus_icon)
		{
			/*
			data_len = sprintf((char *)data_ptr, 
				"<icon id='%d' selectid='%d'/>",
			cur_item_info.menu_data.static_menu_ptr->unselect_icon_id,
			cur_item_info.menu_data.static_menu_ptr->select_icon_id);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
			*/
		}
		else
		{
			/*
			data_len = sprintf((char *)data_ptr, 
				"<icon id='%d'/>",								
			cur_item_info.menu_data.static_menu_ptr->unselect_icon_id);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
			*/
		}

		data_len = sprintf((char *)data_ptr,"<text>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;

		user_data_ptr = text_ptr.wstr_ptr;
		user_data_len = text_ptr.wstr_len;						
		if (user_data_len != 0)
		{
			SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
		}
		user_item_ptr[user_data_len] = L'\0';
		Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
		*data_size_ptr += user_data_len * 4;
		data_len = sprintf((char *)data_ptr,"</text>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
		
		data_len = sprintf((char *)data_ptr, "</item>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;	
	}
	menu_ctrl_ptr->cur_item_index = item_index;
}

/*****************************************************************************/
//  Description: 获取OptionMenu控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_OPTIONS  :    /* 15 !< OptionsMenu */
/*****************************************************************************/
LOCAL void Atest_GetOptionMenuControlProperty( 
										 CTRLMENU_OBJ_T  *menu_ctrl_ptr,//MENU指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr)			//传输的数据text
{
	uint16 data_len = 0;
	uint16 item_index = 0;
	uint16 user_data_len = 0;
	MMI_STRING_T text_ptr = { 0 };
    MMI_IMAGE_ID_T  icon_id_ptr = { 0 };
    BOOLEAN  is_grayed_ptr = FALSE;
	wchar *user_data_ptr = NULL;

	data_len = sprintf((char *)data_ptr,
		"<%s id='%d' style='%d' static='%d' transparent='%d' totalnum='%d' linecnt='%d' numinline='%d' rect='%d %d %d %d'>",
		ctrl_name_ptr,ctrl_id,menu_ctrl_ptr->cur_style,menu_ctrl_ptr->is_static,
		menu_ctrl_ptr->is_transparent,menu_ctrl_ptr->item_total_num,
		menu_ctrl_ptr->line_count,*(menu_ctrl_ptr->num_in_line_ptr),
		menu_ctrl_ptr->base_ctrl.rect.left,menu_ctrl_ptr->base_ctrl.rect.top,
		menu_ctrl_ptr->base_ctrl.rect.right,menu_ctrl_ptr->base_ctrl.rect.bottom);
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	*data_size_ptr += data_len;

	for (item_index = 0; item_index < menu_ctrl_ptr->item_total_num; item_index++)
	{
		SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
		if(!CTRLMENU_GetItem(menu_ctrl_ptr,item_index,&text_ptr,&icon_id_ptr,&is_grayed_ptr))
		{
			break;
		}

		if(!menu_ctrl_ptr->options_item_info_ptr[item_index].is_more_item)
		{
			data_len = sprintf((char *)data_ptr, 
				"<item imgid='%d' rect='%d %d %d %d'>",
				icon_id_ptr,
				menu_ctrl_ptr->options_item_info_ptr[item_index].rect.left,
				menu_ctrl_ptr->options_item_info_ptr[item_index].rect.top,
				menu_ctrl_ptr->options_item_info_ptr[item_index].rect.right,
				menu_ctrl_ptr->options_item_info_ptr[item_index].rect.bottom);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;	

			user_data_ptr = text_ptr.wstr_ptr;
			user_data_len = text_ptr.wstr_len;						
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;
			
			data_len = sprintf((char *)data_ptr, "</item>");
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
		}
		else
		{	
			data_len = sprintf((char *)data_ptr, 
				"<item imgid='%d' textid='%d' rect='%d %d %d %d'>",
				menu_ctrl_ptr->options_theme.more_item_image_id,
				menu_ctrl_ptr->options_theme.more_item_text_id,
				menu_ctrl_ptr->options_item_info_ptr[item_index].rect.left,
				menu_ctrl_ptr->options_item_info_ptr[item_index].rect.top,
				menu_ctrl_ptr->options_item_info_ptr[item_index].rect.right,
				menu_ctrl_ptr->options_item_info_ptr[item_index].rect.bottom);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;	

			MMITHEME_GetResText(menu_ctrl_ptr->options_theme.more_item_text_id, menu_ctrl_ptr->win_handle, &text_ptr);

			user_data_ptr = text_ptr.wstr_ptr;
			user_data_len = text_ptr.wstr_len;						
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;
			
			data_len = sprintf((char *)data_ptr, "</item>");
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
			
			break;
		}
	}
}

/*****************************************************************************/
//  Description: 获取CrystalMenu控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_CRYSTAL_CUBE:/*! 17 < 水晶立方体风格 */
/*****************************************************************************/
LOCAL void Atest_GetCrystalMenuControlProperty(
										 CTRLMENU_OBJ_T  *menu_ctrl_ptr,//MENU指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr)			//传输的数据text
{
#ifdef MENU_CRYSTALCUBE_SUPPORT
	uint16 data_len = 0;
	uint16 item_index = 0;
	uint16 user_data_len = 0;
	MMI_STRING_T text_ptr = { 0 };
    MMI_IMAGE_ID_T icon_id_ptr = { 0 };
    BOOLEAN  is_grayed_ptr = FALSE;
	BOOLEAN  is_focus = FALSE;
	wchar *user_data_ptr = NULL;
	GUIMENU_CRYSTALCUBEMENU_DATA_T menu_data = { 0 };
	CTRLMAINMENU_ITEM_T cur_item_info = { 0 };
	
	menu_data = menu_ctrl_ptr->main_menu_data.crystalcube_menu_data; //crystal nemu data

	data_len = sprintf((char *)data_ptr,
		"<%s id='%d' style='%d' cubemode='%d' static='%d' transparent='%d' pagenum='%d' rownum='%d' colnum='%d' rect='%d %d %d %d'>",
		ctrl_name_ptr,ctrl_id,menu_ctrl_ptr->cur_style,
		menu_ctrl_ptr->cube_mode,menu_ctrl_ptr->is_static,
		menu_ctrl_ptr->is_transparent,menu_data.page_num,
		menu_data.page_row_num,menu_data.page_col_num,
		menu_data.page_rect.left,menu_data.page_rect.top,
		menu_data.page_rect.right,menu_data.page_rect.bottom);
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	*data_size_ptr += data_len;

	item_index = menu_ctrl_ptr->cur_item_index;

	for (menu_ctrl_ptr->cur_item_index = 0;menu_ctrl_ptr->cur_item_index < CRYSTALCUBE_MENUMAIN_ICON_ITEM_MAX_NUM ; menu_ctrl_ptr->cur_item_index++)
	{
		if(!CTRLMENU_GetItem(menu_ctrl_ptr,menu_ctrl_ptr->cur_item_index,&text_ptr,&icon_id_ptr,&is_grayed_ptr))
		{
			break;
		}

		if(item_index == menu_ctrl_ptr->cur_item_index)
		{
			is_focus= 1;
		}
		else
		{
			is_focus = 0;
		}

		if(!icon_id_ptr)
		{
		/*
			if (PNULL == ((GUIMENU_PROCESS_T*)(menu_ctrl_ptr->process_func[menu_ctrl_ptr->cur_style]))->GetItemPtr)
		 	{
				break;
			}
			else
			{
				((GUIMENU_PROCESS_T*)(menu_ctrl_ptr->process_func[menu_ctrl_ptr->cur_style]))->GetItemPtr(menu_ctrl_ptr, menu_ctrl_ptr->cur_page_index, menu_ctrl_ptr->cur_item_index,&cur_item_info);
			}*/

			if(PNULL != cur_item_info.menu_data.static_menu_ptr)
			{
				icon_id_ptr = cur_item_info.menu_data.static_menu_ptr->unselect_icon_id;
			}
		}

		data_len = sprintf((char *)data_ptr, 
			"<item iconid='%d' focus='%d' rect='%d %d %d %d'>",
			icon_id_ptr,is_focus,
			menu_data.item_image_display_rect[menu_ctrl_ptr->cur_item_index].left,
			menu_data.item_image_display_rect[menu_ctrl_ptr->cur_item_index].top,
			menu_data.item_image_display_rect[menu_ctrl_ptr->cur_item_index].right,
			menu_data.item_image_display_rect[menu_ctrl_ptr->cur_item_index].bottom);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;	

		user_data_ptr = text_ptr.wstr_ptr;
		user_data_len = text_ptr.wstr_len;						
		if (user_data_len != 0)
		{
			SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
		}
		user_item_ptr[user_data_len] = L'\0';
		Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
		*data_size_ptr += user_data_len * 4;
		
		data_len = sprintf((char *)data_ptr, "</item>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;		
	}
	menu_ctrl_ptr->cur_item_index = item_index;
#endif
}

/*****************************************************************************/
//  Description: 获取Scrollkey控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetScrollkeyControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
#ifdef GUIF_SCROLLKEY
	uint16 data_len = 0; 
	CTRLSCROLLKEY_OBJ_T* scrollkey_ptr = PNULL;

	scrollkey_ptr = (CTRLSCROLLKEY_OBJ_T *)ctrl_ptr;
	if (PNULL == scrollkey_ptr)
	{
		 return;
	}

	data_len = sprintf((char *)data_ptr, 
		"<%s id='%d' visible='%d' tpdisable='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr,ctrl_id,scrollkey_ptr->is_visible,scrollkey_ptr->tp_disable,
		scrollkey_ptr->base_ctrl.rect.left,scrollkey_ptr->base_ctrl.rect.top,
		scrollkey_ptr->base_ctrl.rect.right,scrollkey_ptr->base_ctrl.rect.bottom);
	 Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	 *data_size_ptr += data_len;
#endif
}

/*****************************************************************************/
//  Description: 获取Iconfolder控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetIconfolderControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	uint16 data_len = 0; 
	
	CTRLICONLIST_OBJ_T    *iconfolder_ctrl_ptr = PNULL;
	//GUI_RECT_T rect = {0};

	iconfolder_ctrl_ptr = (CTRLICONLIST_OBJ_T *)ctrl_ptr;
	if (PNULL == iconfolder_ctrl_ptr)
	{
		 return;
	}

	data_len = sprintf((char *)data_ptr, 
		"<%s id='%d' totalnum='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr,ctrl_id,iconfolder_ctrl_ptr->total_num,
		iconfolder_ctrl_ptr->base_ctrl.rect.left,iconfolder_ctrl_ptr->base_ctrl.rect.top,
		iconfolder_ctrl_ptr->base_ctrl.rect.right,iconfolder_ctrl_ptr->base_ctrl.rect.bottom);
	 Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	 *data_size_ptr += data_len;
}

/*****************************************************************************/
//  Description:触摸对应的控件
//				AT+SFTIN="ISCP,text,0,1,0061"			//字符串
//				AT+SFTIN="ISCP,control,0,1,4556622"		//控件id
//				AT+SFTIN="ISCP,image,0,1,1023645"		//图片id 
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_ClickControl( // 取到控件内容，返回TRUE
    uint8 *user_data_ptr)
{
	uint8 *start_ptr = user_data_ptr;
	uint8 find_content[ATEST_MAX_STR_LEN] = {0};
	uint16 rect_x,rect_y = 0;
	ATEST_ID_TYPE_E id_type;
	uint32 delay_time = 0;
	uint8 rect_arr[32] ={0};
	BOOLEAN result= FALSE;
	int user_data_len = 0;

	if(PNULL == user_data_ptr)
	{
		return FALSE;
	}
	
	user_data_len = strlen((char *)user_data_ptr);	
	receive_data_arr = (uint8 *)SCI_ALLOC_APP(user_data_len + 1);
	if (PNULL == receive_data_arr)
	{
	    return FALSE;
	}
		
	if(user_data_len)
	{
		SCI_MEMSET(receive_data_arr, 0, user_data_len + 1);
	    SCI_MEMCPY(receive_data_arr, user_data_ptr, user_data_len);
	}

	// 解析两个逗号之间的部分，为要触发的字符串命令
	Atest_GetMessageContent(find_content,',',&start_ptr);	
	if(!stricmp((char*)find_content,"text"))
	{
		id_type = TEXT_TYPE;
	}
	else if(!stricmp((char*)find_content,"textid"))
	{
		id_type = TEXT_ID_TYPE;
	}
	else if(!stricmp((char*)find_content,"control"))
	{
		id_type = CONTROL_ID_TYPE;
	}
	else if(!stricmp((char*)find_content,"image"))
	{
		id_type = IMAGE_ID_TYPE;
	}
	else if(!stricmp((char*)find_content,"index"))
	{
		id_type = INDEX_ID_TYPE;
	}
	else if(!stricmp((char*)find_content,"imgindex"))
	{
		id_type = IMAGE_INDEX_TYPE;
	}
	else if(!stricmp((char*)find_content,"textimg"))
	{
		id_type = TEXT_IMG_TYPE;
	}
	else
	{
		id_type = NONE_ID_TYPE;
		return FALSE;
	}

	//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_ClickControl--%d"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_6912_112_2_18_1_59_39_31,(uint8*)"d",id_type);

	delay_time = Atest_GetTestMessageId(',',&start_ptr); //获得延时时间

	if(Atest_SearchControlPosition(id_type,start_ptr,&rect_x,&rect_y))
	{
		//SCI_TRACE_LOW:"[ATC:][ATEST:]find Control position succeed--%d--%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_6918_112_2_18_1_59_39_32,(uint8*)"dd",rect_x,rect_y);

		if(Atest_ConvertPositionByLcd(&rect_x,&rect_y))
		{
			Atest_SendTouchMessage(MMI_TP_DOWN,rect_x,rect_y);
			if(delay_time>=MMI_TP_LONG_PRESS_VALUE)
			{
				sprintf((char *)rect_arr,",%d,%d,",rect_x,rect_y);			
				Atest_SendSignalToAppTask( rect_arr,strlen((char *)rect_arr),delay_time,ATEST_SIGNAL_TPLONG);			
			}
			
			Atest_SendTouchMessage(MMI_TP_UP,rect_x,rect_y);			
			result= TRUE;
		}
		else
		{
			//SCI_TRACE_LOW:"[ATC:][ATEST:] ConvertPosition failed"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_6934_112_2_18_1_59_39_33,(uint8*)"");
			result= FALSE;
		}
	}
	else
	{
		//SCI_TRACE_LOW:"[ATC:][ATEST:]find Control failed"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_6940_112_2_18_1_59_39_34,(uint8*)"");
		result= FALSE;
	}

	SCI_FREE(receive_data_arr);
	return result;
}

/*****************************************************************************/
//  Description:解析命令,获取内容
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetMessageContent( 
									uint8 *message_content,		// 解析的内容
								    char separator,             // ID分隔符
								    uint8 **message_pptr)      // 返回指向下一个要解析的位置

{
    char mssage_id_arr[MAX_CMD_LEN] = { 0 };
	char *end_ptr = PNULL;
	uint8 i = 0;
	char *start_ptr = (char*)*message_pptr; 

    // 解析两个逗号之间的部分
    while ( ('\0' != *start_ptr) && (*start_ptr != separator) )
    {
        start_ptr++;
    }

    end_ptr = ++start_ptr;
    start_ptr = mssage_id_arr;

    while ( ('\0' != *end_ptr) && (*end_ptr != separator) )
    {
		*(message_content+i)= (uint8)*end_ptr;
		end_ptr++;
		i++;
    }
	*(message_content+i) = '\0';

    // *message_pptr指向下一个待解析的消息
    *message_pptr = (uint8*)end_ptr;	
}

/*****************************************************************************/
//  Description:查找对应的控件，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_SearchControlPosition(
										ATEST_ID_TYPE_E id_type,	//查找类型
										uint8 *find_data_ptr,		//所需查找的数据
										uint16 *rect_x,				//返回的坐标
										uint16 *rect_y)				//返回的坐标
{
	MMI_HANDLE_T win_handle = MMK_GetTopmostWindow();
    MMI_TREE_NODE_T *win_tree_ptr = MMK_GetWinTreeNode(win_handle);
	if (PNULL == win_tree_ptr)
    {
        return FALSE;
    }
	
	if(!Atest_SearchWindowTree(win_tree_ptr,win_tree_ptr->next_ptr,id_type,find_data_ptr,rect_x,rect_y))
	{
		return FALSE;
	}

	return TRUE;
}

/*****************************************************************************/
//  Description: 查找窗体
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_SearchWindowTree(
									MMI_TREE_NODE_T *root_ptr,	//窗体的根节点指针
									MMI_TREE_NODE_T *next_ptr,	//窗体根节点的兄弟指针
									ATEST_ID_TYPE_E id_type,	//查找类型
									uint8 *find_data_ptr,		//所需查找的数据
									uint16 *rect_x,				//返回的坐标
									uint16 *rect_y)				//返回的坐标
{
    MMI_TREE_NODE_T *find_node_ptr = root_ptr;
    MMI_TREE_NODE_T *ctrl_tree_root_ptr = PNULL;
    
    // 从树根开始搜索
    if (PNULL == find_node_ptr)
    {
        return FALSE;
    }

    // 递归遍历窗体
    do {
        ctrl_tree_root_ptr = MMK_GetCtrlTreeRootByWin(find_node_ptr->data);
		//SCI_TRACE_LOW:"[ATC:][ATEST:]Search Window--%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7033_112_2_18_1_59_39_35,(uint8*)"d",find_node_ptr->data);
		
		if (ctrl_tree_root_ptr)
		{
			if(Atest_SearchControlTree(ctrl_tree_root_ptr,id_type,find_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}

        // 先遍历子节点
        if (PNULL != find_node_ptr->child_ptr)
        {
            if(Atest_SearchWindowTree(find_node_ptr->child_ptr,next_ptr,id_type,find_data_ptr,rect_x,rect_y))
            {
				return TRUE;
			}
        }
        // 再遍历兄弟节点
        find_node_ptr = find_node_ptr->next_ptr;
		if (next_ptr == find_node_ptr)
        {
            break;
        }
    } while (find_node_ptr != root_ptr); 

	return FALSE;
}

/*****************************************************************************/
//  Description:遍历该窗口的控件，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/  
LOCAL BOOLEAN Atest_SearchControlTree(
								    MMI_TREE_NODE_T *root_ptr,	// 控件树根节点
								    ATEST_ID_TYPE_E id_type,	//查找类型
								    uint8 *user_data_ptr,		//所需查找的数据
								    uint16 *rect_x,				//返回的坐标
									uint16 *rect_y)				//返回的坐标
{
    IGUICTRL_T *ctrl_ptr = PNULL;
    MMI_TREE_NODE_T *find_node_ptr = root_ptr;

    // 从控件树根开始搜索
    if (PNULL == root_ptr)
    {
        return FALSE;
    }

    // 递归遍历窗体控件
    do {
        // 通过控件节点获取控件指针
        ctrl_ptr = MMK_GetCtrlPtr(find_node_ptr->data);
        // 控件起始属性标记 <EDITBOX>
        if(Atest_SearchControlProperty(ctrl_ptr,id_type,user_data_ptr,rect_x,rect_y))
        {
			return TRUE;
		}
		else
		{
			// 先遍历子节点
			if (PNULL != find_node_ptr->child_ptr)
			{
				if(Atest_SearchControlTree(find_node_ptr->child_ptr,id_type,user_data_ptr,rect_x,rect_y))
				{
					return TRUE;
				}				
			}

			// 再遍历兄弟节点
			find_node_ptr = find_node_ptr->next_ptr;
		}
    } while (find_node_ptr != root_ptr);

	return FALSE;
}

/*****************************************************************************/
//  Description:查找各控件，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchControlProperty(
	IGUICTRL_T *ctrl_ptr,
    ATEST_ID_TYPE_E id_type,
    uint8 *user_data_ptr,
    uint16 *rect_x,
	uint16 *rect_y)
{
	MMI_HANDLE_T ctrl_handle = GUICTRL_GetCtrlHandle(ctrl_ptr);
	MMI_CTRL_ID_T ctrl_id = MMK_GetCtrlId(ctrl_handle);	
	CAF_GUID_T ctrl_guid = GUICTRL_GetCtrlGuid(ctrl_ptr);

	//SCI_TRACE_LOW:"[ATC:][ATEST:]Search Control,ctrl_guid=%d"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7125_112_2_18_1_59_39_36,(uint8*)"d",ctrl_guid);

	if(!ctrl_id)
	{
		return FALSE;
	}

	ctrl_ptr = MMK_GetCtrlPtrByWin(MMK_GetFocusWinHandle(), ctrl_id);
    if (PNULL == ctrl_ptr)
    {
        return FALSE;
    }

	switch (ctrl_guid)		
	{
		case SPRD_GUI_EDITBOX_ID:
		case SPRD_GUI_TEXTEDIT_ID:
        	case SPRD_GUI_PHONENUMEDIT_ID:
        	case SPRD_GUI_DIGITALEDIT_ID:
        	case SPRD_GUI_PSWEDIT_ID:
	       case SPRD_GUI_LISTEDIT_ID:
		{
			if(Atest_SearchEditBoxControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;

		case SPRD_GUI_LIST_ID :
	    {
			if(Atest_SearchListControlItem(ctrl_ptr,ctrl_handle,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
	    }
		break;

        case SPRD_GUI_MAINMENU_ID:
		{
			if(Atest_SearchMainMenuControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
   	    }
		break;
		case SPRD_GUI_MENU_ID :
	    {
			if(Atest_SearchMenuControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
	    }
		break;

		case SPRD_GUI_SOFTKEY_ID:
	    {
			if(Atest_SearchSoftKeyControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
	    }
		break; 

		case SPRD_GUI_LABEL_ID:
	    {
			if(Atest_SearchLableControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
	    }
		break; 
		
		case SPRD_GUI_SETLIST_ID:
		{
			if(Atest_SearchSetlistControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
	    }
		break;

		case SPRD_GUI_BUTTON_ID:
		{
			if(Atest_SearchButtonControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
	    }
		break;

		case SPRD_GUI_RICHTEXT_ID:
		{
			if(Atest_SearchRichTextControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;

		case SPRD_GUI_TAB_ID:
		{
			if(Atest_SearchTabControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;

		case SPRD_GUI_ANIM_ID :
		{
			if(Atest_SearchAnimControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;
		
		case SPRD_GUI_MSGBOX_ID:
		{
			if(Atest_SearchMsgboxControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;        

		case SPRD_GUI_TEXTBOX_ID: 
		{
			if(Atest_SearchTextboxControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;      

		case SPRD_GUI_DROPDOWNLIST_ID:
		{
			if(Atest_SearchDropdownlistControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;  
		
		case SPRD_GUI_ICONLIST_ID: 
		{
			if(Atest_SearchIconlistControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;

		case SPRD_GUI_TITLE_ID: 
		{
			if(Atest_SearchTitleControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;

		case SPRD_GUI_IM_ID :
		{
			if(Atest_SearchIMControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;

		case SPRD_GUI_TOOLBAR_ID : 
		{
			if(Atest_SearchToolBarControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;

		case SPRD_GUI_TIPS_ID:
		{
			if(Atest_SearchTipsControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;
		
		case SPRD_GUI_STATUSBAR_ID: 
		{
			if(Atest_SearchStatusbarControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;

		case SPRD_GUI_OWNDRAW_ID :
		{
			if(Atest_SearchOwndrawControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;
		
		case SPRD_GUI_PRGBOX_ID:
		{
			if(Atest_SearchPrgboxControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;
		
		case SPRD_GUI_FORM_ID:
		{
			if(Atest_SearchFormControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;
		
		case SPRD_GUI_ICONFOLDER_ID: 
		{
			if(Atest_SearchIconfolderControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;
		
		case SPRD_GUI_PUNCTUATION_ID:		
		default:
			break;
	}
	return FALSE;
}

/*****************************************************************************/
//  Description:根据rotate lcd对按键事件进行转换
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL void Atest_KbdConvert(uint32 *signal_keycode)		//按键事件类型
{
    switch (GUILCD_GetRotateAngle((LCD_ID_E)GUI_MAIN_LCD_ID))
    {
	case LCD_ANGLE_90:
		switch (*signal_keycode)
	    {
		case SCI_VK_UP:
			*signal_keycode = SCI_VK_RIGHT;
	        break;
		case SCI_VK_DOWN:
			*signal_keycode = SCI_VK_LEFT;
	        break;
		case SCI_VK_LEFT:	
			*signal_keycode = SCI_VK_DOWN;
	        break;
	    case SCI_VK_RIGHT:
			*signal_keycode = SCI_VK_UP;
	        break;
	    default:
	        break;
	    }
        break;
	case LCD_ANGLE_270:	
		switch (*signal_keycode)
	    {
		case SCI_VK_UP:
			*signal_keycode = SCI_VK_LEFT;
	        break;
		case SCI_VK_DOWN:
			*signal_keycode = SCI_VK_RIGHT;
	        break;
		case SCI_VK_LEFT:	
			*signal_keycode = SCI_VK_UP;
	        break;
	    case SCI_VK_RIGHT:
			*signal_keycode = SCI_VK_DOWN;
	        break;
	    default:
	        break;
	    }
        break;
    case LCD_ANGLE_180:
		switch (*signal_keycode)
	    {
		case SCI_VK_UP:
			*signal_keycode = SCI_VK_DOWN;
	        break;
		case SCI_VK_DOWN:
			*signal_keycode = SCI_VK_UP;
	        break;
		case SCI_VK_LEFT:	
			*signal_keycode = SCI_VK_RIGHT;
	        break;
	    case SCI_VK_RIGHT:
			*signal_keycode = SCI_VK_LEFT;
	        break;
	    default:
	        break;
	    }
        break;
    default:
        break;
    }
	//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_KbdConvert,keycode--%d"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7416_112_2_18_1_59_40_37,(uint8*)"d",*signal_keycode);
}

/*****************************************************************************/
//  Description: 将消息发送到APP task处理
//  Global resource dependence :none
//  Author: linchen
//  Note:缓解P_ATC压力，开一块内存，扔给P_APP处理
/*****************************************************************************/
LOCAL void Atest_SendSignalToAppTask( 
								uint8 *user_data_ptr,	 // 用户发过来的AT命令
								uint32 len,				 // 用户发过来的AT命令的长度
								uint32 reserved_data,	 // 发送时附加的数据
								uint16 signalType)		 // 发送到APP的消息类型
{
    MmiOtherTaskMsgS*signal_ptr = PNULL;
    uint8 *send_data_ptr = PNULL;

    MmiCreateSignal(signalType, sizeof(MmiOtherTaskMsgS), (MmiSignalS**)&signal_ptr);
    signal_ptr->Sender = P_APP;	

    //申请一块内存保存用户数据
    send_data_ptr = (uint8 *)SCI_ALLOC_APP(len + 1);
    if (PNULL == send_data_ptr)
    {
        return;
    }
	if(PNULL != user_data_ptr && 0 != len)
	{
	    SCI_MEMSET(send_data_ptr, 0, len + 1);
	    SCI_MEMCPY(send_data_ptr, user_data_ptr, len);
	    
	    signal_ptr->param_ptr = (void *)send_data_ptr;
	}
	signal_ptr->msg_id = reserved_data;
		
    MmiSendSignal(TASK_FL_ID, (MmiSignalS*)signal_ptr);
}

/*****************************************************************************/
//  Description:处理atc按键消息
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL void Atest_ResolveKbdSignal(
								uint32 signal_keycode,
								uint8 *use_data_ptr,
								uint32 reserved_data)	 
{
//	if(reserved_data != 0)
//	{
		Atest_SendKbdMessage(signal_keycode);	
		Atest_SendSignalToAppTask(use_data_ptr,strlen((char *)use_data_ptr),0,ATEST_SIGNAL_ISCP);
//	}
}

/*****************************************************************************/
//  Description:根据坐标，发送按键事件
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL void Atest_SendKbdMessage(
								uint32 signal_keycode)	 //按键事件类型
{
	MmiKeyPress* KeysendSignal  = PNULL;

	Atest_KbdConvert(&signal_keycode);
	//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SendKbdMessage,signal_keycode=%d"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7479_112_2_18_1_59_40_38,(uint8*)"d",signal_keycode);

	//虚拟物理按键消息，KEY_DOWN/KEY_UP要成对
    MmiCreateSignal(KPD_DOWN, sizeof(MmiKeyPress), (MmiSignalS**)&KeysendSignal);
    KeysendSignal->keyCode = signal_keycode;
    KeysendSignal->Sender = KPDSVR;
    MmiSendSignal(TASK_FL_ID, (MmiSignalS*)KeysendSignal);
  
    //key up msg
    MmiCreateSignal(KPD_UP, sizeof(MmiKeyPress), (MmiSignalS**)&KeysendSignal);
    KeysendSignal->keyCode = signal_keycode;
    KeysendSignal->Sender = KPDSVR;
    MmiSendSignal(TASK_FL_ID, (MmiSignalS*)KeysendSignal);
}

/*****************************************************************************/
//  Description:根据坐标，发送触屏事件
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL void Atest_SendTouchMessage(
									MMI_TP_STATUS_E tp_type,	//TP类型
									uint16 rect_x,				//TP 坐标x
									uint16 rect_y)				//TP 坐标y
{
	MmiTPPress* sendSignal  = PNULL;

	//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SendTouchMessage,tp_type--%d"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7505_112_2_18_1_59_40_39,(uint8*)"d",tp_type);

	MmiCreateSignal((uint16)tp_type, sizeof(MmiTPPress), (MmiSignalS**)&sendSignal);    
    sendSignal->x  = rect_x;
    sendSignal->y  = rect_y;
    sendSignal->Sender = P_TPP;
    
    MmiSendSignal(TASK_FL_ID, (MmiSignalS*)sendSignal);	
}

/*****************************************************************************/
//  Description: 获得当前的分辨率
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetCurResolution()
{
	LCD_ANGLE_E RotateAngle = {0} ;
	uint16 logic_width = 0;
    uint16 logic_height = 0;
	uint8 data_len = 0;
	uint8 *data_ptr = PNULL;

	data_ptr = (uint8 *)SCI_ALLOC_APP(64);
    if (PNULL == data_ptr)
    {
        return FALSE;
    }
    SCI_MEMSET(data_ptr, 0, 64);

	//get rotate angle
	RotateAngle = GUILCD_GetRotateAngle((LCD_ID_E)GUI_MAIN_LCD_ID);
	//get lcd width and height
	if(GUILCD_GetWidthHeightByAngle((LCD_ID_E)GUI_MAIN_LCD_ID,RotateAngle,&logic_width,&logic_height))
	{
		data_len = sprintf((char *)data_ptr,"%dx%d",logic_width,logic_height);
		SCI_MEMSET(data_ptr, 0, 64);
		data_len = sprintf((char *)data_ptr,"<Reso>%dx%d</Reso><Len>%d</Len>",logic_width,logic_height,data_len);		
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	}

	SCI_FREE(data_ptr);
	return TRUE;
}

/*****************************************************************************/
//  Description: 获取当前语言
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetCurLang()
{
	uint8 data_len = 0;
	uint8 *data_ptr = PNULL;
	uint8 language_type = MMISET_GetCurrentLanguageType();

	//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_GetCurLang-%d-%s"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7559_112_2_18_1_59_40_40,(uint8*)"ds",language_type,cur_lang[language_type].language_name);

	data_ptr = (uint8 *)SCI_ALLOC_APP(64);
    if (PNULL == data_ptr)
    {
        return FALSE;
    }
    SCI_MEMSET(data_ptr, 0, 64);

	data_len = sprintf((char *)data_ptr,"<Lang>%s</Lang><Len>%d</Len>",cur_lang[language_type].language_name,strlen(cur_lang[language_type].language_name));
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);

	SCI_FREE(data_ptr);
	return TRUE;
}

/*****************************************************************************/
//  Description: 获取当前list或icon list的总个数
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetListNum(uint8 *user_data_ptr)
{
	uint32 ctrl_id = 0;
	IGUICTRL_T* ctrl_ptr = PNULL;
	CAF_GUID_T ctrl_guid = {0};
	CTRLLIST_OBJ_T *list_ctrl_ptr = PNULL;
	CTRLICONLIST_OBJ_T  *iconlist_ctrl_ptr = PNULL;
	CTRLRICHTEXT_OBJ_T *richtext_ptr = PNULL;
	GUIRICHTEXT_ITEM_T richedit_item = { 0 };
	uint8 data_len = 0;
	uint8 *data_ptr = PNULL;
	uint16 total_num = 0;
	MMI_HANDLE_T win_handle;
	
	uint8 *start_ptr = user_data_ptr;	
	
	ctrl_id = Atest_GetTestMessageId(',',&start_ptr); 
	ctrl_ptr = MMK_GetCtrlPtr(ctrl_id);

	// 获取焦点窗体handle
    win_handle = MMK_GetFocusWinHandle();
    ctrl_ptr = MMK_GetCtrlPtrByWin(win_handle, ctrl_id);

	if(PNULL == ctrl_ptr)
	{
		return FALSE;
	}

	data_ptr = (uint8 *)SCI_ALLOC_APP(64);
    if (PNULL == data_ptr)
    {
        return FALSE;
    }
	
		ctrl_guid= GUICTRL_GetCtrlGuid(ctrl_ptr);
	if(SPRD_GUI_LIST_ID == ctrl_guid)
	{
		list_ctrl_ptr = (CTRLLIST_OBJ_T *)ctrl_ptr;
		total_num = list_ctrl_ptr->total_item_num;
	}
	else if(SPRD_GUI_ICONLIST_ID == ctrl_guid)
	{
		iconlist_ctrl_ptr = (CTRLICONLIST_OBJ_T *)ctrl_ptr;
		total_num = iconlist_ctrl_ptr->total_num;
	}
	else if(SPRD_GUI_RICHTEXT_ID == ctrl_guid)
	{
		richtext_ptr = (CTRLRICHTEXT_OBJ_T *)ctrl_ptr;
		for (total_num = 0; ; total_num++)
	    {
	        if(!CTRLRICHTEXT_GetItem(GUICTRL_GetCtrlHandle(ctrl_ptr), total_num, &richedit_item))
	        {
				break;
			}
			
			if ( (GUIRICHTEXT_TEXT_INVALID == richedit_item.text_type ) && (GUIRICHTEXT_IMAGE_INVALID == richedit_item.img_type) )
	        {
	            break;
	        }
			
			if(total_num > 20)
			{
				total_num = 0;
				break;
			}
		}
	}

	data_len = sprintf((char *)data_ptr,"<TotalNum>%d</TotalNum>",total_num);
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);

	SCI_FREE(data_ptr);
	return TRUE;	
}


/*****************************************************************************/
//  Description: 获取当前主题
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetCurStyle(uint8 *user_data_ptr)
{
	uint8 data_len = 0;
	uint8 *data_ptr = PNULL;
	char strstyle[16] = {0};
	MMISET_IDLE_STYLE_E style = MMIAPISET_GetIdleStyle();

	data_ptr = (uint8 *)SCI_ALLOC_APP(64);
    if (PNULL == data_ptr)
    {
        return FALSE;
    }
	
	switch (style)
	{
		case MMISET_IDLE_STYLE_COMMON:
			sprintf(strstyle,"COMMON");
			break;
		case MMISET_IDLE_STYLE_SMART:
			sprintf(strstyle,"SMART");
			break;			
		case MMISET_IDLE_STYLE_WIDGET:
			sprintf(strstyle,"WIDGET");
			break;			
		case MMISET_IDLE_STYLE_GRID:
			sprintf(strstyle,"GRID");
			break;			
		case MMISET_IDLE_ISTYLE:
			sprintf(strstyle,"ISTYLE");
			break;			
		case MMISET_IDLE_QBTHEME:
			sprintf(strstyle,"QBTHEME");
			break;	
		default:
			sprintf(strstyle,"UNKNOW");
			break;			
	}	

	data_len = sprintf((char *)data_ptr,"<CurStyle>%s</CurStyle><Len>%d</Len>",strstyle,strlen(strstyle));
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);

	SCI_FREE(data_ptr);
	return TRUE;
}


/*****************************************************************************/
//  Description: 触笔对应的坐标
//  Global resource dependence :
//  Author:linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_TouchPanelPoint( uint8 *user_data_ptr)
{
	uint32 delay_time = 0;
	uint8 *start_ptr = PNULL;
	uint32 rect_x = 0;
	uint32 rect_y = 0;
	uint8 rect_arr[32] ={0};

	if(PNULL != user_data_ptr)
	{
		start_ptr = user_data_ptr;

		delay_time = Atest_GetTestMessageId(',',&start_ptr);
		rect_x = Atest_GetTestMessageId(',',&start_ptr);
		rect_y = Atest_GetTestMessageId(',',&start_ptr);
		
		Atest_SendTouchMessage(MMI_TP_DOWN,rect_x,rect_y);
		if(delay_time>=MMI_TP_LONG_PRESS_VALUE)
		{
			sprintf((char *)rect_arr,",%d,%d,",rect_x,rect_y);			
			Atest_SendSignalToAppTask( rect_arr,strlen((char *)rect_arr),delay_time,ATEST_SIGNAL_TPLONG);			
		}
		
		Atest_SendTouchMessage(MMI_TP_UP,rect_x,rect_y);
	}
}

/*****************************************************************************/
//  Description: 触笔down
//  Global resource dependence :
//  Author:linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_TouchPanelDown( uint8 *user_data_ptr)
{
	uint8 *start_ptr = PNULL;
	uint32 rect_x = 0;
	uint32 rect_y = 0;

	if(PNULL != user_data_ptr)
	{
		start_ptr = user_data_ptr;
		rect_x = Atest_GetTestMessageId(',',&start_ptr);
		rect_y = Atest_GetTestMessageId(',',&start_ptr);

		//SCI_TRACE_LOW:"[AT][ATEST]:Atest_TouchPanelDown,-%d,%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7677_112_2_18_1_59_40_41,(uint8*)"dd",rect_x,rect_y);
		
		Atest_SendTouchMessage(MMI_TP_DOWN,rect_x,rect_y);		
	}
}

/*****************************************************************************/
//  Description: 按键down
//  Global resource dependence :
//  Author:linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_KBDown( uint8 *user_data_ptr)
{
	uint32 signal_keycode = 0;
	uint8 *start_ptr = PNULL;

	if(PNULL != user_data_ptr)
	{
		start_ptr = user_data_ptr;
		signal_keycode = Atest_GetTestMessageId(',',&start_ptr);

		//SCI_TRACE_LOW:"[AT][ATEST]:Atest_KBDown,-%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7697_112_2_18_1_59_40_42,(uint8*)"d",signal_keycode);

		Atest_SendKbdMessage(signal_keycode);
	}
}

/*****************************************************************************/
//  Description: 触笔move
//  Global resource dependence :
//  Author:linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_TouchPanelMove( uint8 *user_data_ptr)
{
	uint8 *start_ptr = PNULL;
	uint32 rect_x = 0;
	uint32 rect_y = 0;

	if(PNULL != user_data_ptr)
	{
		start_ptr = user_data_ptr;
		rect_x = Atest_GetTestMessageId(',',&start_ptr);
		rect_y = Atest_GetTestMessageId(',',&start_ptr);

		//SCI_TRACE_LOW:"[AT][ATEST]:Atest_TouchPanelMove,-%d,%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7719_112_2_18_1_59_40_43,(uint8*)"dd",rect_x,rect_y);
		
		Atest_SendTouchMessage(MMI_TP_MOVE,rect_x,rect_y);		
	}
}

/*****************************************************************************/
//  Description: 触笔move
//  Global resource dependence :
//  Author:linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_TouchPanelUp( uint8 *user_data_ptr)
{
	uint8 *start_ptr = PNULL;
	uint32 rect_x = 0;
	uint32 rect_y = 0;

	if(PNULL != user_data_ptr)
	{
		start_ptr = user_data_ptr;
		rect_x = Atest_GetTestMessageId(',',&start_ptr);
		rect_y = Atest_GetTestMessageId(',',&start_ptr);

		//SCI_TRACE_LOW:"[AT][ATEST]:Atest_TouchPanelUp,-%d,%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7741_112_2_18_1_59_40_44,(uint8*)"dd",rect_x,rect_y);
		
		Atest_SendTouchMessage(MMI_TP_UP,rect_x,rect_y);		
	}
}


/*****************************************************************************/
//  Description: 根据当前lcd旋转的情况，对坐标进行转换
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_ConvertPositionByLcd(
											uint16 *rect_x,		//需要转换的坐标x
											uint16 *rect_y)		//需要转换的坐标y
{
	LCD_ANGLE_E RotateAngle = {0} ;
	uint16 logic_width = 0;
    uint16 logic_height = 0;
	uint16 old_x = 0;
	uint16 old_y = 0;
	GUI_POINT_T  point = {0};
	LCD_INFO_T  lcd_info = {0};
	GUI_RECT_T  rect = {0}; 

	//get rotate angle
	RotateAngle = GUILCD_GetRotateAngle((LCD_ID_E)GUI_MAIN_LCD_ID);
	//get lcd width and height
	GUILCD_GetWidthHeightByAngle((LCD_ID_E)GUI_MAIN_LCD_ID,RotateAngle,&logic_width,&logic_height);
	//SCI_TRACE_LOW:"[ATC:][ATEST:] Atest_ConvertPositionByLcd,%d,%d*%d"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7769_112_2_18_1_59_40_45,(uint8*)"ddd",RotateAngle,logic_width,logic_height);
		
    switch (RotateAngle)
    {
    case LCD_ANGLE_270:		
        old_x  = *rect_x;
        *rect_x = *rect_y;
        *rect_y = logic_width - old_x;
        break;

    case LCD_ANGLE_180:
        *rect_x = logic_width - *rect_x;
        *rect_y = logic_height - *rect_y;
        break;

    case LCD_ANGLE_90:
        old_y  = *rect_y;
        *rect_y = *rect_x;
        *rect_x = logic_height - old_y;
        break;

    default:
        break;
    }
	
	//SCI_TRACE_LOW:"[ATC:][ATEST:]ConvertPosition-%d-%d"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7794_112_2_18_1_59_40_46,(uint8*)"dd",*rect_x,*rect_y);

	point.x = (int16)*rect_x;
	point.y = (int16)*rect_y;
	if(!GUILCD_GetInfo((LCD_ID_E)GUI_MAIN_LCD_ID,&lcd_info))
	{
		return FALSE;
	}
	
	rect.left = 0;
	rect.right = lcd_info.lcd_width;
	rect.top = 0;
	rect.bottom = lcd_info.lcd_height;	

	if(!GUI_PointIsInRect(point,rect))
	{
		//SCI_TRACE_LOW:"[ATC:][ATEST:] invalid point"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7810_112_2_18_1_59_40_47,(uint8*)"");
		return FALSE;
	}
	
	return TRUE;
}

/*****************************************************************************/
//  Description:比较AT发送过来的数据和从控件取到的数据
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_Compare_content(ATEST_ID_TYPE_E id_type,	//查找类型
									MMI_HANDLE_T ctrl_handle,	//控件handle
									MMI_STRING_T ctrl_str,	    //遍历控件的字符串数据
									uint8 *at_data,			    //AT收到的字符串数据
									uint32 id_data)				//遍历控件的id数据
{	
	int j= 0;
	uint32 i=0;
	uint8  find_content[ATEST_MAX_STR_LEN]={0};	
	uint16 at_str_len = 0;
	uint16 ctrl_str_len = 0;
	uint32 string_num = 0;
	uint32 message_decode = 0;
	MMI_STRING_T at_str_ptr = {0};
	uint8 *start_ptr = at_data;

	switch(id_type) //compare text
	{	
		case TEXT_TYPE:
		case TEXT_ID_TYPE:
		case TEXT_IMG_TYPE:
 			if(!ctrl_str.wstr_len)	//从控件取到的数据为0直接返回，不比较
			{
				return FALSE;
			}
			
			if(TEXT_IMG_TYPE == id_type)
			{
				Atest_GetTestMessageId(',',&start_ptr);	//去掉img id部分
			}

			string_num = Atest_GetTestMessageId(',',&start_ptr); //获得字符串个数
			//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_Compare_content:AT string Num=%d"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7853_112_2_18_1_59_40_48,(uint8*)"d",message_decode);

			for(i=0;i<string_num;i++)
			{
				SCI_MEMSET(&at_str_ptr,0,sizeof(MMI_STRING_T));
				if(TEXT_TYPE == id_type || TEXT_IMG_TYPE == id_type)	//取AT发过来的字符串内容，并转为wchar类型
				{
					SCI_MEMSET(find_content,0,ATEST_MAX_STR_LEN);
					Atest_GetMessageContent(find_content,',',&start_ptr);
					at_str_ptr.wstr_ptr = (wchar *)GetATCParameter(MMI_UT_UNICODE, find_content, (uint32)strlen((char *)find_content), 0);
					at_str_ptr.wstr_len = (uint16)strlen((char *)find_content)/2;
				}
				else	//TEXT_ID_TYPE  取AT发过来的id，取字符串
				{
					message_decode = Atest_GetTestMessageId(',',&start_ptr); //text_id
				//	MMITHEME_GetResText(message_decode,ctrl_handle,&at_str_ptr);
					 MMITHEME_GetLabelTextByLang(message_decode, &at_str_ptr);
				}
				if (PNULL == at_str_ptr.wstr_ptr)
			    {
			       continue;
			    }

				//计算AT和控件的宽字符串长度
				ctrl_str_len = Atest_wcslen(ctrl_str.wstr_ptr,ctrl_str.wstr_len);
				at_str_len = Atest_wcslen(at_str_ptr.wstr_ptr,at_str_ptr.wstr_len);
				//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_Compare_content:Atest_wcslen:ctrl=%d--at=%d"
				SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7879_112_2_18_1_59_40_49,(uint8*)"dd",ctrl_str_len,at_str_len);
				//矫正长度，去末尾空格
				for(j=ctrl_str_len-1;j>=0;j--)
				{
					if(' ' == ctrl_str.wstr_ptr[j])
					{
						//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_Compare_content:remove the last word if is space of ctrl_str"
						SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7885_112_2_18_1_59_40_50,(uint8*)"");
						ctrl_str_len--;				
					}
					else
					{
						break;
					}
				}
				for(j=at_str_len-1;j>=0;j--)
				{
					if(' ' == at_str_ptr.wstr_ptr[j])
					{
						//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_Compare_content:remove the last word if is space of at_str"
						SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7897_112_2_18_1_59_40_51,(uint8*)"");
						at_str_len--;				
					}
					else
					{
						break;
					}
				}
				//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_Compare_content:Atest_wcslen:ctrl=%d--at=%d"
				SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7905_112_2_18_1_59_40_52,(uint8*)"dd",ctrl_str_len,at_str_len);

				if(!MMIAPICOM_CompareTwoWstrExt(ctrl_str.wstr_ptr,ctrl_str_len,at_str_ptr.wstr_ptr,at_str_len,FALSE))
				{
					//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_Compare_content:compare text TRUE"
					SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7909_112_2_18_1_59_40_53,(uint8*)"");
					if(TEXT_TYPE == id_type || TEXT_IMG_TYPE == id_type)
					{
						SCI_FREE(at_str_ptr.wstr_ptr);
					}
 					return TRUE;
				}

				if(TEXT_TYPE == id_type || TEXT_IMG_TYPE == id_type)
				{
					if(PNULL != at_str_ptr.wstr_ptr)
					{
						SCI_FREE(at_str_ptr.wstr_ptr);
					}
				}
			}			
			break;
		case CONTROL_ID_TYPE:
	    case IMAGE_ID_TYPE:
	    case INDEX_ID_TYPE:
			string_num = Atest_GetTestMessageId(',',&start_ptr);	//id个数，默认为1
			message_decode = Atest_GetTestMessageId(',',&start_ptr);	//id
			if(message_decode == id_data )
			{
				//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_Compare_content:compare id TRUE"
				SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7933_112_2_18_1_59_41_54,(uint8*)"");
				return TRUE;
			}
		break;
		default:
			break;
	}

	//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_Compare_content:FALSE"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7941_112_2_18_1_59_41_55,(uint8*)"");
	return FALSE;
}

/*****************************************************************************/
//  Description:计算宽字符的长度
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL uint16 Atest_wcslen(	wchar *s,			//宽字符串
							uint16 limit_len)	//限制长度
{
	uint16 len = 0;

	if(PNULL != s)
	{
		while (s[len] != L'\0') 
	    {
			if(len > limit_len-1)
			{
				break;
			}
			len++;
	    }
	}
	
	return len;
}

/*****************************************************************************/
//  Description:根据item所在的控件的位置，返回对应的触笔坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:主要针对list，pop menu
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_GetValidTPPoint(	GUI_RECT_T item_rect,	//item的区域
										GUI_RECT_T ctrl_rect,	//item所在的控件的区域
										uint16 *rect_x,			//out:坐标x
										uint16 *rect_y)			//out:坐标y
{
	GUI_POINT_T  point = {0}; 

	//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_GetValidTPPoint item_rect:%d %d %d %d--ctrl_rect:%d %d %d %d"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7982_112_2_18_1_59_41_56,(uint8*)"dddddddd",item_rect.left,item_rect.top,item_rect.right,item_rect.bottom,ctrl_rect.left,ctrl_rect.top,ctrl_rect.right,ctrl_rect.bottom);

	point.x = (int16)(item_rect.left+item_rect.right)/2;
	point.y = (int16)(item_rect.top+item_rect.bottom)/2;

	if(!GUI_PointIsInRect(point,ctrl_rect))
	{
		if(point.y < (int16)ctrl_rect.top)
		{
			*rect_x = (item_rect.left +item_rect.right)/2;
			*rect_y = item_rect.bottom-1; 
		}
		else if(point.y > (int16)ctrl_rect.bottom)
		{
			*rect_x = (item_rect.left +item_rect.right)/2;
			*rect_y = item_rect.top+1; 
		}
		else if(point.x < (int16)ctrl_rect.left)
		{
			*rect_x = item_rect.right - 1;
			*rect_y = (item_rect.bottom+item_rect.top)/2;; 
		}
		else if(point.y > (int16)ctrl_rect.right)
		{
			*rect_x = item_rect.left + 1;
			*rect_y = (item_rect.bottom+item_rect.top)/2;; 
		}		
		else
		{
			//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_GetValidTPPoint failed"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8011_112_2_18_1_59_41_57,(uint8*)"");
			return FALSE;
		}
	}
	else
	{
		*rect_x =(item_rect.left +item_rect.right)/2;
		*rect_y =(item_rect.top +item_rect.bottom)/2; 
	}

	point.x = (int16)(item_rect.left+item_rect.right)/2;
	point.y = (int16)(item_rect.top+item_rect.bottom)/2;

	if(!GUI_PointIsInRect(point,ctrl_rect))
	{
		return FALSE;
	}

	//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_GetValidTPPoint:%d %d"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8029_112_2_18_1_59_41_58,(uint8*)"dd",*rect_x,*rect_y);
	return TRUE;
}

/*****************************************************************************/
//  Description:查找控件LABLE，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持name查找
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchLableControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	uint32  user_data_id = 0;
	MMI_STRING_T text_ptr = {0};
	
	CTRLLABEL_OBJ_T	*label_ctrl_ptr = PNULL;

	label_ctrl_ptr = (CTRLLABEL_OBJ_T *)ctrl_ptr; 
	if(PNULL == label_ctrl_ptr)
	{
		return FALSE;
	}

	switch (id_type)
	{
		case CONTROL_ID_TYPE:
			user_data_id = ctrl_id;
			break;
		case TEXT_TYPE:
		case TEXT_ID_TYPE:
			GUILABEL_GetText(ctrl_id,&text_ptr);
			break;
			default:
				return FALSE;
	}
	
	if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
	{
		if(0 == label_ctrl_ptr->base_ctrl.display_rect.bottom
			&& 0 == label_ctrl_ptr->base_ctrl.display_rect.left
			&& 0 == label_ctrl_ptr->base_ctrl.display_rect.top
			&& 0 == label_ctrl_ptr->base_ctrl.display_rect.right) //未显示
		{
			if(label_ctrl_ptr->base_ctrl.rect.top < ATEST_RECT_LIMIT) //需上翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_UP);
				return FALSE;
						
			}
			else if(label_ctrl_ptr->base_ctrl.rect.bottom > ATEST_RECT_LIMIT) //需下翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_DOWN);
				return FALSE;
			}
		}
		
		*rect_x = (label_ctrl_ptr->base_ctrl.display_rect.left+label_ctrl_ptr->base_ctrl.display_rect.right)/2;
		*rect_y = (label_ctrl_ptr->base_ctrl.display_rect.bottom+label_ctrl_ptr->base_ctrl.display_rect.top)/2;
		return TRUE;
	}
	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件EditBbox，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持id查找
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchEditBoxControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	
	CTRLBASEEDIT_OBJ_T *edit_ctrl_ptr = PNULL;
	uint32  user_data_id = 0;
	MMI_STRING_T text_ptr = {0};

	edit_ctrl_ptr = (CTRLBASEEDIT_OBJ_T *)ctrl_ptr;
	if(PNULL == edit_ctrl_ptr)
	{
		return FALSE;
	}
	
	switch (id_type)
	{
		case CONTROL_ID_TYPE:
			user_data_id = ctrl_id;
			break;
			default:
				return FALSE;
	}

	if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
	{
		if(0 == edit_ctrl_ptr->base_ctrl.display_rect.bottom
			&& 0 == edit_ctrl_ptr->base_ctrl.display_rect.left
			&& 0 == edit_ctrl_ptr->base_ctrl.display_rect.top
			&& 0 == edit_ctrl_ptr->base_ctrl.display_rect.right) //未显示
		{
			if(edit_ctrl_ptr->base_ctrl.rect.top < ATEST_RECT_LIMIT) //需上翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_UP);
				return FALSE;
			}
			else if(edit_ctrl_ptr->base_ctrl.rect.bottom > ATEST_RECT_LIMIT) //需下翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_DOWN);
				return FALSE;
			}			
		}

		*rect_x = (edit_ctrl_ptr->base_ctrl.display_rect.left+edit_ctrl_ptr->base_ctrl.display_rect.right)/2;
		*rect_y = (edit_ctrl_ptr->base_ctrl.display_rect.bottom+edit_ctrl_ptr->base_ctrl.display_rect.top)/2;
		return TRUE;
	}

	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件SoftKey，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持name查找
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchSoftKeyControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	uint16 j = 0;
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_IMAGE_ID_T image_id = 0;
	MMI_TEXT_ID_T text_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	CTRLSOFTKEY_OBJ_T	*softkey_ptr = PNULL;
	GUI_BUTTON_T    *button_ptr = PNULL;
	
	softkey_ptr = (CTRLSOFTKEY_OBJ_T*)ctrl_ptr;
	if(PNULL == softkey_ptr)
	{
		return FALSE;
	}
	
	for(j=0;j < GUISOFTKEY_BUTTON_NUM;j++)
	{
		button_ptr = &softkey_ptr->button_arr[j];
		if(softkey_ptr->button_arr[j].is_show)
		{
			SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
			switch(softkey_ptr->button_arr[j].content.data_type)
			{	
				case GUISK_DATA_TEXT_ID:
					text_id = button_ptr->content.data_u.text_id;
					MMITHEME_GetResText(text_id, softkey_ptr->win_handle, &text_ptr);
					break;
				case GUISK_DATA_TEXT_BUFFER:
					text_ptr.wstr_ptr = softkey_ptr->button_arr[j].content.data_u.text_buffer.wstr_ptr;
					text_ptr.wstr_len = softkey_ptr->button_arr[j].content.data_u.text_buffer.wstr_len;
					break;
				case GUISK_DATA_IMAGE_ID:
					image_id = button_ptr->content.data_u.image_id;
					break;
				default:
						break;
			}

			switch (id_type)
			{
		    	case CONTROL_ID_TYPE:
					user_data_id = ctrl_id;					
					break;
				case TEXT_TYPE:
				case TEXT_ID_TYPE:
					break;
		    	case IMAGE_ID_TYPE:
					user_data_id = image_id;
					break;
					default:
						return FALSE;
			}
			
			if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
			{
				if(Atest_GetValidTPPoint(softkey_ptr->button_arr[j].rect,softkey_ptr->base_ctrl.display_rect,rect_x,rect_y))
				{			
					return TRUE;
				}
			}
		}
	}
	return FALSE;
}
/*****************************************************************************/
//  Description:查找控件Menu，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: 
//  Note:支持name查找
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchMainMenuControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr = (CTRLMAINMENU_OBJ_T *)ctrl_ptr;
	BOOL flag = FALSE;
	if(PNULL == menu_ctrl_ptr)
	{
		return FALSE;
	}

	switch (menu_ctrl_ptr->type)
	{   
		#ifdef MATRIX_MAIN_MENU_SUPPORT
	 	case MMIMAINMENU_MATRIX_E :  
		case MMIMAINMENU_MATRIX_TITLE_E :  
			flag = Atest_SearchMatrixMainMenuControlItem(menu_ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y);		
    		break;
		#endif
		#ifdef QBTHEME_SUPPORT
	 	case MMIMAINMENU_QBTHEME_E : 			
			flag = Atest_SearchQbMainMenuControlItem(menu_ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y);		
			break;
		#endif
	    #ifdef MMI_ISTYLE_SUPPORT
	    case MMIMAINMENU_ISTYLE_E : 			
			flag = Atest_SearchIStyleMainMenuControlItem(menu_ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y);		
			break;
	    #endif
		#ifdef PDA_UI_SUPPORT_MANIMENU_GO										 
		case MMIMAINMENU_GO_SLIDE_E :
			flag =Atest_SearchSlideMainMenuControlItem(menu_ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y);		
			break;
		#endif
	    #ifdef MENU_SWEETS_SUPPORT
	    case MMIMAINMENU_SWEETS_E :
			flag = Atest_SearchSweetMainMenuControlItem(menu_ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y);		
			break;
	    #endif
		default:
			break;
	}

	return flag;
}

/*****************************************************************************/
//  Description:查找控件Menu，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持name查找
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchMenuControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	CTRLMENU_OBJ_T  *menu_ctrl_ptr = (CTRLMENU_OBJ_T *)ctrl_ptr;
	if(PNULL == menu_ctrl_ptr)
	{
		return FALSE;
	}

	switch (menu_ctrl_ptr->cur_style)
	{
	    case GUIMENU_STYLE_SECOND :      /* 1 !< 二级菜单风格，显示为列表形式，多用于由主菜单进入的二级菜单 */
	    //case GUIMENU_STYLE_THIRD: 		 /* 2 !< 已去掉此风格，其显示同GUIMENU_STYLE_SECOND */
			if(Atest_SearchPopMenuControlItem(
				menu_ctrl_ptr,
				ctrl_ptr,
				ctrl_handle,
				id_type,
				user_data_ptr,
				menu_ctrl_ptr->sec_theme.item_height,
				menu_ctrl_ptr->sec_theme.item_space,
				rect_x,
				rect_y))
			{
				return TRUE;
			}										
			break;
		case GUIMENU_STYLE_POPUP :       /* 6 !< 弹出式菜单，由系统统一计算它的位置和宽度，用户不能设置 */
	    case GUIMENU_STYLE_POPUP_AUTO :  /* 11 !< 弹出式菜单，其坐标可由用户设置，且会根据文本自适应宽度 */
	    case GUIMENU_STYLE_POPUP_RECT :  /* 12 !< 弹出式菜单，其坐标和宽度可由用户设置，系统不会做自适应 */
		case GUIMENU_STYLE_POPUP_RADIO : /* 7 !< 弹出式菜单，菜单项带有单选的radio风格 */
	    case GUIMENU_STYLE_POPUP_CHECK : /* 8 !< 弹出式菜单，菜单项带有多选的check风格 */
			if(Atest_SearchPopMenuControlItem(
				menu_ctrl_ptr,
				ctrl_ptr,
				ctrl_handle,
				id_type,
				user_data_ptr,
				menu_ctrl_ptr->pop_theme.item_height,
				menu_ctrl_ptr->pop_theme.item_space,
				rect_x,
				rect_y))
			{
				return TRUE;
			}
			break;			
		case GUIMENU_STYLE_OPTIONS:     /* 15 !< OptionsMenu */
			if(Atest_SearchOptionMenuControlItem(menu_ctrl_ptr,
										ctrl_ptr,
										ctrl_handle,
										id_type,
										user_data_ptr,
										rect_x,
										rect_y))
			{
				return TRUE;
			}
			break;
			default:
				break;
	}

	return FALSE;
}

#ifdef QBTHEME_SUPPORT
/*****************************************************************************/
//  Description:查找控件MENU 的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:GUIMENU_STYLE_QBTHEME
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchQbMainMenuControlItem(
										CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										MMI_CTRL_ID_T ctrl_id,		//控件id
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y)					//out,查找到的控件坐标y
{

	uint16 page_item_num = 0;
	MMI_STRING_T text_ptr = { 0 };
       //MMI_IMAGE_ID_T  icon_id_ptr = { 0 };
	CTRLMAINMENU_ITEM_T cur_item_info = { 0 };
	uint32 text_id = 0,icon_id = 0,user_data_id = 0;
	GUIMENU_QBTHEME_DATA_T qb_menu_info_ptr = { 0 };
	GUI_RECT_T item_image_rect = { 0 };
	uint16 pre_item_index = 0;
	uint16 pre_page_index = 0;
	uint16 move_page_num = 0;
	MMIMAINMENU_QBTHEME_DATA_T *mainmenu = NULL;
	GUIMENU_ITEM_POSITION_E position = GUIMENU_ITEM_IN_PAGE;

	if(PNULL == menu_ctrl_ptr)
	{
		return FALSE;
	}

	mainmenu =  (MMIMAINMENU_QBTHEME_DATA_T*)menu_ctrl_ptr->pm_data_ptr;
	if(!mainmenu->page_total_num)
	{
		return FALSE;
	}
	page_item_num =  Atest_GetSlideMenuPageItemNum((MMIMAINMENU_SLIDEPAGE_DATA_T *)mainmenu);

	
	//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchQbMainMenuControlItem,cur_page=%d,item_num=%d,totalpage='%d'"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8421_112_2_18_1_59_42_59,(uint8*)"ddd",mainmenu->cur_page_index,page_item_num,mainmenu->page_total_num);

	pre_page_index = mainmenu->cur_page_index; //保存当前page index
	for(;;mainmenu->cur_page_index++)
	{
		if(mainmenu->cur_page_index >= mainmenu->page_total_num)
		{
			mainmenu->cur_page_index = 0;
		}
		
		//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchQbMainMenuControlItem:page=%d/%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8431_112_2_18_1_59_42_60,(uint8*)"dd",mainmenu->cur_page_index ,mainmenu->page_total_num);

		if(mainmenu->page_total_num == move_page_num)
		{
			//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchQbMainMenuControlItem:move_page_num=%d stop"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8435_112_2_18_1_59_42_61,(uint8*)"d",move_page_num);
			break;
		}

		if(!move_page_num)
		{
			pre_item_index = mainmenu->cur_item_index;//保存当前item index
		}

		pre_item_index = mainmenu->cur_item_index;//焦点所在的item
		for (mainmenu->cur_item_index = 0; mainmenu->cur_item_index < page_item_num; mainmenu->cur_item_index++)
		{
			if ( mainmenu->is_bar_item )
			{
				position = GUIMENU_ITEM_IN_BAR;
			}
			else
			{
				position = GUIMENU_ITEM_IN_PAGE;
			}
			Atest_QbThemeMenuGetItemInfo(mainmenu, position, mainmenu->cur_page_index, mainmenu->cur_item_index, &cur_item_info);

			text_id = cur_item_info.text.data.text_id;
			icon_id = cur_item_info.icon.data.icon_id;

		    if (CTRL_TEXT_ID == cur_item_info.text.type )
	            {
				MMITHEME_GetResText(cur_item_info.text.data.text_id, mainmenu->win_handle, &text_ptr);
	            }
	            else
	            {
	                text_ptr.wstr_ptr = cur_item_info.text.data.str_info.wstr_ptr;
	                text_ptr.wstr_len = cur_item_info.text.data.str_info.wstr_len;
	            }			//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchQbMainMenuControlItem,MMITHEME_GetResText,icon_id=%d,text_id=%d,text=%x"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8479_112_2_18_1_59_42_64,(uint8*)"ddd",icon_id,text_id,*(text_ptr.wstr_ptr));

			switch (id_type)
			{
				case TEXT_TYPE:
				case TEXT_ID_TYPE:
					break;
				case IMAGE_ID_TYPE:
					user_data_id = icon_id;
					break;
					default:
						return FALSE;
			}

			if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
			{
				MMITHEME_GetQbthemeMenuInfo(ctrl_handle,&qb_menu_info_ptr);
				item_image_rect = qb_menu_info_ptr.item_rect[mainmenu->cur_item_index];

				*rect_x = (item_image_rect.left + item_image_rect.right)/2;
				*rect_y = (item_image_rect.bottom + item_image_rect.top)/2;
				return TRUE;
			}
		}
		move_page_num ++;
	}
	mainmenu->cur_page_index = pre_page_index;
	mainmenu->cur_item_index = pre_item_index;

	return FALSE;
}

#endif	
/*****************************************************************************/
//  Description:查找控件MENU 的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:GUIMENU_STYLE_CYCLONE
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchCycloneMenuControlItem(
										CTRLMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										IGUICTRL_T *ctrl_ptr,			//控件指针
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y)					//out,查找到的控件坐标y
{
	MMI_STRING_T text_ptr = { 0 };
    MMI_IMAGE_ID_T  user_data_id = 0;
    MMI_IMAGE_ID_T  icon_id_ptr = 0;
    BOOLEAN  is_grayed_ptr = FALSE;
	//CTRLMAINMENU_ITEM_T cur_item_info = { 0 };
	uint16 pre_item_index = 0;
	MMI_LINK_NODE_T  *item_head_ptr = PNULL;

	if(PNULL == menu_ctrl_ptr)
	{
		return FALSE;
	}

	 item_head_ptr= (MMI_LINK_NODE_T  *)menu_ctrl_ptr->cur_group_ptr->item_ptr;	
	if(PNULL == item_head_ptr)
	{
		return FALSE;
	}
	
	if(!menu_ctrl_ptr->item_total_num)
	{
		return FALSE;
	}

	pre_item_index = menu_ctrl_ptr->cur_item_index;

	for (menu_ctrl_ptr->cur_item_index = 0;menu_ctrl_ptr->cur_item_index < menu_ctrl_ptr->item_total_num ; menu_ctrl_ptr->cur_item_index++)
	{
		if(PNULL == item_head_ptr)
		{
			break;
		}		
		SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
		if(!CTRLMENU_GetItem(menu_ctrl_ptr,menu_ctrl_ptr->cur_item_index,&text_ptr,&icon_id_ptr,&is_grayed_ptr))
		{
			break;
		}
		if(!icon_id_ptr)
		{
			/*
			if (PNULL == ((GUIMENU_PROCESS_T*)(menu_ctrl_ptr->process_func[menu_ctrl_ptr->cur_style]))->GetItemPtr)
		 	{
				break;
			}
			else
			{
				((GUIMENU_PROCESS_T*)(menu_ctrl_ptr->process_func[menu_ctrl_ptr->cur_style]))->GetItemPtr(menu_ctrl_ptr, menu_ctrl_ptr->cur_page_index, menu_ctrl_ptr->cur_item_index,&cur_item_info);
			}

			if(PNULL != cur_item_info.menu_data.static_menu_ptr)
			{
				icon_id_ptr = cur_item_info.menu_data.static_menu_ptr->unselect_icon_id;
			}*/
		}

		switch (id_type)
		{
			case TEXT_TYPE:
			case TEXT_ID_TYPE:
				break;
			case IMAGE_ID_TYPE:
				user_data_id = icon_id_ptr;
				break;
				default:
					return FALSE;
		}

		if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
		{
			MMK_PostMsg(ctrl_handle,MSG_NOTIFY_OK,0,0);
			*rect_x = 0;
			*rect_y = 0;					
			return TRUE;
		}
		item_head_ptr = item_head_ptr->next_ptr;
	}

	menu_ctrl_ptr->cur_item_index = pre_item_index;
	return FALSE;
}


/*****************************************************************************/
//  Description:查找控件MENU 的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:GUIMENU_STYLE_CRYSTAL_CUBE
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchCrystalMenuControlItem(
										CTRLMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										IGUICTRL_T *ctrl_ptr,			//控件指针
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y)					//out,查找到的控件坐标y
{
#ifdef MENU_CRYSTALCUBE_SUPPORT
	uint16 item_index = 0;
	uint16 move_page_num= 0;
	MMI_STRING_T text_ptr = { 0 };
    MMI_IMAGE_ID_T user_data_id = { 0 };
	MMI_IMAGE_ID_T icon_id_ptr = { 0 };
    BOOLEAN  is_grayed_ptr = FALSE;
	GUIMENU_CRYSTALCUBEMENU_DATA_T menu_data = { 0 };
	GUI_RECT_T item_image_rect = { 0 };
	CTRLMAINMENU_ITEM_T cur_item_info = { 0 };
	uint16 pre_item_index = 0;
	uint16 pre_page_index = 0;

	if(PNULL == menu_ctrl_ptr)
	{
		return FALSE;
	}
	
	if(!menu_ctrl_ptr->item_total_num)
	{
		return FALSE;
	}
	
	menu_data = menu_ctrl_ptr->main_menu_data.crystalcube_menu_data; //crystal nemu data

	pre_page_index = menu_ctrl_ptr->cur_page_index;
		
	for(;;menu_ctrl_ptr->cur_page_index++)
	{
		if(menu_ctrl_ptr->cur_page_index >= menu_data.page_num)
		{
			menu_ctrl_ptr->cur_page_index = 0;
		}

		if(menu_data.page_num == move_page_num)
		{
			break;
		}
		item_index = menu_ctrl_ptr->cur_item_index;
		pre_item_index = item_index;

		for (menu_ctrl_ptr->cur_item_index = 0;menu_ctrl_ptr->cur_item_index < CRYSTALCUBE_MENUMAIN_ICON_ITEM_MAX_NUM ; menu_ctrl_ptr->cur_item_index++)
		{
			SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
			if(!CTRLMENU_GetItem(menu_ctrl_ptr,menu_ctrl_ptr->cur_item_index,&text_ptr,&icon_id_ptr,&is_grayed_ptr))
			{
				break;
			}
			if(!icon_id_ptr)
			{
			/*
				if (PNULL == ((GUIMENU_PROCESS_T*)(menu_ctrl_ptr->process_func[menu_ctrl_ptr->cur_style]))->GetItemPtr)
			 	{
					break;
				}
				else
				{
					((GUIMENU_PROCESS_T*)(menu_ctrl_ptr->process_func[menu_ctrl_ptr->cur_style]))->GetItemPtr(menu_ctrl_ptr, menu_ctrl_ptr->cur_page_index, menu_ctrl_ptr->cur_item_index,&cur_item_info);
				}*/

				if(PNULL != cur_item_info.menu_data.static_menu_ptr)
				{
					icon_id_ptr = cur_item_info.menu_data.static_menu_ptr->unselect_icon_id;
				}
			}

			switch (id_type)
			{
				case TEXT_TYPE:
				case TEXT_ID_TYPE:					
					break;
				case IMAGE_ID_TYPE:
					user_data_id = icon_id;
					break;
					default:
						return FALSE;
			}
			
			if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
			{
				item_image_rect = menu_data.item_image_display_rect[menu_ctrl_ptr->cur_item_index];
				*rect_x = item_image_rect.left + 1;
				*rect_y = item_image_rect.top + 1;
				return TRUE;
			}
		}
		move_page_num++;
		menu_ctrl_ptr->cur_item_index = item_index;
	}

	menu_ctrl_ptr->cur_page_index = pre_page_index;
	menu_ctrl_ptr->cur_item_index = pre_item_index;
#endif

	return FALSE;
}

#ifdef PDA_UI_SUPPORT_MANIMENU_GO										 
/*****************************************************************************/
//  Description: 获取Slide Menu每页的item数
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_SLIDE_PAGE 
/*****************************************************************************/
LOCAL uint16 Atest_GetSlideMenuPageItemNum(MMIMAINMENU_SLIDEPAGE_DATA_T *menu_ctrl_ptr)
{
	//MMI_LINK_NODE_T     *link_node_ptr = PNULL;
	MMIMAINEMENU_ITEM_LIST_T *page_item_info_ptr = PNULL;	
	uint16 page_item_num = 0;
	MMIMAINMENU_SLIDEPAGE_DATA_T* mainmenu = (MMIMAINMENU_SLIDEPAGE_DATA_T*)menu_ctrl_ptr;

	page_item_info_ptr = MMIMENU_GetItemList(&mainmenu->menu_page_info, mainmenu->cur_page_index);

	if (PNULL != page_item_info_ptr)
	{
        	page_item_num = page_item_info_ptr->item_count;
	}
	
	return page_item_num;
}
#endif

#ifdef MATRIX_MAIN_MENU_SUPPORT
/*****************************************************************************/
//  Description:查找控件slide menu的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchMatrixMainMenuControlItem(
										CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										MMI_CTRL_ID_T ctrl_id,		//控件id,			//控件指针
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y)					//out,查找到的控件坐标y
{
	uint16 item_index = 0, cur_item_index = 0;
	uint16 first_item_index= 0;
	uint16 page_item_num = 0;
	MMI_STRING_T text_ptr = { 0 };
       MMI_IMAGE_ID_T  user_data_id = 0;
       //BOOLEAN  is_grayed_ptr = FALSE;
	CTRLMAINMENU_ITEM_T cur_item_info = { 0 };
	GUI_RECT_T rect ={0};
	MMIMAINMENU_MATRIX_DATA_T *mainmenu = { 0 };
	uint16 text_id =0, icon_id = 0;
	MMIMAINMENU_ITEM_INFO_T item_ptr = {0};

	mainmenu = (MMIMAINMENU_MATRIX_DATA_T *)menu_ctrl_ptr->pm_data_ptr;	
	if(PNULL == mainmenu)
	{
		return FALSE;
	}
	
	if(!mainmenu->item_total_num)
	{
		return FALSE;
	}
	
	page_item_num = mainmenu->icon_data.page_col_num * mainmenu->icon_data.page_row_num;; //每页的item数
	if(!page_item_num)
	{
		return FALSE;
	}

	//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchIconMenuControlItem:page_col=%d,page_row=%d,page_item=%d"
//	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_9055_112_2_18_1_59_43_68,(uint8*)"ddd",page_col_num,page_row_num,page_item_num);
	first_item_index = mainmenu->first_item_index;
	cur_item_index = mainmenu->cur_item_index; //初始时焦点所在的item

	for (mainmenu->cur_item_index = 0; mainmenu->cur_item_index < mainmenu->item_total_num; mainmenu->cur_item_index++)
	{
			MMIMAINMENU_GetItem(&mainmenu->menu_list_info, mainmenu->cur_item_index, &item_ptr);
			MMIMAINMENU_GetItemData(item_ptr.menu_id, item_ptr.group_id, &cur_item_info);

			text_id = cur_item_info.text.data.text_id;
			icon_id = cur_item_info.icon.data.icon_id;

		    if (CTRL_TEXT_ID == cur_item_info.text.type )
	            {
				MMITHEME_GetResText(cur_item_info.text.data.text_id, mainmenu->win_handle, &text_ptr);
	            }
	            else
	            {
	                text_ptr.wstr_ptr = cur_item_info.text.data.str_info.wstr_ptr;
	                text_ptr.wstr_len = cur_item_info.text.data.str_info.wstr_len;
	            }
				
			//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchQbMainMenuControlItem,MMITHEME_GetResText,icon_id=%d,text_id=%d,text=%x"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8479_112_2_18_1_59_42_64,(uint8*)"ddd",icon_id,text_id,*(text_ptr.wstr_ptr));

			switch (id_type)
			{
				case TEXT_TYPE:
				case TEXT_ID_TYPE:
					break;
				case IMAGE_ID_TYPE:
					user_data_id = icon_id;
					break;
					default:
						return FALSE;
			}

		if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
		{
			item_index = mainmenu->cur_item_index;  //所要选择的item的index

			if(item_index >= mainmenu->first_item_index  + page_item_num) //需要下移
			{	
				//mainmenu->first_item_index = mainmenu->icon_data.page_row_num;
				mainmenu->first_item_index += 4;
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_DOWN);
				return FALSE;
			}
			else if((mainmenu->first_item_index != 0) && (item_index <  mainmenu->first_item_index + 4)) //需要上移
			{
				//mainmenu->first_item_index = mainmenu->icon_data.page_row_num;
				mainmenu->first_item_index -= 4;
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_UP);
				return FALSE;
			}
			
			 rect = Atest_MatrixMenuGetItemRect(mainmenu, mainmenu->cur_item_index);
			 *rect_x = (rect.left + rect.right)/2;
			 *rect_y = (rect.bottom + rect.top)/2;

			return TRUE;
		}
	}
	
	mainmenu->cur_item_index = cur_item_index;

	return FALSE;
}
#endif

#ifdef MENU_SWEETS_SUPPORT
/*****************************************************************************/
//  Description:查找控件slide menu的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchSweetMainMenuControlItem(
										CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										MMI_CTRL_ID_T ctrl_id,		//控件id
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y)					//out,查找到的控件坐标y
{
	uint16 page_item_num = 0;
	MMI_STRING_T text_ptr = { 0 };
    	//MMI_IMAGE_ID_T  icon_id_ptr = { 0 };
    	//BOOLEAN is_grayed_ptr = FALSE;
	CTRLMAINMENU_ITEM_T cur_item_info = { 0 };
	uint32 text_id = 0,icon_id = 0,user_data_id = 0;
	MMIMAINMENU_SWEETS_DATA_T *mainmenu = NULL;
	MMIMAINMENU_ITEM_INFO_T item_ptr = {0};
	//IMGREF_POINT_T point = {0};

	GUI_RECT_T item_image_rect = { 0 };
	uint16 pre_item_index = 0;
	uint16 pre_page_index = 0;
	uint16 move_page_num = 0;
	uint16 pre_item_nums = 0;
	uint16 i = 0;

	if(PNULL == menu_ctrl_ptr)
	{
		return FALSE;
	}
	mainmenu =  (MMIMAINMENU_SWEETS_DATA_T*)menu_ctrl_ptr->pm_data_ptr;
	if(!mainmenu->item_total_num)
	{
		return FALSE;
	}

	pre_page_index = mainmenu->cur_page_index; //保存当前page index
	for(;;mainmenu->cur_page_index++)
	{
		if(mainmenu->cur_page_index >= (mainmenu->item_total_num/12 + 1))
		{
			mainmenu->cur_page_index = 0;
		}
		pre_item_nums = 0;
		
		//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchQbMainMenuControlItem:page=%d/%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8431_112_2_18_1_59_42_60,(uint8*)"dd",mainmenu->cur_page_index, ISTYLE_PAGE_CNT_MAX);

		if(ISTYLE_PAGE_CNT_MAX == move_page_num)
		{
			//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchQbMainMenuControlItem:move_page_num=%d stop"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8435_112_2_18_1_59_42_61,(uint8*)"d",move_page_num);
			break;
		}

		if(!move_page_num)
		{
			pre_item_index = mainmenu->cur_item_index;//保存当前item index
		}

		pre_item_index = mainmenu->cur_item_index;//焦点所在的item
		page_item_num = Atest_SWEETS_GetPageItemNum(mainmenu, mainmenu->cur_page_index);
		for(i=0; i < mainmenu->cur_page_index; i++)
		{
			 pre_item_nums += Atest_SWEETS_GetPageItemNum(mainmenu, i);
		}
		for (mainmenu->cur_item_index = 0; mainmenu->cur_item_index <  page_item_num; mainmenu->cur_item_index++)
		{
			MMIMAINMENU_GetItem(&mainmenu->menu_list_info, mainmenu->cur_item_index + pre_item_nums, &item_ptr);
			MMIMAINMENU_GetItemData(item_ptr.menu_id, item_ptr.group_id, &cur_item_info);
			text_id = cur_item_info.text.data.text_id;
			icon_id = cur_item_info.icon.data.icon_id;

			
		    if (CTRL_TEXT_ID == cur_item_info.text.type )
	            {
				MMITHEME_GetResText(cur_item_info.text.data.text_id, mainmenu->win_handle, &text_ptr);
	            }
	            else
	            {
	                text_ptr.wstr_ptr = cur_item_info.text.data.str_info.wstr_ptr;
	                text_ptr.wstr_len = cur_item_info.text.data.str_info.wstr_len;
	            }			//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchQbMainMenuControlItem,MMITHEME_GetResText,icon_id=%d,text_id=%d,text=%x"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8479_112_2_18_1_59_42_64,(uint8*)"ddd",icon_id,text_id,*(text_ptr.wstr_ptr));

			switch (id_type)
			{
				case TEXT_TYPE:
				case TEXT_ID_TYPE:
					break;
				case IMAGE_ID_TYPE:
					user_data_id = icon_id;
					break;
					default:
						return FALSE;
			}

			if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
			{
				item_image_rect  = Atest_SWEETS_GetItemDisRect(mainmenu, mainmenu->cur_item_index);

				*rect_x = (item_image_rect.left + item_image_rect.right)/2;
				*rect_y = (item_image_rect.bottom + item_image_rect.top)/2;
				return TRUE;
			}
		}
		move_page_num ++;
	}

	mainmenu->cur_page_index = pre_page_index;
	mainmenu->cur_item_index = pre_item_index;
	return FALSE;
}
#endif

#ifdef MMI_ISTYLE_SUPPORT
/*****************************************************************************/
//  Description:查找控件slide menu的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchIStyleMainMenuControlItem(
										CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										MMI_CTRL_ID_T ctrl_id,		//控件id
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y)					//out,查找到的控件坐标y
{
	uint16 page_item_num = 0;
	MMI_STRING_T text_ptr = { 0 };
       //MMI_IMAGE_ID_T  icon_id_ptr = { 0 };
       //BOOLEAN is_grayed_ptr = FALSE;
	CTRLMAINMENU_ITEM_T cur_item_info = { 0 };
	uint32 text_id = 0,icon_id = 0,user_data_id = 0;
	MMIMAINMENU_ISTYLE_DATA_T *mainmenu = NULL;
	MMIMAINMENU_ITEM_INFO_T *item_ptr = {0};

	GUI_RECT_T item_image_rect = { 0 };
	uint16 pre_item_index = 0;
	uint16 pre_page_index = 0;
	uint16 move_page_num = 0;

	if(PNULL == menu_ctrl_ptr)
	{
		return FALSE;
	}

	mainmenu =  (MMIMAINMENU_ISTYLE_DATA_T*)menu_ctrl_ptr->pm_data_ptr;
	if(!mainmenu->page_info.cnt)
	{
		return FALSE;
	}
	page_item_num = mainmenu->page_info.cnt;

	pre_page_index = mainmenu->cur_page_index; //保存当前page index
	for(;;mainmenu->cur_page_index++)
	{
		if(mainmenu->cur_page_index >= ISTYLE_PAGE_CNT_MAX)
		{
			mainmenu->cur_page_index = 0;
		}
		
		//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchQbMainMenuControlItem:page=%d/%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8431_112_2_18_1_59_42_60,(uint8*)"dd",mainmenu->cur_page_index, ISTYLE_PAGE_CNT_MAX);

		if(ISTYLE_PAGE_CNT_MAX == move_page_num)
		{
			//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchQbMainMenuControlItem:move_page_num=%d stop"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8435_112_2_18_1_59_42_61,(uint8*)"d",move_page_num);
			break;
		}

		if(!move_page_num)
		{
			pre_item_index = mainmenu->cur_item_index;//保存当前item index
		}

		pre_item_index = mainmenu->cur_item_index;//焦点所在的item
		for (mainmenu->cur_item_index = 0; mainmenu->cur_item_index <  mainmenu->page_info.page[mainmenu->cur_page_index].cnt; mainmenu->cur_item_index++)
		{
			item_ptr = mainmenu->page_info.page[mainmenu->cur_page_index].item + mainmenu->cur_item_index;
			IStyleGetItemData(mainmenu, item_ptr->menu_id, item_ptr->group_id, &cur_item_info);
			text_id = cur_item_info.text.data.text_id;
			icon_id = cur_item_info.icon.data.icon_id;

		    if (CTRL_TEXT_ID == cur_item_info.text.type )
	            {
				MMITHEME_GetResText(cur_item_info.text.data.text_id, mainmenu->win_handle, &text_ptr);
	            }
	            else
	            {
	                text_ptr.wstr_ptr = cur_item_info.text.data.str_info.wstr_ptr;
	                text_ptr.wstr_len = cur_item_info.text.data.str_info.wstr_len;
	            }			//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchQbMainMenuControlItem,MMITHEME_GetResText,icon_id=%d,text_id=%d,text=%x"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8479_112_2_18_1_59_42_64,(uint8*)"ddd",icon_id,text_id,*(text_ptr.wstr_ptr));

			switch (id_type)
			{
				case TEXT_TYPE:
				case TEXT_ID_TYPE:
					break;
				case IMAGE_ID_TYPE:
					user_data_id = icon_id;
					break;
					default:
						return FALSE;
			}

			if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
			{
				//item_image_rect = IStyleMenuGetItemRect(mainmenu, mainmenu->cur_item_index);
				item_image_rect = mainmenu->default_data.item_rect[mainmenu->cur_item_index];

				*rect_x = (item_image_rect.left + item_image_rect.right)/2;
				*rect_y = (item_image_rect.bottom + item_image_rect.top)/2;
				return TRUE;
			}
		}
		move_page_num ++;
	}

	mainmenu->cur_page_index = pre_page_index;
	mainmenu->cur_item_index = pre_item_index;
	return FALSE;
}
#endif

#ifdef PDA_UI_SUPPORT_MANIMENU_GO										 
/*****************************************************************************/
//  Description:查找控件slide menu的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchSlideMainMenuControlItem(
										CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										MMI_CTRL_ID_T ctrl_id,		//控件id
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y)					//out,查找到的控件坐标y
{
	uint16 page_item_num = 0;
	MMI_STRING_T text_ptr = { 0 };
	//MMI_IMAGE_ID_T  icon_id_ptr = { 0 };
	//BOOLEAN is_grayed_ptr = FALSE;
	CTRLMAINMENU_ITEM_T cur_item_info = { 0 };
	MMIMAINMENU_ITEM_INFO_T *item_ptr = {0};
	MMIMAINEMENU_ITEM_LIST_T  *page_item_info_ptr = PNULL;
	MMIMAINMENU_SLIDEPAGE_DATA_T* mainmenu = NULL;
	uint32 text_id = 0,icon_id = 0,user_data_id = 0;

	GUI_RECT_T item_image_rect = { 0 };
	uint16 pre_item_index = 0;
	uint16 pre_page_index = 0;
	uint16 move_page_num = 0;

	if(PNULL == menu_ctrl_ptr)
	{
		return FALSE;
	}

	mainmenu =  (MMIMAINMENU_SLIDEPAGE_DATA_T*)menu_ctrl_ptr->pm_data_ptr;
	if(!mainmenu->item_total_num)
	{
		return FALSE;
	}
	page_item_num = mainmenu->item_total_num;

	pre_page_index = mainmenu->cur_page_index; //保存当前page index
	for(;;mainmenu->cur_page_index++)
	{
		if(mainmenu->cur_page_index >= mainmenu->item_total_num)
		{
			mainmenu->cur_page_index = 0;
		}
		
		//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchQbMainMenuControlItem:page=%d/%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8431_112_2_18_1_59_42_60,(uint8*)"dd",mainmenu->cur_page_index ,mainmenu->item_total_num);

		if(mainmenu->item_total_num == move_page_num)
		{
			//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchQbMainMenuControlItem:move_page_num=%d stop"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8435_112_2_18_1_59_42_61,(uint8*)"d",move_page_num);
			break;
		}

		if(!move_page_num)
		{
			pre_item_index = mainmenu->cur_item_index;//保存当前item index
		}

		page_item_info_ptr = Atest_GetSlidePageMenuLinkListPtr(mainmenu, mainmenu->cur_page_index);
		pre_item_index = mainmenu->cur_item_index;//焦点所在的item
		for (mainmenu->cur_item_index = 0; mainmenu->cur_item_index <page_item_info_ptr->item_count; mainmenu->cur_item_index++)
		{
			if (PNULL == page_item_info_ptr)
		    	{
		    		break;
			}

			item_ptr = Atest_SlidePageMenuGetItemInfoByIndex(page_item_info_ptr, mainmenu->cur_item_index);

		        if (PNULL != item_ptr)
		        {
		            	MMIMAINMENU_GetItemData(item_ptr->menu_id,item_ptr->group_id,&cur_item_info);
		        }

			text_id = cur_item_info.text.data.text_id;
			icon_id = cur_item_info.icon.data.icon_id;

		    if (CTRL_TEXT_ID == cur_item_info.text.type )
	            {
				MMITHEME_GetResText(cur_item_info.text.data.text_id, mainmenu->win_handle, &text_ptr);
	            }
	            else
	            {
	                text_ptr.wstr_ptr = cur_item_info.text.data.str_info.wstr_ptr;
	                text_ptr.wstr_len = cur_item_info.text.data.str_info.wstr_len;
	            }			//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchQbMainMenuControlItem,MMITHEME_GetResText,icon_id=%d,text_id=%d,text=%x"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8479_112_2_18_1_59_42_64,(uint8*)"ddd",icon_id,text_id,*(text_ptr.wstr_ptr));

			switch (id_type)
			{
				case TEXT_TYPE:
				case TEXT_ID_TYPE:
					break;
				case IMAGE_ID_TYPE:
					user_data_id = icon_id;
					break;
					default:
						return FALSE;
			}

			if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
			{
				item_image_rect = Atest_GetSlideMenuItemRect(mainmenu, mainmenu->cur_item_index);

				*rect_x = (item_image_rect.left + item_image_rect.right)/2;
				*rect_y = (item_image_rect.top + item_image_rect.bottom)/2;
				return TRUE;
			}
		}
		move_page_num ++;
	}

	mainmenu->cur_page_index = pre_page_index;
	mainmenu->cur_item_index = pre_item_index;
	return FALSE;
}
#endif

/*****************************************************************************/
//  Description:查找控件pop menu的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:针对second，third，pop menu
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchPopMenuControlItem(
										CTRLMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										IGUICTRL_T *ctrl_ptr,			//控件指针
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16  item_height,			//item高度
										uint16  item_space,				//item之间的距离
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y)					//out,查找到的控件坐标y
{
	uint16 item_index = 0;
	uint16 cur_item_index = 0;
	uint16 index_offset = 0;
	MMI_STRING_T text_ptr = {0};
	MMI_IMAGE_ID_T  icon_id_ptr = 0;
	uint32 icon_id = 0,user_data_id = 0;
	BOOLEAN is_grayed_ptr = FALSE;
	GUI_RECT_T item_rect = {0};

	if(PNULL == menu_ctrl_ptr)
	{
		return FALSE;
	}

	if(!((item_height+item_space) && menu_ctrl_ptr->item_total_num))
	{
		return FALSE;
	}

	cur_item_index = menu_ctrl_ptr->cur_item_index;

	for ( menu_ctrl_ptr->cur_item_index = 0;  menu_ctrl_ptr->cur_item_index < menu_ctrl_ptr->item_total_num; menu_ctrl_ptr->cur_item_index++)
	{
		SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
		CTRLMENU_GetItem(menu_ctrl_ptr,menu_ctrl_ptr->cur_item_index,&text_ptr,&icon_id_ptr,&is_grayed_ptr);
		switch (id_type)
		{
			case TEXT_TYPE:
			case TEXT_ID_TYPE:
				break;
			case IMAGE_ID_TYPE:
				user_data_id = icon_id;
				break;
				default:
					return FALSE;
		}

		if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
		{
			item_index = menu_ctrl_ptr->cur_item_index;
			menu_ctrl_ptr->cur_item_index = cur_item_index;

			if(item_index > menu_ctrl_ptr->cur_item_index) //需要下移
			{	
				index_offset = item_index - cur_item_index;
				
				//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchPopMenuControlItem,down:cur_item_index=%d,index_offset=%d"
				SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8957_112_2_18_1_59_43_66,(uint8*)"dd",cur_item_index,index_offset);

				if(index_offset >0 )
				{
					Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),index_offset,ATEST_SIGNAL_KB_DOWN);
					return FALSE;
				}
			}
			else if(item_index < menu_ctrl_ptr->cur_item_index) //需要上移
			{
				index_offset = cur_item_index - item_index;

				//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchPopMenuControlItem,up:cur_item_index=%d,index_offset=%d"
				SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8969_112_2_18_1_59_43_67,(uint8*)"dd",cur_item_index,index_offset);
				
				if(index_offset >0 )
				{
					Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),index_offset,ATEST_SIGNAL_KB_UP);
					return FALSE;
				}
			}

			if(GUIMENU_STYLE_SECOND == menu_ctrl_ptr->cur_style 	//second third
				|| GUIMENU_STYLE_THIRD == menu_ctrl_ptr->cur_style )
			{
				item_rect = menu_ctrl_ptr->item_pos_info_ptr[item_index].item_rect;
			}
			else		//pop
			{
				Atest_GetPopmenuItemTextRect( item_index,menu_ctrl_ptr,&item_rect);
			}

			if(Atest_GetValidTPPoint(item_rect,menu_ctrl_ptr->base_ctrl.rect,rect_x,rect_y))
			{			
				return TRUE;
			}
		}
	}

	menu_ctrl_ptr->cur_item_index = cur_item_index;	
	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件MENU 的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_OPTIONS 
/*****************************************************************************/
LOCAL BOOLEAN Atest_SearchOptionMenuControlItem( 
										CTRLMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										IGUICTRL_T *ctrl_ptr,			//控件指针
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y)					//out,查找到的控件坐标y
{
	uint16 item_index = 0; 
	MMI_STRING_T text_ptr = { 0 };
    MMI_IMAGE_ID_T  user_data_id = 0,icon_id_ptr = 0;
    BOOLEAN  is_grayed_ptr = FALSE;

	if(PNULL == menu_ctrl_ptr)
	{
		return FALSE;
	}
	
	if(!menu_ctrl_ptr->item_total_num)
	{
		return FALSE;
	}

	for (item_index = 0; item_index < menu_ctrl_ptr->item_total_num; item_index++)
	{
		switch (id_type)
		{
			case TEXT_TYPE:
			case TEXT_ID_TYPE:
				break;
			case IMAGE_ID_TYPE:
				user_data_id = icon_id_ptr;
				break;
				default:
					return FALSE;
		}

		if(!menu_ctrl_ptr->options_item_info_ptr[item_index].is_more_item)
		{
			SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
			if(!CTRLMENU_GetItem(menu_ctrl_ptr,item_index,&text_ptr,&icon_id_ptr,&is_grayed_ptr))
			{
				break;
			}			
		}
		else	//more item
		{	
			MMITHEME_GetResText(menu_ctrl_ptr->options_theme.more_item_text_id, menu_ctrl_ptr->win_handle, &text_ptr);
		}

		if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
		{
			//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchOptionMenuControlItem:Find index=%d"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_9210_112_2_18_1_59_44_71,(uint8*)"d",item_index);
			if(Atest_GetValidTPPoint(menu_ctrl_ptr->options_item_info_ptr[item_index].rect,menu_ctrl_ptr->base_ctrl.rect,rect_x,rect_y))
			{			
				return TRUE;
			}
		}
	}

	return FALSE;
}


/*****************************************************************************/
//  Description:查找控件list 的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note: byIndex
/*****************************************************************************/
LOCAL BOOLEAN Atest_SearchListByIndex(
									    CTRLLIST_OBJ_T *list_ctrl_ptr,	//list控件指针
									    MMI_HANDLE_T ctrl_handle,		//控件handle
									    uint16 page_item_num,			//每页的item数
									    uint8 *user_data_ptr,			//查找数据
									    uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y)					//out,查找到的控件坐标y
{
	uint32 message_decode = 0;
	uint16 item_index = 0;
	uint16 cur_item_idx = 0;
	uint16 index_offset = 0;
	CTRLLIST_ITEM_T *list_item_ptr = PNULL;
	GUI_RECT_T  clip_rect_ptr = {0};

	uint8 *start_ptr = user_data_ptr;
	if(PNULL == start_ptr)
	{
		return FALSE;
	}

	message_decode = Atest_GetTestMessageId(',',&start_ptr);
	message_decode = Atest_GetTestMessageId(',',&start_ptr);	//at收到的index

	for(item_index = 0; item_index < list_ctrl_ptr->total_item_num; item_index++)
	{
		//SCI_TRACE_LOW:"[Atest_SearchListByIndex]-searchitemindex=%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_9252_112_2_18_1_59_44_72,(uint8*)"d",item_index);

		list_item_ptr = (CTRLLIST_ITEM_T*)CTRLLIST_GetItem(ctrl_handle, item_index);
		if (PNULL == list_item_ptr)
		{
			continue;
		}

		if(item_index!=message_decode)
		{
			continue;
		}
		else
		{
			if(item_index > list_ctrl_ptr->cur_item_idx)
			{
				cur_item_idx = list_ctrl_ptr->cur_item_idx;
				index_offset = item_index - cur_item_idx;
				if(index_offset >0 )
				{
					Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),index_offset,ATEST_SIGNAL_KB_DOWN);
					return FALSE;
				}
			}
			else if(item_index <  list_ctrl_ptr->cur_item_idx)//上移
			{
				cur_item_idx = list_ctrl_ptr->cur_item_idx;
				index_offset = cur_item_idx - item_index;
				if(index_offset >0 )
				{
					Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),index_offset,ATEST_SIGNAL_KB_UP);
					return FALSE;
				}
			}

			GUILIST_GetItemRect(ctrl_handle,item_index,&clip_rect_ptr);
			if(Atest_GetValidTPPoint(clip_rect_ptr,list_ctrl_ptr->base_ctrl.rect,rect_x,rect_y))
			{			
				return TRUE;
			}
		}
	}

	return FALSE; 		
}


/*****************************************************************************/
//  Description:查找控件list 的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note: byimgIndex
/*****************************************************************************/
LOCAL BOOLEAN Atest_SearchListByImgIndex(
										    CTRLLIST_OBJ_T *list_ctrl_ptr,	//list控件指针
										    MMI_HANDLE_T ctrl_handle,		//控件handle
										    MMI_CTRL_ID_T ctrl_id,			//控件id
										    uint16 page_item_num,			//每页的item数
										    uint8 *user_data_ptr,			//查找数据
										    uint16 *rect_x,					//out,查找到的控件坐标x
											uint16 *rect_y)					//out,查找到的控件坐标y

{

	uint32 message_decode = 0;
	uint16 item_index = 0;
	uint16 cur_item_idx = 0;
	uint16 index_offset = 0;
	CTRLLIST_ITEM_T *list_item_ptr = PNULL;
	GUI_RECT_T  clip_rect_ptr = {0};
	GUI_RECT_T  disp_rect_ptr = {0};
	GUI_RECT_T con_rect = {0};
	GUILIST_ITEM_DATA_T *item_data_ptr = PNULL;
	uint32 user_data_id =0;
	int j = 0;
	uint32 SelectFlag = 0;

	uint8 *start_ptr = user_data_ptr;
	if(PNULL == start_ptr)
	{
		return FALSE;
	}

	message_decode = Atest_GetTestMessageId(',',&start_ptr);	//at收到的index

	for(item_index = 0; item_index < list_ctrl_ptr->total_item_num; item_index++)
	{
		//SCI_TRACE_LOW:"[Atest_SearchListByImgIndex]-searchitemindex=%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_9334_112_2_18_1_59_44_73,(uint8*)"d",item_index);

		list_item_ptr = (CTRLLIST_ITEM_T*)CTRLLIST_GetItem(ctrl_handle, item_index);
		if (PNULL == list_item_ptr)
		{
			continue;
		}

		if(item_index!=message_decode)
		{
			continue;
		}
		else
		{
			item_data_ptr = list_item_ptr->data_ptr;
			if (PNULL == item_data_ptr)
			{
				break;
			}

			message_decode = Atest_GetTestMessageId(',',&start_ptr);	//at收到的image id
			SelectFlag = Atest_GetTestMessageId(',',&start_ptr);
			
			for (j = 0; j < GUIITEM_CONTENT_MAX_NUM; j++)
			{
				if(GUIITEM_DATA_IMAGE_ID == item_data_ptr->item_content[j].item_data_type)
				{
					con_rect = list_item_ptr->style_ptr->content[j].rect;
					user_data_id = item_data_ptr->item_content[j].item_data.image_id;
					if(2 == SelectFlag)	//click
					{
						 if(user_data_id == list_ctrl_ptr->display_style.radio_selected_image_id ||
						 	user_data_id == list_ctrl_ptr->display_style.radio_unselected_image_id)
						 {
							 user_data_id = list_ctrl_ptr->display_style.radio_unselected_image_id;
						 }
						 else if(user_data_id == list_ctrl_ptr->display_style.check_selected_image_id ||
							 user_data_id == list_ctrl_ptr->display_style.check_unselected_image_id)
						 {
							 user_data_id = list_ctrl_ptr->display_style.check_unselected_image_id;
						 }
					}
					else if(1 == SelectFlag)	//select
					{
						if(user_data_id == list_ctrl_ptr->display_style.radio_selected_image_id ||
							user_data_id == list_ctrl_ptr->display_style.check_selected_image_id)
						{
							return FALSE; 
						}
					}
					else if(0 == SelectFlag)	//unselect
					{
						if(user_data_id == list_ctrl_ptr->display_style.radio_selected_image_id)
						{
							user_data_id = list_ctrl_ptr->display_style.radio_unselected_image_id;
						}
						else if(user_data_id == list_ctrl_ptr->display_style.check_selected_image_id)
						{
							user_data_id = list_ctrl_ptr->display_style.check_unselected_image_id;
						}
						else
						{
							return FALSE; 
						}
				}
				}
				else
				{
					continue;
				}

				if(item_index > list_ctrl_ptr->cur_item_idx)
				{
					cur_item_idx = list_ctrl_ptr->cur_item_idx;
					index_offset = item_index - cur_item_idx;
					if(index_offset >0 )
					{
						Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),index_offset,ATEST_SIGNAL_KB_DOWN);
						return FALSE;
					}
				}
				else if(item_index <  list_ctrl_ptr->cur_item_idx)//上移
				{
					cur_item_idx = list_ctrl_ptr->cur_item_idx;
					index_offset = cur_item_idx - item_index;
					if(index_offset >0 )
					{
						Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),index_offset,ATEST_SIGNAL_KB_UP);
						return FALSE;
					}
				}

				if(user_data_id == message_decode)
				{
					if(Atest_GetItemContentRect(ctrl_id,item_index,j,&disp_rect_ptr,&clip_rect_ptr))
					//if(GUILIST_GetItemRect(ctrl_id,item_index,&clip_rect_ptr))
					{
						clip_rect_ptr.left = con_rect.left;
						clip_rect_ptr.right = con_rect.right;
						if(Atest_GetValidTPPoint(clip_rect_ptr,list_ctrl_ptr->base_ctrl.rect,rect_x,rect_y))
						{			
							return TRUE;
						}
					}
				}
			}
		}
	}

	return FALSE; 
}

/*****************************************************************************/
//  Description:查找控件list 的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note: bytextimg
/*****************************************************************************/
LOCAL BOOLEAN Atest_SearchListByTextImg(
										    CTRLLIST_OBJ_T *list_ctrl_ptr,	//list控件指针
										    MMI_HANDLE_T ctrl_handle,		//控件handle
										    MMI_CTRL_ID_T ctrl_id,			//控件id
										    uint16 page_item_num,			//每页的item数
										    uint8 *user_data_ptr,			//查找数据
										    uint16 *rect_x,					//out,查找到的控件坐标x
											uint16 *rect_y)					//out,查找到的控件坐标y
{
	uint32 message_decode = 0;
	uint16 item_index = 0;
	uint16 cur_item_idx = 0;
	uint16 index_offset = 0;
	CTRLLIST_ITEM_T *list_item_ptr = PNULL;
	GUI_RECT_T  clip_rect_ptr = {0};
	GUI_RECT_T  disp_rect_ptr = {0};
	GUI_RECT_T con_rect = {0};
	GUILIST_ITEM_DATA_T *item_data_ptr = PNULL;
	uint32 user_data_id =0;
	int j = 0;
	MMI_STRING_T text_ptr = {0};

	//解决buffer地址变化，导致字节对齐错误assert
	wchar *temp_buffer_ptr = PNULL;
	uint16 temp_buffer_len = 0;
	wchar *user_item_ptr = NULL;

	uint8 *start_ptr = user_data_ptr;
	if(PNULL == start_ptr)
	{
		return FALSE;
	}

	user_item_ptr = (wchar *)SCI_ALLOC_APP(ATEST_MAX_STR_LEN);
	if (user_item_ptr == PNULL)
	{
	    return FALSE;    
	}
	//SCI_TRACE_LOW:"[Atest_SearchListByTextImg]--%x--%x--%x--%x--%x,"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_9455_112_2_18_1_59_44_74,(uint8*)"ddddd",user_item_ptr,user_item_ptr[0],user_item_ptr[1],user_item_ptr[ATEST_MAX_STR_LEN-2],user_item_ptr[ATEST_MAX_STR_LEN-1]);
	message_decode = Atest_GetTestMessageId(',',&start_ptr);	//at收到的img id

	for(item_index = 0; item_index < list_ctrl_ptr->total_item_num; item_index++)
	{
		//SCI_TRACE_LOW:"[Atest_SearchListByTextImg]-searchitemindex=%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_9460_112_2_18_1_59_45_75,(uint8*)"d",item_index);

		list_item_ptr = (CTRLLIST_ITEM_T*)CTRLLIST_GetItem(ctrl_handle, item_index);
		if (PNULL == list_item_ptr)
		{
			continue;
		}
		
		item_data_ptr = list_item_ptr->data_ptr;
		if (PNULL == item_data_ptr)
		{
			continue;
		}
		
		for (j = 0; j < GUIITEM_CONTENT_MAX_NUM; j++)
		{
			con_rect = list_item_ptr->style_ptr->content[j].rect;
			if(GUIITEM_DATA_TEXT_ID == item_data_ptr->item_content[j].item_data_type)
			{
				SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
				MMITHEME_GetResText(item_data_ptr->item_content[j].item_data.text_id, ctrl_handle, &text_ptr);
			}
			else if(GUIITEM_DATA_TEXT_BUFFER == item_data_ptr->item_content[j].item_data_type)
			{
				temp_buffer_ptr = item_data_ptr->item_content[j].item_data.text_buffer.wstr_ptr;
				temp_buffer_len = item_data_ptr->item_content[j].item_data.text_buffer.wstr_len;
				//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchListByTextImg:Save buffer data! len=%d\n"
				SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_9486_112_2_18_1_59_45_76,(uint8*)"d", temp_buffer_len);
				
				// 写越界可能
				if (temp_buffer_len >= ATEST_MAX_STR_LEN/2)
				{
				    temp_buffer_len = ATEST_MAX_STR_LEN/2 - 1;
				}
				        
				// 解决buffer地址变化，导致字节对齐错误assert						 					
				if (temp_buffer_len != 0)
				{
					SCI_MEMCPY((char *)user_item_ptr, (char *)temp_buffer_ptr, temp_buffer_len * 2);
				}
				user_item_ptr[temp_buffer_len] = L'\0';
				text_ptr.wstr_ptr = user_item_ptr;
				text_ptr.wstr_len = temp_buffer_len;
			}
			else
			{
				continue;
			}

			cur_item_idx = list_ctrl_ptr->cur_item_idx;

			//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchListByTextImg:item_index-%d,content_index=%d"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_9510_112_2_18_1_59_45_77,(uint8*)"dd",item_index,j);
			
			if(Atest_Compare_content(TEXT_IMG_TYPE,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
			{
				for (j = 0; j < GUIITEM_CONTENT_MAX_NUM; j++)
				{
					if(GUIITEM_DATA_IMAGE_ID == item_data_ptr->item_content[j].item_data_type)
					{
						con_rect = list_item_ptr->style_ptr->content[j].rect;
						user_data_id = item_data_ptr->item_content[j].item_data.image_id;
						if(user_data_id == list_ctrl_ptr->display_style.radio_selected_image_id ||
							user_data_id == list_ctrl_ptr->display_style.radio_unselected_image_id)
						{
						   user_data_id = list_ctrl_ptr->display_style.radio_unselected_image_id;
						}
						else if(user_data_id == list_ctrl_ptr->display_style.check_selected_image_id ||
						 user_data_id == list_ctrl_ptr->display_style.check_unselected_image_id)
						{
							user_data_id = list_ctrl_ptr->display_style.check_unselected_image_id;
						}

						if(message_decode == user_data_id)
						{
							if(Atest_GetItemContentRect(ctrl_id,item_index,j,&disp_rect_ptr,&clip_rect_ptr))
							//if(GUILIST_GetItemRect(ctrl_id,item_index,&clip_rect_ptr))
							{
								clip_rect_ptr.left = con_rect.left;
								clip_rect_ptr.right = con_rect.right;
								if(!Atest_GetValidTPPoint(clip_rect_ptr,list_ctrl_ptr->base_ctrl.display_rect,rect_x,rect_y))
								{			
									if(item_index > list_ctrl_ptr->cur_item_idx) //下移
									{
										list_ctrl_ptr->cur_item_idx = list_ctrl_ptr->top_item_idx + page_item_num;
										cur_item_idx = list_ctrl_ptr->cur_item_idx;
										index_offset = item_index - cur_item_idx;
										if(index_offset >0 )
										{
											Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),index_offset,ATEST_SIGNAL_KB_DOWN);
											SCI_FREE(user_item_ptr);
											return FALSE;
										}
									}
									else if(item_index < list_ctrl_ptr->cur_item_idx)//上移
									{
										list_ctrl_ptr->cur_item_idx = list_ctrl_ptr->top_item_idx;
										cur_item_idx = list_ctrl_ptr->cur_item_idx;
										index_offset = cur_item_idx - item_index;
										if(index_offset >0 )
										{
											Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),index_offset,ATEST_SIGNAL_KB_UP);
											SCI_FREE(user_item_ptr);
											return FALSE;
										}
									}
									else
									{
										if(clip_rect_ptr.bottom > list_ctrl_ptr->base_ctrl.display_rect.bottom)
										{
											Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),index_offset,ATEST_SIGNAL_KB_DOWN);
											SCI_FREE(user_item_ptr);
											return FALSE;								
										}
										else if(clip_rect_ptr.top < list_ctrl_ptr->base_ctrl.display_rect.top)
										{
											Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),index_offset,ATEST_SIGNAL_KB_UP);
											SCI_FREE(user_item_ptr);
											return FALSE;
										}
									}
								}
							}

							if(Atest_GetItemContentRect(ctrl_handle,item_index,j,&disp_rect_ptr,&clip_rect_ptr))
							//if(GUILIST_GetItemRect(ctrl_id,item_index,&clip_rect_ptr))
							{
								clip_rect_ptr.left = con_rect.left;
								clip_rect_ptr.right = con_rect.right;
								if(Atest_GetValidTPPoint(clip_rect_ptr,list_ctrl_ptr->base_ctrl.display_rect,rect_x,rect_y))
								{			
									SCI_FREE(user_item_ptr);
									return TRUE;
								}
							}
						}
					}
				}
			}
		}
	}

	SCI_FREE(user_item_ptr);
	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件list 的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note: bytext imgid
/*****************************************************************************/
LOCAL BOOLEAN Atest_SearchListByTextAndImgID(
										    CTRLLIST_OBJ_T *list_ctrl_ptr,	//list控件指针
										    MMI_HANDLE_T ctrl_handle,		//控件handle
										    MMI_CTRL_ID_T ctrl_id,			//控件id
										    ATEST_ID_TYPE_E id_type,		//查找类型
										    uint16 page_item_num,			//每页的item数
										    uint8 *user_data_ptr,			//查找数据
										    uint16 *rect_x,					//out,查找到的控件坐标x
											uint16 *rect_y)					//out,查找到的控件坐标y

{
	uint32 message_decode = 0;
	uint16 item_index = 0;
	uint16 cur_item_idx = 0;
	uint16 index_offset = 0;
	CTRLLIST_ITEM_T *list_item_ptr = PNULL;
	GUI_RECT_T  clip_rect_ptr = {0};
	GUI_RECT_T  disp_rect_ptr = {0};
	GUI_RECT_T con_rect = {0};
	GUILIST_ITEM_DATA_T *item_data_ptr = PNULL;
	uint32 user_data_id =0;
	int j = 0;
	MMI_STRING_T text_ptr = {0};

	//解决buffer地址变化，导致字节对齐错误assert
	wchar *temp_buffer_ptr = PNULL;
	uint16 temp_buffer_len = 0;
	wchar *user_item_ptr = NULL;

	uint8 *start_ptr = user_data_ptr;
	if(PNULL == start_ptr)
	{
		return FALSE;
	}

	user_item_ptr = (wchar *)SCI_ALLOC_APP(ATEST_MAX_STR_LEN);
	if (user_item_ptr == PNULL)
	{
	    return FALSE;    
	}

	//SCI_TRACE_LOW:"[Atest_SearchListByTextAndImgID]--%x--%x--%x--%x--%x,"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_9641_112_2_18_1_59_45_78,(uint8*)"ddddd",user_item_ptr,user_item_ptr[0],user_item_ptr[1],user_item_ptr[ATEST_MAX_STR_LEN-2],user_item_ptr[ATEST_MAX_STR_LEN-1]);

	message_decode = Atest_GetTestMessageId(',',&start_ptr);	//at收到的img id

	for(item_index = 0; item_index < list_ctrl_ptr->total_item_num; item_index++)
	{
		//SCI_TRACE_LOW:"[Atest_SearchListByTextAndImgID]-searchitemindex=%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_9647_112_2_18_1_59_45_79,(uint8*)"d",item_index);

		list_item_ptr = (CTRLLIST_ITEM_T *)CTRLLIST_GetItem(ctrl_handle, item_index);
		if (PNULL == list_item_ptr)
		{
			continue;
		}

		item_data_ptr = list_item_ptr->data_ptr;
		if (PNULL == item_data_ptr)
		{
			continue;
		}
		for (j = 0; j < GUIITEM_CONTENT_MAX_NUM; j++)
		{
			con_rect = list_item_ptr->style_ptr->content[j].rect;
			switch (id_type)
			{
				case TEXT_TYPE:
				case TEXT_ID_TYPE:
					if(GUIITEM_DATA_TEXT_ID == item_data_ptr->item_content[j].item_data_type)
					{
						SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
						MMITHEME_GetResText(item_data_ptr->item_content[j].item_data.text_id, ctrl_handle, &text_ptr);
					}
					else if(GUIITEM_DATA_TEXT_BUFFER == item_data_ptr->item_content[j].item_data_type)
					{
						temp_buffer_ptr = item_data_ptr->item_content[j].item_data.text_buffer.wstr_ptr;
						temp_buffer_len = item_data_ptr->item_content[j].item_data.text_buffer.wstr_len;
						//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchListByTextAndImgID:Save buffer data! len=%d\n"
						SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_9676_112_2_18_1_59_45_80,(uint8*)"d", temp_buffer_len);
						
						// 写越界可能
						if (temp_buffer_len >= ATEST_MAX_STR_LEN/2)
						{
						    temp_buffer_len = ATEST_MAX_STR_LEN/2 - 1;
						}
						        
						// 解决buffer地址变化，导致字节对齐错误assert						 					
						if (temp_buffer_len != 0)
						{
							SCI_MEMCPY((char *)user_item_ptr, (char *)temp_buffer_ptr, temp_buffer_len * 2);
						}
						user_item_ptr[temp_buffer_len] = L'\0';
						text_ptr.wstr_ptr = user_item_ptr;
						text_ptr.wstr_len = temp_buffer_len;
					}
					else
					{
						continue;
					}
					break;
				case IMAGE_ID_TYPE:
					if(GUIITEM_DATA_IMAGE_ID == item_data_ptr->item_content[j].item_data_type)
					{
						user_data_id = item_data_ptr->item_content[j].item_data.image_id;
						if(user_data_id == list_ctrl_ptr->display_style.radio_selected_image_id ||
						    user_data_id == list_ctrl_ptr->display_style.radio_unselected_image_id)
						{
						   user_data_id = list_ctrl_ptr->display_style.radio_unselected_image_id;
						}
						else if(user_data_id == list_ctrl_ptr->display_style.check_selected_image_id ||
						 user_data_id == list_ctrl_ptr->display_style.check_unselected_image_id)
						{
						    user_data_id = list_ctrl_ptr->display_style.check_unselected_image_id;
						}
					}
					else
					{
						continue;
					}
					break;
					default:
						break;
			}

			cur_item_idx = list_ctrl_ptr->cur_item_idx;

			//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchListByTextAndImgID:item_index-%d,content_index=%d,content_type=%d"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_9724_112_2_18_1_59_45_81,(uint8*)"ddd",item_index,j,id_type);
			
			if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
			{
				Atest_GetItemContentRect(ctrl_id,item_index,j,&disp_rect_ptr,&clip_rect_ptr);
				//GUILIST_GetItemRect(ctrl_id,item_index,&clip_rect_ptr);
			
				if(!Atest_GetValidTPPoint(clip_rect_ptr,list_ctrl_ptr->base_ctrl.display_rect,rect_x,rect_y))
				{			
					if(item_index > list_ctrl_ptr->cur_item_idx) //下移
					{
						list_ctrl_ptr->cur_item_idx = list_ctrl_ptr->top_item_idx + page_item_num;
						cur_item_idx = list_ctrl_ptr->cur_item_idx;
						index_offset = item_index - cur_item_idx;
						if(index_offset >0 )
						{
							Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),index_offset,ATEST_SIGNAL_KB_DOWN);
							SCI_FREE(user_item_ptr);
							return FALSE;
						}
					}
					else if(item_index < list_ctrl_ptr->cur_item_idx)//上移
					{
						list_ctrl_ptr->cur_item_idx = list_ctrl_ptr->top_item_idx;
						cur_item_idx = list_ctrl_ptr->cur_item_idx;
						index_offset = cur_item_idx - item_index;
						if(index_offset >0 )
						{
							Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),index_offset,ATEST_SIGNAL_KB_UP);
							SCI_FREE(user_item_ptr);
							return FALSE;
						}
					}
					else
					{
						if(clip_rect_ptr.bottom > list_ctrl_ptr->base_ctrl.display_rect.bottom)
						{
							Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),index_offset,ATEST_SIGNAL_KB_DOWN);
							SCI_FREE(user_item_ptr);
							return FALSE;									
						}
						else if(clip_rect_ptr.top < list_ctrl_ptr->base_ctrl.display_rect.top)
						{
							Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),index_offset,ATEST_SIGNAL_KB_UP);
							SCI_FREE(user_item_ptr);
							return FALSE;
						}
					}
				}

				if(Atest_GetItemContentRect(ctrl_id,item_index,j,&disp_rect_ptr,&clip_rect_ptr))
				//if(GUILIST_GetItemRect(ctrl_id,item_index,&clip_rect_ptr))
				{
					clip_rect_ptr.left = con_rect.left;
					clip_rect_ptr.right = con_rect.right;
					if(Atest_GetValidTPPoint(clip_rect_ptr,list_ctrl_ptr->base_ctrl.display_rect,rect_x,rect_y))
					{			
						SCI_FREE(user_item_ptr);
						return TRUE;
					}
				}
			}
		}
	}

	SCI_FREE(user_item_ptr);
	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件list，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持name查找
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchListControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	
	CTRLLIST_OBJ_T *list_ctrl_ptr = PNULL;
	uint16 page_item_num = 0;
	uint16 getitemnum = 0;
	uint8 *start_ptr = user_data_ptr;
	if(PNULL == start_ptr)
	{
		return FALSE;
	}

	list_ctrl_ptr = ( CTRLLIST_OBJ_T *)ctrl_ptr;
	if(PNULL == list_ctrl_ptr)
	{
		return FALSE;
	}

	if(!list_ctrl_ptr->total_item_num)
	{
		return FALSE;
	}

	if(!(list_ctrl_ptr->total_item_height/list_ctrl_ptr->total_item_num))
	{
		return FALSE;
	}

	//SCI_TRACE_LOW:"[Atest_SearchListControlItem]totalnum=%d,itemheight=%d"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_9827_112_2_18_1_59_45_82,(uint8*)"dd",list_ctrl_ptr->total_item_num,list_ctrl_ptr->total_item_height/list_ctrl_ptr->total_item_num);

	page_item_num =( list_ctrl_ptr->base_ctrl.display_rect.bottom-list_ctrl_ptr->base_ctrl.display_rect.top)/(list_ctrl_ptr->total_item_height/list_ctrl_ptr->total_item_num);
	getitemnum = GUILIST_GetPageItemNum(ctrl_handle);
	page_item_num = MIN(getitemnum,page_item_num);

	if(!page_item_num)//每页可存放的item数
	{
		return FALSE;
	}

	switch (id_type)
	{
		case INDEX_ID_TYPE:
			if(Atest_SearchListByIndex(list_ctrl_ptr,ctrl_handle,page_item_num,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
			break;
		case IMAGE_INDEX_TYPE:
			if(Atest_SearchListByImgIndex(list_ctrl_ptr,ctrl_id,ctrl_handle,page_item_num,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
			break;
		case TEXT_IMG_TYPE:
			if(Atest_SearchListByTextImg(list_ctrl_ptr,ctrl_id,ctrl_handle,page_item_num,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
			break;
		default:
			if(TEXT_TYPE== id_type || IMAGE_ID_TYPE==id_type ||TEXT_ID_TYPE==id_type)
			{
				if(Atest_SearchListByTextAndImgID(list_ctrl_ptr,ctrl_id,ctrl_handle,id_type,page_item_num,user_data_ptr,rect_x,rect_y))
				{
					return TRUE;
				}
			}				
			break;
	}
	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件Setlist，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持控件id,字符串查找
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchSetlistControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	
	CTRLSETLIST_OBJ_T *setlist_ptr = PNULL;
	MMI_STRING_T text_ptr = {0};
	MMI_IMAGE_ID_T user_data_id = 0;

	setlist_ptr = (CTRLSETLIST_OBJ_T *)ctrl_ptr;
	if(PNULL == setlist_ptr)
	{
		return FALSE;
	}
	
	if(PNULL == user_data_ptr)
	{
		return FALSE;
	}

	switch (id_type)
	{
		case CONTROL_ID_TYPE:
			user_data_id = ctrl_id;
			break;
		case TEXT_TYPE:
		case TEXT_ID_TYPE:
			text_ptr.wstr_ptr = setlist_ptr->disp_str.wstr_ptr;
			text_ptr.wstr_len = setlist_ptr->disp_str.wstr_len;
			break;
			default:
				return FALSE;
	}

	if(setlist_ptr->is_valid)
	{
		if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
		{
			if(0 == setlist_ptr->base_ctrl.display_rect.bottom
				&& 0 == setlist_ptr->base_ctrl.display_rect.left
				&& 0 == setlist_ptr->base_ctrl.display_rect.top
				&& 0 == setlist_ptr->base_ctrl.display_rect.right) //未显示
			{
				if(setlist_ptr->base_ctrl.rect.top < ATEST_RECT_LIMIT) //需上翻
				{
					Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_UP);
					return FALSE;
							
				}
				else if(setlist_ptr->base_ctrl.rect.bottom > ATEST_RECT_LIMIT) //需下翻
				{
					Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_DOWN);
					return FALSE;
				}
			}
			
			*rect_x = (setlist_ptr->base_ctrl.display_rect.left+setlist_ptr->base_ctrl.display_rect.right)/2;
			*rect_y = (setlist_ptr->base_ctrl.display_rect.bottom+setlist_ptr->base_ctrl.display_rect.top)/2;
			return TRUE;
		}
	}

	return FALSE;
}


/*****************************************************************************/
//  Description:查找控件Button，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持控件id查找
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchButtonControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	CTRLBUTTON_OBJ_T  *button_ctrl_ptr = PNULL;
	
    button_ctrl_ptr = (CTRLBUTTON_OBJ_T *)ctrl_ptr;
	if(PNULL == button_ctrl_ptr)
	{
		return FALSE;
	}
	
	switch (id_type)
	{
		case CONTROL_ID_TYPE:
			user_data_id = ctrl_id;
			break;
		case TEXT_TYPE:
		case TEXT_ID_TYPE:
			if (GUISTR_TEXT_ID == button_ctrl_ptr->text_info.text_type)
			{
			   MMITHEME_GetResText( button_ctrl_ptr->text_info.text_id, button_ctrl_ptr->win_handle, &text_ptr );
			}
			else if (GUISTR_TEXT_BUFFER == button_ctrl_ptr->text_info.text_type)
			{
				text_ptr.wstr_ptr = button_ctrl_ptr->text_info.str_info.wstr_ptr;
				text_ptr.wstr_len = button_ctrl_ptr->text_info.str_info.wstr_len;
			}
			break;
			default:
				return FALSE;
	}
	
	if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
	{
		if(0 == button_ctrl_ptr->base_ctrl.display_rect.bottom
			&& 0 == button_ctrl_ptr->base_ctrl.display_rect.left
			&& 0 == button_ctrl_ptr->base_ctrl.display_rect.top
			&& 0 == button_ctrl_ptr->base_ctrl.display_rect.right) //未显示
		{
			if(button_ctrl_ptr->base_ctrl.rect.top < ATEST_RECT_LIMIT) //需上翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_UP);
				return FALSE;
						
			}
			else if(button_ctrl_ptr->base_ctrl.rect.bottom > ATEST_RECT_LIMIT) //需下翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_DOWN);
				return FALSE;
			}
		}
		
		*rect_x = (button_ctrl_ptr->base_ctrl.display_rect.left+button_ctrl_ptr->base_ctrl.display_rect.right)/2;
		*rect_y = (button_ctrl_ptr->base_ctrl.display_rect.bottom+button_ctrl_ptr->base_ctrl.display_rect.top)/2;
		return TRUE;
	}
	
	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件tab，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持text,image id查找
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchTabControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	uint8 index_offset = 0;
	uint16 index = 0;
	uint16 start_index = 0;
	uint16 end_index = 0;
	uint16 cur_index = 0;
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_IMAGE_ID_T image_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	CTRLTAB_OBJ_T *tab_ptr = NULL;
	GUITAB_ITEM_T	*item_ptr = PNULL;

	tab_ptr = (CTRLTAB_OBJ_T *)ctrl_ptr;
	if(PNULL == tab_ptr)
	{
		return FALSE;
	}

	item_ptr = tab_ptr->valid_item_list.item_ptr;

	start_index = tab_ptr->start_show_item_index;
	end_index = tab_ptr->show_item_num + tab_ptr->start_show_item_index - 1;
	cur_index = tab_ptr->cur_sel_item_index;

	for(index=0; index < tab_ptr->valid_item_list.item_num; index++)
	{
		if(PNULL == item_ptr)
		{
			return FALSE;
		}

		switch (item_ptr->item_data_ptr->image_data.image_data_type)
		{
		    case TABITEM_DATA_IMAGE_ID:		/*!< 图片资源ID*/
				image_id = item_ptr->item_data_ptr->image_data.image_data_u.anim_data.img_id;
				break;						
		    case TABITEM_DATA_ANIM_ID:			/*!< 动画资源ID*/
				image_id = item_ptr->item_data_ptr->image_data.image_data_u.anim_data.anim_id;
				break;						
		    case TABITEM_DATA_ANIM_DATA:	/*!< 动画数据*/
		    case TABITEM_DATA_ANIM_PATH:/*!< 动画路径*/
			default:
				break;
		}
		SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
		switch (id_type)
		{
			case TEXT_TYPE:
			case TEXT_ID_TYPE:
				text_ptr.wstr_ptr = item_ptr->item_data_ptr->text_data.text.text_buffer.wstr;
				text_ptr.wstr_len = item_ptr->item_data_ptr->text_data.text.text_buffer.wstr_len;
				break;
			case IMAGE_ID_TYPE:
				user_data_id = image_id;
				break;
				default:
					return FALSE;
		}

		if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
		{
			if(index < start_index)//左移
			{
				tab_ptr->cur_sel_item_index = start_index;
				index_offset = tab_ptr->cur_sel_item_index -index;
				if(index_offset>0)
				{
					Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_LEFT);
					return FALSE;
				}
				
			}
			else if(index > end_index)//右移
			{
				tab_ptr->cur_sel_item_index = end_index;
				index_offset = index-tab_ptr->cur_sel_item_index;
				if(index_offset>0)
				{
					Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_RIGHT);
					return FALSE;
				}
			}

			*rect_x = (item_ptr->rect.left+item_ptr->rect.right)/2;
			*rect_y = (item_ptr->rect.top+item_ptr->rect.bottom)/2;			
			return TRUE;
		}
		item_ptr = item_ptr->next_ptr;
	}
	
	return FALSE;
}


/*****************************************************************************/
//  Description:查找控件RichText，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持TEXT,IMAGE ID
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchRichTextControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	MMI_IMAGE_ID_T user_data_id = 0,image_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	uint16 item_index,focus_item = 0;
	GUIRICHTEXT_ITEM_T richedit_item = { 0 };
	CTRLRICHTEXT_OBJ_T *richtext_ptr = PNULL;
	RICHTEXT_ITEM_T *item_pptr = PNULL;

	richtext_ptr = (CTRLRICHTEXT_OBJ_T *)ctrl_ptr;
	if(PNULL == richtext_ptr)
	{
		return FALSE;
	}
 
	item_pptr = richtext_ptr->first_item_ptr;		
    for (item_index = 0; ; item_index++)
    {
		if(PNULL == item_pptr)
		{
			return FALSE;
		}
		
		SCI_MEMSET(&richedit_item, 0, sizeof(GUIRICHTEXT_ITEM_T));
        if(!CTRLRICHTEXT_GetItem(ctrl_handle, item_index, &richedit_item))
        {
			break;
		}

        if ( (GUIRICHTEXT_TEXT_INVALID == richedit_item.text_type ) && (GUIRICHTEXT_IMAGE_INVALID == richedit_item.img_type) )
        {
            break;
        }

		//text
		SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
		if(GUIRICHTEXT_TEXT_RES == richedit_item.text_type || GUIRICHTEXT_TEXT_BUF == richedit_item.text_type)
		{
			 text_ptr.wstr_ptr = richedit_item.text_data.buf.str_ptr;
			 text_ptr.wstr_len = richedit_item.text_data.buf.len;
		}

		image_id = richedit_item.img_data.res.id;

		switch (id_type)
		{
			case TEXT_TYPE:
			case TEXT_ID_TYPE:
				user_data_id = richedit_item.text_data.res.id;
				break;
			case IMAGE_ID_TYPE:
				user_data_id = image_id;
				break;
			case INDEX_ID_TYPE:
				item_index = Atest_GetTestMessageId(',',&user_data_ptr);	//
				item_index = Atest_GetTestMessageId(',',&user_data_ptr);	//id	
				break;
			default:
				return FALSE;
		}

		if((id_type == INDEX_ID_TYPE) || Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
		{
			if (item_index > 3)
			{
				item_index -= 1;
			}
			else
			{
				CTRLRICHTEXT_SetFocusItem(ctrl_id, 0);	
				CTRLRICHTEXT_ScrollToFocus(ctrl_id);
			}
			CTRLRICHTEXT_GetFocusItemIndex(ctrl_id,&focus_item);	

			CTRLRICHTEXT_SetFocusItem(ctrl_id, item_index);	

			switch (id_type)
			{
				case TEXT_TYPE:
				case TEXT_ID_TYPE:
					*rect_x = (item_pptr->data.txt_ext_data.disp_rect.left + item_pptr->data.txt_ext_data.disp_rect.right)/2 +richtext_ptr->base_ctrl.rect.left;
					*rect_y = (item_pptr->data.txt_ext_data.disp_rect.top + item_pptr->data.txt_ext_data.disp_rect.bottom)/2 + richtext_ptr->base_ctrl.rect.top;
					break;
				case IMAGE_ID_TYPE:
					*rect_x = (item_pptr->data.img_ext_data.disp_rect.left + item_pptr->data.img_ext_data.disp_rect.right)/2 +richtext_ptr->base_ctrl.rect.left;
					*rect_y = (item_pptr->data.img_ext_data.disp_rect.top + item_pptr->data.img_ext_data.disp_rect.bottom)/2 + richtext_ptr->base_ctrl.rect.top;
					break;
				case INDEX_ID_TYPE:
					*rect_x = (richtext_ptr->focus_item_ptr->virtual_rect.left + richtext_ptr->focus_item_ptr->virtual_rect.right)/2 + richtext_ptr->base_ctrl.rect.left;
					*rect_y = (richtext_ptr->focus_item_ptr->virtual_rect.top + richtext_ptr->focus_item_ptr->virtual_rect.bottom)/2 + richtext_ptr->base_ctrl.rect.top;
					break;
				default:
					return FALSE;
			}
			return TRUE;
		}
		item_pptr = item_pptr->next_ptr;
    }

	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件Anim，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持控件ID和动画id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchAnimControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	CTRLANIM_OBJ_T  *anim_ctrl_ptr = PNULL;

	anim_ctrl_ptr = (CTRLANIM_OBJ_T  *)ctrl_ptr;
	if(PNULL == anim_ctrl_ptr)
	{
		return FALSE;
	}

	switch (id_type)
	{
		case CONTROL_ID_TYPE:
			user_data_id = ctrl_id;
			break;
		case IMAGE_ID_TYPE:
			if(anim_ctrl_ptr->data_info.anim_id)
			{
				user_data_id = anim_ctrl_ptr->data_info.anim_id;
			}
			else
			{
				user_data_id = anim_ctrl_ptr->data_info.img_id;
			}
			break;
			default:
				return FALSE;
	}

	if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
	{
		if(0 == anim_ctrl_ptr->base_ctrl.display_rect.bottom
			&& 0 == anim_ctrl_ptr->base_ctrl.display_rect.left
			&& 0 == anim_ctrl_ptr->base_ctrl.display_rect.top
			&& 0 == anim_ctrl_ptr->base_ctrl.display_rect.right) //未显示
		{
			if(anim_ctrl_ptr->base_ctrl.rect.top < ATEST_RECT_LIMIT) //需上翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_UP);
				return FALSE;
						
			}
			else if(anim_ctrl_ptr->base_ctrl.rect.bottom > ATEST_RECT_LIMIT) //需下翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_DOWN);
				return FALSE;
			}
		}
		
		*rect_x = (anim_ctrl_ptr->base_ctrl.display_rect.left+anim_ctrl_ptr->base_ctrl.display_rect.right)/2;
		*rect_y = (anim_ctrl_ptr->base_ctrl.display_rect.bottom+anim_ctrl_ptr->base_ctrl.display_rect.top)/2;
		return TRUE;	
	}
	return FALSE;
}


/*****************************************************************************/
//  Description:查找控件Msgbox，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持控件ID
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchMsgboxControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	CTRLMSGBOX_OBJ_T* msgbox_ptr = PNULL;

	msgbox_ptr = (CTRLMSGBOX_OBJ_T*)ctrl_ptr;
	if(PNULL == msgbox_ptr)
	{
		return FALSE;
	}

	switch (id_type)
	{
		case CONTROL_ID_TYPE:
			user_data_id = ctrl_id;
			*rect_x = (msgbox_ptr->base_ctrl.rect.left + msgbox_ptr->base_ctrl.rect.right)/2;
			*rect_y = (msgbox_ptr->base_ctrl.rect.bottom + msgbox_ptr->base_ctrl.rect.top)/2;
			break;
		case IMAGE_ID_TYPE:
			switch(msgbox_ptr->image_type)
			{
				case GUIMSGBOX_IMAGE_ANIMA:/*!<动画 */
					user_data_id = msgbox_ptr->anim_id;
					break;					
   				case GUIMSGBOX_IMAGE_BMP:/*!<图片*/
					user_data_id = msgbox_ptr->image_id;
					break;
					default:
						break;
			}
			*rect_x = (msgbox_ptr->image_rect.left + msgbox_ptr->image_rect.right)/2;
			*rect_y = (msgbox_ptr->image_rect.bottom + msgbox_ptr->image_rect.top)/2;
			break;			
		case TEXT_TYPE:
		case TEXT_ID_TYPE:
			text_ptr.wstr_ptr = msgbox_ptr->text_info.string.wstr_ptr;
			text_ptr.wstr_len = msgbox_ptr->text_info.string.wstr_len;
			*rect_x = (msgbox_ptr->text_info.text_rect.left + msgbox_ptr->text_info.text_rect.right)/2;
			*rect_y = (msgbox_ptr->text_info.text_rect.bottom + msgbox_ptr->text_info.text_rect.top)/2;
			break;
			default:
				return FALSE;
	}

	if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
	{
		return TRUE;
	}

	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件Textbox，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持控件ID和文本id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchTextboxControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	CTRLTEXT_OBJ_T *text_ctrl_ptr = PNULL;

	text_ctrl_ptr = (CTRLTEXT_OBJ_T *)ctrl_ptr;
	if(PNULL == text_ctrl_ptr)
	{
		return FALSE;
	}

	switch (id_type)
	{
		case CONTROL_ID_TYPE:
			user_data_id = ctrl_id;
			break;
		case TEXT_TYPE:
		case TEXT_ID_TYPE:
			GUITEXT_GetString(ctrl_handle,&text_ptr);
			break;
			default:
				return FALSE;
	}

	if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
	{
		if(0 == text_ctrl_ptr->base_ctrl.display_rect.bottom
			&& 0 == text_ctrl_ptr->base_ctrl.display_rect.left
			&& 0 == text_ctrl_ptr->base_ctrl.display_rect.top
			&& 0 == text_ctrl_ptr->base_ctrl.display_rect.right) //未显示
		{
			if(text_ctrl_ptr->base_ctrl.rect.top < ATEST_RECT_LIMIT) //需上翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_UP);
				return FALSE;
						
			}
			else if(text_ctrl_ptr->base_ctrl.rect.bottom > ATEST_RECT_LIMIT) //需下翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_DOWN);
				return FALSE;
			}
		}
		
		*rect_x = (text_ctrl_ptr->base_ctrl.display_rect.left+text_ctrl_ptr->base_ctrl.display_rect.right)/2;
		*rect_y = (text_ctrl_ptr->base_ctrl.display_rect.bottom+text_ctrl_ptr->base_ctrl.display_rect.top)/2;
		return TRUE;
	}
	return FALSE;
}


/*****************************************************************************/
//  Description:查找控件Dropdownlist，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持控件ID,和文本字符
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchDropdownlistControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	CTRLDROPDOWNLIST_OBJ_T* dropdownlist_ptr = PNULL;

	dropdownlist_ptr = (CTRLDROPDOWNLIST_OBJ_T*)ctrl_ptr;
	if(PNULL == dropdownlist_ptr)
	{
		return FALSE;
	}

	switch (id_type)
	{
		case CONTROL_ID_TYPE:
			user_data_id = ctrl_id;
			break;
		case TEXT_TYPE:
		case TEXT_ID_TYPE:
			text_ptr = GUIDROPDOWNLIST_GetCurItem(ctrl_handle);
			break;
			default:
				return FALSE;
	}

	if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
	{
		if(0 == dropdownlist_ptr->base_ctrl.display_rect.bottom
			&& 0 == dropdownlist_ptr->base_ctrl.display_rect.left
			&& 0 == dropdownlist_ptr->base_ctrl.display_rect.top
			&& 0 == dropdownlist_ptr->base_ctrl.display_rect.right) //未显示
		{
			if(dropdownlist_ptr->base_ctrl.rect.top < ATEST_RECT_LIMIT) //需上翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_UP);
				return FALSE;
						
			}
			else if(dropdownlist_ptr->base_ctrl.rect.bottom > ATEST_RECT_LIMIT) //需下翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_DOWN);
				return FALSE;
			}
		}
		
		*rect_x = (dropdownlist_ptr->base_ctrl.display_rect.left+dropdownlist_ptr->base_ctrl.display_rect.right)/2;
		*rect_y = (dropdownlist_ptr->base_ctrl.display_rect.bottom+dropdownlist_ptr->base_ctrl.display_rect.top)/2;
		return TRUE;
	}
	return FALSE;
}


/*****************************************************************************/
//  Description:查找控件Iconlist，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持字符串
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchIconlistControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	uint32 index_ptr = 0;
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	GUI_RECT_T rect_ptr = { 0 };
	CTRLICONLIST_OBJ_T  *iconlist_ctrl_ptr = PNULL;
	GUIICONLIST_ITEM_T  *item_ptr = PNULL;

	iconlist_ctrl_ptr = (CTRLICONLIST_OBJ_T  *)ctrl_ptr;
	if(PNULL == iconlist_ctrl_ptr)
	{
		return FALSE;
	}

	item_ptr = iconlist_ctrl_ptr->item_ptr;
	for(index_ptr = 0; index_ptr < iconlist_ctrl_ptr->total_num; index_ptr++)
	{
		if(PNULL == item_ptr)
		{
			break;
		}

		switch (id_type)
		{
			case INDEX_ID_TYPE:
				user_data_id = index_ptr;
				break;
			case TEXT_TYPE:
			case TEXT_ID_TYPE:
				text_ptr.wstr_ptr = item_ptr->text.display.name_str.wstr_ptr;
				text_ptr.wstr_len = item_ptr->text.display.name_str.wstr_len;
				break;
				default:
					return FALSE;
		}
		
		//SCI_TRACE_LOW:"[ATC][ATEST]:Iconlist:index_ptr=%d,row=%d,col=%d,item=%d,top=%d,bottom=%d,cur=%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_10517_112_2_18_1_59_47_83,(uint8*)"ddddddd",index_ptr,iconlist_ctrl_ptr->row_num_page,iconlist_ctrl_ptr->col_num_page,iconlist_ctrl_ptr->icon_num_page,iconlist_ctrl_ptr->top_index,iconlist_ctrl_ptr->bottom_index,iconlist_ctrl_ptr->cur_index);

		if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
		{
			if(index_ptr > iconlist_ctrl_ptr->cur_index)	//右移
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_RIGHT);
				return FALSE;
			}
			else if(index_ptr < iconlist_ctrl_ptr->cur_index)	//左移
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_LEFT);
				return FALSE;
			}

			rect_ptr = ICONLIST_GetIconRect(index_ptr,iconlist_ctrl_ptr);
			if(Atest_GetValidTPPoint(rect_ptr,iconlist_ctrl_ptr->base_ctrl.rect,rect_x,rect_y))
			{			
				return TRUE;
			}
		}
		item_ptr++;
	}
	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件Title，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持文本ID，image id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchTitleControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	uint16 i = 0;
	CTRLTITLE_OBJ_T  *title_ptr = PNULL;
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_STRING_T text_ptr = { 0 };

	title_ptr = (CTRLTITLE_OBJ_T  *)ctrl_ptr;
	if (PNULL == title_ptr)
	{
		return FALSE;
	}

	if(title_ptr->is_need_button)
	{
		for(i=0;i<GUITITLE_BUTTON_NUM;i++)
		{
			if(!title_ptr->button_state[i])
			{
				switch (id_type)
				{
					case TEXT_TYPE:
					case TEXT_ID_TYPE:
						SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
						if(GUITITLE_DATA_TEXT_ID == title_ptr->button_info[i].text_type)
						{
							MMITHEME_GetResText(title_ptr->button_info[i].text_id, title_ptr->win_handle, &text_ptr);
						}
						else if(GUITITLE_DATA_TEXT_BUFFER == title_ptr->button_info[i].text_type)
						{
							text_ptr.wstr_ptr = title_ptr->button_info[i].icon_str_ptr;
							text_ptr.wstr_len = title_ptr->button_info[i].str_len;
						}
						break;
					case IMAGE_ID_TYPE:
						user_data_id = title_ptr->button_info[i].image_id;
						break;
						default:
							return FALSE;
				}

				if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
				{
					*rect_x = (title_ptr->button_rect[i].left + title_ptr->button_rect[i].right)/2;
					*rect_y = (title_ptr->button_rect[i].bottom + title_ptr->button_rect[i].top)/2;
					return TRUE;
				}
			}
		}
	}

	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件IM，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持按键code字符查找
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchIMControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
#if defined (MMI_IM_PDA_SUPPORT)
	uint16 key_idx = 0;
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	IM_DATA_T *im_data_ptr = PNULL;
	CTRLIM_OBJ_T *im_ptr = PNULL;

	im_ptr = (CTRLIM_OBJ_T *)ctrl_ptr;
	if (PNULL == im_ptr)
	{
		return FALSE;
	}

	im_data_ptr = im_ptr->im_handle;
	if (PNULL == im_data_ptr)
	{
		return FALSE;
	}

	for (key_idx = 0; key_idx < im_data_ptr->vkb.key_cnt; key_idx++)
    {
		if(!im_data_ptr->vkb.keys[key_idx].is_hide)
		{
			switch (id_type)
			{
				case TEXT_TYPE:
				case TEXT_ID_TYPE:
					SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
					text_ptr.wstr_ptr = im_data_ptr->vkb.keys[key_idx].text;
					text_ptr.wstr_len = im_data_ptr->vkb.keys[key_idx].text_len;
					break;
				case CONTROL_ID_TYPE:
					user_data_id = im_data_ptr->vkb.keys[key_idx].code;
					break;
					default:
						return FALSE;
			}

			if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
			{
				*rect_x = (im_data_ptr->vkb.keys[key_idx].rect.left + im_data_ptr->vkb.keys[key_idx].rect.right)/2 + im_ptr->base_ctrl.rect.left;
				*rect_y = (im_data_ptr->vkb.keys[key_idx].rect.bottom + im_data_ptr->vkb.keys[key_idx].rect.top)/2 + im_ptr->base_ctrl.rect.top;
				return TRUE;
			}
		}
	}
#endif
	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件ToolBar，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持文本ID，image id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchToolBarControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
#ifdef GUIF_TOOLBAR
	uint16 index = 0;
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	GUITOOLBAR_ITEM_T* toolbar_item_ptr = PNULL;
	CTRLTOOLBAR_OBJ_T* toolbar_ptr = PNULL;
	GUITOOLBAR_ITEM_INFO_T* item_info_ptr = PNULL;

	toolbar_ptr = (CTRLTOOLBAR_OBJ_T *)ctrl_ptr;
	if (PNULL == toolbar_ptr)
	{
		return FALSE;
	}

	index = toolbar_ptr->click_index;

	item_info_ptr = toolbar_ptr->item_info_ptr;
	for(toolbar_ptr->click_index=0;toolbar_ptr->click_index<toolbar_ptr->total_num;toolbar_ptr->click_index++)
	{
		if(PNULL == item_info_ptr)
		{
			break;
		}

		toolbar_item_ptr = &(item_info_ptr->item);

		switch (id_type)
		{
			case TEXT_TYPE:
			case TEXT_ID_TYPE:
				SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
				MMITHEME_GetResText(toolbar_item_ptr->text_id, toolbar_ptr->win_handle,&text_ptr);
				break;
			case IMAGE_ID_TYPE:
				user_data_id = toolbar_item_ptr->image_id;
				break;
				default:
					return FALSE;
		}

		if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
		{
			*rect_x = (item_info_ptr->base_ctrl.rect.left + item_info_ptr->base_ctrl.rect.right)/2;
			*rect_y = (item_info_ptr->base_ctrl.rect.bottom + item_info_ptr->base_ctrl.rect.top)/2;
			return TRUE;
		}
		
		item_info_ptr = item_info_ptr + 1;
	}

	toolbar_ptr->click_index = index;
#endif
	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件Tips，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持文本,控件id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchTipsControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	TIPS_OBJ_T *tips_ptr  = PNULL;

	tips_ptr  = (TIPS_OBJ_T *)ctrl_ptr;
	if (PNULL == tips_ptr)
	{
		return FALSE;
	}

	if(tips_ptr->is_valid) //tip是否有效
	{
		switch (id_type)
		{
			case TEXT_TYPE:
			case TEXT_ID_TYPE:
				text_ptr.wstr_ptr = tips_ptr->text_info.wstr_ptr;
				text_ptr.wstr_len = tips_ptr->text_info.wstr_len;
				break;
			case CONTROL_ID_TYPE:
				user_data_id = ctrl_id;
				break;
				default:
					return FALSE;
		}

		if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
		{
			*rect_x = (tips_ptr->base_ctrl.rect.left + tips_ptr->base_ctrl.rect.right)/2;
			*rect_y = (tips_ptr->base_ctrl.rect.bottom + tips_ptr->base_ctrl.rect.top)/2;
			return TRUE;
		}
	}
	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件Statusbar，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持文本,image id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchStatusbarControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	uint16 item_total_num = 0;
	uint16 item_index = 0;
	CTRLSTATUSBAR_OBJ_T *statusbar_ptr = PNULL;
	GUISTBDATA_ITEM_DATA_T *stb_item_ptr = PNULL;
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_STRING_T text_ptr = { 0 };

	statusbar_ptr = (CTRLSTATUSBAR_OBJ_T *)ctrl_ptr;
	if (PNULL == statusbar_ptr)
	{
		 return FALSE;
	} 
	item_total_num = GUISTBDATA_GetItemTotalNum();
	if(statusbar_ptr->is_shown)
	{
		 for(item_index=0;item_index<item_total_num;item_index++)
		 {
			if(GUISTBDATA_IsItemVisible(item_index))
			{
				stb_item_ptr = GUISTBDATA_GetItemData(item_index);
				if (PNULL == stb_item_ptr)
				{
					 break;
				} 

				switch (id_type)
				{
					case TEXT_TYPE:
					case TEXT_ID_TYPE:
						text_ptr.wstr_ptr = stb_item_ptr->text_info.wstr_ptr;
						text_ptr.wstr_len = stb_item_ptr->text_info.wstr_len;
						break;
					case IMAGE_ID_TYPE:
						user_data_id = stb_item_ptr->icon_info.icon_array[stb_item_ptr->cur_frame];
						break;
						default:
							return FALSE;
				}

				if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
				{
					*rect_x = (stb_item_ptr->item_rect.left + stb_item_ptr->item_rect.right)/2;
					*rect_y = (stb_item_ptr->item_rect.bottom + stb_item_ptr->item_rect.top)/2;
					return TRUE;
				}
			}
		}
	}
	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件Owndraw，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持control id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchOwndrawControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	CTRLOWNERDRAW_OBJ_T  *owndraw_ctrl_ptr = PNULL;

    owndraw_ctrl_ptr = (CTRLOWNERDRAW_OBJ_T *)ctrl_ptr;
    if (PNULL == owndraw_ctrl_ptr)
    {
		return FALSE;
	}

	switch (id_type)
	{
		case CONTROL_ID_TYPE:
			user_data_id = ctrl_id;
			break;
			default:
				return FALSE;
	}

	if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
	{
		if(0 == owndraw_ctrl_ptr->base_ctrl.display_rect.bottom
			&& 0 == owndraw_ctrl_ptr->base_ctrl.display_rect.left
			&& 0 == owndraw_ctrl_ptr->base_ctrl.display_rect.top
			&& 0 == owndraw_ctrl_ptr->base_ctrl.display_rect.right) //未显示
		{
			if(owndraw_ctrl_ptr->base_ctrl.rect.top < ATEST_RECT_LIMIT) //需上翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_UP);
				return FALSE;
						
			}
			else if(owndraw_ctrl_ptr->base_ctrl.rect.bottom > ATEST_RECT_LIMIT) //需下翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_DOWN);
				return FALSE;
			}
		}
		
		*rect_x = (owndraw_ctrl_ptr->base_ctrl.display_rect.left+owndraw_ctrl_ptr->base_ctrl.display_rect.right)/2;
		*rect_y = (owndraw_ctrl_ptr->base_ctrl.display_rect.bottom+owndraw_ctrl_ptr->base_ctrl.display_rect.top)/2;
		return TRUE;
	}

	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件Prgbox，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持control id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchPrgboxControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	CTRLPROGRESS_OBJ_T *prgbox_ctrl_ptr = PNULL;

	prgbox_ctrl_ptr = (CTRLPROGRESS_OBJ_T *)ctrl_ptr;
	if (PNULL == prgbox_ctrl_ptr)
	{
		 return FALSE;
	}

	switch (id_type)
	{
		case CONTROL_ID_TYPE:
			user_data_id = ctrl_id;
			break;
			default:
				return FALSE;
	}

	if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
	{
		*rect_x = (prgbox_ctrl_ptr->base_ctrl.rect.left + prgbox_ctrl_ptr->base_ctrl.rect.right)/2;
		*rect_y = (prgbox_ctrl_ptr->base_ctrl.rect.bottom + prgbox_ctrl_ptr->base_ctrl.rect.top)/2;
		return TRUE;
	}

	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件Form，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持control id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchFormControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	CTRLFORM_OBJ_T  *form_ctrl_ptr = PNULL;

	form_ctrl_ptr = (CTRLFORM_OBJ_T *)ctrl_ptr;
	if (PNULL == form_ctrl_ptr)
	{
		return FALSE;
	}

	switch (id_type)
	{
		case CONTROL_ID_TYPE:
			user_data_id = ctrl_id;
			break;
			default:
				return FALSE;
	}

	if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
	{
		if(0 == form_ctrl_ptr->base_ctrl.rect.bottom
			&& 0 == form_ctrl_ptr->base_ctrl.rect.left
			&& 0 == form_ctrl_ptr->base_ctrl.rect.top
			&& 0 == form_ctrl_ptr->base_ctrl.rect.right) //未显示
		{
			if(form_ctrl_ptr->base_ctrl.rect.top < ATEST_RECT_LIMIT) //需上翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_UP);
				return FALSE;
						
			}
			else if(form_ctrl_ptr->base_ctrl.rect.bottom > ATEST_RECT_LIMIT) //需下翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_DOWN);
				return FALSE;
			}
		}
		
		*rect_x = (form_ctrl_ptr->base_ctrl.display_rect.left+form_ctrl_ptr->base_ctrl.display_rect.right)/2;
		*rect_y = (form_ctrl_ptr->base_ctrl.display_rect.bottom+form_ctrl_ptr->base_ctrl.display_rect.top)/2;
		return TRUE;
	}

	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件Iconfolder，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持control id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchIconfolderControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	CTRLICONFOLDER_OBJ_T    *iconfolder_ctrl_ptr = PNULL;

	iconfolder_ctrl_ptr = (CTRLICONFOLDER_OBJ_T *)ctrl_ptr;
	if (PNULL == iconfolder_ctrl_ptr)
	{
		 return FALSE;
	}

	switch (id_type)
	{
		case CONTROL_ID_TYPE:
			user_data_id = ctrl_id;
			break;
			default:
				return FALSE;
	}

	if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
	{
		*rect_x = (iconfolder_ctrl_ptr->base_ctrl.rect.left + iconfolder_ctrl_ptr->base_ctrl.rect.right)/2;
		*rect_y = (iconfolder_ctrl_ptr->base_ctrl.rect.bottom + iconfolder_ctrl_ptr->base_ctrl.rect.top)/2;
		return TRUE;
	}

	return FALSE;
}

/*****************************************************************************/
//  Description: 设置闹钟时间
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_SetAlarmTime(uint8 *user_data_ptr)
{
	uint8 *start_ptr = user_data_ptr;
	SCI_TIME_T    time_val;
	uint32 win_id = Atest_GetTestMessageId(',',&start_ptr); 
	uint32 hour = Atest_GetTestMessageId(',',&start_ptr); 
	uint32 min = Atest_GetTestMessageId(',',&start_ptr); 
	uint32 sec = Atest_GetTestMessageId(',',&start_ptr); 
	
	if(win_id != MMK_GetFocusWinId())
	{
		return FALSE;
	}	

	time_val.sec = sec;	
	time_val.min = min;	
	time_val.hour = hour;
	
#ifdef MMI_ALARM_GESTURE_CLOCK_SUPPORT
#if (defined MMIWIDGET_SUPPORT) || (defined MMI_GRID_IDLE_SUPPORT)

	if(ATESTALM_SetAlarmTime( time_val ))
	{
		return TRUE;
	}
	
#endif
#endif
	return FALSE;	
}

/*****************************************************************************/
//  Description: 获取下个闹钟的时间
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetLatestAlarmTime(uint8 *user_data_ptr)
{
	uint8 data_len = 0;
	uint8 *data_ptr = PNULL;
	char date[50];
	uint32 second = 0;
	SCI_ALARM_T s_alarm= {0};

	data_ptr = (uint8 *)SCI_ALLOC_APP(128);
    if (PNULL == data_ptr)
    {
        return FALSE;
    }

	ATESTALM_GetLatestAlarmTime(&s_alarm);
	second = MMIAPICOM_Tm2Second( s_alarm.sec,s_alarm.min,s_alarm.hour,s_alarm.mday,s_alarm.mon,s_alarm.year );   

	data_len = sprintf((char *)date,"%d,%d,%d,%d,%d,%d,%d",second,s_alarm.year,s_alarm.mon,s_alarm.mday,s_alarm.hour,s_alarm.min,s_alarm.sec);
	data_len = sprintf((char *)data_ptr,"<AlarmTime>%s</AlarmTime><Len>%d</Len>",date,data_len);
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);

	SCI_FREE(data_ptr);
	return TRUE;
}

/*****************************************************************************/
//  Description: 获取当前手机的时间
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetCurSysTime(uint8 *user_data_ptr)
{
	uint8 data_len = 0;
	uint8 *data_ptr = PNULL;
	uint32 second = MMIAPICOM_GetCurTime();
	MMI_TM_T tm=MMIAPICOM_Second2Tm(second);
	char date[50];

	data_ptr = (uint8 *)SCI_ALLOC_APP(128);
    if (PNULL == data_ptr)
    {
        return FALSE;
    }

	data_len = sprintf((char *)date,"%d,%d,%d,%d,%d,%d,%d",second,tm.tm_year,tm.tm_mon,tm.tm_mday,tm.tm_hour,tm.tm_min,tm.tm_sec);
	data_len = sprintf((char *)data_ptr,"<SysTime>%s</SysTime><Len>%d</Len>",date,data_len);
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);

	SCI_FREE(data_ptr);
	return TRUE;
}

/*****************************************************************************/
//  Description: 进入日历上的某个日期
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_ClickCalendarDate(uint8 *user_data_ptr)
{
	uint8 cur_date = 0;
	uint8 cur_month = 0;
	uint16 cur_year = 0;
	GUI_RECT_T rect = {0};
	uint16 rect_x = 0;
	uint16 rect_y = 0;
	
	uint8 *start_ptr = user_data_ptr;
	uint32 win_id = Atest_GetTestMessageId(',',&start_ptr); 
	uint32 year = Atest_GetTestMessageId(',',&start_ptr); 
	uint32 month = Atest_GetTestMessageId(',',&start_ptr); 
	uint32 date = Atest_GetTestMessageId(',',&start_ptr); 
	
	if(win_id != MMK_GetFocusWinId())
	{
		return FALSE;
	}

	ATESTCALENDAR_GetCurDate(&cur_date,&cur_month,&cur_year);	
	if(cur_year != year && cur_month != month)
	{
		return FALSE;
	}	

	ATESTCALENDAR_GetDateRect(date,month,year,&rect);

	rect_x = (rect.left + rect.right)/2;
	rect_y = (rect.top + rect.bottom)/2;

	Atest_SendTouchMessage(MMI_TP_DOWN,rect_x,rect_y);
	Atest_SendTouchMessage(MMI_TP_UP,rect_x,rect_y);			

	return TRUE;
}

/*****************************************************************************/
//  Description: 获得当前日历的焦点日期
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetCalendarCurDate(uint8 *user_data_ptr)
{
	uint8 date = 0;
	uint8 month = 0;
	uint16 year = 0;
	uint8 data_len = 0;
	uint8 *data_ptr = PNULL;
	char dateArr[50];	

	data_ptr = (uint8 *)SCI_ALLOC_APP(128);
    if (PNULL == data_ptr)
    {
        return FALSE;
    }

	ATESTCALENDAR_GetCurDate(&date,&month,&year);

	data_len = sprintf((char *)dateArr,"%d,%d,%d",date,month,year);
	data_len = sprintf((char *)data_ptr,"<CalendarCurDate>%s</CalendarCurDate><Len>%d</Len>",dateArr,data_len);
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);

	SCI_FREE(data_ptr);
	return TRUE;
}

#endif // ATEST_SUPPORT
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/*                                    End  of Atest  Function                                                                  */
/* Description:  Hanlde at cmd for auto test cases                                                                    */
/* Author: Shuyan.hu                                                                                                           */
/* Date: 30/12/2010                                                                                                            */ 
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/



/*****************************************************************************/
// 	Description : If the cmd is match the indication
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN IsMatchIndication(
				                uint8 *cmd,  // Point to the command infomation buffer
				                uint32 len,   // The length of command infomation buffer
                                const char* ind_ptr //the indication
				                )
{
    uint8 ind_str[MMI_MAX_INDICATE_LEN + 1] = {0};
    uint16 ind_len = 0;

    SCI_ASSERT(PNULL != cmd); /*assert verified*/
    SCI_ASSERT(PNULL != ind_ptr); /*assert verified*/

    ind_len = strlen(ind_ptr);
    SCI_TRACE_LOW("mmi_atc.c IsMatchIndication %s",ind_ptr);
    strncpy((char *)ind_str, (char *)cmd, ind_len);
    if(0 == strcmp((char *)ind_str, ind_ptr))
    {
        SCI_TRACE_LOW("mmi_atc.c IsMatchIndication TRUE");
        return TRUE;
    }
    else
    {
        SCI_TRACE_LOW("mmi_atc.c IsMatchIndication FALSE");
        return FALSE;
    }
}

/*****************************************************************************/
// 	Description : This function handle the group getinfo command
//	Global resource dependence : none
//  Author:   xiaohua.liu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleScheduleGetInfo()
{
    SCHEDULE_HEAD_INFO_T    schedule_head_info = {0};
    uint8               *res_cmd = NULL;
    uint16              res_len = 0; 
    uint16              dest_len = 0;
    CHAR     temp_buf[10] = {0};
    
    res_cmd = (uint8 *)SCI_ALLOC_APP(MAX_RESCMD_LEN);

    SCI_MEMSET(&schedule_head_info, 0, sizeof(SCHEDULE_HEAD_INFO_T));
    SCI_MEMSET(res_cmd, 0, MAX_RESCMD_LEN);
    
    if(MMISCHEDULE_SyncHeadInfo(&schedule_head_info))
    {
        strcat((char *)res_cmd, (char *)MMI_SYNC_INDICATE);
        res_len += SCI_STRLEN((char *)MMI_SYNC_INDICATE);

        strcat((char *)res_cmd, (char *)MMI_COLON_SYMBOL);
        res_len += SCI_STRLEN((char *)MMI_COLON_SYMBOL);
        
        SCI_MEMSET(temp_buf,0,sizeof(temp_buf));
        MMIAPICOM_Int2Str(schedule_head_info.max_count,(uint8*)temp_buf, sizeof(temp_buf));
       // itoa(schedule_head_info.max_count,temp_buf,10);
        strcat((char *)res_cmd, (char *)temp_buf);
        res_len += SCI_STRLEN((char *)temp_buf);
        
        strcat((char *)res_cmd, (char *)MMI_COMMA_SYMBOL);
        res_len += SCI_STRLEN((char *)MMI_COMMA_SYMBOL);

        MMIAPICOM_BinaryToHexChar(schedule_head_info.all_entry_id,
            sizeof(schedule_head_info.all_entry_id)-1,res_cmd+res_len, &dest_len);
        res_len+=dest_len;

        strcat((char *)res_cmd, (char *)MMI_COMMA_SYMBOL);
        res_len += SCI_STRLEN((char *)MMI_COMMA_SYMBOL);

        SCI_MEMSET(temp_buf,0,sizeof(temp_buf));
        MMIAPICOM_Int2Str(schedule_head_info.title_max_len,(uint8*)temp_buf, sizeof(temp_buf));
       // itoa(schedule_head_info.title_max_len,temp_buf,10);
        strcat((char *)res_cmd, (char *)temp_buf);
        res_len += SCI_STRLEN((char *)temp_buf);
        
        dest_len = SCI_STRLEN((char*)MMI_TO_SYNC_OK_SYMBOL);
        MMI_MEMCPY(res_cmd + res_len, MAX_RESCMD_LEN - res_len, (char *)MMI_TO_SYNC_OK_SYMBOL, dest_len, dest_len);
        res_len += dest_len;

        ReturnResponse(res_cmd, res_len);
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }

    SCI_FREE(res_cmd);

    return TRUE;
}
/*****************************************************************************/
// 	Description : This function parse at cmd wich from sync tool
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN ParseSyncAtCmd(
					      uint8 *cmd,  // Point to the command infomation buffer
					      uint32 len   // The length of command infomation buffer
					      )
{
    uint8 module_type = 0;
    uint8 operation_type = 0;
    BOOLEAN recode = TRUE;

	uint8	*cmd_dec = NULL;
	uint16	dec_len = 0;

#if 0//ndef _WIN32
    if(!s_atc_is_run)
    {
        //SCI_TRACE_LOW:"mmi_atc.c: ParseSyncAtCmd(), mmi atc is not run"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11114_112_2_18_1_59_49_84,(uint8*)"");
        return FALSE;
    }
#endif 

    //check length, must be have module type and operation type
    //sync_alarm have only module type
    if(len < 1)
    {
        return FALSE;
    }

    module_type = *(cmd++);
    len--;
    operation_type = *(cmd++);
    len--;

    //SCI_TRACE_LOW:"mmi_atc.c: ParseSyncAtCmd(), module_type = %c, operation_type = %c"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11131_112_2_18_1_59_49_85,(uint8*)"cc", module_type, operation_type);

	cmd_dec = (uint8*)SCI_ALLOC_APP(MAX(MAX_RESCMD_LEN, (len +1)));
	SCI_ASSERT(NULL != cmd_dec); /*assert verified*/
	SCI_MEMSET(cmd_dec, 0, MAX(MAX_RESCMD_LEN, (len +1)));
	
	//解压缩命令字符串
	dec_len = DecompressCmdStr(cmd, len, cmd_dec, MAX(MAX_RESCMD_LEN, (len +1)));

    switch(module_type)
    {
    case MMI_SYNC_PB:
        switch(operation_type) 
        {
        case MMI_SYNC_GETINFO:
            recode = HandlePbGetInfo(cmd_dec, dec_len);
        	break;

        case MMI_SYNC_ADD:
            recode = HandlePbAdd(cmd_dec, dec_len);
            break;        

        case MMI_SYNC_DELETE:
            recode = HandlePbDelete(cmd_dec, dec_len);
            break;

        case MMI_SYNC_MODIFY:
            recode = HandlePbModify(cmd_dec, dec_len);
            break;

        case MMI_SYNC_GETITEM:
            recode = HandlePbReadItem(cmd_dec, dec_len);
            break;

        default:
            recode = FALSE;
        }
        break;

    case MMI_SYNC_SMS:
        switch(operation_type) 
        {
        case MMI_SYNC_DELETE:
            recode = HandleSmsDelete(cmd_dec, dec_len);
            break;

        default:
            recode = FALSE;
			break;
        }
        break;

    case MMI_SYNC_RING:
        recode = FALSE;
        break;

    case MMI_SYNC_PICTURE:
        recode = FALSE;
        break;

    case MMI_SYNC_SCHEDULE:
        switch(operation_type) 
        {
        case MMI_SYNC_GETINFO:
            recode = HandleScheduleGetInfo();
            break;

        case MMI_SYNC_ADD:
            recode = HandleScheduleAdd(cmd_dec, dec_len);
            break;        

        case MMI_SYNC_DELETE:
            recode = HandleScheduleDelete(cmd_dec, dec_len);
            break;

        case MMI_SYNC_MODIFY:
            recode = HandleScheduleModify(cmd_dec, dec_len);
            break;

        case MMI_SYNC_GETITEM:
            recode = HandleScheduleReadItem(cmd_dec, dec_len);
            break;

        default:
            recode = FALSE;
        }
        break;        

    case MMI_SYNC_PBGROUP:
        switch(operation_type) 
        {
        case MMI_SYNC_GETINFO:
            recode = HandleGroupGetInfo(cmd_dec, dec_len);
            break;

        case MMI_SYNC_ADD:
            recode = HandleGroupAdd(cmd_dec, dec_len);
            break;        

        case MMI_SYNC_DELETE:
            recode = HandleGroupDelete(cmd_dec, dec_len);
            break;

        case MMI_SYNC_MODIFY:
            recode = HandleGroupModify(cmd_dec, dec_len);
            break;

        case MMI_SYNC_GETITEM:
            recode = HandleGroupReadItem(cmd_dec, dec_len);
            break;

        default:
            recode = FALSE;
        }
        break;

    default:
        recode = FALSE;
        break;
    }

	SCI_FREE(cmd_dec);

    return recode;
}

#define MMI_AUTO_TEST_MODULE_STR "+TESTMODULE:"
/*****************************************************************************/
// 	Description : handle auto test module
//	Global resource dependence : none
//  Author:      
//	Note:James.Zhang
/*****************************************************************************/
LOCAL BOOLEAN HandleAutoTestModule(
                                   uint8 *cmd,  // Point to the command infomation buffer
                                   uint32 len   // The length of command infomation buffer
                                   )
{
    BOOLEAN result = FALSE;
    uint32  str_len = strlen( MMI_AUTO_TEST_MODULE_STR );

    if ( len > str_len
        && 0 == strncmp( (const char*)cmd, (const char*)MMI_AUTO_TEST_MODULE_STR, str_len ) )
    {
        if ( MMK_IsFocusWin( MAIN_IDLE_WIN_ID ) )
        {
            uint32 module_len = len - str_len;
            char*  module_str = SCI_ALLOC_APP( module_len + 1 );

            strncpy( module_str, (const char*)(cmd + str_len), module_len );
            module_str[module_len] = 0;

            MMIAPICOM_OtherTaskToMMI(VIRTUAL_WIN_ID, MSG_MMI_AUTO_TEST_MODULE, (DPARAM)module_str, module_len + 1);
            
            SCI_FREE(module_str);

            result = TRUE;
        }
    }

    return result;
}


#define MMI_MONKEY_TEST_SETTING_STR "+MONKEYTEST_SETTING"
/***************************************************************************//*!
@brief monkey test setting
@author Lianxiang.Zhou
@param cmd_str [IN] at cmd string
@param cmd_len [IN] at cmd string len
@retval TRUE - is monkey test at cmd, and deal it
@retval FALSE - not monkey test at cmd
@return deal it?
@note 实现以下的部分功能
-# 锁屏关闭
-# USB log Open
-# Call BARING Open
-# 动态墙纸随机设定
-# 视频墙纸开启
-# idle放置widget及shortcut
-# 4个系统切换
-# LOGEL工具自动加载map
@note AT##AUTOTEST+MONKEYTEST_SETTING 
*******************************************************************************/
LOCAL BOOLEAN HandleMonkeyTest(
    const char *cmd_str,
    uint32 cmd_len
)
{
    uint32  str_len = strlen(MMI_MONKEY_TEST_SETTING_STR);

    if (cmd_len != str_len)
    {
        return FALSE;
    }

    if (0 != strncmp(cmd_str, MMI_MONKEY_TEST_SETTING_STR, str_len))
    {
        return FALSE;
    }

    //setting
    //turn on
    MMIDEFAULT_TurnOnBackLight();
#ifdef MMI_KEY_LOCK_SUPPORT
    //unlock
    MMIAPIKL_UnlockPhone();
#endif
    //backlight
    MMIDEFAULT_AllowTurnOffBackLight(FALSE);

    //锁屏关闭
    MMISET_SetAutoBoardKey(MMISET_KEYLOCK_CLOSE);

#ifdef ENG_SUPPORT
    //USB log Open
    MMIENG_SetUSBLog(TRUE);

    //Call BARING Open
    MMIAPIENG_SetCallBarring(TRUE);

    //set monkey test mode
    MMIENG_SetMonkeyTestMode(1);
#endif



    return TRUE;
}


extern void MMI_SetAllAtValue(BOOLEAN is_on);
/*****************************************************************************/
// 	Description : This function parse at atuo test cmd
//	Global resource dependence : none
//  Author:      
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN ParseSyncUTAtCmd(
					      uint8 *cmd,  // Point to the command infomation buffer
					      uint32 len   // The length of command infomation buffer
					      )
{
    uint8 module_type = 0;
    uint8 operation_type = 0;
    BOOLEAN recode = TRUE;
    uint8   str_buf[MMI_MAX_INDICATE_LEN] = {0};
	uint8	*cmd_dec = NULL;
	uint16	dec_len = 0;
	BOOLEAN  is_on = FALSE;
#ifndef  FLASH_SUPPORT
	MMIMAINMENU_TYPE_E mainmenu_style = MMIMAINMENU_MATRIX_E;
#endif

    if ( HandleAutoTestModule( cmd, len ) )
    {
        return TRUE;
    }

    //monkey test setting
    if (HandleMonkeyTest((char *)cmd, len))
    {
        return TRUE;
    }

    //check length, must be have module type and operation type
    //sync_alarm have only module type
    if(len < 1)
    {
        return FALSE;
    }
    if(MMI_UT_CMD_INTERVAL_FLAG != *(cmd++))
	{
		//SCI_TRACE_LOW:"ParseSyncUTAtCmd, cmd[0] 0x%x"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11299_112_2_18_1_59_49_86,(uint8*)"d", cmd[0]);
		return FALSE;
	}
	len --;
	SCI_MEMSET(str_buf, 0x00, sizeof(str_buf));
	if(!GetATCNextString(cmd, len, str_buf, MMI_MAX_INDICATE_LEN))
	{
		//SCI_TRACE_LOW:"ParseSyncUTAtCmd, get module_type error"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11306_112_2_18_1_59_49_87,(uint8*)"");
		return FALSE;
	}
	dec_len = strlen((char*)str_buf);
	module_type = atoi((char*)str_buf);
    if(dec_len + 1 >= len)
	{
		//SCI_TRACE_LOW:"ParseSyncUTAtCmd, module_type strlen %d, cmd_len %d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11313_112_2_18_1_59_49_88,(uint8*)"dd",strlen((char*)str_buf), len);
		return FALSE;
	}
	cmd = cmd + dec_len + 1; 
	len = len - dec_len - 1;
    SCI_MEMSET(str_buf, 0x00, sizeof(str_buf));
	if(!GetATCNextString(cmd, len, str_buf, MMI_MAX_INDICATE_LEN))
	{
		//SCI_TRACE_LOW:"ParseSyncUTAtCmd, Get operation_type error"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11321_112_2_18_1_59_49_89,(uint8*)"");
		return FALSE;
	}
    operation_type = atoi((char*)str_buf);
    dec_len = strlen((char*)str_buf);
	if(dec_len + 1 > len)
	{
		//SCI_TRACE_LOW:"ParseSyncUTAtCmd, operation_type strlen %d, cmd_len %d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11328_112_2_18_1_59_49_90,(uint8*)"dd",strlen((char*)str_buf), len);
		return FALSE;
	}
	cmd = cmd + dec_len + 1; 
	len = len - dec_len - 1;
    //SCI_TRACE_LOW:"mmi_atc.c: ParseSyncAtCmd(), module_type = %c, operation_type = %c"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11333_112_2_18_1_59_49_91,(uint8*)"cc", module_type, operation_type);

	cmd_dec = (uint8*)SCI_ALLOC_APP(MAX(MAX_RESCMD_LEN, (len +1)));
	SCI_ASSERT(NULL != cmd_dec); /*assert verified*/
	SCI_MEMSET(cmd_dec, 0, MAX(MAX_RESCMD_LEN, (len +1)));
	//解压缩命令字符串
	dec_len = DecompressCmdStr(cmd, len, cmd_dec, MAX(MAX_RESCMD_LEN, (len +1)));

    switch(module_type)
    {
    case MMI_UT_SMS://SMS
        switch(operation_type) 
        {
		case MMI_AUTO_TEST_INPUT_STRING:
            //send message
			recode = HandleSmsSendMsg(cmd, dec_len);
			break;
        default:
            recode = FALSE;
			break;
        }
        break;
	case MMI_UT_MMS://MMS
			switch(operation_type) 
			{
			case MMI_AUTO_TEST_INPUT_STRING:
				//send message
				recode = HandleMMSSendMsg(cmd, dec_len);
				break;
			default:
				recode = FALSE;
			}
			break;
	case MMI_UT_WAP://WAP
			switch(operation_type) 
			{
			case MMI_AUTO_TEST_INPUT_STRING:
				//send message
				recode = HandleWAPInputURL(cmd, dec_len);
				break;
			default:
				recode = FALSE;
				break;
			}
		break;
	case MMI_UT_CONNECTION://connection
			switch(operation_type) 
			{
			case MMI_AUTO_TEST_INPUT_STRING:
				//send message
				recode = HandleConnection(cmd, dec_len);
				break;
			default:
				recode = FALSE;
				break;
			}
		break;
	case MMI_UT_CC://call control
			switch(operation_type) 
			{
			case MMI_AUTO_TEST_ACO_OFF:
				//close auto answer call--on
				//SCI_TRACE_LOW:"[baokun] MMI_AUTO_TEST_ACO_OFF"
				SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11395_112_2_18_1_59_49_92,(uint8*)"");
#ifdef ENG_SUPPORT
				MMIAPIENG_SetAutoAnswerCallSet(FALSE);
#endif
				break;
			case MMI_AUTO_TEST_ACO_ON:
				//open auto answer call--on
				//SCI_TRACE_LOW:"[baokun] MMI_AUTO_TEST_ACO_ON"
				SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11402_112_2_18_1_59_49_93,(uint8*)"");
#ifdef ENG_SUPPORT
				MMIAPIENG_SetAutoAnswerCallSet(TRUE);
#endif
				break;
			case MMI_AUTO_TEST_HEADSET_MODE_OFF:
				//close vt默认为耳机模式 
				//SCI_TRACE_LOW:"[baokun] MMI_AUTO_TEST_HEADSET_MODE_OFF"
				SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11409_112_2_18_1_59_49_94,(uint8*)"");
#ifdef VT_SUPPORT
				MMIAPIVT_SetIsEPDefault(FALSE);
#endif
				break;	
			case MMI_AUTO_TEST_HEADSET_MODE_ON:
				//open vt默认为耳机模式
				//SCI_TRACE_LOW:"[baokun] MMI_AUTO_TEST_HEADSET_MODE_ON"
				SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11416_112_2_18_1_59_49_95,(uint8*)"");
#ifdef VT_SUPPORT
				MMIAPIVT_SetIsEPDefault(TRUE);
#endif
				break;				
			default:
				recode = FALSE;
				break;
			}		
		break;
#ifdef ENG_SUPPORT        
	case MMI_UT_USB://USB log
			switch(operation_type) 
			{
			case MMI_AUTO_TEST_OFF:
				//usb log --close
				is_on = FALSE;
				//SCI_TRACE_LOW:"[baokun] MMI_AUTO_TEST_OFF is_on %d"
				SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11433_112_2_18_1_59_49_96,(uint8*)"d", is_on);
				MMINV_WRITE(MMINV_ENG_USBLOG,&is_on);
				break;
			case MMI_AUTO_TEST_ON:
				//usb log --open
				is_on = TRUE;
				//SCI_TRACE_LOW:"[baokun] MMI_AUTO_TEST_ON is_on %d"
				SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11439_112_2_18_1_59_49_97,(uint8*)"d", is_on);
				MMINV_WRITE(MMINV_ENG_USBLOG,&is_on);
				break;
			default:
				recode = FALSE;
				break;
			}
		break;
  /* +CR247389 */
  case MMI_UT_AUTOTEST_ALLSETTINGS: 
      switch(operation_type) 
      {
      case MMI_AUTO_TEST_OFF:
#ifdef MMI_AUTOTEST_SUPPORT
        {

            MMI_SetAllAtValue(FALSE);
        }
#endif
        break;
      case MMI_AUTO_TEST_ON:
#ifdef MMI_AUTOTEST_SUPPORT

        MMI_SetAllAtValue(TRUE);
#endif
        break;
      default:
        recode = FALSE;
        break;
      }
    break;
  /* -CR247389 */
#endif        
        case MMI_UT_LCD_BRIGHTNESS://Lcd brightness
            {                
                MMISET_BACKLIGHT_SET_T  backlight_info={0};
                
                //SCI_TRACE_LOW:" AutoTest Lcd Brightness  MMI_AUTO_TEST_OFF is_on %d"
                SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11472_112_2_18_1_59_49_98,(uint8*)"d", operation_type);
                switch(operation_type) 
                {   
                    case MMI_AUTO_TEST_BACKLIGHT_FOREVER_OFF:		
                        //is off,restore to factory setting
                        backlight_info.backlight_type = MMISET_EDEFAULT_BACKLIGHT_OPEN;
                        backlight_info.backlight_time = MMISET_EDEFAULT_BACKLIGHT_TIME;
                        MMIAPISET_SetBackLightInfo(backlight_info);	
                    break;
                    case MMI_AUTO_TEST_BACKLIGHT_FOREVER_ON:                 
                        //is on, set backlight open forever,turn on backlight  first
                        MMIDEFAULT_TurnOnBackLight();
                        backlight_info.backlight_type = MMISET_BACKLIGHT_OPEN_FOREVER;                        
                        MMIAPISET_SetBackLightInfo(backlight_info);	
                    break;
                    case MMI_AUTO_TEST_BACKLIGH_ON:
                         MMIDEFAULT_TurnOnBackLight();
                        break;                    
                    default:
                        recode = FALSE;
                    break;
                }
                break;
            }
#ifndef  FLASH_SUPPORT
	case MMI_UT_MAINMENU://set MainMenu style
		switch(operation_type) 
		{
		case MMI_AUTO_TEST_SET_ICON_MENU:
			mainmenu_style = MMIMAINMENU_MATRIX_E;
			break;
		case MMI_AUTO_TEST_SET_TITLE_ICON_MENU:
			mainmenu_style = MMIMAINMENU_MATRIX_TITLE_E;
			break;
#ifndef PDA_UI_SUPPORT_MANIMENU_GO
        case MMI_AUTO_TEST_SET_LIDE_PAGE_MENU:
            mainmenu_style = MMIMAINMENU_GO_SLIDE_E;
            break;
#endif
        default:
            mainmenu_style = MMIMAINMENU_MATRIX_E;
            break;
		}
		MMIAPISET_SetMainmenuStyle((uint32)mainmenu_style);
		MMIAPIMENU_UpdateMainMenu();
		break;	
#endif
#ifdef PUSH_EMAIL_SUPPORT
    case MMI_UT_PUSH_MAIL://Push mail
        switch(operation_type) 
        {
		case MMI_AUTO_TEST_INPUT_STRING:
			recode = HandlePushMailSendMsg(cmd, dec_len);
			break;
        default:
            recode = FALSE;
			break;
        }
        break;
#endif /* PUSH_EMAIL_SUPPORT */

    default:
        recode = FALSE;
        break;
    }

	SCI_FREE(cmd_dec);

    return recode;
}

/*****************************************************************************/
// 	Description : This function handle the pb getinfo command
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandlePbGetInfo(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{
    PB_HEAD_INFO_T  pb_head_info = {0};
    uint8 *res_cmd = NULL;
    uint16 res_len = 0; 

    uint16 dest_len = 0;
    uint8  pos = 0;
    char temp_str[10] = {0};

	if(PNULL==cmd||len<1)
	{
		return FALSE;
	}
	
	res_cmd = (uint8 *)SCI_ALLOC_APP(MAX_RESCMD_LEN);
    	if(PNULL == res_cmd)
    	{
    		return FALSE;
    	}
	
    if(!GetPbStorage(&pos, *cmd))
    {
        return FALSE;
    }
	cmd++;//split pos
	len--;
    //SCI_TRACE_LOW:"mmi_atc.c: HandlePbGetInfo(), pos = %d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11570_112_2_18_1_59_50_99,(uint8*)"d", pos);
    
    SCI_MEMSET(&pb_head_info, 0, sizeof(PB_HEAD_INFO_T));
    SCI_MEMSET((char*)res_cmd, 0, MAX_RESCMD_LEN);
    if(MMIPB_SyncHeadInfo(&pb_head_info, pos))
    {
        //SCI_TRACE_LOW:"mmi_atc.c: HandlePbGetInfo(), max_record_num = %d, used_record_num = %d"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11577_112_2_18_1_59_50_100,(uint8*)"dd",pb_head_info.max_record_num, pb_head_info.used_record_num);

        strcpy((char *)res_cmd, (char *)MMI_SYNC_INDICATE);
        res_len += SCI_STRLEN((char *)MMI_SYNC_INDICATE);

        strcat((char *)res_cmd, (char *)MMI_COLON_SYMBOL);
        res_len += SCI_STRLEN((char *)MMI_COLON_SYMBOL);

        SCI_MEMSET((char *)temp_str,0,sizeof(temp_str));
        MMIAPICOM_Int2Str(pb_head_info.max_record_num,(uint8*)temp_str,sizeof(temp_str));
       // itoa(pb_head_info.max_record_num,(char *)temp_str,10);
        strcat((char *)res_cmd, (char *)temp_str);
        res_len += SCI_STRLEN((char*)temp_str);

        strcat((char *)res_cmd, (char *)MMI_COMMA_SYMBOL);
        res_len += SCI_STRLEN((char *)MMI_COMMA_SYMBOL);
        {
            uint8 i = 0;
            uint8 j=0;
            uint8 mask[8] = {1,2,4,8,16,32,64,128};
                //get all entry id infor string,id的16进制字符串，右边的0去掉
            uint8   all_entry_id[(MMI_SYNC_PB_MAX_ENTRY_NUM+7)/8+1] = {0};
            for(i = 0;(i<(MMI_SYNC_PB_MAX_ENTRY_NUM+7)/8);i++)
            {
                if(pb_head_info.all_entry_id[i]>0)
                {    
                    for(j=0;j<8;j++)
                    {
                        if(((7-j)-j)>0)
                        {
                            all_entry_id[i] |= (pb_head_info.all_entry_id[i]&mask[j])<<((7-j)-j);
                        }
                        else
                        {
                        all_entry_id[i] |= (pb_head_info.all_entry_id[i]&mask[j])>>(2*j-7);
                        }
                    }
                }
            }
            
            MMIAPICOM_BinaryToHexChar((uint8 *)all_entry_id,
                sizeof(all_entry_id), res_cmd+res_len, &dest_len);

            while(dest_len>0&&(48==res_cmd[dest_len+res_len-1]))//48 is '0'
            {
              //  entry_id_infor[infor_str_len-1]='\0';
                dest_len--;
            }
			if(0==dest_len)
			{
				//only append 0
				res_len++;
			}
			else
			{
				res_len += dest_len;
			}
        }
        SCI_MEMSET(res_cmd+res_len,0,(MMI_SYNC_PB_MAX_ENTRY_NUM+7)/8-res_len-1);

        if(dest_len>0&&(48==res_cmd[res_len-dest_len]))//48 is '0'
        {
			uint8 i = 0; 
            for(i=0;i<dest_len;i++)
            {
                res_cmd[res_len-dest_len+i] = res_cmd[res_len-dest_len+i+1];
            }
            res_len--;
        }
        
        strcat((char *)res_cmd, (char *)MMI_COMMA_SYMBOL);
        res_len += SCI_STRLEN((char *)MMI_COMMA_SYMBOL);

        SCI_MEMSET((char *)temp_str,0,sizeof(temp_str));
        MMIAPICOM_Int2Str(pb_head_info.max_alpha_len,(uint8*)temp_str,sizeof(temp_str));
       // itoa(pb_head_info.max_alpha_len,temp_str,10);
        strcat((char *)res_cmd,(char *)temp_str);
        res_len += SCI_STRLEN((char *)temp_str);
        
        strcat((char *)res_cmd, (char *)MMI_COMMA_SYMBOL);
        res_len += SCI_STRLEN((char *)MMI_COMMA_SYMBOL);

        SCI_MEMSET((char *)temp_str,0,sizeof(temp_str));
        MMIAPICOM_Int2Str(pb_head_info.max_num_len,(uint8*)temp_str,sizeof(temp_str));
        //itoa(pb_head_info.max_num_len,temp_str,10);
        strcat((char *)res_cmd,(char *)temp_str);
        res_len += SCI_STRLEN((char *)temp_str);
        
        strcat((char *)res_cmd+res_len,(char *)MMI_COMMA_SYMBOL);
        res_len += SCI_STRLEN((char *)MMI_COMMA_SYMBOL);

        SCI_MEMSET((char *)temp_str,0,sizeof(temp_str));
        MMIAPICOM_Int2Str(pb_head_info.max_email_len,(uint8*)temp_str,sizeof(temp_str));
       // itoa(pb_head_info.max_email_len,temp_str,10);
        strcat((char*)res_cmd,temp_str);
        res_len += SCI_STRLEN((char*)temp_str);
        
        strcat((char *)res_cmd, (char *)MMI_COMMA_SYMBOL);
        res_len += SCI_STRLEN((char *)MMI_COMMA_SYMBOL);

        SCI_MEMSET((char *)temp_str,0,sizeof(temp_str));
        MMIAPICOM_Int2Str(pb_head_info.max_memo_len,(uint8*)temp_str,sizeof(temp_str));
       
       // itoa(pb_head_info.max_memo_len,temp_str,10);
        strcat((char *)res_cmd,(char *)temp_str);
        res_len += SCI_STRLEN((char *)temp_str);
        

        dest_len = SCI_STRLEN((char*)MMI_TO_SYNC_OK_SYMBOL);
        MMI_MEMCPY((char*)res_cmd + res_len, MAX_RESCMD_LEN - res_len, (char *)MMI_TO_SYNC_OK_SYMBOL, dest_len, dest_len);
        res_len += dest_len;

        ReturnResponse((uint8*)res_cmd, res_len);
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)SCI_STRLEN((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }

    SCI_FREE(res_cmd);

    return TRUE;
}
/*****************************************************************************/
// 	Description : This function get pb entry id from cmd string,there may be more
//  than one entry id
//	Global resource dependence : none
//  Author: Xiaohua.liu
//	Note:
/*****************************************************************************/
LOCAL uint16* GetPbEntryIdFromIntervalStr(char* interval_str_ptr, 
    char* separa_pos,uint16* id_out,uint16 max_id,BOOLEAN* result)
{
    char id_buf[10] = {0};
    char* begin_pos = PNULL;
    uint16 id_begin = 0;
    uint16 id_end = 0;
    uint8  str_len = 0;
    if(PNULL == interval_str_ptr||PNULL == separa_pos||PNULL == id_out)
    {
        return id_out;
    }

    begin_pos = interval_str_ptr;
    str_len = separa_pos - begin_pos;
    
    strncpy((char*)id_buf,(char*)begin_pos,str_len);
    id_begin = atoi((char*)id_buf);
    *id_out = id_begin;
    id_out++;
    begin_pos+=str_len;
    begin_pos++;//split "-"
    id_end = atoi((char*)begin_pos);
    if((id_end-id_begin)>=max_id)
    {
        *result = FALSE;
        return id_out;
    }
    while(++id_begin<id_end)
    {
        *id_out = id_begin;
        id_out++;
    }
    *id_out = id_end;
    id_out++;
    return id_out;            
}
/*****************************************************************************/
// 	Description : This function getentry id from cmd string,there may be more
//  than one entry id
//	Global resource dependence : none
//  Author: Xiaohua.liu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN GetMoreThanOneEntryId(char* cmd, uint16 len,uint16* id_out,uint16 max_id)
{
    char* begin_pos = PNULL;
    char* end_pos = PNULL;
    char* separa_pos = PNULL;

    uint8 str_len = 0;
    char id_str[PB_ENTRY_ID_MAX_LEN +1] = {0};
    BOOLEAN reach_end = FALSE;
    BOOLEAN result = TRUE;
    
	begin_pos = (char*)cmd;
    if(PNULL ==begin_pos||len < 1||PNULL==id_out)
	{
		return FALSE;
	}
    end_pos = MMIAPICOM_Stristr((char*)begin_pos,(char *)",");
    if(PNULL == (char*)end_pos)
    {
        strcat((char *)id_str,(char*)cmd);
        separa_pos = MMIAPICOM_Stristr((char*)id_str,(char *)"-");
            if(PNULL == (char*)separa_pos)
            {
                *id_out = atoi((char*)id_str);
                id_out++;
            }
            else
            {//for example "3-7"
                
                id_out = GetPbEntryIdFromIntervalStr((char*)id_str,
                    (char*)separa_pos,id_out,max_id,&result);
                if(!result)
                {
                    return result;
                }
            }  
    }
    else
    {
        while(PNULL!=end_pos&&end_pos>begin_pos)
        {
            str_len = end_pos - begin_pos;
            len-=str_len;
            strncpy(id_str,begin_pos,str_len);
            separa_pos = MMIAPICOM_Stristr(id_str,(char *)"-");
            if(PNULL == separa_pos)
            {
                *id_out = atoi((char *)id_str);
                id_out++;
            }
            else
            {//for example "3-7"
                id_out = GetPbEntryIdFromIntervalStr((char*)id_str,(char*)separa_pos,id_out,
                    max_id,&result);
            }  
            end_pos++;//split ","
            len--;
            begin_pos = end_pos;
            end_pos = MMIAPICOM_Stristr(begin_pos,(char*)MMI_COMMA_SYMBOL);
            if((PNULL == end_pos)&&len>0)
            {
                reach_end = TRUE;
            }
            SCI_MEMSET((char *)id_str,0,sizeof(id_str));
        }
        if(reach_end)
        {
            str_len = len;
            strncpy((char*)id_str,(char*)begin_pos,str_len);
            separa_pos = MMIAPICOM_Stristr((char*)id_str,(char *)"-");
            if(PNULL == (char*)separa_pos)
            {
                *id_out = atoi((char *)id_str);
                id_out++;
            }
            else
            {//for example "3-7"
               id_out = GetPbEntryIdFromIntervalStr((char*)id_str,(char*)separa_pos,
                id_out,max_id,&result);
               if(!result)
                {
                    return result;
                }
            }  
        }
    }
    return result;
}
/*****************************************************************************/
// 	Description : get the store index in number_t[] of the specify number_type
//	Global resource dependence : none
//  Author:  xiaohua.liu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN GetIndexOfNumberType(PB_NUMBER_TYPE_E number_type,PB_PHONEBOOK_ENTRY_T *pb_entry_ptr,
        uint16* num_index_ptr)
{
    uint8 i = 0;
    BOOLEAN result = FALSE;
        
    if(PNULL == pb_entry_ptr||PNULL == num_index_ptr)
    {
        return result;
    }
    for(i = 0;i < MMI_SYNC_PB_MAX_NV_PHONE_NUM;i++)
    {
        if(number_type == pb_entry_ptr->number_t[i].number_type&&
            pb_entry_ptr->number_t[i].number_len>0)
        {
            *num_index_ptr = i;
            result = TRUE;
            break;
        }
    }
    return result;
}
/*****************************************************************************/
// 	Description : according to the output protocal,format the output string
//	Global resource dependence : none
//  Author:  xiaohua.liu
//	Note:
/*****************************************************************************/
LOCAL char* FormatPbInforOut(char* str_out_ptr,uint16* out_len_ptr,PB_PHONEBOOK_ENTRY_T *pb_entry_ptr)
{
    uint16 number_index = 0;
    uint16 i=0;
    uint16 unit_len = 0;
	uint32 output_len = 0;
    uint32 hex_len = 0;
    char temp_buf[ATC_TEMP_BUF_LEN+1] = {0};
    char hex_buf[ATC_TEMP_BUF_LEN+1] = {0};
    
    BOOLEAN have_group_info = FALSE;

    if(PNULL == str_out_ptr||PNULL == pb_entry_ptr)
    {
        return str_out_ptr;
    }

    strcat((char*)str_out_ptr, (char*)MMI_SYNC_INDICATE);
    unit_len += SCI_STRLEN((char*)MMI_SYNC_INDICATE);

    strcat((char*)str_out_ptr,(char*)MMI_COLON_SYMBOL);
    unit_len += SCI_STRLEN((char*)MMI_COLON_SYMBOL);

    strcat((char*)str_out_ptr,(char*)MMI_ID_TAG);
    unit_len += SCI_STRLEN((char*)MMI_ID_TAG);

    SCI_MEMSET(temp_buf,0,sizeof(temp_buf));
    MMIAPICOM_Int2Str(pb_entry_ptr->entry_id,(uint8*)temp_buf,sizeof(temp_buf));
    //itoa(pb_entry_ptr->entry_id,temp_buf,10);
    strcat(str_out_ptr,temp_buf);
    unit_len +=SCI_STRLEN((char*)temp_buf);
    
    strcat(str_out_ptr,(char*)MMI_COMMA_SYMBOL);
    unit_len += SCI_STRLEN((char*)MMI_COMMA_SYMBOL);
    if(pb_entry_ptr->entry_name.alpha_len>0)    
    {
        strcat(str_out_ptr,(char*)PB_NAME_TAG);
        unit_len += SCI_STRLEN((char *)PB_NAME_TAG);
	//output_len = GUI_WstrToGB((uint8*)str_out_ptr+unit_len, pb_entry_ptr->entry_name.alpha, pb_entry_ptr->entry_name.alpha_len);
        SCI_MEMSET(temp_buf,0,sizeof(temp_buf));
        output_len = GUI_WstrToUTF8((uint8*)temp_buf, sizeof(temp_buf),pb_entry_ptr->entry_name.alpha, pb_entry_ptr->entry_name.alpha_len);

        SCI_MEMSET(hex_buf,0,sizeof(hex_buf));
        MMIAPICOM_BinaryToHexChar(temp_buf,output_len,hex_buf,&hex_len);
        
       strncpy(str_out_ptr+unit_len,hex_buf,hex_len);
        unit_len += hex_len;
        
        strcat(str_out_ptr,(char*)MMI_COMMA_SYMBOL);//add ","
        unit_len += SCI_STRLEN((char *)MMI_COMMA_SYMBOL);
    }
    //append number info
    for(i = 0;i<PB_NUMBER_MAX;i++)
    {    
        if(GetIndexOfNumberType(
            s_pb_number_tag[i].number_type,
            pb_entry_ptr,
            &number_index))
        {
            strcat(str_out_ptr,(char*)s_pb_number_tag[i].type_tag);
            unit_len += SCI_STRLEN((char *)s_pb_number_tag[i].type_tag);

            strcat(str_out_ptr,(char*)pb_entry_ptr->number_t[number_index].number);
            unit_len += pb_entry_ptr->number_t[number_index].number_len;
    
            strcat(str_out_ptr,(char*)MMI_COMMA_SYMBOL);
            unit_len += SCI_STRLEN((char *)MMI_COMMA_SYMBOL);
        }
    }

    if(pb_entry_ptr->mail.mail_len>0)    
    {
        strcat(str_out_ptr,(char*)PB_EMAIL_TAG);
        unit_len += SCI_STRLEN((char*)PB_EMAIL_TAG);

        // output_len = GUI_WstrToGB((uint8*)str_out_ptr+unit_len, pb_entry_ptr->mail.mail,
       //     pb_entry_ptr->mail.mail_len);
        SCI_MEMSET(temp_buf,0,sizeof(temp_buf));
        output_len = GUI_WstrToUTF8((uint8*)temp_buf, sizeof(temp_buf),pb_entry_ptr->mail.mail, pb_entry_ptr->mail.mail_len);

        SCI_MEMSET(hex_buf,0,sizeof(hex_buf));
        MMIAPICOM_BinaryToHexChar(temp_buf,output_len,hex_buf,&hex_len);
        
        strcat(str_out_ptr,hex_buf);
        unit_len += hex_len;
       
    
        strcat(str_out_ptr,(char*)MMI_COMMA_SYMBOL);//add ","
        unit_len += SCI_STRLEN((char *)MMI_COMMA_SYMBOL);
    }


    if(pb_entry_ptr->group>0)    
    {
        have_group_info = TRUE;
        strcat(str_out_ptr,(char*)PB_GROUP_TAG);
        unit_len += SCI_STRLEN((char*)PB_GROUP_TAG);
        i=PB_GROUP_HOME;
        while(i<(MMIPB_USER_GROUP_NUM + MMIPB_SYSTEM_GROUP_NUM))
        {
            if((pb_entry_ptr->group&(1<<i))>0)
            {
                SCI_MEMSET(temp_buf,0,sizeof(temp_buf));
                MMIAPICOM_Int2Str(i,(uint8*)temp_buf,sizeof(temp_buf));
                //itoa(i,temp_buf,10);
                strcat(str_out_ptr,(char*)temp_buf);
                unit_len += SCI_STRLEN(temp_buf);
                
                strcat(str_out_ptr,(char*)MMI_COMMA_SYMBOL);//add ","
                unit_len += SCI_STRLEN((char *)MMI_COMMA_SYMBOL);
            }
            i++;
        }
        
    
        strncpy(str_out_ptr+unit_len-1,(char*)")",1);//replace the final ","
        //unit_len ++;
    }
    if(!have_group_info)
    {
        str_out_ptr[unit_len-1]='\0';
        unit_len--;//if no group info,replace the final ","
    }
    strcat(str_out_ptr,(char*)MMI_NEW_LINE_SYMBOL);
    unit_len += SCI_STRLEN((char*)MMI_NEW_LINE_SYMBOL);
    
    *out_len_ptr = unit_len;
    return str_out_ptr+unit_len;
}
/*****************************************************************************/
// 	Description : This function handle the pb get one item command
//	Global resource dependence : none
//  Author:  xiaohua.liu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandlePbReadItem(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{
    PB_PHONEBOOK_ENTRY_T  pb_item = {0};
	char* end_pos = PNULL;
    char* res_cmd = NULL;
    char*  res_str_ptr = NULL;
	uint8 str_len = 0;
    uint16 res_len = 0;    
    uint16 entry_id[PB_ITEM_READ_MAX_NUM] = {0};
    uint16 dest_len = 0;
    uint8  pos = 0;
    uint8 i = 0;
    BOOLEAN result = FALSE;

	if(PNULL == (char*)cmd||len<2)
	{
		return FALSE;
	}
	
    	res_cmd = (uint8 *)SCI_ALLOC_APP(MAX_RESCMD_LEN);
	if(NULL == res_cmd)
    	{
    		return FALSE;
    	}

    if(!GetPbStorage(&pos, *cmd))
    {
        return FALSE;
    }

    cmd++;//split pos
    len--;
    end_pos = MMIAPICOM_Stristr((char*)cmd,(char*)"=");

	if(PNULL == (char*)end_pos)
	{
		return FALSE;
	}
	str_len = (char*)end_pos-(char*)cmd;
	len-=str_len;
	end_pos++;//split '='
	cmd = (uint8*)end_pos;
	len--;
	if(GetMoreThanOneEntryId((char*)cmd,(uint16)len,entry_id,PB_ITEM_READ_MAX_NUM )) 
	    {
    //SCI_TRACE_LOW:"mmi_atc.c: HandlePbReadItem(), pos = %d, entry_id = %d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11632_112_2_18_1_59_50_101,(uint8*)"dd", pos, entry_id);

    SCI_MEMSET((char*)res_cmd, 0, MAX_RESCMD_LEN);

    res_str_ptr = res_cmd;
    while(i<PB_ITEM_READ_MAX_NUM&&entry_id[i]>0)
    {
        SCI_MEMSET((PB_PHONEBOOK_ENTRY_T*)&pb_item, 0, sizeof(PB_PHONEBOOK_ENTRY_T));
        pb_item.entry_id = entry_id[i];
        if(MMIPB_SyncRead(&pb_item, pos))
        {
            //SCI_TRACE_LOW:"mmi_atc.c: HandlePbReadItem(), entry_id = %d"
            SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11639_112_2_18_1_59_50_102,(uint8*)"d", pb_item.entry_id);

            res_str_ptr = FormatPbInforOut(res_str_ptr,&res_len,&pb_item);
            dest_len+=res_len;
            result = TRUE;
        }
        i++;
    }
	    }
    if(result)
    {
        strcat((char*)res_cmd,(char*)MMI_TO_SYNC_OK_SYMBOL);
        dest_len += SCI_STRLEN((char*)MMI_TO_SYNC_OK_SYMBOL);
        ReturnResponse((uint8*)res_cmd, dest_len);
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)SCI_STRLEN((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }

    SCI_FREE(res_cmd);

    return TRUE;
}
/*****************************************************************************/
// 	Description : This function parse the add command and get contact infor
//	Global resource dependence : none
//  Author:      xiaohua.liu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN ParsePbAddInforFromCmd(char *cmd,
    uint32 len,
    PB_PHONEBOOK_ENTRY_T *pb_entry_ptr
)
{
    char *begin_pos = PNULL;
    char *end_pos = PNULL;
    uint8 index = 0;
    uint8 i = 0;
    uint8 item_num = 0;
    uint8 tag_len = 0;
    uint16 infor_len = 0;

    BOOL reach_end = FALSE;
   
	MMI_STRING_T str_t = {0};
	char temp_buf[ATC_TEMP_BUF_LEN+1] = {0};
	uint16 bufstr_len = 0;
    
    if(PNULL == (char*)cmd||PNULL == pb_entry_ptr||len<2)
    {
        return FALSE;
    }
    
    item_num = sizeof(s_pb_number_tag)/sizeof(s_pb_number_tag[0]);
    begin_pos = MMIAPICOM_Stristr((char*)cmd,(char *)PB_NAME_TAG);
    if(PNULL!=begin_pos)
    {
        end_pos = MMIAPICOM_Stristr((char*)cmd,(char *)MMI_COMMA_SYMBOL);
        if(PNULL == end_pos)
        {
            end_pos = MMIAPICOM_Stristr((char*)cmd,(char *)CMD_LINE_END_TAG);
            reach_end = TRUE;
        }
        if(NULL!= (char*)end_pos&&(char*)end_pos>(char*)begin_pos)
        {
            tag_len = SCI_STRLEN((char*)PB_NAME_TAG);
            infor_len = (char*)end_pos - (char*)begin_pos;
			
		SCI_MEMSET((char*)temp_buf,0,sizeof(temp_buf));
	/*	SCI_MEMCPY((char*)temp_buf,begin_pos+tag_len,infor_len-tag_len);

	//	MMIAPICOM_GBToSTRING((uint8*)temp_buf,&str_t);
	//	MMIAPICOM_Wstrncpy(pb_entry_ptr->entry_name.alpha,str_t.wstr_ptr,MIN(str_t.wstr_len,MMI_SYNC_PB_NAME_MAX_LEN));
	//	pb_entry_ptr->entry_name.alpha_len = str_t.wstr_len;
*/
        MMIAPICOM_HexCharToBinary(begin_pos+tag_len, infor_len-tag_len, temp_buf, &bufstr_len);
        pb_entry_ptr->entry_name.alpha_len = GUI_UTF8ToWstr(pb_entry_ptr->entry_name.alpha,
            MMI_SYNC_PB_NAME_MAX_LEN,temp_buf, bufstr_len);//begin_pos+tag_len,begin_pos+tag_len);
		
		
            pb_entry_ptr->entry_name.is_ucs2 = !MMIAPICOM_IsASCIIString(
                pb_entry_ptr->entry_name.alpha,
                pb_entry_ptr->entry_name.alpha_len
                );
            if(reach_end)
            {
                return TRUE;
            }
            else
            {
                end_pos++;//split ','
                cmd = end_pos;
            }
        }
    }
        
    while(i<item_num)   
    {     
        begin_pos = MMIAPICOM_Stristr((char*)cmd,(char *)s_pb_number_tag[i].type_tag);
        if(PNULL!=begin_pos)
        {
            end_pos = MMIAPICOM_Stristr((char*)cmd,(char *)MMI_COMMA_SYMBOL);
            if(PNULL == (char*)end_pos)
            {
                end_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)CMD_LINE_END_TAG);
            }
            if(NULL!=end_pos&&end_pos>begin_pos)
            {
                tag_len = SCI_STRLEN((char*)s_pb_number_tag[i].type_tag);
                infor_len = (char*)end_pos - (char*)begin_pos;
                index=0;
                while(index<(MMI_SYNC_PB_MAX_NV_PHONE_NUM-1)&&
                    pb_entry_ptr->number_t[index].number_len>0)
                {
                    index++;
                }
              //  if(index<MMI_SYNC_PB_MAX_NV_PHONE_NUM)
                {
                    pb_entry_ptr->number_t[index].number_type = s_pb_number_tag[i].number_type;
                    MMIAPICOM_CopyString(&pb_entry_ptr->number_t[index].number_len,
                        pb_entry_ptr->number_t[index].number,infor_len-tag_len,MMI_SYNC_PB_NUM_MAX_LEN,
                        (uint8*)begin_pos+tag_len);
                   // strncpy(pb_entry_ptr->number_t[index].number,begin_pos+tag_len,infor_len-tag_len);
                  //  pb_entry_ptr->number_t[index].number_len= infor_len-tag_len;
			    }
                if(reach_end)
                {
                    return TRUE;
                }
                else
                {
                    end_pos++;//split ','
                    cmd = end_pos;
                }
            }
        }
        i++;
    }
    

    begin_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)PB_EMAIL_TAG);
    if(PNULL!=(char*)begin_pos)
    {
        end_pos = MMIAPICOM_Stristr(cmd,(CHAR *)MMI_COMMA_SYMBOL);
        if(PNULL == end_pos)
        {
            end_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)CMD_LINE_END_TAG);
        }
        if(NULL!=(char*)end_pos&&(char*)end_pos>(char*)begin_pos)
        {
            infor_len = end_pos - begin_pos;
            tag_len = SCI_STRLEN((char*)PB_EMAIL_TAG);

            
            SCI_MEMSET(&str_t,0,sizeof(MMI_STRING_T));
            MMIAPICOM_GBToSTRING((uint8*)begin_pos+tag_len,&str_t);
            if(PNULL!= str_t.wstr_ptr)
            {
                MMIAPICOM_Wstrncpy(pb_entry_ptr->mail.mail,str_t.wstr_ptr, str_t.wstr_len);
                pb_entry_ptr->mail.mail_len = str_t.wstr_len;

                SCI_FREE(str_t.wstr_ptr);
            //  strncpy(pb_entry_ptr->mail.mail,begin_pos+tag_len,infor_len-tag_len);
            //  pb_entry_ptr->mail.mail_len = infor_len-tag_len;
            }
			if(reach_end)
            {
                return TRUE;
            }
            else
            {
                end_pos++;//split ','
                cmd = end_pos;
            }
        }
    }

	#ifndef PB_SUPPORT_LOW_MEMORY
    begin_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)PB_MEMO_TAG);
    if(PNULL!= (char*)begin_pos)
    {
        end_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)MMI_COMMA_SYMBOL);
        if(PNULL == end_pos)
        {
            end_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)CMD_LINE_END_TAG);
        }
        if(NULL!=(char*)end_pos&&(char*)end_pos>(char*)begin_pos)
        {
            infor_len = (char*)end_pos - (char*)begin_pos;
            tag_len = SCI_STRLEN((char*)PB_MEMO_TAG);
            
      
 		//SCI_MEMSET((char*)temp_buf,0,sizeof(temp_buf));
		//SCI_MEMCPY((char*)temp_buf,begin_pos+tag_len,infor_len-tag_len);
        pb_entry_ptr->memo.note_len = GUI_UTF8ToWstr(pb_entry_ptr->memo.note,
            MMIPB_MAX_CUSTOM_TEXT_LEN,begin_pos+tag_len,infor_len-tag_len);
/*
		MMIAPICOM_GBToSTRING((uint8*)temp_buf,&str_t);
		MMIAPICOM_Wstrncpy(pb_entry_ptr->memo.note,str_t.wstr_ptr,MIN(str_t.wstr_len,MMIPB_MAX_CUSTOM_TEXT_LEN));
		pb_entry_ptr->memo.note_len= str_t.wstr_len;
		if(PNULL!=str_t.wstr_ptr)
		{
			SCI_FREE(str_t.wstr_ptr);
		}
*/		
            if(reach_end)
            {
                return TRUE;
            }
            else
            {
                end_pos++;//split ','
                cmd = end_pos;
            }
        }
    }
    #endif
	
    begin_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)PB_GROUP_TAG);
    if(PNULL!=(char*)begin_pos)//GROUP:(1,2,4)
    {
       end_pos = MMIAPICOM_Stristr(cmd,(char*)")");
        if(PNULL == end_pos)
        {
            end_pos = MMIAPICOM_Stristr(cmd,(char*)CMD_LINE_END_TAG);
        }
        if(NULL!=end_pos&&end_pos>begin_pos)
        {
        #if 0
             uint16 sim_num = sizeof(pb_sync_sim_ids)/sizeof(pb_sync_sim_ids[0]);
		infor_len = end_pos - begin_pos;
            tag_len = SCI_STRLEN(PB_GROUP_TAG);
        //    begin_pos = cmd+tag_len;
            strncpy(group_str,begin_pos+tag_len,infor_len-tag_len);
		if(SCI_STRLEN(group_str)>1)
		{
			begin_pos = group_str;
			end_pos = MMIAPICOM_Stristr(begin_pos,(CHAR *)MMI_COMMA_SYMBOL);
			while(PNULL!=end_pos&&end_pos>begin_pos)
			{
				SCI_MEMSET(temp_buf,0,sizeof(temp_buf));
				infor_len = end_pos - begin_pos;
				strncpy(temp_buf,begin_pos,infor_len);
				group_id = (PB_GROUP_LIST_E)atoi(temp_buf);
				if(group_id>pb_sync_sim_ids[sim_num-1])
				{	
                    			pb_entry_ptr->group |= 1<<group_id;
				}
				end_pos++;
                begin_pos=end_pos;
                end_pos = MMIAPICOM_Stristr(begin_pos,(CHAR *)MMI_COMMA_SYMBOL);
            }
			group_id = (PB_GROUP_LIST_E)atoi(begin_pos);
			if(group_id>pb_sync_sim_ids[sim_num-1])
			{	
				pb_entry_ptr->group |= 1<<group_id;
			}
            	}
		else
		{
			group_id = (PB_GROUP_LIST_E)atoi(group_str);
                	if(group_id>pb_sync_sim_ids[sim_num-1])
			{	
				pb_entry_ptr->group |= 1<<group_id;
			}
		}
           #else
		   MMIPB_GetPbGroupIdFromStr(pb_entry_ptr,begin_pos, end_pos);
		   #endif
        }
    }
	return TRUE;	
}
/*****************************************************************************/
// 	Description : This function handle the pb add command
//	Global resource dependence : none
//  Author:      xiaohua.liu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandlePbAdd(	
                            uint8 *cmd,  // Point to the command infomation buffer
					        uint32 len   // The length of command infomation buffer
                            )
{
	PB_PHONEBOOK_ENTRY_T *pb_entry_ptr = PNULL;
	uint16 contact_id = 0;
	uint8  pos = 0;
	uint8 res_len = 0;
	char res_cmd[ATC_TEMP_BUF_LEN] = {0};
	char temp_buf[10] = {0};
	char* end_pos = PNULL;
    uint16 str_len = 0;
    BOOLEAN result = FALSE;
	MMIPB_ERROR_E add_ret = 0;
	if(PNULL == cmd||len<2)
	{
		return result;
	}
     
    pb_entry_ptr = (PB_PHONEBOOK_ENTRY_T *)SCI_ALLOC_APP(sizeof(PB_PHONEBOOK_ENTRY_T));
    if(pb_entry_ptr == PNULL)
    {
        return result;
    }
    SCI_MEMSET(pb_entry_ptr, 0, sizeof(PB_PHONEBOOK_ENTRY_T));

    if(!GetPbStorage(&pos, *cmd))
    {
        return result;
    }

    end_pos = MMIAPICOM_Stristr((char*)cmd,(char*)"=");
    if(PNULL == end_pos)
    {
        return FALSE;
    }
    str_len = end_pos - (char*)cmd;
    len-=str_len;
    end_pos++;//split '='
    len--;
    cmd=(uint8*)end_pos;
  /*  
	cmd++;
	cmd++;//split '='
	len-=2;
   */
    //SCI_TRACE_LOW:"mmi_atc.c: HandlePbAdd(), pos = %d, entry_id = %d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11699_112_2_18_1_59_50_103,(uint8*)"dd", pos, pb_entry_ptr->entry_id);

	if( ParsePbAddInforFromCmd((char*)cmd,len,pb_entry_ptr))
	{	
		add_ret = MMIPB_SyncAdd(pos, pb_entry_ptr,&contact_id);
		if(MMIPB_ERROR_ERROR == add_ret)
		{
			//   if(PB_SYNC_POS_ME == pos)
			result = TRUE;
			//return "ok\r\n" to sync tool;
		}
		
	}
	if(MMIPB_ERROR_PENDING != add_ret)
	{
		if(result)
		{
			strcat(res_cmd,(char*)MMI_SYNC_INDICATE);
			res_len += SCI_STRLEN((char*)MMI_SYNC_INDICATE);
			
			strcat(res_cmd,(char*)MMI_COLON_SYMBOL);
			res_len += SCI_STRLEN((char*)MMI_COLON_SYMBOL);
			
			MMIAPICOM_Int2Str(contact_id,(uint8*)temp_buf,sizeof(temp_buf));
			//itoa(contact_id,temp_buf,10);
			strcat(res_cmd,temp_buf);
			res_len += SCI_STRLEN((char*)temp_buf);
			
			strcat(res_cmd,(char*)MMI_TO_SYNC_OK_SYMBOL);
			res_len += (uint8)SCI_STRLEN((char*)MMI_TO_SYNC_OK_SYMBOL);
			ReturnResponse((uint8 *)res_cmd,res_len);
		}
		else
		{
			ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)SCI_STRLEN((char*)MMI_TO_SYNC_ERROR_SYMBOL));
		}
	}

	SCI_FREE(pb_entry_ptr);
	return TRUE;
}

/*****************************************************************************/
// 	Description : This function handle pb delete callback
//	Global resource dependence : none
//  Author: liqing.peng
//	Note:
/*****************************************************************************/
void MMISYNC_PbDeleteCallback(
                              BOOLEAN   is_success
                              )
{
    //SCI_TRACE_LOW:"mmi_atc.c: MMISYNC_PbDeleteCallback, is_success = %d, s_ispbop_wait = %d"
//    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11729_112_2_18_1_59_50_104,(uint8*)"dd", is_success, s_ispbop_wait);

  //  if(s_ispbop_wait)
    {
        if(is_success)
        {
            ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)SCI_STRLEN((char*)MMI_TO_SYNC_OK_SYMBOL));
        }
        else
        {
            ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)SCI_STRLEN((char*)MMI_TO_SYNC_ERROR_SYMBOL));
        }

    //    s_ispbop_wait = FALSE;
    }
}

/*****************************************************************************/
// 	Description : This function handle the pb delete command
//	Global resource dependence : none
//  Author:    xiaohua.liu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandlePbDelete(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{
	uint16 entry_id = 0;
	uint8  pos = 0;
	uint8 str_len = 0;
//	char* begin_pos = PNULL;
	char* end_pos= PNULL;
	MMIPB_ERROR_E del_ret = 0;
    if(PNULL == cmd||len < 2)
    {
    	return FALSE;
    }
    
    if(!GetPbStorage(&pos, *cmd))
    {
        return FALSE;
    }

    cmd++;//split pos
    len--;
    end_pos = MMIAPICOM_Stristr((char*)cmd,(char*)"=");

	if(PNULL == end_pos)
	{
		return FALSE;
	}
	str_len = end_pos-(char*)cmd;
	len-=str_len;
	end_pos++;//split '='
	cmd = (uint8*)end_pos;
	len--;
	if(len<1)
	{
		return FALSE;
	}
    entry_id = (uint16)GetEntryId((char*)cmd, (uint16)len) ;    
    //SCI_TRACE_LOW:"mmi_atc.c: HandlePbDelete(), pos = %d, entry_id = %d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11767_112_2_18_1_59_50_105,(uint8*)"dd",pos, entry_id);
    del_ret = MMIPB_SyncDelete(pos, entry_id);
    if(MMIPB_ERROR_SUCCESS == del_ret)
    {
        //return "ok\r\n" to sync tool;
        ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)SCI_STRLEN((char*)MMI_TO_SYNC_OK_SYMBOL));
    }
    else
    {
		if(MMIPB_ERROR_PENDING != del_ret)
		{
			ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)SCI_STRLEN((char*)MMI_TO_SYNC_ERROR_SYMBOL));
		}
    }

    return TRUE;
}
/*****************************************************************************/
// 	Description : This function parse the modify command and get contact infor
//	Global resource dependence : none
//  Author:      xiaohua.liu
//	Note:
/*****************************************************************************/
LOCAL void ParsePbModifyInforFromCmd(uint8 *cmd,
    uint32 len,
    PB_PHONEBOOK_ENTRY_T *pb_entry_ptr
)
{
    CHAR *begin_pos = PNULL;
    CHAR *end_pos = PNULL;
    uint8 index = 0;
    uint8 i = 0;
    uint8 item_num = 0;
    uint8 tag_len = 0;
    uint16 infor_len = 0;
    BOOL reach_end = FALSE;
    CHAR group_str[20] = {0};
    CHAR temp_buf[50] = {0};
	MMI_STRING_T str_t = {0};
    
    if(PNULL == cmd||PNULL == pb_entry_ptr)
    {
        return ;
    }
	
     item_num = sizeof(s_pb_number_tag)/sizeof(s_pb_number_tag[0]);
   begin_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)MMI_ID_TAG);
    if(PNULL!=begin_pos)
    {
        end_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)MMI_COMMA_SYMBOL);
        if(PNULL == end_pos)
        {
            end_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)CMD_LINE_END_TAG);
            reach_end = TRUE;
        }
        if(NULL!=end_pos&&end_pos>begin_pos)
        {
            tag_len = SCI_STRLEN((char*)MMI_ID_TAG);
            infor_len = end_pos - begin_pos;
            strncpy(temp_buf,begin_pos+tag_len,infor_len-tag_len);
            pb_entry_ptr->entry_id = atoi(temp_buf);
            if(reach_end)
            {
                return;
            }
            else
            {
                end_pos++;//split ','
                cmd = (uint8*)end_pos;
            }
        }
    }
    
    begin_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)PB_NAME_TAG);
    if(PNULL!=begin_pos)
    {
        end_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)MMI_COMMA_SYMBOL);
        if(PNULL == end_pos)
        {
            end_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)CMD_LINE_END_TAG);
            reach_end = TRUE;
        }
        if(NULL!=end_pos&&end_pos>begin_pos)
        {
            tag_len = SCI_STRLEN((char*)PB_NAME_TAG);
            infor_len = end_pos - begin_pos;
  /*
		SCI_MEMSET((char*)temp_buf,0,sizeof(temp_buf));
		SCI_MEMCPY((char*)temp_buf,begin_pos+tag_len,infor_len-tag_len);

		MMIAPICOM_GBToSTRING((uint8*)temp_buf,&str_t);
		if(PNULL!=str_t.wstr_ptr)
		{
		    MMIAPICOM_Wstrncpy(pb_entry_ptr->entry_name.alpha, str_t.wstr_ptr,MIN(str_t.wstr_len,MMI_SYNC_PB_NAME_MAX_LEN));
		    pb_entry_ptr->entry_name.alpha_len = str_t.wstr_len;
		
			SCI_FREE(str_t.wstr_ptr);
		}			
       */    
        pb_entry_ptr->entry_name.alpha_len = GUI_UTF8ToWstr(pb_entry_ptr->entry_name.alpha, 
            MMI_SYNC_PB_NAME_MAX_LEN,begin_pos+tag_len, infor_len-tag_len);
	       pb_entry_ptr->entry_name.is_ucs2 = !MMIAPICOM_IsASCIIString(
                pb_entry_ptr->entry_name.alpha,
                pb_entry_ptr->entry_name.alpha_len
                );
            if(reach_end)
            {
                return;
            }
            else
            {
                end_pos++;//split ','
                cmd = (uint8*)end_pos;
            }
        }
    }
        
    while(i<item_num)   
    {     
        begin_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)s_pb_number_tag[i].type_tag);
        if(PNULL!=begin_pos)
        {
            end_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)MMI_COMMA_SYMBOL);
            if(PNULL == end_pos)
            {
                end_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)CMD_LINE_END_TAG);
                reach_end = TRUE;
            }
            if(NULL!=end_pos&&end_pos>begin_pos)
            {
                tag_len = SCI_STRLEN(s_pb_number_tag[i].type_tag);
                infor_len = end_pos - begin_pos;
                index=0;
                while(index<(MMI_SYNC_PB_MAX_NV_PHONE_NUM-1)&&
                    pb_entry_ptr->number_t[index].number_len>0)
                {
                    if(pb_entry_ptr->number_t[index].number_type == s_pb_number_tag[i].number_type)
                    {
                        break;
                    }
                    else
                    {
                        index++;
                    }
                }
                pb_entry_ptr->number_t[index].number_type = s_pb_number_tag[i].number_type;
                strncpy((char*)pb_entry_ptr->number_t[index].number,(char*)cmd+tag_len,MIN(MMI_SYNC_PB_NUM_MAX_LEN,infor_len-tag_len));
                pb_entry_ptr->number_t[index].number_len= infor_len-tag_len;
			    if(reach_end)
                {
                    return;
                }
                else
                {
                    end_pos++;//split ','
                    cmd = (uint8*)end_pos;
                }
            }
        }
        i++;
    }
    

    begin_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)PB_EMAIL_TAG);
    if(PNULL!=begin_pos)
    {
        end_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)MMI_COMMA_SYMBOL);
        if(PNULL == end_pos)
        {
            end_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)CMD_LINE_END_TAG);
            reach_end = TRUE;
        }
        if(NULL!=(char*)end_pos&&(char*)end_pos>(char*)begin_pos)
        {
            infor_len = (char*)end_pos - (char*)begin_pos;
            tag_len = SCI_STRLEN((char*)PB_EMAIL_TAG);

            SCI_MEMSET(&str_t,0,sizeof(MMI_STRING_T));
            MMIAPICOM_GBToSTRING((uint8*)begin_pos+tag_len,&str_t);
            if(PNULL!= str_t.wstr_ptr)
            {
                MMIAPICOM_Wstrncpy(pb_entry_ptr->mail.mail,str_t.wstr_ptr, str_t.wstr_len);
                pb_entry_ptr->mail.mail_len = str_t.wstr_len;

                SCI_FREE(str_t.wstr_ptr);
            //strncpy((char*)pb_entry_ptr->mail.mail,cmd+tag_len,infor_len-tag_len);
           // pb_entry_ptr->mail.mail_len = infor_len-tag_len;
            }
			if(reach_end)
            {
                return;
            }
            else
            {
                end_pos++;//split ','
                cmd = (uint8*)end_pos;
            }
        }
    }
    #ifndef PB_SUPPORT_LOW_MEMORY
    begin_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)PB_MEMO_TAG);
    if(PNULL!=begin_pos)
    {
        end_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)MMI_COMMA_SYMBOL);
        if(PNULL == (char*)end_pos)
        {
            end_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)CMD_LINE_END_TAG);
            reach_end = TRUE;
        }
        if(NULL!= end_pos&& end_pos> begin_pos)
        {
            infor_len = end_pos - begin_pos;
            tag_len = SCI_STRLEN((char*)PB_MEMO_TAG);
/*
			SCI_MEMSET((char*)temp_buf,0,sizeof(temp_buf));
		SCI_MEMCPY((char*)temp_buf,begin_pos+tag_len,infor_len-tag_len);

		MMIAPICOM_GBToSTRING((uint8*)temp_buf,&str_t);
		MMIAPICOM_Wstrncpy(pb_entry_ptr->memo.note,str_t.wstr_ptr,MIN(str_t.wstr_len,MMIPB_MAX_CUSTOM_TEXT_LEN));
		pb_entry_ptr->memo.note_len= str_t.wstr_len;
		if(PNULL!=str_t.wstr_ptr)
		{
			SCI_FREE(str_t.wstr_ptr);
		}
		*/
       pb_entry_ptr->memo.note_len = GUI_UTF8ToWstr(pb_entry_ptr->memo.note,
            MMIPB_MAX_CUSTOM_TEXT_LEN,begin_pos+tag_len,infor_len-tag_len);

            if(reach_end)
            {
                return;
            }
            else
            {
                end_pos++;//split ','
                cmd = (uint8*)end_pos;
            }
        }
    }
    #endif
	
    begin_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)PB_GROUP_TAG);
    if(PNULL!=begin_pos)//GROUP:(1,2,4)
    {
        end_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)")");
        if(PNULL == (char*)end_pos)
        {
            end_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)CMD_LINE_END_TAG);
            reach_end = TRUE;
        }
        if(NULL!= (char*)end_pos&&(char*)end_pos>(char*)begin_pos)
        {
            infor_len = (char*)end_pos - (char*)begin_pos;
            tag_len = SCI_STRLEN((char*)PB_GROUP_TAG);
            begin_pos = (char*)cmd+tag_len;
            strncpy((char*)group_str,(char*)cmd+tag_len,infor_len-tag_len);
            if(SCI_STRLEN(group_str)>1)
            {
				CHAR temp_str[5] = {0};
				begin_pos = group_str;
                end_pos = MMIAPICOM_Stristr((char*)begin_pos,(CHAR *)MMI_COMMA_SYMBOL);
                while(PNULL!=(char*)end_pos&&(char*)end_pos>(char*)begin_pos)
                {
					SCI_MEMSET((char*)temp_str,0,sizeof(temp_str));
                    infor_len = (char*)end_pos - (char*)begin_pos;
                    strncpy((char*)temp_str,(char*)begin_pos,infor_len);
                    pb_entry_ptr->group |= 1<<atoi(temp_str);
                    end_pos++;
                    begin_pos= end_pos;
                    end_pos = MMIAPICOM_Stristr((char*)begin_pos,(CHAR *)MMI_COMMA_SYMBOL);
                }
				pb_entry_ptr->group |= 1<<atoi(begin_pos);
            }
			else
			{
                pb_entry_ptr->group |= 1<<atoi(group_str);
            }
           
        }
    }
}
/*****************************************************************************/
// 	Description : This function handle the pb modify command
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandlePbModify(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{
    PB_PHONEBOOK_ENTRY_T pb_entry = {0};
    uint8  pos = 0;
    MMIPB_ERROR_E error_code = 0;
	if(PNULL == cmd||len<2)
	{
		return FALSE;
	}
	
    if(!GetPbStorage(&pos, *cmd))
    {
        return FALSE;
    }
    cmd++;
    cmd++;//split '='
    len-=2;
//    SCI_MEMCPY(&pb_entry, cmd, sizeof(PB_PHONEBOOK_ENTRY_T));
//liuxiaohua    pb_entry_size = sizeof(PB_PHONEBOOK_ENTRY_T);
//liuxiaohua     MMIAPICOM_HexCharToBinary(cmd, len-1,(uint8*)&pb_entry, &pb_entry_size);
//liuxiaohua     SCI_ASSERT(pb_entry_size == sizeof(PB_PHONEBOOK_ENTRY_T)); /*assert verified*/
    ParsePbModifyInforFromCmd(cmd,len,&pb_entry);
    //SCI_TRACE_LOW:"mmi_atc.c: HandlePbModify(), pos = %d, entry_id = %d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11815_112_2_18_1_59_50_106,(uint8*)"dd", pos, pb_entry.entry_id);
    error_code =MMIPB_SyncModify(pos, &pb_entry);
	if(MMIPB_ERROR_PENDING != error_code)
	{
		if(MMIPB_ERROR_SUCCESS == error_code)
		{
			//return "ok\r\n" to sync tool;
			ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)SCI_STRLEN((char*)MMI_TO_SYNC_OK_SYMBOL));
		}
		else
		{
			ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)SCI_STRLEN((char*)MMI_TO_SYNC_ERROR_SYMBOL));
		}
	}

    return TRUE;
}

/*****************************************************************************/
// 	Description : This function handle pb delete callback
//	Global resource dependence : none
//  Author: liqing.peng
//	Note:
/*****************************************************************************/
void MMISYNC_PbUpdateCallback(
                              BOOLEAN   is_success
                              )
{
    //SCI_TRACE_LOW:"mmi_atc.c: MMISYNC_PbUpdateCallback, is_success = %d, s_ispbop_wait = %d"
  //  SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11845_112_2_18_1_59_50_107,(uint8*)"dd", is_success, s_ispbop_wait);

//    if(s_ispbop_wait)
    {
        if(is_success)
        {
            ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)SCI_STRLEN((char*)MMI_TO_SYNC_OK_SYMBOL));
        }
        else
        {
            ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)SCI_STRLEN((char*)MMI_TO_SYNC_ERROR_SYMBOL));
        }

   //     s_ispbop_wait = FALSE;
    }
}

/*****************************************************************************/
// 	Description : This function handle the sms deletecommand
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:   status(1 byte) + storage(1 byte) + record id(1 byte)
/*****************************************************************************/
LOCAL BOOLEAN HandleSmsDelete(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{
    MN_SMS_RECORD_ID_T record_id = 0;
    BOOLEAN is_mt_sms = FALSE;
    uint8	pos = 0;

	uint8 record_id_str[4]= {0};

    uint8 param[SMS_DELETE_PARAM_NUM] = {0};
    int32 i = 0;

    if(len != SMS_DELETE_PARAM_NUM + 3)
    {
		//SCI_TRACE_LOW:"mmi_atc.c:HandleSmsDelete(), length error, len = %d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11882_112_2_18_1_59_50_108,(uint8*)"d", len);
        return FALSE;
    }

    for (i=0; i<SMS_DELETE_PARAM_NUM - 1; i++)
    {         
        param[i] = *(cmd++);  
        len--;      
    }

	strncpy((char*)record_id_str,(char*)cmd,4);
	//SCI_TRACE_LOW:"mmi_atc.c:HandleSmsDelete(), record_id_str = %s"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11893_112_2_18_1_59_50_109,(uint8*)"s", record_id_str);
	record_id= atoi((char*)record_id_str);
    
    if(SMS_SYNC_STATUS_MT == param[0])
    {
        is_mt_sms = TRUE;
    }
    else if(SMS_SYNC_STATUS_MO == param[0])
    {
        is_mt_sms = FALSE;
    }
    else
    {
		//SCI_TRACE_LOW:"mmi_atc.c:HandleSmsDelete(), SMS status error,  %s"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11906_112_2_18_1_59_50_110,(uint8*)"s", param[0]);
        return FALSE;
    }
    
    if(SMS_SYNC_POS_ME == param[1])
    {
        pos = SMS_SYNC_POS_ME;
    }
    else if(SMS_SYNC_POS_SIM_1 == param[1])
    {
        pos = SMS_SYNC_POS_SIM_1;
    }
	else if(SMS_SYNC_POS_SIM_2 == param[1])
	{
		pos = SMS_SYNC_POS_SIM_2;
	}
    else
    {
		//SCI_TRACE_LOW:"mmi_atc.c:HandleSmsDelete(), SMS storage error,  %d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11924_112_2_18_1_59_50_111,(uint8*)"d", param[1]);
        return FALSE;
    }

    //record_id = param[2];

    //SCI_TRACE_LOW:"mmi_atc.c: HandleSmsDelete(), record_id = %d, is_mt_sms = %d, pos = %d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11931_112_2_18_1_59_50_112,(uint8*)"ddd",record_id, is_mt_sms, pos);

    //call the SMS function       
    if(MMIAPISMS_DelSMSByAT(is_mt_sms, pos, record_id))
    {
        //return "ok\r\n" to sync tool;
        ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)SCI_STRLEN((char*)MMI_TO_SYNC_OK_SYMBOL));
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)SCI_STRLEN((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }

    return TRUE;
}

/*****************************************************************************/
// 	Description : This function handle the group getinfo command
//	Global resource dependence : none
//  Author:      liqing.peng
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleGroupGetInfo(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{
    GROUP_HEAD_INFO_T   group_head_info = {0};
    char               *res_cmd = NULL;
    uint16              res_len = 0; 

    uint16              dest_len = 0;
    CHAR    temp_buf[10] = {0};

	
	res_cmd = (uint8 *)SCI_ALLOC_APP(MAX_RESCMD_LEN+1);
	if(NULL == res_cmd)
    	{
    		return FALSE;
    	}

    SCI_MEMSET(&group_head_info, 0, sizeof(GROUP_HEAD_INFO_T));
    SCI_MEMSET(res_cmd, 0, MAX_RESCMD_LEN);
    if(MMIPBGROUP_SyncHeadInfo(&group_head_info))
    {
        strcpy((char *)res_cmd, (char *)MMI_SYNC_INDICATE);
        res_len += SCI_STRLEN((char *)MMI_SYNC_INDICATE);

        strcat((char *)res_cmd, (char *)MMI_COLON_SYMBOL);
        res_len += SCI_STRLEN((char *)MMI_COLON_SYMBOL);

        SCI_MEMSET(temp_buf,0,sizeof(temp_buf));
        MMIAPICOM_Int2Str(group_head_info.max_group_num,(uint8*)temp_buf,sizeof(temp_buf));
        //itoa(group_head_info.max_group_num,temp_buf,10);
        strcat(res_cmd,temp_buf);
        res_len+=SCI_STRLEN(temp_buf);
        
         strcat((char *)res_cmd, (char *)MMI_COMMA_SYMBOL);
        res_len += SCI_STRLEN((char *)MMI_COMMA_SYMBOL);

        MMIAPICOM_BinaryToHexChar((uint8*)&group_head_info.all_group_id, sizeof(group_head_info.all_group_id),
			(uint8*)res_cmd+res_len,&dest_len);
        while(dest_len>0&&(48==res_cmd[dest_len+res_len-1]))//48 is '0'
            {
              //  entry_id_infor[infor_str_len-1]='\0';
                dest_len--;
            }
			if(0==dest_len)
			{
				//only append 0
				res_len++;
			}
			else
			{
				res_len += dest_len;
			}
	SCI_MEMSET(res_cmd+res_len,0,MMI_SYNC_PB_MAX_ENTRY_NUM/8-res_len-1);
	
         strcat((char *)res_cmd, (char *)MMI_COMMA_SYMBOL);
        res_len += SCI_STRLEN((char *)MMI_COMMA_SYMBOL);

        SCI_MEMSET(temp_buf,0,sizeof(temp_buf));
        MMIAPICOM_Int2Str(group_head_info.max_name_len,(uint8*)temp_buf,sizeof(temp_buf));
        //itoa(group_head_info.max_name_len,temp_buf,10);
        strcat(res_cmd,temp_buf);
        res_len+=SCI_STRLEN(temp_buf);


      //  strcat((char *)res_cmd, (char *)MMI_COMMA_SYMBOL);
      //  res_len += SCI_STRLEN((char *)MMI_COMMA_SYMBOL);
        
        dest_len = SCI_STRLEN((char*)MMI_TO_SYNC_OK_SYMBOL);
        strcat(res_cmd , (char *)MMI_TO_SYNC_OK_SYMBOL);
        res_len += dest_len;

        ReturnResponse((uint8*)res_cmd, res_len);
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)SCI_STRLEN((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }

    SCI_FREE(res_cmd);

    return TRUE;
}

/*****************************************************************************/
// 	Description : This function handle the group get one item command
//	Global resource dependence : none
//  Author:    xiaohua.liu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleGroupReadItem(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{
    uint16          group_id[PBGROUP_ITEM_READ_MAX_NUM] = {0};
    GROUP_ENTRY_T   group_item_info = {0};
    uint8           *res_cmd = NULL;
    uint16          res_len = 0; 
    uint16 str_len = 0;
    uint16          dest_len = 0;
    uint16   i=0;
    char* end_pos = PNULL;
    BOOLEAN result = FALSE;
    
    uint32 hex_len = 0;
    char temp_buf[ATC_TEMP_BUF_LEN+1] = {0};
    char hex_buf[ATC_TEMP_BUF_LEN+1] = {0};
    
    if(NULL == cmd||len < 2)
	{
		return FALSE;
	}
    
    res_cmd = (uint8 *)SCI_ALLOC_APP(MAX_RESCMD_LEN);
    if(PNULL == res_cmd)
    {
        return FALSE;
    }

    end_pos = MMIAPICOM_Stristr((char*)cmd,(char*)"=");
    if(PNULL == end_pos)
    {
        return FALSE;
    }
    str_len = end_pos - (char*)cmd;
    len -= str_len;
    end_pos++;//split "="
    len--;
    cmd = (uint8*)end_pos;
    
if(GetMoreThanOneEntryId((char*)cmd, (uint16)len,group_id,PBGROUP_ITEM_READ_MAX_NUM))
{
    SCI_MEMSET(res_cmd, 0, MAX_RESCMD_LEN);
    while(i<PBGROUP_ITEM_READ_MAX_NUM&&group_id[i]>0)
    {   
        SCI_MEMSET(&group_item_info, 0, sizeof(GROUP_ENTRY_T));
        group_item_info.group_id = group_id[i];
        if(MMIPBGROUP_SyncRead(&group_item_info))
        {
            strcat((char *)res_cmd, (char *)MMI_SYNC_INDICATE);
            res_len += SCI_STRLEN((char *)MMI_SYNC_INDICATE);

            strcat((char *)res_cmd, (char *)MMI_COLON_SYMBOL);
            res_len += SCI_STRLEN((char *)MMI_COLON_SYMBOL);

            SCI_MEMSET(temp_buf,0,sizeof(temp_buf));
            MMIAPICOM_Int2Str(group_item_info.group_id,(uint8*)temp_buf, sizeof(temp_buf));
           // itoa(group_item_info.group_id,(char*)temp_buf,10);
            strcat((char *)res_cmd,temp_buf);
            res_len += strlen(temp_buf);

            strcat((char *)res_cmd, (char *)MMI_COMMA_SYMBOL);
            res_len += SCI_STRLEN((char *)MMI_COMMA_SYMBOL);
            
          //  dest_len = GUI_WstrToGB(res_cmd+res_len,group_item_info.group_name, group_item_info.name_len);
            SCI_MEMSET(temp_buf,0,sizeof(temp_buf));
            dest_len = GUI_WstrToUTF8((uint8*)temp_buf, sizeof(temp_buf),group_item_info.group_name, group_item_info.name_len);

            SCI_MEMSET(hex_buf,0,sizeof(hex_buf));
        MMIAPICOM_BinaryToHexChar(temp_buf,dest_len,hex_buf,&hex_len);
        
          strcat((char *)res_cmd,hex_buf);
        
            res_len += hex_len;

          strcat((char *)res_cmd, (char *)MMI_COMMA_SYMBOL);
            res_len += SCI_STRLEN((char *)MMI_COMMA_SYMBOL);
            

            if(group_item_info.is_fixed_group)
            {
                strcat((char *)res_cmd, (char *)"1");
            }
            else
            {
                strcat((char *)res_cmd, (char *)"0");
            }
            res_len++;
            
           // strcat((char *)res_cmd, (char *)MMI_COMMA_SYMBOL);
          //  res_len += SCI_STRLEN((char *)MMI_COMMA_SYMBOL);

            strcat((char *)res_cmd, (char *)SYNC_TO_MMI_FINISH_SYMBOL);
            res_len += SCI_STRLEN((char *)SYNC_TO_MMI_FINISH_SYMBOL);
            
            result = TRUE;
        }
        i++;
    }
}
    if(result)
    {
        dest_len = SCI_STRLEN((char*)MMI_TO_SYNC_OK_SYMBOL);
        strcat((char*)res_cmd,(char *)MMI_TO_SYNC_OK_SYMBOL);
        res_len += dest_len;
            
        ReturnResponse(res_cmd, res_len);
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)SCI_STRLEN((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }

    SCI_FREE(res_cmd);

    return TRUE;
}


/*****************************************************************************/
// 	Description : This function handle the group add command
//	Global resource dependence : none
//  Author:      liqing.peng
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleGroupAdd(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{
    uint32 group_id = 0;
    GROUP_ENTRY_T   group_entry = {0};
    CHAR res_cmd[ATC_TEMP_BUF_LEN] = {0};
    CHAR temp_buf[ATC_TEMP_BUF_LEN] = {0};
    char* end_pos = PNULL;
    uint32 name_len = 0;
    uint16 dest_len = 0;
    uint16 str_len = 0;
//    MMI_STRING_T str_t = {0};
    char* finish_sym_pos = PNULL;
    
	if(PNULL == cmd||len<1)
	{
		return FALSE;
	}
	
    end_pos = MMIAPICOM_Stristr((char*)cmd,(char*)"=");
    if(PNULL == end_pos)
    {
        return FALSE;
    }
    str_len = end_pos - (char*)cmd;
    len-=str_len;
    end_pos++;//split '='
    len--;
    cmd=(uint8*)end_pos;
    
    SCI_MEMSET(&group_entry, 0, sizeof(GROUP_ENTRY_T));

    finish_sym_pos =  MMIAPICOM_Stristr((char*)cmd,(char*)SYNC_TO_MMI_FINISH_SYMBOL);

    if(PNULL!=finish_sym_pos)
    {
        name_len = finish_sym_pos - cmd;
    }
    else
    {
        name_len = len;
    }
    group_entry.name_len = GUI_UTF8ToWstr(group_entry.group_name, MMI_SYNC_GROUP_NAME_MAX_LEN,
        cmd, name_len);
/*
    MMIAPICOM_GBToSTRING(cmd,&str_t);
    MMIAPICOM_Wstrncpy(group_entry.group_name,str_t.wstr_ptr,str_t.wstr_len);
    group_entry.name_len = str_t.wstr_len;
    if(PNULL !=str_t.wstr_ptr)
    {
        SCI_FREE(str_t.wstr_ptr);
    }    
  */
    if(MMIPBGROUP_SyncAdd(&group_entry,&group_id))
    {
        strcat((CHAR *)res_cmd, (char *)MMI_SYNC_INDICATE);
        dest_len += SCI_STRLEN((char *)MMI_SYNC_INDICATE);

        strcat((CHAR *)res_cmd, (char *)MMI_COLON_SYMBOL);
        dest_len += SCI_STRLEN((char *)MMI_COLON_SYMBOL);

        SCI_MEMSET(temp_buf,0,sizeof(temp_buf));
        MMIAPICOM_Int2Str(group_id,(uint8*)temp_buf, sizeof(temp_buf));
        //itoa(group_id,temp_buf,10);
        strcat(res_cmd,temp_buf);
        dest_len+=SCI_STRLEN(temp_buf);

        strcat((CHAR *)res_cmd, (char *)MMI_TO_SYNC_OK_SYMBOL);
        dest_len += SCI_STRLEN((char *)MMI_TO_SYNC_OK_SYMBOL);
        //return "ok\r\n" to sync tool;
        ReturnResponse((uint8 *)res_cmd, dest_len);
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)SCI_STRLEN((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }

    return TRUE;
}


/*****************************************************************************/
// 	Description : This function handle the group delete command
//	Global resource dependence : none
//  Author:      liqing.peng
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleGroupDelete(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{
    uint32 group_id = 0;
    uint16 str_len = 0;
    char* end_pos = PNULL;
    
	if(NULL == cmd||len<1)
    {
        return FALSE;
    }
	
    end_pos = MMIAPICOM_Stristr((char*)cmd,(char*)"=");
    if(PNULL == (char*)end_pos)
    {
        return FALSE;
    }
    str_len = end_pos - (char*)cmd;
    len-=str_len;
    end_pos++;//split '='
    len--;
    cmd = (uint8*)end_pos;
    
    group_id = GetEntryId((char*)cmd, (uint16)len);
    if(MMIPBGROUP_SyncDelete(group_id))
    {
        //return "ok\r\n" to sync tool;
        ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)SCI_STRLEN((char*)MMI_TO_SYNC_OK_SYMBOL));
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)SCI_STRLEN((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }

    return TRUE;
}


/*****************************************************************************/
// 	Description : This function handle the group modify command
//	Global resource dependence : none
//  Author:      liqing.peng
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleGroupModify(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{
    GROUP_ENTRY_T   group_entry = {0};
    char* finish_sym_pos = PNULL;
    CHAR* end_pos = PNULL;
    CHAR temp_buf[MMI_SYNC_GROUP_NAME_MAX_LEN] = {0};
    uint8 str_len = 0;
    BOOLEAN result = FALSE;
 //   MMI_STRING_T str_t = {0};
    uint32 name_len = 0;
 
	if(NULL == cmd||len<1)
	{
		return FALSE;
	}
    
    end_pos = MMIAPICOM_Stristr((char*)cmd,(char*)"=");
    if(PNULL == end_pos)
    {
        return FALSE;
    }
    str_len = end_pos - (char*)cmd;
    len-=str_len;
    end_pos++;//split '='
    len--;
    cmd=(uint8*)end_pos;
    
    SCI_MEMSET((GROUP_ENTRY_T*)&group_entry, 0, sizeof(GROUP_ENTRY_T));
    str_len = 0;
    end_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR*)",");
    if(PNULL!=end_pos)
    {
        str_len = (char*)end_pos-(char*)cmd;
        strncpy(temp_buf,(char*)cmd,str_len);
        group_entry.group_id = atoi(temp_buf);
        len-=str_len;
        
        end_pos++;//split ','
        cmd = (uint8*)end_pos;
        len--;
        
        if(len>0)
        {
            finish_sym_pos =  MMIAPICOM_Stristr((char*)cmd,(char*)SYNC_TO_MMI_FINISH_SYMBOL);

            if(PNULL!=finish_sym_pos)
            {
                name_len = finish_sym_pos - cmd;
            }
            else
            {
                name_len = len;
            }
    
            group_entry.name_len = GUI_UTF8ToWstr(group_entry.group_name, MMI_SYNC_GROUP_NAME_MAX_LEN, 
                cmd, name_len);
    /*        
            MMIAPICOM_GBToSTRING(cmd,&str_t);
            MMIAPICOM_Wstrncpy(group_entry.group_name,str_t.wstr_ptr,str_t.wstr_len);
            group_entry.name_len = str_t.wstr_len;
            if(PNULL !=str_t.wstr_ptr)
            {
                SCI_FREE(str_t.wstr_ptr);
            }
          */ 
            result = MMIPBGROUP_SyncModify(group_entry.group_id, &group_entry);
        
        }
    }
    if(result)
    {
            //return "ok\r\n" to sync tool;
        ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)SCI_STRLEN((char*)MMI_TO_SYNC_OK_SYMBOL));
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)SCI_STRLEN((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }
    return TRUE;
}

/*****************************************************************************/
// 	Description : This function format the output string of date&time
//	Global resource dependence : none
//  Author:  xiaohua.liu
//	Note:
/*****************************************************************************/
LOCAL uint16 FormatScheduleDateTimeStr(SCHEDULE_TIME_T* in_ptr,CHAR* out_ptr)
{
    CHAR temp_buf[10] = {0};
    uint16 str_len = 0;
    
    if(PNULL == in_ptr||PNULL == out_ptr)
    {
        return 0;
    }
    //year
    SCI_MEMSET(temp_buf,0,sizeof(temp_buf));
    MMIAPICOM_Int2Str(in_ptr->year,(uint8*)temp_buf,sizeof(temp_buf));
    //itoa(in_ptr->year,temp_buf,10);
    strcat(out_ptr,temp_buf);
    str_len += SCI_STRLEN(temp_buf);

    strcat(out_ptr,(CHAR*)"-");
    str_len++;
    //month
    SCI_MEMSET(temp_buf,0,sizeof(temp_buf));
    MMIAPICOM_Int2Str(in_ptr->month,(uint8*)temp_buf,sizeof(temp_buf));
   // itoa(in_ptr->month,temp_buf,10);
    strcat(out_ptr,temp_buf);
    str_len += SCI_STRLEN(temp_buf);

    strcat(out_ptr,(CHAR*)"-");
    str_len++;
    //day
    SCI_MEMSET(temp_buf,0,sizeof(temp_buf));
    MMIAPICOM_Int2Str(in_ptr->day,(uint8*)temp_buf,sizeof(temp_buf));
    //itoa(in_ptr->day,temp_buf,10);
    strcat(out_ptr,temp_buf);
    str_len += SCI_STRLEN(temp_buf);

    strcat(out_ptr,(CHAR*)" ");
    str_len++;
    //hour
    SCI_MEMSET(temp_buf,0,sizeof(temp_buf));
    MMIAPICOM_Int2Str(in_ptr->hour,(uint8*)temp_buf,sizeof(temp_buf));
   // itoa(in_ptr->hour,temp_buf,10);
    strcat(out_ptr,temp_buf);
    str_len += SCI_STRLEN(temp_buf);

    strcat(out_ptr,(CHAR*)":");
    str_len++;
    //minut
    SCI_MEMSET(temp_buf,0,sizeof(temp_buf));
    MMIAPICOM_Int2Str(in_ptr->minute,(uint8*)temp_buf,sizeof(temp_buf));
   // itoa(in_ptr->minute,temp_buf,10);
    strcat(out_ptr,temp_buf);
    str_len += SCI_STRLEN(temp_buf);

    strcat(out_ptr,(CHAR*)":");
    str_len++;
    //sec
    SCI_MEMSET(temp_buf,0,sizeof(temp_buf));
    MMIAPICOM_Int2Str(in_ptr->sec,(uint8*)temp_buf,sizeof(temp_buf));
   // itoa(in_ptr->sec,temp_buf,10);
    strcat(out_ptr,temp_buf);
    str_len += SCI_STRLEN(temp_buf);

    return str_len;
}
/*****************************************************************************/
// 	Description : This function format the output string of date&time
//	Global resource dependence : none
//  Author:  xiaohua.liu
//	Note:
/*****************************************************************************/
LOCAL uint16 FormatScheduleFrequenceStr(uint8* in_ptr,CHAR* out_ptr)
{
#define WEEK_DAY_NUM 7


    uint16 str_len = 0;
    uint8 i = 0;
    uint8 week_mask[WEEK_DAY_NUM] = 
        {
            1,2,4,8,16,32,64
        };
    CHAR* week_day_str[WEEK_DAY_NUM] = {
        "1","2","3","4","5","6","7"
        };
    if(PNULL == in_ptr||PNULL == out_ptr)
    {
        return 0;
    }

    for(i = 0;i<WEEK_DAY_NUM;i++)
    {
        if(((*in_ptr)&week_mask[i])>0)
        {
            strcat(out_ptr,(char*)week_day_str[i]);
            strcat(out_ptr,(char*)",");
            str_len+=2;
        }
    }
    //replay the last ',' by ')'
    strncpy((char*)(out_ptr+str_len-1),(char*)")",1);
    
    return str_len;
}
/*****************************************************************************/
// 	Description : This function to get one item schedule command
//	Global resource dependence : none
//  Author: xiaohua.liu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleScheduleReadItem(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{
    uint16          entry_id[SCHEDULE_MAX_ENTRY_NUM] = {0};
    SCHEDULE_ENTRY_T    schedule_info = {0};
    uint8           *res_cmd = NULL;
	char* end_pos = PNULL;
    uint32 hex_len = 0;
    char temp_buf[ATC_TEMP_BUF_LEN+1] = {0};
    char hex_buf[ATC_TEMP_BUF_LEN+1] = {0};
	uint16 str_len = 0;
    uint16          res_len = 0; 
    uint16          dest_len = 0;
    uint16 i = 0;
    BOOLEAN result = FALSE;
    
    if(NULL == cmd||len < 1)
    {
        return FALSE;
    }
		
	end_pos = MMIAPICOM_Stristr((char*)cmd,(char*)"=");

	if(PNULL == end_pos)
	{
		return FALSE;
	}
	str_len = end_pos-(char*)cmd;
	len-=str_len;
	end_pos++;//split '='
	cmd = (uint8*)end_pos;
	len--;
    	res_cmd = (uint8 *)SCI_ALLOC_APP(MAX_RESCMD_LEN+1);
    	if(PNULL == res_cmd)
    	{
       	return FALSE;
    	}

if(GetMoreThanOneEntryId((char*)cmd,(uint16)len,entry_id,SCHEDULE_MAX_ENTRY_NUM))
{
    SCI_MEMSET(&schedule_info, 0, sizeof(SCHEDULE_ENTRY_T));
    SCI_MEMSET(res_cmd, 0, MAX_RESCMD_LEN);

    while(i<SCHEDULE_MAX_ENTRY_NUM&&entry_id[i]>0)
    {
        if(MMISCHEDULE_SyncRead(entry_id[i], &schedule_info))
        {
            strcat((char *)res_cmd, (char *)MMI_SYNC_INDICATE);
            res_len += SCI_STRLEN((char *)MMI_SYNC_INDICATE);

            strcat((char *)res_cmd, (char *)MMI_COLON_SYMBOL);
            res_len += SCI_STRLEN((char *)MMI_COLON_SYMBOL);

            strcat((char *)res_cmd, (char *)MMI_ID_TAG);
            res_len += SCI_STRLEN((char *)MMI_ID_TAG);



            SCI_MEMSET(temp_buf,0,sizeof(temp_buf));
            MMIAPICOM_Int2Str(schedule_info.entry_id,(uint8*)temp_buf,sizeof(temp_buf));
            //itoa(schedule_info.entry_id,temp_buf,10);
            strcat((char*)res_cmd,temp_buf);
            res_len+=SCI_STRLEN(temp_buf);

            strcat((char *)res_cmd, (char *)MMI_COMMA_SYMBOL);
            res_len += SCI_STRLEN((char *)MMI_COMMA_SYMBOL);
        //title
            strcat((char *)res_cmd, (char *)MMI_TITLE_SYMBOL);
            res_len += SCI_STRLEN((char *)MMI_TITLE_SYMBOL);

            //dest_len = GUI_WstrToGB((uint8*)(res_cmd+res_len),schedule_info.title,schedule_info.title_len);
            SCI_MEMSET(temp_buf,0,sizeof(temp_buf));
            dest_len = GUI_WstrToUTF8((uint8*)temp_buf, sizeof(temp_buf),schedule_info.title,schedule_info.title_len);

            SCI_MEMSET(hex_buf,0,sizeof(hex_buf));
        MMIAPICOM_BinaryToHexChar(temp_buf,dest_len,hex_buf,&hex_len);
        
            strcat((char *)res_cmd,hex_buf);
            res_len += hex_len;

            strcat((char *)res_cmd, (char *)MMI_COMMA_SYMBOL);
            res_len += SCI_STRLEN((char *)MMI_COMMA_SYMBOL);
        //startdate
            strcat((char *)res_cmd, (char *)MMI_STARTDATE_SYMBOL);
            res_len += SCI_STRLEN((char *)MMI_STARTDATE_SYMBOL);

            SCI_MEMSET(temp_buf,0,sizeof(temp_buf));
            dest_len = FormatScheduleDateTimeStr(&schedule_info.start_time,temp_buf);
            strcat((char*)res_cmd,temp_buf);
            res_len += dest_len;

             strcat((char *)res_cmd, (char *)MMI_COMMA_SYMBOL);
            res_len += SCI_STRLEN((char *)MMI_COMMA_SYMBOL);
            //enddate
            strcat((char *)res_cmd, (char *)MMI_ENDDATE_SYMBOL);
            res_len += SCI_STRLEN((char *)MMI_ENDDATE_SYMBOL);

            SCI_MEMSET(temp_buf,0,sizeof(temp_buf));
            dest_len = FormatScheduleDateTimeStr(&schedule_info.end_time,temp_buf);
            strcat((char*)res_cmd,temp_buf);
            res_len += dest_len;

            strcat((char *)res_cmd, (char *)MMI_COMMA_SYMBOL);
            res_len += SCI_STRLEN((char *)MMI_COMMA_SYMBOL);
        //mode
            strcat((char *)res_cmd, (char *)MMI_MODE_SYMBOL);
            res_len += SCI_STRLEN((char *)MMI_MODE_SYMBOL);

            SCI_MEMSET(temp_buf,0,sizeof(temp_buf));
            MMIAPICOM_Int2Str(schedule_info.alarm_mode,(uint8*)temp_buf,sizeof(temp_buf));
            //itoa(schedule_info.alarm_mode,temp_buf,10);
            strcat((char*)res_cmd,temp_buf);
            res_len+=SCI_STRLEN(temp_buf);

            strcat((char *)res_cmd, (char *)MMI_COMMA_SYMBOL);
            res_len += SCI_STRLEN((char *)MMI_COMMA_SYMBOL);

            strcat((char *)res_cmd, (char *)MMI_FRE_SYMBOL);
            res_len += SCI_STRLEN((char *)MMI_FRE_SYMBOL);

           
            SCI_MEMSET(temp_buf,0,sizeof(temp_buf));
            dest_len = FormatScheduleFrequenceStr(&schedule_info.frequece,temp_buf);
            strcat((char*)res_cmd,temp_buf);
            res_len += dest_len;
            
            strcat((char *)res_cmd, (char *)MMI_NEW_LINE_SYMBOL);
            res_len += SCI_STRLEN((char *)MMI_NEW_LINE_SYMBOL);
            
            result = TRUE;
        }
        i++;
    }
}
    if(result)
    {
        dest_len = SCI_STRLEN((char*)MMI_TO_SYNC_OK_SYMBOL);
        strcat((char*)res_cmd,(char *)MMI_TO_SYNC_OK_SYMBOL);
        res_len += dest_len;

        ReturnResponse(res_cmd, res_len);
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)SCI_STRLEN((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }

    SCI_FREE(res_cmd);

    return TRUE;
}
/*****************************************************************************/
// 	Description : This function parse the DATE information from command
//	Global resource dependence : none
//  Author:    xiaohua.liu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN ParseScheduleDateTimeInfo(
    char *in_ptr,  // Point to the command infomation buffer
    uint32 len,   // The length of command infomation buffer
    SCHEDULE_TIME_T* time_ptr
    )
{
    uint16 pro_len = 0;
    CHAR temp_buf[10] = {0};
    //date & time total len
    if(PNULL == in_ptr||PNULL==time_ptr||len<10)
    {
        return FALSE;
    }
    //year
    strncpy(temp_buf,(char*)in_ptr,4);
    pro_len+=4;
    time_ptr->year = atoi(temp_buf);
    SCI_MEMSET(temp_buf,0,sizeof(temp_buf));

    pro_len++;//split '-'
    if(pro_len>len)
    {
        return FALSE;
    }
    //month;
    strncpy(temp_buf,(char*)in_ptr+pro_len,2);
    pro_len+=2;
    time_ptr->month= atoi(temp_buf);
    SCI_MEMSET(temp_buf,0,sizeof(temp_buf));

    pro_len++;//split '-'
    if(pro_len>len)
    {
        return FALSE;
    }
    //day;
    strncpy(temp_buf,(char*)in_ptr+pro_len,2);
    pro_len+=2;
    time_ptr->day= atoi(temp_buf);
    SCI_MEMSET(temp_buf,0,sizeof(temp_buf));

    pro_len++;//split '-'
    if(pro_len>len)
    {
        return FALSE;
    }
    //hour;
    strncpy(temp_buf,(char*)in_ptr+pro_len,2);
    pro_len+=2;
    time_ptr->hour= atoi(temp_buf);
    SCI_MEMSET(temp_buf,0,sizeof(temp_buf));

    pro_len++;//split '-'
    if(pro_len>len)
    {
        return FALSE;
    }
    //minute;
    strncpy(temp_buf,(char*)in_ptr+pro_len,2);
    pro_len+=2;
    time_ptr->minute= atoi(temp_buf);
    SCI_MEMSET(temp_buf,0,sizeof(temp_buf));

    pro_len++;//split '-'
    if(pro_len>len)
    {
        return FALSE;
    }
    //sec;
    strncpy(temp_buf,(char*)in_ptr+pro_len,2);
    pro_len+=2;
    time_ptr->sec= atoi(temp_buf);
	
  return TRUE;
}
/*****************************************************************************/
// 	Description : This function parse the schedule frequence and write the id flag 
//  from command
//	Global resource dependence : none
//  Author:   xiaohua.liu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN GetScheduleFreFlag(char *in_ptr,  // Point to the command infomation buffer
    uint32 len,   // The length of command infomation buffer
    uint8* fre_ptr
    )
{
    uint16 pro_len = 0;
    CHAR temp_buf[10] = {0};
    BOOLEAN result = FALSE;
    //date & time total len
    if(PNULL == in_ptr||PNULL==fre_ptr)
    {
        return result;
    }

    while(pro_len<len)
    {
        strncpy(temp_buf,in_ptr+pro_len,1);
        *fre_ptr|=(1<<(atoi(temp_buf)-1));
        pro_len++;
        pro_len++;//split ','
        SCI_MEMSET(temp_buf,0,sizeof(temp_buf));
        result = TRUE;
    }
    return result;
}
/*****************************************************************************/
// 	Description : This function parse the schedule information from command
//	Global resource dependence : none
//  Author:   xiaohua.liu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN ParseScheduleInfoFromCmd(
    uint8 *cmd,  // Point to the command infomation buffer
    uint32 len,   // The length of command infomation buffer
    SCHEDULE_ENTRY_T* schedule_ptr
    )
{
    CHAR* begin_pos = PNULL;
    CHAR* end_pos = PNULL;
    uint16 tag_len = 0;
    uint16 infor_len = 0;
    CHAR temp_buf[100] = {0};
    BOOLEAN reach_end = FALSE;
    BOOLEAN result = FALSE;
    
    if(PNULL == cmd||len<10||PNULL == schedule_ptr)
    {
        return result;
    }
    
    //id
    begin_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR*)MMI_ID_TAG);
    if(PNULL!=begin_pos)
    {
        end_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)MMI_COMMA_SYMBOL);
        if(PNULL == end_pos)
        {
            end_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)CMD_LINE_END_TAG);
            reach_end = TRUE;
        }
        if(NULL!=end_pos&&end_pos>begin_pos)
        {
            tag_len = SCI_STRLEN(MMI_ID_TAG);
            infor_len = end_pos - begin_pos;
            
            strncpy(temp_buf,begin_pos+tag_len,infor_len-tag_len);
            schedule_ptr->entry_id = atoi(temp_buf);
            
            if(reach_end)
            {
                return result;
            }
            else
            {
                end_pos++;//split ','
                cmd = (uint8*)end_pos;
            }
        }
    }
    
//title
    begin_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR*)MMI_TITLE_SYMBOL);
    if(PNULL!=begin_pos)
    {
        end_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)MMI_COMMA_SYMBOL);
        if(PNULL == end_pos)
        {
            end_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)CMD_LINE_END_TAG);
            reach_end = TRUE;
        }
        if(NULL!=end_pos&&end_pos>begin_pos)
        {
			
            tag_len = SCI_STRLEN(MMI_TITLE_SYMBOL);
            infor_len = end_pos - begin_pos;
            
            
            schedule_ptr->title_len = GUI_UTF8ToWstr(schedule_ptr->title,MMI_SYNC_EVENT_TEXT_MAX_LEN,
                begin_pos+tag_len,infor_len-tag_len);
    /*	
            SCI_MEMSET(&temp_buf,0,sizeof(temp_buf));
		    SCI_MEMCPY((char*)temp_buf,begin_pos+tag_len,infor_len-tag_len);		

            MMIAPICOM_GBToSTRING((uint8*)temp_buf,&w_string);
            MMIAPICOM_Wstrncpy(schedule_ptr->title,w_string.wstr_ptr,w_string.wstr_len);
            schedule_ptr->title_len = w_string.wstr_len;

		if(PNULL !=w_string.wstr_ptr)
		{
			SCI_FREE(w_string.wstr_ptr);
		}
		*/
            if(reach_end)
            {
                return result;
            }
            else
            {
                end_pos++;//split ','
                cmd = (uint8*)end_pos;
            }
        }
    }
    //begin date
    begin_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR*)MMI_STARTDATE_SYMBOL);
    if(PNULL!=begin_pos)
    {
        end_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)MMI_COMMA_SYMBOL);
        if(PNULL == end_pos)
        {
            end_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)CMD_LINE_END_TAG);
            reach_end = TRUE;
        }
        if(NULL!=end_pos&&end_pos>begin_pos)
        {
            tag_len = SCI_STRLEN(MMI_STARTDATE_SYMBOL);
            infor_len = end_pos - begin_pos;
            SCI_MEMSET(temp_buf,0,sizeof(temp_buf));
            strncpy(temp_buf,begin_pos+tag_len,infor_len-tag_len);
            
            ParseScheduleDateTimeInfo(temp_buf,infor_len-tag_len,
                &schedule_ptr->start_time);
           
            if(reach_end)
            {
                return result;
            }
            else
            {
                end_pos++;//split ','
                cmd = (uint8*)end_pos;
            }
        }
    }
    //end date
    begin_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR*)MMI_ENDDATE_SYMBOL);
    if(PNULL!=begin_pos)
    {
        end_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)MMI_COMMA_SYMBOL);
        if(PNULL == end_pos)
        {
            end_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)CMD_LINE_END_TAG);
            reach_end = TRUE;
        }
        if(NULL!=end_pos&&end_pos>begin_pos)
        {
            tag_len = SCI_STRLEN(MMI_ENDDATE_SYMBOL);
            infor_len = end_pos - begin_pos;
            SCI_MEMSET(temp_buf,0,sizeof(temp_buf));
            strncpy(temp_buf,begin_pos+tag_len,infor_len-tag_len);
            
            ParseScheduleDateTimeInfo((char*)temp_buf,infor_len-tag_len,
               &schedule_ptr->end_time);
            
            if(reach_end)
            {
                return result;
            }
            else
            {
                end_pos++;//split ','
                cmd = (uint8*)end_pos;
            }
        }
    }
 /*  
    //time
    begin_pos = MMIAPICOM_Stristr(cmd,(CHAR*)MMI_TIME_SYMBOLE);
    if(PNULL!=begin_pos)
    {
        end_pos = MMIAPICOM_Stristr(cmd,(CHAR *)MMI_COMMA_SYMBOL);
        if(PNULL == end_pos)
        {
            end_pos = MMIAPICOM_Stristr(cmd,(CHAR *)CMD_LINE_END_TAG);
            reach_end = TRUE;
        }
        if(NULL!=end_pos&&end_pos>begin_pos)
        {
            tag_len = SCI_STRLEN(MMI_TIME_SYMBOLE);
            infor_len = end_pos - begin_pos;
            SCI_MEMSET(temp_buf,0,sizeof(temp_buf));
            strncpy(temp_buf,begin_pos+tag_len,infor_len-tag_len);
            
            ParseScheduleDateTimeInfo(temp_buf,infor_len-tag_len,
               &schedule_ptr->end_time);
            
            if(reach_end)
            {
                return result;
            }
            else
            {
                end_pos++;//split ','
                cmd = end_pos;
            }
        }
    }
  */  
    //alarm mode
    begin_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR*)MMI_MODE_SYMBOL);
    if(PNULL!= (char*)begin_pos)
    {
        end_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)MMI_COMMA_SYMBOL);
        if(PNULL == end_pos)
        {
            end_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)CMD_LINE_END_TAG);
            reach_end = TRUE;
        }
        if(NULL!= (char*)end_pos&&(char*)end_pos>(char*)begin_pos)
        {
            tag_len = SCI_STRLEN((char*)MMI_MODE_SYMBOL);
            infor_len = (char*)end_pos - (char*)begin_pos;
            SCI_MEMSET(temp_buf,0,sizeof(temp_buf));
            
            strncpy(temp_buf,(char*)begin_pos+tag_len,infor_len-tag_len);
            schedule_ptr->alarm_mode = atoi(temp_buf);
            
            if(reach_end)
            {
                return result;
            }
            else
            {
                end_pos++;//split ','
                cmd = (uint8*)end_pos;
            }
        }
    }
    //frequence 
    begin_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR*)MMI_FRE_SYMBOL);
    if(PNULL!=begin_pos)
    {
        end_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)")");
        if(PNULL == end_pos)
        {
            end_pos = MMIAPICOM_Stristr((char*)cmd,(CHAR *)CMD_LINE_END_TAG);
            reach_end = TRUE;
        }
        if(NULL!=end_pos&&end_pos>begin_pos)
        {
            tag_len = SCI_STRLEN(MMI_FRE_SYMBOL);
            infor_len = end_pos - begin_pos;
            SCI_MEMSET(temp_buf,0,sizeof(temp_buf));
            
            strncpy(temp_buf,begin_pos+tag_len,infor_len-tag_len);
            if(GetScheduleFreFlag(temp_buf,SCI_STRLEN(temp_buf),&schedule_ptr->frequece))
            {
                result = TRUE;
            }
            
        }
    }
    return result;
}
/*****************************************************************************/
// 	Description : This function handle the schedule add command
//	Global resource dependence : none
//  Author:      liqing.peng
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleScheduleAdd(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{
    SCHEDULE_ENTRY_T    schedule_entry = {0};
    uint16        index = 0;
    uint8           *res_cmd = PNULL;
    uint16          res_len = 0; 
    uint16          dest_len = 0;
    BOOLEAN result = FALSE;
    CHAR temp_buf[10] = {0};
    char* end_pos = PNULL;
    uint16 str_len = 0;
    
    if(NULL == cmd||len<1)
    {
        return FALSE;
    }
    
    res_cmd = (uint8 *)SCI_ALLOC_APP(MAX_RESCMD_LEN);
    if(PNULL == res_cmd)
    {
        return FALSE;
    }

    end_pos = MMIAPICOM_Stristr((char*)cmd,(char*)"=");
    if(PNULL == end_pos)
    {
        return FALSE;
    }
    str_len = end_pos - (char*)cmd;
    len-=str_len;
    end_pos++;//split '='
    len--;
    cmd= (uint8*)end_pos;
    
    SCI_MEMSET(res_cmd, 0, MAX_RESCMD_LEN);;

    SCI_MEMSET(&schedule_entry, 0, sizeof(SCHEDULE_ENTRY_T));
    
    if(ParseScheduleInfoFromCmd(cmd, len,&schedule_entry))
    {

        if(MMISCHEDULE_SyncAdd(&schedule_entry,&index))
        {
            strcat((char *)res_cmd, (char *)MMI_SYNC_INDICATE);
            res_len += strlen((char *)MMI_SYNC_INDICATE);

            strcat((char *)res_cmd, (char *)MMI_COLON_SYMBOL);
            res_len += strlen((char *)MMI_COLON_SYMBOL);

            MMIAPICOM_Int2Str(index,(uint8*)temp_buf,sizeof(temp_buf));
            //itoa(index,temp_buf,10);
            strcat((char *)res_cmd, (char *)temp_buf);
            res_len += strlen((char *)temp_buf);
            
            dest_len = strlen((char*)MMI_TO_SYNC_OK_SYMBOL);
            strcat((CHAR*)res_cmd, (CHAR *)MMI_TO_SYNC_OK_SYMBOL);
            res_len += dest_len;

            result = TRUE;
        }
    }
    if(result)
    {
        ReturnResponse(res_cmd, res_len);
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }
    SCI_FREE(res_cmd);
    return TRUE;
}


/*****************************************************************************/
// 	Description : This function handle the group delete command
//	Global resource dependence : none
//  Author:      xiaohua.liu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleScheduleDelete(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{
    uint16  entry_id = 0;
    uint16 str_len = 0;
    char* end_pos = PNULL;
    
    if(NULL == cmd||len < 2)
	{
		return FALSE;
	}
		
    end_pos = MMIAPICOM_Stristr((char*)cmd,(char*)"=");
    if(PNULL == (char*)end_pos)
    {
        return FALSE;
    }
    str_len = (char*)end_pos - (char*)cmd;
    len-=str_len;
    end_pos++;//split '='
    len--;
    cmd = (uint8*)end_pos;
    
    entry_id = (uint16)GetEntryId((char*)cmd, (uint16)len);
    if(MMISCHEDULE_SyncDelete(entry_id))
    {
        //return "ok\r\n" to sync tool;
        ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_OK_SYMBOL));
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }

    return TRUE;
}


/*****************************************************************************/
// 	Description : This function handle the group modify command
//	Global resource dependence : none
//  Author:      xiaohua.liu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleScheduleModify(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{
    SCHEDULE_ENTRY_T    schedule_entry = {0};
    char* end_pos = PNULL;
    uint16 str_len  = 0;
    
	if(NULL == cmd||len<1)
    {
        return FALSE;
    }
	
    SCI_MEMSET(&schedule_entry, 0, sizeof(SCHEDULE_ENTRY_T));

    end_pos = MMIAPICOM_Stristr((char*)cmd,(char*)"=");
    if(PNULL == end_pos)
    {
        return FALSE;
    }
    str_len = end_pos - (char*)cmd;
    len-=str_len;
    end_pos++;//split '='
    len--;
    cmd=(uint8*)end_pos;

    if(ParseScheduleInfoFromCmd(cmd, len,&schedule_entry))
    {
        if(MMISCHEDULE_SyncModify(schedule_entry.entry_id, &schedule_entry))
        {
            //return "ok\r\n" to sync tool;
            ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)SCI_STRLEN((char*)MMI_TO_SYNC_OK_SYMBOL));
        }
        else
        {
            ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)SCI_STRLEN((char*)MMI_TO_SYNC_ERROR_SYMBOL));
        }
    }
    return TRUE;
}

/*****************************************************************************/
// 	Description : This function get string finished by finish_char
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
//LOCAL BOOLEAN GetString(
//                        uint8* dest_str_ptr, 
//                        uint32 max_len, 
//                        uint8* src_str_ptr, 
//                        uint32 src_str_len,
//                        uint8 finish_char
//                        )
//{
//    uint8* ptr = src_str_ptr;
//    uint32 i=0;
//
//    for(i=0; i<src_str_len; i++)
//    {
//        if(*(ptr++) == finish_char)
//        {
//            break;
//        }
//    }
//
//    if((ptr-1 - src_str_ptr > 0) && (ptr-1 - src_str_ptr <= max_len))
//    {
////        strncpy((char *)dest_str_ptr, (char *)src_str_ptr, ptr-1 - src_str_ptr);
//        MMI_MEMCPY(dest_str_ptr, max_len, src_str_ptr, src_str_len, ptr-1 - src_str_ptr);
//    }
//    else
//    {
//        return FALSE;
//    }    
//
//    return TRUE;
//}
//

/*****************************************************************************/
// 	Description : This function return response to at
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL void ReturnResponse(
                            uint8* res_ptr,
                            uint16 len
                            )
{
	uint8	*res_cmp = NULL;
	uint16	cmp_len = 0;

	res_cmp = (uint8*)SCI_ALLOC_APP(MAX_RESCMD_LEN);
	SCI_ASSERT(NULL != res_cmp); /*assert verified*/
	SCI_MEMSET(res_cmp, 0, MAX_RESCMD_LEN);

	SCI_TRACE_LOW("mmi_atc.c ReturnResponse %s,%d",res_ptr,len);
	//压缩命令字符串
	cmp_len = CompressCmdStr(res_ptr, len, res_cmp);
	SCI_ASSERT(MAX_RESCMD_LEN > cmp_len); /*assert verified*/
#ifndef WIN32
	ATC_WriteCmdRsp(res_cmp, cmp_len);/*lint !e718 !e746*/
#endif
    //SIO_ATC_WriteCmdRes(res_cmp, cmp_len);

	SCI_FREE(res_cmp);
}


/*****************************************************************************/
// 	Description : This function judge pb paramter
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN GetPbStorage(
                     uint8 *pos, 
                     uint8 cmd_char
                     )
{
	if(NULL == pos)
	{
		//SCI_TRACE_LOW:"[MMIATC] GetPbStorage pos 0x%x"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_12442_112_2_18_1_59_51_113,(uint8*)"d", pos);
		return FALSE;
	}

	*pos = cmd_char;
    return TRUE;
}

/*****************************************************************************/
// 	Description : This function get pb entry id from cmd string
//	Global resource dependence : none
//  Author: Xiaohua.liu
//	Note:
/*****************************************************************************/
LOCAL uint32 GetEntryId(char* cmd, uint16 len)
{
    uint8 id_str[PB_ENTRY_ID_MAX_LEN +1] = {0};
    
    SCI_ASSERT(len > 0); /*assert verified*/

    strncpy((char *)id_str,(char*)cmd, PB_ENTRY_ID_MAX_LEN);
    return atoi((char*)id_str);
}



/*****************************************************************************/
// 	Description : 行程压缩法
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL uint16 CompressCmdStr(
							  uint8 *cmd_in,	//cmd str, in
							  uint16 len,		//cmd str len
							  uint8	*cmd_out	//out
							  )
{
	int32	i = 0;
	int32	j = 0;
	uint16	out_len = 0;
	uint16	zero_num = 0;
	uint8	szValue[6] = {0};

	SCI_ASSERT(NULL != cmd_in); /*assert verified*/
	SCI_ASSERT(NULL != cmd_out); /*assert verified*/

	//压缩
	while(i<len)
	{
		if(i+5 < len 
			&& '0' == cmd_in[i] && '0' == cmd_in[i+1] && '0' == cmd_in[i+2]
			&& '0' == cmd_in[i+3] && '0' == cmd_in[i+4] && '0' == cmd_in[i+5])
		{
			//遇到连续6个0的字符串
			j = 0;
			while('0' == cmd_in[i+j])
			{
				j++;
			}
			zero_num = j;

			SCI_MEMSET(szValue, 0, sizeof(szValue));
			sprintf((char*)szValue, "%04x", zero_num);
			cmd_out[out_len] = 'x';
			cmd_out[out_len+1] = 'x';
			cmd_out[out_len+2] = szValue[0];
			cmd_out[out_len+3] = szValue[1];
			cmd_out[out_len+4] = szValue[2];
			cmd_out[out_len+5] = szValue[3];

			out_len += 6;

			i += zero_num;
		}
		else
		{
			cmd_out[out_len] = cmd_in[i];
			out_len++;
			i++;
		}
	}

	return out_len;
}

/*****************************************************************************/
// 	Description : 行程压缩法
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL uint16 DecompressCmdStr(
							  uint8 *cmd_in,	//cmd str, in
							  uint16 len,		//cmd str len
							  uint8	*cmd_out,	//out
							  uint16 out_buf_max_len//IN:
							  )
{
	int32	i = 0;
	uint16	out_len = 0;
	uint16	zero_num = 0;

	SCI_ASSERT(NULL != cmd_in); /*assert verified*/
	SCI_ASSERT(NULL != cmd_out); /*assert verified*/

	//解压缩
	while(i<len)
	{
		if(i+5 < len && '#' == cmd_in[i] && '#' == cmd_in[i+1])
		{
			//遇到以'xx'开始的字符串,且长度等于6
			zero_num = MMIAPICOM_HexCharToByte(cmd_in[i+2]);
			zero_num = zero_num*16 + MMIAPICOM_HexCharToByte(cmd_in[i+3]);
			zero_num = zero_num*16 + MMIAPICOM_HexCharToByte(cmd_in[i+4]);
			zero_num = zero_num*16 + MMIAPICOM_HexCharToByte(cmd_in[i+5]);
            if(out_len + zero_num < out_buf_max_len)
			{
				SCI_MEMSET((cmd_out+out_len), '0', zero_num);	
				out_len += zero_num;
				
				i += 6;
			}
			else
			{
				//SCI_TRACE_LOW:"[MMIATC] DecompressCmdStr out_len %d"
				SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_12560_112_2_18_1_59_52_114,(uint8*)"d", out_len + zero_num);
				break;
			}
		}
		else
		{
			if(out_len + 1 < out_buf_max_len)
			{
				cmd_out[out_len] = cmd_in[i];
				out_len++;
				i++;
			}
			else
			{
				//SCI_TRACE_LOW:"[MMIATC] DecompressCmdStr out_len %d"
				SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_12574_112_2_18_1_59_52_115,(uint8*)"d", out_len + 1);
			}
		}
	}

	return out_len;
}

/*****************************************************************************/
// 	Description : send sms message
//	Global resource dependence : none
//  Author:     
//	Note:   codeformat(1 byte) + message string
/*****************************************************************************/
LOCAL BOOLEAN HandleSmsSendMsg(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{

    uint32  text_format = MMI_UT_UTF8;
    uint32  offset = 0;
    // int32 i = 0;
	wchar  *wstr_msg_ptr = PNULL;
	BOOLEAN result = FALSE;
	uint8   str_buf[MMI_MAX_INDICATE_LEN] = {0};

	if(len > 0)
	{
		//get string format type
		if(GetATCNextString(cmd, len, str_buf, MMI_MAX_INDICATE_LEN))
		{
			text_format = atoi((char*)str_buf);
			offset = strlen((char*)str_buf) + 1;
		}
		if(offset < len)
		{
			len = len - offset;
			cmd = cmd + offset;
		}
		else
		{
			len = 0;
		}
	}

	if(len > 0)
	{
		wstr_msg_ptr = (wchar *)GetATCParameter(text_format, cmd, len, 0);
		if(wstr_msg_ptr != PNULL)
		{
			//call sms insert message function
			result = MMIAPISMS_InsertMessage(wstr_msg_ptr, MMIAPICOM_Wstrlen(wstr_msg_ptr));
			//SCI_TRACE_LOW:"[MMIATC] HandleSmsSendMsg wstr_msg_ptr %x  %x"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_12625_112_2_18_1_59_52_116,(uint8*)"dd",wstr_msg_ptr[0],wstr_msg_ptr[1]);
			SCI_FREE(wstr_msg_ptr);
		}
	}

    //call the SMS function       
    if(result)
    {
        //return "ok\r\n" to sync tool;
        ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_OK_SYMBOL));
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }

    return TRUE;
}
#ifdef PUSH_EMAIL_SUPPORT
/*****************************************************************************/
// 	Description : send Input string  message
//	Global resource dependence : none
//  Author: Jiaoyou.wu
//	Note:   codeformat(1 byte) + message string
/*****************************************************************************/
LOCAL BOOLEAN HandlePushMailSendMsg(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{

    uint32  text_format = MMI_UT_UTF8;
    uint32  offset = 0;
    wchar  *wstr_msg_ptr = PNULL;
    BOOLEAN result = FALSE;
    uint8   str_buf[MMI_MAX_INDICATE_LEN] = {0};

	if(len > 0)
	{
		//get string format type
		if(GetATCNextString(cmd, len, str_buf, MMI_MAX_INDICATE_LEN))
		{
			text_format = atoi((char*)str_buf);
			offset = strlen((char*)str_buf) + 1;
		}
		if(offset < len)
		{
			len = len - offset;
			cmd = cmd + offset;
		}
		else
		{
			len = 0;
		}
	}

	if(len > 0)
	{
		wstr_msg_ptr = (wchar *)GetATCParameter(text_format, cmd, len, 0);
		if(wstr_msg_ptr != PNULL)
		{
                //call pushmail insert message function
                result = MMIAPIMAIL_InsertMessage(wstr_msg_ptr, MMIAPICOM_Wstrlen(wstr_msg_ptr));
                //SCI_TRACE_LOW:"[MMIATC] HandleSmsSendMsg wstr_msg_ptr %x  %x"
                SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_12686_112_2_18_1_59_52_117,(uint8*)"dd",wstr_msg_ptr[0],wstr_msg_ptr[1]);
                SCI_FREE(wstr_msg_ptr);
		}
	}

    if(result)
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_OK_SYMBOL));
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }

    return TRUE;
}
#endif

/*****************************************************************************/
// 	Description : send sms message
//	Global resource dependence : none
//  Author:     
//	Note:   codeformat(1 byte) + message string
/*****************************************************************************/
LOCAL BOOLEAN HandleMMSSendMsg(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{

    uint32  text_format = MMI_UT_UTF8;
    uint32  offset = 0;
    // int32 i = 0;
	wchar  *wstr_msg_ptr = PNULL;
	uint8   str_buf[MMI_MAX_INDICATE_LEN] = {0};
	BOOLEAN result = FALSE;

	if(len > 0)
	{
		//get string format type
		if(GetATCNextString(cmd, len, str_buf, MMI_MAX_INDICATE_LEN))
		{
			text_format = atoi((char*)str_buf);
			offset = strlen((char*)str_buf) + 1;
		}
		if(offset < len)
		{
			len = len - offset;
			cmd = cmd + offset;
		}
		else
		{
			len = 0;
		}
	}

	if(len > 0)
	{
		wstr_msg_ptr = (wchar *)GetATCParameter(text_format, cmd, len, 0);
		if(wstr_msg_ptr != PNULL)
		{
			//call sms insert message function
#ifdef MMS_SUPPORT			
			result = MMIAPIMMS_InsertMessage(wstr_msg_ptr, MMIAPICOM_Wstrlen(wstr_msg_ptr));
#endif			
			//SCI_TRACE_LOW:"[MMIATC] MMIAPIMMS_InsertMessage wstr_msg_ptr %x  %x"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_12749_112_2_18_1_59_52_118,(uint8*)"dd",wstr_msg_ptr[0],wstr_msg_ptr[1]);
			SCI_FREE(wstr_msg_ptr);
		}
	}

    //call the SMS function   
#ifdef MMS_SUPPORT	    
    if(result)
    {
        //return "ok\r\n" to sync tool;
        ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_OK_SYMBOL));
    }
    else
#endif
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }

    return result;
}

/*****************************************************************************/
// 	Description : send sms message
//	Global resource dependence : none
//  Author:     
//	Note:   codeformat(1 byte) + message string
/*****************************************************************************/
LOCAL BOOLEAN HandleWAPInputURL(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{
    // int32 i = 0;
#ifdef BROWSER_SUPPORT
	BOOLEAN result = FALSE;
	uint32  offset = 0;
	uint8   str_buf[MMI_MAX_INDICATE_LEN] = {0};
	uint32  text_format = MMI_UT_UTF8;
	wchar  *wstr_msg_ptr = PNULL;
	if(len > 0)
	{
		//get string format type
		if(GetATCNextString(cmd, len, str_buf, MMI_MAX_INDICATE_LEN))
		{
			text_format = atoi((char*)str_buf);
			offset = strlen((char*)str_buf) + 1;
		}
		if(offset < len)
		{
			len = len - offset;
			cmd = cmd + offset;
		}
		else
		{
			len = 0;
		}
	}

	if(len > 0)
	{
		wstr_msg_ptr = (wchar *)GetATCParameter(text_format, cmd, len, 0);
		if(wstr_msg_ptr != PNULL)
		{
			//call sms insert message function
#ifdef BROWSER_SUPPORT_NETFRONT			
			result = MMIAPIWWW_InsertURL(wstr_msg_ptr, MMIAPICOM_Wstrlen(wstr_msg_ptr));
			//SCI_TRACE_LOW:"[MMIATC] MMIAPIWWW_InsertURL wstr_msg_ptr %x  %x"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_12812_112_2_18_1_59_52_119,(uint8*)"dd",wstr_msg_ptr[0],wstr_msg_ptr[1]);
#elif defined BROWSER_SUPPORT_DORADO
			result = Atest_BROWSERInsertURL(wstr_msg_ptr, MMIAPICOM_Wstrlen(wstr_msg_ptr));
			SCI_TRACE_LOW("[MMIATC] Atest_BROWSERInsertURL wstr_msg_ptr %x  %x",wstr_msg_ptr[0],wstr_msg_ptr[1]);
#endif
            SCI_FREE(wstr_msg_ptr);
		}
	}

    //call the SMS function       
    if(result)
    {
        //return "ok\r\n" to sync tool;
        ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_OK_SYMBOL));
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }
#endif
    return TRUE;
}

/*****************************************************************************/
// 	Description : connection setting
//	Global resource dependence : none
//  Author:     
//	Note:   codeformat(1 byte) + message string
/*****************************************************************************/
LOCAL BOOLEAN HandleConnection(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{

    uint32  text_format = MMI_UT_UTF8;
    uint32  offset = 0;
    // int32 i = 0;
	wchar  *wstr_msg_ptr = PNULL;
	uint8   str_buf[MMI_MAX_INDICATE_LEN] = {0};
	BOOLEAN result = FALSE;
	if(len > 0)
	{
		//get string format type
		if(GetATCNextString(cmd, len, str_buf, MMI_MAX_INDICATE_LEN))
		{
			text_format = atoi((char*)str_buf);
			offset = strlen((char*)str_buf) + 1;
		}
		if(offset < len)
		{
			len = len - offset;
			cmd = cmd + offset;
		}
		else
		{
			len = 0;
		}
	}

	if(len > 0)
	{
		wstr_msg_ptr = (wchar *)GetATCParameter(text_format, cmd, len, 0);
		if(wstr_msg_ptr != PNULL)
		{
			//call sms insert message function
			result = MMIAPICONNECTION_InsertStr(wstr_msg_ptr, MMIAPICOM_Wstrlen(wstr_msg_ptr));
			//SCI_TRACE_LOW:"[MMIATC] MIAPICONNECTION_InsertStr wstr_msg_ptr %x  %x"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_12873_112_2_18_1_59_52_120,(uint8*)"dd",wstr_msg_ptr[0],wstr_msg_ptr[1]);
			SCI_FREE(wstr_msg_ptr);
		}
	}

    //call the SMS function       
    if(result)
    {
        //return "ok\r\n" to sync tool;
        ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_OK_SYMBOL));
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }
    return TRUE;
}


/*****************************************************************************/
// 	Description : send string or struct from cmd
//	Global resource dependence : none
//  Author:     
//	Note:   
/*****************************************************************************/
LOCAL void* GetATCParameter(uint32 text_format,
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 cmd_len,   // The length of command infomation buffer
								uint32 struct_size//if text_format is MMI_ATC_STRUCT, this size must be input
                                )
{
	void   *paramter_ptr = PNULL;
	uint16 binary_val_len = 0;
    uint8  *binary_val_ptr = PNULL;
	if(PNULL == cmd)
	{
		//SCI_TRACE_LOW:"[MMIATC] GetATCParameter cmd == PNULL !"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_12907_112_2_18_1_59_52_121,(uint8*)"");
		return PNULL;
	}

    //SCI_TRACE_LOW:"[MMIATC] GetATCParameter cmd %x  %x  %x  %x  %x  %x  %x  %x  %x"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_12912_112_2_18_1_59_52_122,(uint8*)"ddddddddd",cmd[0],cmd[1],cmd[2],cmd[3],cmd[4],cmd[5],cmd[6],cmd[7],cmd[8]);
	binary_val_ptr = (void *)SCI_ALLOC_APP(cmd_len +1);
	if(binary_val_ptr == PNULL)
	{
		return PNULL;
	}
	SCI_MEMSET(binary_val_ptr, 0x00, (cmd_len +1 ));
   
	MMIAPICOM_HexCharToBinary(cmd, cmd_len, (uint8*)binary_val_ptr, &binary_val_len);
	
	switch(text_format)
	{
	case MMI_UT_UTF8:
		paramter_ptr = (wchar *)SCI_ALLOC_APP((binary_val_len +1 )*sizeof(wchar));
		SCI_MEMSET(paramter_ptr, 0x00, ((binary_val_len +1 )*sizeof(wchar)));
		GUI_UTF8ToWstr((wchar *)paramter_ptr, binary_val_len, (uint8 *)binary_val_ptr, binary_val_len);
		break;
	case MMI_UT_UNICODE:
        paramter_ptr = (wchar *)SCI_ALLOC_APP((binary_val_len +1 )*sizeof(wchar));
		SCI_MEMSET(paramter_ptr, 0x00, ((binary_val_len +1 )*sizeof(wchar)));
		SCI_MEMCPY(paramter_ptr, binary_val_ptr, binary_val_len);
		break;
	case MMI_UT_GB2312:
        paramter_ptr = (wchar *)SCI_ALLOC_APP((binary_val_len +1 )*sizeof(wchar));
		SCI_MEMSET(paramter_ptr, 0x00, ((binary_val_len +1 )*sizeof(wchar)));
		GUI_GBToWstr(paramter_ptr, binary_val_ptr, binary_val_len);
		break;
	case MMI_UT_STRUCT:
		if(struct_size > 0)
		{
			paramter_ptr = SCI_ALLOC_APP(struct_size);
			SCI_MEMSET(paramter_ptr, 0x00, struct_size);
			SCI_MEMCPY(paramter_ptr, binary_val_ptr, binary_val_len);
		}
		break;

    default:
        break;
	}
    SCI_FREE(binary_val_ptr);
	return paramter_ptr;
}

/*****************************************************************************/
// 	Description : send string or struct from cmd
//	Global resource dependence : none
//  Author:     
//	Note:   
/*****************************************************************************/
LOCAL BOOLEAN GetATCNextString( uint8 *cmd,  // Point to the command infomation buffer
					            uint32 cmd_len,   // The length of command infomation buffer
								uint8 *next_str_ptr,//OUT
								uint8 next_str_max_len//IN
                                )
{

	BOOLEAN result = FALSE;
    uint32  i = 0;
    uint32  min_len = 0;

	if(PNULL == cmd 
		|| (PNULL == next_str_ptr) 
		|| 0 == cmd_len 
		|| 0 ==next_str_max_len 
	 )
	{
		//parameter error
		//SCI_TRACE_LOW:"[MMIATC] GetATCNextString parameter error !"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_12977_112_2_18_1_59_52_123,(uint8*)"");
		return FALSE;
	}
    
    min_len = (uint32)MIN(cmd_len,next_str_max_len);

    for(i = 0; i < min_len; i++) /*lint !e737*/
	{
		if(MMI_UT_CMD_INTERVAL_FLAG == cmd[i])
		{
			result = TRUE;
			break;
		}
		else
		{
			next_str_ptr[i] = cmd[i];
		}
	}
	//SCI_TRACE_LOW:"[MMIATC] GetATCNextString string %s result %d"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_12995_112_2_18_1_59_52_124,(uint8*)"sd", next_str_ptr, result);
	return result;

}
#endif //#ifdef MMI_SYNCTOOL_V3

#ifdef MMI_SYNCTOOL_SUPPORT
#include    "mmi_atc.h"
#include    "mmk_type.h"
#include    "mmi_appmsg.h"
#include    "mmisms_export.h"
#include    "mmipb_atc.h"
#include    "mmialarm_export.h"
//#include	"mmimultim.h"
#include	"tb_hal.h"
#include	"mmidc_export.h"
//#include    "mmiudisk.h"
#include	"mmiphone_export.h"
#include "mmiudisk_export.h"
#include "mmimms_export.h"

//mod by shuyanhu for at+sytin
#ifdef BROWSER_SUPPORT
#include "mmibrowser_export.h"
#endif
#include "gui_ucs2b_converter.h"
#include "mmieng_nv.h"
#include "mmiconnection_export.h"
//#include "mmieng.h"
#ifdef ENG_SUPPORT
#include "mmieng_export.h"
#include "mmieng_win.h"
#include "mmieng_main.h"
#endif
//add by shuyanhu for at+sytin---start
#include "mmifmm_export.h"
#include "mmifmm_export.h"
#include "mmipb_adapt.h"
#include "mmi_mainmenu_export.h"
#ifdef PUSH_EMAIL_SUPPORT
#include "mmimail_export.h"
#endif /* PUSH_EMAIL_SUPPORT */
#ifdef VT_SUPPORT
#include "mmivt_export.h"
#endif 
#include "mmiset_func.h"
#include "mmiset_export.h"
#ifdef MMI_KEY_LOCK_SUPPORT
#include "mmikl_export.h"
#endif
#include "mmipb_export.h"
//add by shuyanhu for at+sytin---end 

//add by xiaolei.zheng for gui control test ---start
#ifdef ATEST_SUPPORT
#include "mmk_kbd.h"
#include "mmk_app.h"
#include "mmiset_func.h"
#include "mmk_tree.h"
#include "mmk_msg.h"
#include "sci_api.h"
#include "guirichtext.h"
#include "guidropdownlist.h"
#include "guimenu.h"
#include "guitips.h"
#include "guibutton.h"
#include "guititle.h"
#include "guitoolbar.h"
#include "guiscrollkey.h"
#include "guitab.h"
#include "guilcd.h"
#include "guistatusbar.h"
#include "guistatusbar_data.h"
#include "guilistbox.h"
#include "guianim.h"
#include "guiimg.h"
#include "guitext.h"
#include "guiprgbox.h"
#include "guiownerdraw.h"
#include "guisetlist.h"
#include "guiim.h"
#include "guilabel.h"
#include "guiform.h"
#include "guimsgbox.h"
#include "guiiconlist.h"
#include "mmk_window_internal.h"
#include "ctrltitle.h"
#include "ctrltab.h"
#include "ctrlim.h"
#include "mmiim_touch_common.h"
#include "mmiset_export.h"
#include "mmialarm_export.h"
#include "mmicalendar_export.h"
#include "Mmi_mainmenu_istyle.h"
#include "ctrldropdownlist.h"
#include "ctrlmenu.h"
#include "Ctrlanim.h"
#include "Ctrlstatusbar.h"
#include "ctrlownerdraw.h"
#include "Ctrltext.h"
#include "Ctrlform.h"
#include "Ctrliconlist.h"
#include "Ctrltips.h"
#include "Ctrlscrollkey.h"
#include "Ctrlrichtext.h"
#include "Ctrltext.h"
#include "Ctrlprogressbar.h"
#include "Ctrlmsgbox.h"
#include "Ctrlbutton.h"
#include "Ctrliconlist.h"
//#include "Ctrltoolbar.h"
#include "Ctrlsetlist.h"
#include "Ctrlbaseedit.h"
#include "ctrllistedit.h"
#include "Ctrldropdownlist.h"
#include "Ctrlsoftkey.h"
#include "Ctrllistbox.h"
#include "Ctrlprogress.h"
#include "Ctrliconfolder.h"
#include "ctrlmainmenu.h"
#include "Mmi_link.h"
#include "ctrllabel.h"
#include "mmi_mainmenu_sweets.h"
#include "mmi_mainmenu_slide_page.h"
#include "mmi_mainmenu_matrix.h"
#include "mmi_mainmenu_qbtheme.h"
#endif // ATEST_SUPPORT
//add by xiaolei.zheng for gui control test ---end
#ifdef DCD_SUPPORT
#include "mmidcd_export.h"
#endif
#ifdef MMI_AUTOTEST_SUPPORT
#include "mmi_autotest.h"
#endif
/**--------------------------------------------------------------------------*
 **                         MACRO DEFINITION                                 *
 **--------------------------------------------------------------------------*/
#define SMS_DELETE_PARAM_NUM 3

#define PHOTO_DIRECTORY     "photo"
#define PICTURE_DIRECTORY   "picture"
#define DIRECTORY_SYMBOL    '/'

#define MAX_RESCMD_LEN      2048
#define PB_ENTRY_ID_MAX_LEN 4

#ifdef ATEST_SUPPORT
// add by xiaolei.zheng for gui control test
#define ATEST_MAX_SEND_LEN   256

// add by lin.chen for gui search control item
#define ATEST_MAX_STR_LEN	250	
#define ATEST_RECT_LIMIT	100
#endif

/**-------------------------------------------------------------------------*
**                         GLOBAL DEFINITION                                *
**--------------------------------------------------------------------------*/
#ifndef _WIN32
LOCAL BOOLEAN s_atc_is_run = FALSE;
#endif

//add by shuyan.hu for Atest pb create 
LOCAL uint8 *s_pb_name = NULL;
LOCAL uint8 *s_pb_number = NULL;
LOCAL MMIPB_HANDLE_T s_handle_pb = NULL;
LOCAL uint16 s_MMIPB_Create_ID  = MN_DUAL_SYS_1;
LOCAL BOOLEAN s_pbcreatesim = FALSE;

//extern MMIPB_SORT_AND_ENTRY_ID_T   g_mmipb_entry_list;
#ifndef WIN32
extern BOOLEAN ATC_WriteCmdRsp(uint8 * buf_ptr, uint32 len);
#ifdef DM_SUPPORT
extern void MMIDM_SetDmRegSwitchState(BOOLEAN mode);
#endif
#ifdef DSP_USB_LOG
extern void REFPARAM_SetDspDebugPortPhyNo(uint8 phy_port);
#endif
#endif

//add by lin.chen for return cur language ---start
#ifdef ATEST_SUPPORT
#ifdef MATRIX_MAIN_MENU_SUPPORT
typedef struct
{
    MMI_HANDLE_T                win_handle;                             //window handle
    MMI_HANDLE_T                ctrl_handle;

    GUIMENU_ICONMENU_DATA_T     icon_data;

    GUIMENU_STATE_T             menu_state;
    BOOLEAN                     is_static;                              //is static menu
    BOOLEAN                     is_focus_title;                         //title is focus for option page
    BOOLEAN                     is_title_style;

    uint16                      cur_page_index;                         //default 0,from 0 to max-1
    uint16                      cur_item_index;                         //current selected menu index. in option page style, it is also item index
    uint16                      first_item_index;                       //item index at the top
    int16                       offset_y;                               //offset y
    uint16                      pre_cur_item_index;                     //previous current index
    uint16                      item_total_num;                         //current total visible item number. in option page style, it is page count.

    BOOLEAN                     is_need_prgbox;                         //is need prgbox or not
    BOOLEAN                     is_revise_rect;                         //is need revise rect or not，当增加滚动条的时候，需要重新调整区域
    IGUICTRL_T                  *prgbox_ctrl_ptr;                       //progress box control pointer

    MMITHEME_MAINMENU_COMMON_T  main_menu_theme;                        //main menu theme

    MMIMAINEMENU_ITEM_LIST_T    menu_list_info;                         //menu list information

    MMK_TP_SLIDE_E              slide_state;
    BOOLEAN                     is_move_state;                          //item是否在抖动
    BOOLEAN                     is_moving;                              //item是否被拖动
    BOOLEAN                     is_item_pressed;                        //tp down时，是否在item上
    BOOLEAN                     is_tp_pressed;                          //is tp down?

    float                       fling_velocity;                         //滑动速度
    GUIMENU_ENTER_ANIM_TYPE_E   enter_anim_type;                        // 进入时的动画类型

    // mainmenu button
    MMI_HANDLE_T                button_handle[GUIMENU_BUTTON_NUM];      // button控件
    GUI_RECT_T                  writeback_rect;//双buffer回写

    GUIMENU_SOFTKEY_STATE_T     softkey_state;                          //softkey的状态，目前只有主菜单使用

    GUI_LCD_DEV_INFO            highlight_layer_handle;
    GUI_LCD_DEV_INFO            icon_move_layer_handle;
    uint32                      start_item_index;
    uint16                      tmp_cur_item_index;                     //移动的时候使用
    GUI_RECT_T                  move_rect;
    CONTINUE_MOVE_TYPE_E        continue_move_type;

    GUI_POINT_T                 slide_start_point;                      //Slide时候使用
    GUI_POINT_T                 slide_pre_point;                        //Slide时候使用

    MMK_TP_SLIDE_E              tpdown_slide_state;                     //slide state when tp down

    uint16                      tmp_width;                              //移动的时候使用
    uint16                      tmp_height;                             //移动的时候使用

    uint16                      tmp_first_item_index;                   //移动的时候使用

    uint8                       slide_timer_id;                         // 滑动时，slide和fling状态下，画图的timer
    uint16                      pre_msg_loop_page_index;                // 每次消息循环后，focus page index
    uint16                      pre_msg_loop_item_index;                // 每次消息循环后，focus项index
    uint16                      pre_msg_loop_menu_level;                // 每次消息循环后，focus项的level
    uint16                      menu_level;                             //menu level
    
} MMIMAINMENU_MATRIX_DATA_T;
#endif

#ifdef QBTHEME_SUPPORT
typedef struct
{
    MMI_HANDLE_T                win_handle;                             //window handle
    MMI_HANDLE_T                ctrl_handle;

    MMITHEME_MAINMENU_COMMON_T  main_menu_theme;                        //main menu theme
    GUIMENU_QBTHEME_DATA_T      qbtheme_menu_data;                      //千变主题菜单数据以及排版 

    MMIMAINEMENU_PAGE_LIST_T    menu_page_info;                         //menu list information
    MMIMAINEMENU_ITEM_LIST_T    menu_bar_info;                          //menu bar information

    GUIMENU_STATE_T             menu_state;

    uint16                      cur_page_index;                         //default 0,from 0 to max-1
    uint16                      cur_item_index;                         //current selected menu index. in option page style, it is also item index
    uint16                      first_item_index;                       //item index at the top
    uint16                      pre_cur_item_index;                     //previous current index
    uint16                      page_total_num;                         //TODO: total_page_num;

    BOOLEAN                     is_active;                              //
    BOOLEAN                     is_delete_state;                        //item是否在抖动
    BOOLEAN                     is_move_state;                          //item是否在抖动
    BOOLEAN                     is_moving;                              //item是否被拖动
    BOOLEAN                     is_empty_space;                         //tp up时，是否在item上
    BOOLEAN                     is_item_pressed;                        //tp down时，是否在item上
    BOOLEAN                     is_tp_pressed;                          //is tp down?
    BOOLEAN                     is_bar_item;                            //is bar item

    uint16                      tmp_cur_item_index;                     //移动的时候使用
    uint16                      tmp_first_item_index;                   //移动的时候使用
    uint16                      tmp_page_item_index;                    //移动到时候使用
    BOOLEAN                     tmp_is_bar_item;                        //移动的时候使用
    uint16                      move_item_index;                        //移动的item项，用于给idle和删除用

    uint16                      tmp_width;                              //移动的时候使用
    uint16                      tmp_height;                             //移动的时候使用
    
    CONTINUE_MOVE_TYPE_E 	    continue_move_type;	                    // 连续移动的类型
    uint8                       tp_timer_id;				            // 为支持TP连续移动而加的timer
    uint8                       redrew_timer_id;				        // 滑动时，slide和fling状态下，画图的timer
    uint8                       start_move_timer_id;				    // 进入抖动状态的定时器
    uint8                       shake_icon_timer_id;				    // 进入抖动状态时，每次抖动的间隔
    uint8                       user_timer_id;				            // 应用自定义的timer
    uint8                       highlight_timer_id;				        // 

    BOOLEAN                     is_display_item_layer;                  // 是否画item layer的数据

    GUI_LCD_DEV_INFO            highlight_layer_handle;                 //高亮层
    GUI_LCD_DEV_INFO            icon_move_layer_handle;                 //图标移动层
	GUI_LCD_DEV_INFO			to_idle_layer_handle;                   //到主菜单图层

    MMK_TP_SLIDE_E              slide_state;                            //current slide state
    MMI_MENU_ID_T               delete_menu_id;                         //组织状态下使用,要删除的menu_id
    GUI_POINT_T                 slide_start_point;                      //Slide时候使用
    GUI_POINT_T                 slide_pre_point;                        //Slide时候使用
    GUI_POINT_T                 pre_tp_point;                           //上一次tp move的坐标
    GUI_LCD_DEV_INFO            page_layer_handle[GUIMENU_SLIDE_PAGE_NUM]; //页面移动层1
    GUI_LCD_DEV_INFO            titleidx_layer_handle;                  // 页面索引层
    // end

    float                       fling_velocity;                         //滑动速度
    GUIMENU_GO_SLIDE_TYPE_E      support_slide_type;                    //主菜单支持的滑动类型
    GUI_LCD_DEV_INFO            layer_bg; 

    GUIMENU_ENTER_ANIM_TYPE_E   enter_anim_type;                        // 进入时的动画类型
    uint8  init_item_timer_id;
    GUI_LCD_DEV_INFO			delete_layer_handle;                    //删除图层
// 以下应该用控件的数据
    GUI_LCD_DEV_INFO            lcd_dev_info;                           // 页面索引层
    GUI_RECT_T                  rect;
} MMIMAINMENU_QBTHEME_DATA_T;
#endif

#ifdef PDA_UI_SUPPORT_MANIMENU_GO
typedef struct
{
    MMI_HANDLE_T                win_handle;                             //window handle
    MMI_HANDLE_T                ctrl_handle;

    GUIMENU_STATE_T             menu_state;
    GUIMENU_SLIDEMENU_DATA_T    slide_data;
    MMITHEME_MAINMENU_COMMON_T  main_menu_theme;                        // main menu theme
    MMIMAINEMENU_ITEM_LIST_T    menu_list_info;                         // menu list information

    MMI_HANDLE_T                button_handle[GUIMENU_BUTTON_NUM];      // button控件

    GUI_LCD_DEV_INFO            page_layer_handle[GUIMENU_SLIDE_PAGE_NUM];    //页面移动层1
    GUI_LCD_DEV_INFO            titleidx_layer_handle;                  // 页面索引层
    GUI_LCD_DEV_INFO            highlight_layer_handle;                 // 高亮层
    GUI_LCD_DEV_INFO            icon_move_layer_handle;                 // 图标移动层
    GUI_LCD_DEV_INFO            cube_layer_handle;                      //  立方体层
    GUI_LCD_DEV_INFO			to_idle_layer_handle;                   //到主菜单图层
    GUI_LCD_DEV_INFO			delete_layer_handle;                    //删除图层
    MMIMAINEMENU_PAGE_LIST_T    menu_page_info;                         //menu list information

    BOOLEAN                     is_move_state;                          // item是否在抖动
    BOOLEAN                     is_delete_state;                        // item是否在抖动
    BOOLEAN                     is_active;                              // is active
    BOOLEAN                     is_tp_pressed;                          // is tp down
    BOOLEAN                     is_item_pressed;                        // tp down时，是否在item上
    BOOLEAN                     is_empty_space;                         //tp up时，是否在item上

    MMK_TP_SLIDE_E              slide_state;                            // current slide state
    GUI_POINT_T                 slide_start_point;                      // Slide时候使用
    GUI_POINT_T                 slide_pre_point;                        // Slide时候使用
    GUI_POINT_T                 pre_tp_point;                           // 上一次tp move的坐标
    CONTINUE_MOVE_TYPE_E        continue_move_type;                     // 连续移动的类型

    uint8                       redrew_timer_id;                        // 滑动时，slide和fling状态下，画图的timer
    uint8                       init_item_timer_id;
    uint8                       shake_icon_timer_id;
    uint8                       start_move_timer_id;
    MMI_MENU_ID_T               delete_menu_id;                         // 组织状态下使用,要删除的menu_id

    uint16                      pre_cur_item_index;                     // previous current index
    uint16                      first_item_index;                       // item index at the top
    uint16                      tmp_width;                              // 移动的时候使用
    uint16                      tmp_height;                             // 移动的时候使用
    uint16                      tmp_cur_item_index;                     // 移动的时候使用
    uint16                      tmp_first_item_index;                   // 移动的时候使用
    uint16                      tmp_page_item_index;                    // 移动到时候使用

    float                       fling_velocity;                         // 滑动速度

    BOOLEAN                     is_display_title;                       // 是否显示title
    BOOLEAN                     is_display_item_layer;

    uint16                      item_total_num;
    uint16                      cur_page_index;                         // default 0,from 0 to max-1
    uint16                      cur_item_index;                         // current selected menu index. in option page style, it is also item index
#if defined(PDA_UI_SUPPORT_MANIMENU_GO)
    GUI_LCD_DEV_INFO            layer_bg;
    GUIMENU_GO_SLIDE_TYPE_E     support_slide_type;                     // 主菜单支持的滑动类型
    uint8                       highlight_timer_id;                     //  highlight显示的timer ID
#endif
    uint16                      pre_msg_loop_page_index;                // 每次消息循环后，focus page index
    uint16                      pre_msg_loop_item_index;                // 每次消息循环后，focus项index
    uint16                      pre_msg_loop_menu_level;                // 每次消息循环后，focus项的level
    uint16                      menu_level;                             //menu level

} MMIMAINMENU_SLIDEPAGE_DATA_T;
#endif

#ifdef MENU_SWEETS_SUPPORT
typedef struct
{

    MMI_HANDLE_T                win_handle;                             //window handle
    MMI_HANDLE_T                ctrl_handle;

    GUIMENU_STATE_T             menu_state;
    BOOLEAN                     is_active;
    
    uint16                      cur_page_index;                         //default 0,from 0 to max-1
    uint16                      cur_item_index;                         //current selected menu index. in option page style, it is also item index
    uint16                      item_total_num;                         //current total visible item number. in option page style, it is page count.

    MMI_MENU_GROUP_ID_T         cur_group_id;                           //current menu group id
 

    MMITHEME_MAINMENU_COMMON_T  main_menu_theme;                        //main menu theme

    MMIMAINEMENU_ITEM_LIST_T    menu_list_info;                         //menu list information
    uint32                      start_item_index;

    BOOLEAN                     is_move_state;                          //item是否在抖动
    BOOLEAN                     is_moving;                              //item是否被拖动
    BOOLEAN                     is_item_pressed;                        //tp down时，是否在item上
    BOOLEAN                     is_tp_pressed;                          //is tp down?

    
    //CONTINUE_MOVE_TYPE_E 	    continue_move_type;	                    // 连续移动的类型
    uint8                       redrew_timer_id;				        // 滑动时，slide和fling状态下，画图的timer

    BOOLEAN                     is_display_title;                       // 是否显示title

    MMK_TP_SLIDE_E              slide_state;                            //current slide state
    GUI_POINT_T                 slide_start_point;                      //Slide时候使用
    GUI_POINT_T                 slide_pre_point;                        //Slide时候使用

    GUI_LCD_DEV_INFO            titleidx_layer_handle;                  // 页面索引层

    float                       fling_velocity;                         //滑动速度
    GUIMENU_ENTER_ANIM_TYPE_E   enter_anim_type;                        // 进入时的动画类型

    uint16                      pre_msg_loop_page_index;                // 每次消息循环后，focus page index
    uint16                      pre_msg_loop_item_index;                // 每次消息循环后，focus项index
    uint16                      pre_msg_loop_menu_level;                // 每次消息循环后，focus项的level

    uint32			            icon_shake_period;	                    // icon 震动时间间隔
    uint32			            auto_move_period;	                    // 支持连续移动的时间间隔
} MMIMAINMENU_SWEETS_DATA_T;
#endif

extern int stricmp (const char *a, const char *b);

uint8 *receive_data_arr = PNULL;

ATEST_CUR_LANG_T cur_lang[]= 
{
#ifdef MMI_SIM_LANGUAGE_SUPPORT
    	{MMISET_LANGUAGE_AUTO, "AUTO"},     
#endif
	{MMISET_LANGUAGE_ENGLISH,"ENGLISH"},
 	{MMISET_LANGUAGE_SIMP_CHINESE,"SIMP_CHINESE"},
	{MMISET_LANGUAGE_TRAD_CHINESE,"TRAD_CHINESE"},
	{MMISET_LANGUAGE_ARABIC,"ARABIC"},    
	{MMISET_LANGUAGE_FRENCH,"FRENCH"},    
	{MMISET_LANGUAGE_HINDI,"HINDI"},      
	{MMISET_LANGUAGE_HUNGARIAN,"HUNGARIAN"},     
	{MMISET_LANGUAGE_INDONESIAN,"INDONESIAN"},   
	{MMISET_LANGUAGE_MALAY,"MALAY"},     
	{MMISET_LANGUAGE_PORTUGUESE,"PORTUGUESE"},   
	{MMISET_LANGUAGE_RUSSIAN,"RUSSIAN"},   
	{MMISET_LANGUAGE_SPANISH,"SPANISH"},    
	{MMISET_LANGUAGE_TAGALOG,"TAGALOG"},   
	{MMISET_LANGUAGE_THAI,"THAI"},         
	{MMISET_LANGUAGE_VIETNAMESE,"VIETNAMESE"},   
	{MMISET_LANGUAGE_URDU,"URDU"},          
   	{MMISET_LANGUAGE_ITALIAN,"ITALIAN"},    
    {MMISET_LANGUAGE_PERSIAN,"PERSIAN"},    
    {MMISET_LANGUAGE_TURKISH,"TURKISH"},    
    {MMISET_LANGUAGE_GERMAN,"GERMAN"},      
    {MMISET_LANGUAGE_GREEK,"GREEK"},        
    {MMISET_LANGUAGE_HEBREW,"HEBREW"},      
	{MMISET_LANGUAGE_BENGALI,"BENGALI"},    
	{MMISET_LANGUAGE_CZECH,"CZECH"},        
    {MMISET_LANGUAGE_SLOVENIAN,"SLOVENIAN"},
	{MMISET_LANGUAGE_ROMANIAN,"ROMANIAN"},  
    {MMISET_LANGUAGE_TELUGU,"TELUGU"},
	{MMISET_LANGUAGE_MARATHI,"MARATHI"},
	{MMISET_LANGUAGE_TAMIL,"TAMIL"},
	{MMISET_LANGUAGE_GUJARATI,"GUJARATI"},
	{MMISET_LANGUAGE_KANNADA,"KANNADA"},
    {MMISET_LANGUAGE_MALAYALAM,"MALAYALAM"},
    {MMISET_LANGUAGE_ORIYA,"ORIYA"},
    {MMISET_LANGUAGE_PUNJABI,"PUNJABI"},
    {MMISET_LANGUAGE_AFRIKAANS,"AFRIKAANS"},
    {MMISET_LANGUAGE_ALBANIAN,"ALBANIAN"},
    {MMISET_LANGUAGE_ARMENIAN,"ARMENIAN"},
    {MMISET_LANGUAGE_AZERBAIJANI,"AZERBAIJANI"},
    {MMISET_LANGUAGE_BASQUE,"BASQUE"},
    {MMISET_LANGUAGE_BULGARIAN,"BULGARIAN"},
    {MMISET_LANGUAGE_CATALAN,"CATALAN"},
    {MMISET_LANGUAGE_CROATIAN,"CROATIAN"},
    {MMISET_LANGUAGE_DANISH,"DANISH"},
 	{MMISET_LANGUAGE_DUTCH,"DUTCH"},
 	{MMISET_LANGUAGE_ESTONIAN,"ESTONIAN"},
 	{MMISET_LANGUAGE_FILIPINO,"FILIPINO"},
 	{MMISET_LANGUAGE_FINNISH,"FINNISH"},
    {MMISET_LANGUAGE_GALICIAN,"GALICIAN"},
    {MMISET_LANGUAGE_GEORGIAN,"GEORGIAN"},
    {MMISET_LANGUAGE_HAUSA,"HAUSA"},
    {MMISET_LANGUAGE_ICELANDIC,"ICELANDIC"},
    {MMISET_LANGUAGE_IGBO,"IGBO"},
    {MMISET_LANGUAGE_IRISH,"IRISH"},
    {MMISET_LANGUAGE_KAZAKH,"KAZAKH"},
    {MMISET_LANGUAGE_LATVIAN,"LATVIAN"},
    {MMISET_LANGUAGE_LITHUANIAN,"LITHUANIAN"},
    {MMISET_LANGUAGE_MACEDONIAN,"MACEDONIAN"},
    {MMISET_LANGUAGE_MOLDOVAN,"MOLDOVAN"},
    {MMISET_LANGUAGE_NORWEGIAN,"NORWEGIAN"},
    {MMISET_LANGUAGE_POLISH,"POLISH"},
    {MMISET_LANGUAGE_SERBIAN,"SERBIAN"},
    {MMISET_LANGUAGE_SESOTHO,"SESOTHO"},
    {MMISET_LANGUAGE_SLOVAK,"SLOVAK"},
    {MMISET_LANGUAGE_SWEDISH,"SWEDISH"},
    {MMISET_LANGUAGE_UKRAINIAN,"UKRAINIAN"},
    {MMISET_LANGUAGE_YORUBA,"YORUBA"},
    {MMISET_LANGUAGE_XHOSA,"XHOSA"},
    {MMISET_LANGUAGE_ZULU,"ZULU"},
    {MMISET_LANGUAGE_ASSAMESE,"ASSAMESE"},
    {MMISET_LANGUAGE_SWAHILI,"SWAHILI"},
    {MMISET_LANGUAGE_MYANMAR,"MYANMAR"},
    {MMISET_LANGUAGE_AMHARIC,"AMHARIC"},
    {MMISET_LANGUAGE_KHMER,"KHMER"},
    {MMISET_LANGUAGE_LAO,"LAO"},
	{MMISET_MAX_LANGUAGE,"others"}
};
#endif  //ATEST_SUPPORT
//add by lin.chen for return cur language ---end

/*---------------------------------------------------------------------------*/
/*                          LOCAL FUNCTION DECLARE                           */
/*---------------------------------------------------------------------------*/
/*****************************************************************************/
// 	Description : If the cmd is match the indication
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN IsMatchIndication(
				                uint8 *cmd,  // Point to the command infomation buffer
				                uint32 len,   // The length of command infomation buffer
                                const char* ind_ptr //the indication
				                );

/*****************************************************************************/
// 	Description : This function parse at cmd wich from sync tool
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN ParseSyncAtCmd(
					      uint8 *cmd,  // Point to the command infomation buffer
					      uint32 len   // The length of command infomation buffer
					      );

/*****************************************************************************/
// 	Description : This function parse at atuo test cmd
//	Global resource dependence : none
//  Author:      
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN ParseSyncUTAtCmd(
					      uint8 *cmd,  // Point to the command infomation buffer
					      uint32 len   // The length of command infomation buffer
					      );
/*****************************************************************************/
// 	Description : This function handle the pb getinfo command
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandlePbGetInfo(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );

/*****************************************************************************/
// 	Description : This function handle the pb get one item command
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandlePbReadItem(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );

/*****************************************************************************/
// 	Description : This function handle the pb add command
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandlePbAdd(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );
/*****************************************************************************/
// 	Description : This function handle the pb delete command
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandlePbDelete(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );
/*****************************************************************************/
// 	Description : This function handle the pb modify command
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandlePbModify(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );

/*****************************************************************************/
// 	Description : This function handle the sms deletecommand
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleSmsDelete(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );

/*****************************************************************************/
// 	Description : This function handle the sms deletecommand
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleSmsSendMsg(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );
#ifdef PUSH_EMAIL_SUPPORT
/*****************************************************************************/
// 	Description : send Input string  message
//	Global resource dependence : none
//  Author: Jiaoyou.wu
//	Note:   codeformat(1 byte) + message string
/*****************************************************************************/
LOCAL BOOLEAN HandlePushMailSendMsg(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );
#endif
/*****************************************************************************/
// 	Description : send sms message
//	Global resource dependence : none
//  Author:     
//	Note:   codeformat(1 byte) + message string
/*****************************************************************************/
LOCAL BOOLEAN HandleMMSSendMsg(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );

/*****************************************************************************/
// 	Description : send sms message
//	Global resource dependence : none
//  Author:     
//	Note:   codeformat(1 byte) + message string
/*****************************************************************************/
LOCAL BOOLEAN HandleWWWInputURL(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );

/*****************************************************************************/
// 	Description : connection setting
//	Global resource dependence : none
//  Author:     
//	Note:   codeformat(1 byte) + message string
/*****************************************************************************/
LOCAL BOOLEAN HandleConnection(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );

/*****************************************************************************/
// 	Description : send string or struct from cmd
//	Global resource dependence : none
//  Author:     
//	Note:   
/*****************************************************************************/
LOCAL void* GetATCParameter(uint32 text_format,
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 cmd_len,   // The length of command infomation buffer
								uint32 struct_size//if text_format is MMI_ATC_STRUCT, this size must be input
                                );

/*****************************************************************************/
// 	Description : get next string from cmd
//	Global resource dependence : none
//  Author:     
//	Note:   
/*****************************************************************************/
LOCAL BOOLEAN GetATCNextString( uint8 *cmd,  // Point to the command infomation buffer
					            uint32 cmd_len,   // The length of command infomation buffer
								uint8 *next_str_ptr,//OUT
								uint8 next_str_max_len//IN
                                );

/*****************************************************************************/
// 	Description : This function get string finished by finish_char
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
//LOCAL BOOLEAN GetString(
//                        uint8* dest_str_ptr, 
//                        uint32 max_len, 
//                        uint8* src_str_ptr, 
//                        uint32 src_str_len,
//                        uint8 finish_char
//                         );

/*****************************************************************************/
// 	Description : This function return response to at
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL void ReturnResponse(
                            uint8* res_ptr,
                            uint16 len
                            );
/*****************************************************************************/
// 	Description : This function judge pb paramter
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN GetPbStorage(
                     uint8 *pos, 
                     uint8 cmd_char
                     );
/*****************************************************************************/
// 	Description : This function get pb entry id from cmd string
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL uint16 GetPbEntryId(
                    uint8* cmd, 
                    uint16 len);

/*****************************************************************************/
// 	Description : This function handle the group getinfo command
//	Global resource dependence : none
//  Author:      liqing.peng
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleGroupGetInfo(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );

/*****************************************************************************/
// 	Description : This function handle the group get one item command
//	Global resource dependence : none
//  Author:      liqing.peng
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleGroupReadItem(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );

/*****************************************************************************/
// 	Description : This function handle the group add command
//	Global resource dependence : none
//  Author:      liqing.peng
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleGroupAdd(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );
/*****************************************************************************/
// 	Description : This function handle the group delete command
//	Global resource dependence : none
//  Author:      liqing.peng
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleGroupDelete(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );
/*****************************************************************************/
// 	Description : This function handle the group modify command
//	Global resource dependence : none
//  Author:      liqing.peng
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleGroupModify(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );

/*****************************************************************************/
// 	Description : This function handle the group getinfo command
//	Global resource dependence : none
//  Author:      liqing.peng
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleMemoGetInfo(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );

/*****************************************************************************/
// 	Description : This function handle the group get one item command
//	Global resource dependence : none
//  Author:      liqing.peng
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleMemoReadItem(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );

/*****************************************************************************/
// 	Description : This function handle the group add command
//	Global resource dependence : none
//  Author:      liqing.peng
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleMemoAdd(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );
/*****************************************************************************/
// 	Description : This function handle the group delete command
//	Global resource dependence : none
//  Author:      liqing.peng
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleMemoDelete(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );
/*****************************************************************************/
// 	Description : This function handle the group modify command
//	Global resource dependence : none
//  Author:      liqing.peng
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleMemoModify(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                );

/*****************************************************************************/
// 	Description : 
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL uint16 CompressCmdStr(
							  uint8 *cmd_in,	//cmd str, in
							  uint16 len,		//cmd str len
							  uint8	*cmd_out	//out
							  );

/*****************************************************************************/
// 	Description : 
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL uint16 DecompressCmdStr(
							  uint8 *cmd_in,	//cmd str, in
							  uint16 len,		//cmd str len
							  uint8	*cmd_out,	//out
                              uint16 out_buf_max_len//IN:
							  );




/*---------------------------------------------------------------------------*/
/*****************************************************************************/
/*                                    Begin of Atest  Function Declare                                                     */
/* Description:  Hanlde at cmd for auto test cases                                                                    */
/* Author: Shuyan.hu                                                                                                          */
/* Date: 30/12/2010                                                                                                           */ 
/*****************************************************************************/
/*---------------------------------------------------------------------------*/

/*****************************************************************************/
// 	Description : This function handle Atest at cmd
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleAtMMI(
	                                                        uint8 * cmd,            //point to the at information buffer
                                                               uint32 len                  //length of information
	                                                             );

/*****************************************************************************/
// 	Description : This function  handle st at cmd
//	Global resource dependence : none
//  Author:       shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleStAtMMI(
 								uint8 *cmd,                   //point to the at information buffer
 								uint32 len                       //length of information
                                                               );

/*****************************************************************************/
// 	Description : This function handle ft connect gatewayinput at cmd 
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleConnectGatewayDNS(
                                                             uint8 * cmd,                 //point to the connection IP information buffer    
                                                             uint32 len                    //length of information
                                                           );


/*****************************************************************************/
// 	Description : This function  handle ft at cmd
//	Global resource dependence : none
//  Author:       shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleFtAtMMI(
 								uint8 *cmd,            //point to the at information buffer
 								uint32 len              //length of information  
                                                               );
/*****************************************************************************/
// 	Description : This function handle st sms at cmd 
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleSMS(
                                                             uint8 * cmd,                    //point to the sms information buffer
                                                             uint32 len                        //length of information
                                                           );
/*****************************************************************************/
// 	Description : This function handle URL sms at cmd 
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleURL(
                                                            uint8 * cmd,                        //point to the URL information buffer
                                                             uint32 len                             //length of information
                                                           );

/*****************************************************************************/
// 	Description : This function  handle ft connetion input at cmd
//	Global resource dependence : none
//  Author:       shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleConnection(
 								uint8 *cmd,                 //point to the connection  information buffer
 								uint32 len                    //length of information
                                                            );

/*****************************************************************************/
// 	Description : This function handle ft connect paraments at cmd 
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleConnectOther(
                                                             uint8 * cmd,               //point to the connection IP information buffer
                                                             uint32 len                   //length of information
                                                           );

/*****************************************************************************/
// 	Description : This function handle ft bookmark at cmd 
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleBookmark(
                                                             uint8 * cmd,                //point to the bookmark  information buffer
                                                             uint32 len                     //length of information
                                                           );
/*****************************************************************************/
// 	Description : This function handle ft bookmark title input at cmd 
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleBmTitle(
                                                             uint8 * cmd,              //point to the bookmark title information buffer
                                                             uint32 len                  //length of information
                                                           );
/*****************************************************************************/
// 	Description : This function handle ft bookmark URL input at cmd 
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleBmURL(
                                                             uint8 * cmd,            //point to the bookmark url information buffer
                                                             uint32 len                //length of information
                                                           );


/*****************************************************************************/
// 	Description : This function handle URL sms at cmd 
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleFolder(
                                                            uint8 * cmd,                        //point to the folder information buffer
                                                             uint32 len                             //length of information
                                                           );
/*****************************************************************************/
// 	Description : This function handle URL sms at cmd 
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleFolderHori(
                                                            uint8 * cmd,                        //point to the folder information buffer
                                                             uint32 len                             //length of information
                                                           );
/*****************************************************************************/
// 	Description : This function handle URL sms at cmd 
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleFolderVerti(
                                                            uint8 * cmd,                        //point to the folder information buffer
                                                             uint32 len                             //length of information
                                                           );

/*****************************************************************************/
// 	Description : This function is a call back of pb create
//	Global resource dependence : s_pb_name, s_pb_number
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL void Atest_pbcreate_callback(MMIPB_HANDLE_T handle,           //ponit to pb
	                                                        MMIPB_ERROR_E error               // value for result
	                                                        );

/*****************************************************************************/
// 	Description : This function get sim status  
//	Global resource dependence :  
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_CheckSim(uint16 sim_id );

/*****************************************************************************/
// 	Description : This function handle ateat pb create in internal storage  
//	Global resource dependence : s_pb_name, s_pb_number, s_handle_pb
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandlePbPhone(uint16 create_id);

/*****************************************************************************/
// 	Description : This function get pb name and phone number
//	Global resource dependence : s_pb_name, s_pb_number
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetPbPara(
	                                                        uint8 * cmd,                             //input at cmd
                                                               uint32 len                                 //input at length
	                                                             );

/*****************************************************************************/
// 	Description : This function  handle pb create in internal storage 
//	Global resource dependence : none
//  Author:       shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandlePbNv(
 								uint8 *cmd,                   //point to the at information buffer
 								uint32 len                       //length of information
                                                               );

/*****************************************************************************/
// 	Description : This function  handle atest pb create from at+sytin  at cmd
//	Global resource dependence : none
//  Author:       shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandlePhoneBook(
 								uint8 *cmd,                   //point to the at information buffer
 								uint32 len                       //length of information
                                                               );


/*****************************************************************************/
// 	Description : This function  handle pb create in sim card
//	Global resource dependence : none
//  Author:       shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandlePbSim(
 								uint8 *cmd,                   //point to the at information buffer
 								uint32 len                       //length of information
                                                               );


// 控件输入自动测试
#ifdef ATEST_SUPPORT
#ifdef MMI_ISTYLE_SUPPORT
extern BOOLEAN IStyleGetItemData(
    MMIMAINMENU_ISTYLE_DATA_T *menu_ctrl_ptr,
    uint32 menu_id,
    uint32 group_id,
    CTRLMAINMENU_ITEM_T *item_ptr
);
#endif

extern PUBLIC void Atest_GetPopmenuItemTextRect(
                                         uint16         item_index,
                                         CTRLMENU_OBJ_T *menu_ctrl_ptr,
                                         GUI_RECT_T     *item_rect
                                         );


/*****************************************************************************/
//  Description: 将字符串从手机端传回PC端
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL int32 Atest_TransmitATString( // 返回校验码: 传输的数据部分的累加，参数is_need_check=TRUE有效
    uint8 *data_ptr,                // 传输的数据部分
    uint16 data_len,                // 传输数据长度
    BOOLEAN is_unicode,             // 判定是否需要将Unicode码转换为AT字符串
    BOOLEAN is_need_checksum);      // 判定是否需要计算校验和

/*****************************************************************************/
//  Description: 获取控件属性
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetControlProperty(
    IGUICTRL_T *ctrl_ptr,   // 控件指针
    BOOLEAN is_mark_end,    // 控件遍历结束标记
    uint8 *data_ptr,        // 需要传输的控件属性数据
    uint32 *data_size_ptr); // 传输数据大小

/*****************************************************************************/
//  Description: 解析PC端发过来的消息内容: 窗体ID，长度，位置等
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL uint32 Atest_GetTestMessageId( // 返回消息内容: 窗体ID，长度，位置
    char separator,                  // ID分隔符
    uint8 **message_pptr);           // 返回指向下一个要解析的位置

/*****************************************************************************/
//  Description: 解析PC端指令，填充控件数据，返回填充结果
//               AT+SFTIN="IFCD,393435,31002D4E" -> 10,20
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_FillControlData( // 填充失败，返回FALSE
    uint8 *user_data_ptr);           // 用户填充指令和数据

/*****************************************************************************/
//  Description:一次性删除edit输入的数据
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_ClearAllStr(  uint8 *user_data_ptr);

/*****************************************************************************/
//  Description: 遍历控件树，提取控件属性描述，传回PC端
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL void Atest_TravelControlTree(
    MMI_TREE_NODE_T *root_ptr,  // 控件树根节点
    uint8 *data_ptr,            // 传回PC端的数据
    uint32 *data_size_ptr);     // 累计传输的数据大小

/*****************************************************************************/
//  Description: 获取指定控件的数据，返回满足客户端要求的内容、长度和校验信息
//               AT+SFTIN="IGCD,393435,0,20" -> 00314E2D,4,16
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetControlData( // 提取控件数据失败，返回FALSE
    uint8 *user_data_ptr);          // 客户端发出的提取指令

/*****************************************************************************/
//  Description: 遍历窗体
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL void Atest_TravelWindowTree(
    MMI_TREE_NODE_T *root_ptr, // 窗体树根节点
    MMI_TREE_NODE_T *next_ptr,
    uint8 *data_ptr,           // 传回PC端的数据
    uint32 *data_size_ptr);     // 累计传输的数据大小

/*****************************************************************************/
//  Description: 递归焦点窗体控件树，获取控件属性，传回PC端，加上总长度校验
//               AT+SFTIN="IGCT" -> <EDITBOX id='393435' type='TEXT' maxLen='612' maxNum='0'></EDITBOX>,67
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetControlTree( // 取到控件内容，返回TRUE
    uint8 *user_data_ptr);          // 客户端的提取控件属性指令


/*****************************************************************************/
//  Description: 解析客户端AT指令，调用不同处理逻辑
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleControlInput( // 用户命令处理无错，返回TRUE
    uint8 *user_data_ptr,               // 用户发过来的AT命令
    uint32 len);						// 用户发过来的AT命令的长度

/*****************************************************************************/
//  Description: 获取控件RichText描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetRichTextControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取控件Anim描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetAnimControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取PrgBox控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetPrgBoxControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取Text控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetTextControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取Lable控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetLableControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取MsgBox控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetMsgBoxControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取Punctuation控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetPunctuationControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取Button控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetButtonControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取Iconlist控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetIconlistControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取TAB控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetTabControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取Edit控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetStatusBarControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取im控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetIMControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取SetList控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetSetListControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取Form控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetFormControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取Owndraw控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetOwndrawControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取Toolbar控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetToolbarControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取Edit控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetEditControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text
/*****************************************************************************/
//  Description: 获取Edit控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetTextEditControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text
/*****************************************************************************/
//  Description: 获取DropList控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetDropListControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取softkey控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetsoftkeyControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取Tips控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetTipsControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取Title控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetTitleControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取List控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetListControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取MainMenu控件描述
//  Global resource dependence :none
//  Author: 
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetMainMenuControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text 		
 										 
#ifdef MENU_SWEETS_SUPPORT
/*****************************************************************************/
//  Description: 获取SweetMainMenu控件描述
//  Global resource dependence :none
//  Author: 
/*****************************************************************************/
LOCAL void Atest_GetSweetMainMenuControlProperty( 
										 CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,//MENU指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr);			//传输的数据text
#endif

#ifdef PDA_UI_SUPPORT_MANIMENU_GO										 
/*****************************************************************************/
//  Description: 获取SlideMainMenu控件描述
//  Global resource dependence :none
//  Author: 
/*****************************************************************************/
LOCAL void Atest_GetSlideMainMenuControlProperty( 
										 CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,//MENU指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr);			//传输的数据text
#endif

#ifdef QBTHEME_SUPPORT 							
/*****************************************************************************/
//  Description: 获取QbMainMenu控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_SECOND\GUIMENU_STYLE_THIRD\GUIMENU_STYLE_POPUP  
// 	      GUIMENU_STYLE_POPUP_AUTO\GUIMENU_STYLE_POPUP_RECT
//		  GUIMENU_STYLE_POPUP_RADIO\GUIMENU_STYLE_POPUP_CHECK
/*****************************************************************************/
LOCAL void Atest_GetQbMainMenuControlProperty( 
										 CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,//MENU指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr);			//传输的数据text
#endif 										 

#ifdef MMI_ISTYLE_SUPPORT
/*****************************************************************************/
//  Description: 获取IStyleMainMenu控件描述
//  Global resource dependence :none
//  Author: 
/*****************************************************************************/
LOCAL void Atest_GetIStyleMainMenuControlProperty( 
										 CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,//MENU指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr);			//传输的数据text
#endif

#ifdef MATRIX_MAIN_MENU_SUPPORT
/*****************************************************************************/
//  Description: 获取MaxtricMainMenu控件描述
//  Global resource dependence :none
//  Author:
/*****************************************************************************/
LOCAL void Atest_GetMatrixMainMenuControlProperty( 
										 CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,//MENU指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr);			//传输的数据text
#endif 										 
/*****************************************************************************/
//  Description: 获取Menu控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetMenuControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description: 获取PopMenu控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_SECOND\GUIMENU_STYLE_THIRD、GUIMENU_STYLE_POPUP  
// 	      GUIMENU_STYLE_POPUP_AUTO\GUIMENU_STYLE_POPUP_RECT
//		  GUIMENU_STYLE_POPUP_RADIO\GUIMENU_STYLE_POPUP_CHECK
/*****************************************************************************/
LOCAL void Atest_GetPopMenuControlProperty( 
										 CTRLMENU_OBJ_T  *menu_ctrl_ptr,//menu指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr);			//传输的数据text

/*****************************************************************************/
//  Description: 获取IconMenu控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_ICO\GUIMENU_STYLE_CYCLONE
/*****************************************************************************/
LOCAL void Atest_GetIconMenuControlProperty( 
										 CTRLMENU_OBJ_T  *menu_ctrl_ptr,//menu指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr);			//传输的数据text


/*****************************************************************************/
//  Description: 获取OptionMenu控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_OPTIONS
/*****************************************************************************/
LOCAL void Atest_GetOptionMenuControlProperty( 
										 CTRLMENU_OBJ_T  *menu_ctrl_ptr,//menu指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr);			//传输的数据text
 										 
#ifdef PDA_UI_SUPPORT_MANIMENU_GO										  										 
/*****************************************************************************/
//  Description: 获取SlideMenu控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_SLIDE_PAGE\GUIMENU_STYLE_TRAPEZOID
//		 GUIMENU_STYLE_SPHERE\GUIMENU_STYLE_CYLINDER
//		 GUIMENU_STYLE_BINARY_STAR\GUIMENU_STYLE_SHUTTER
//	     GUIMENU_STYLE_CHARIOT\GUIMENU_STYLE_CUBE
//		 GUIMENU_ISTYLEGUIMENU_STYLE_QBTHEME
/*****************************************************************************/
LOCAL void Atest_GetSlideMenuControlProperty( 
										 CTRLMENU_OBJ_T  *menu_ctrl_ptr,//menu指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr);			//传输的数据text
#endif

/*****************************************************************************/
//  Description: 获取CrystalMenu控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_CRYSTAL_CUBE
/*****************************************************************************/
LOCAL void Atest_GetCrystalMenuControlProperty( 
										 CTRLMENU_OBJ_T  *menu_ctrl_ptr,//menu指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr);			//传输的数据text								 
 										 
/*****************************************************************************/
//  Description: 获取Scrollkey控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetScrollkeyControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text
 										 
/*****************************************************************************/
//  Description: 获取Iconfolder控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetIconfolderControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr);		//传输的数据text

/*****************************************************************************/
//  Description:点击对应的控件
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_ClickControl(uint8 *user_data_ptr);

/*****************************************************************************/
//  Description:解析命令,获取内容
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetMessageContent( 
									uint8 *message_content,		// 解析的内容
								    char separator,             // ID分隔符
								    uint8 **message_pptr);      // 返回指向下一个要解析的位置

/*****************************************************************************/
//  Description:查找对应的控件，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_SearchControlPosition(
										ATEST_ID_TYPE_E id_type,	//查找类型
										uint8 *find_data_ptr,		//所需查找的数据
										uint16 *rect_x,				//返回的坐标
										uint16 *rect_y);			//返回的坐标

/*****************************************************************************/
//  Description: 查找窗体
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_SearchWindowTree(
									MMI_TREE_NODE_T *root_ptr,	//窗体的根节点指针
									MMI_TREE_NODE_T *next_ptr,	//窗体根节点的兄弟指针
									ATEST_ID_TYPE_E id_type,	//查找类型
									uint8 *find_data_ptr,		//所需查找的数据
									uint16 *rect_x,				//返回的坐标
									uint16 *rect_y);			//返回的坐标
	
/*****************************************************************************/
//  Description:遍历该窗口的控件，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/  
LOCAL BOOLEAN Atest_SearchControlTree(
								    MMI_TREE_NODE_T *root_ptr,	//控件树根节点
								    ATEST_ID_TYPE_E id_type,	//查找类型
								    uint8 *user_data_ptr,		//所需查找的数据
								    uint16 *rect_x,				//返回的坐标
									uint16 *rect_y);			//返回的坐标

/*****************************************************************************/
//  Description:查找各控件，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchControlProperty(
	IGUICTRL_T *ctrl_ptr,
    ATEST_ID_TYPE_E id_type,
    uint8 *user_data_ptr,
    uint16 *rect_x,
	uint16 *rect_y);

/*****************************************************************************/
//  Description:根据坐标，发送触屏事件
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL void Atest_SendTouchMessage(
									MMI_TP_STATUS_E tp_type,	//TP类型
									uint16 rect_x,				//TP 坐标x
									uint16 rect_y);				//TP 坐标y


/*****************************************************************************/
//  Description:根据rotate lcd对按键事件进行转换
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL void Atest_KbdConvert(uint32 *signal_keycode); //按键事件类型


/*****************************************************************************/
//  Description:处理atc按键消息
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL void Atest_ResolveKbdSignal(
								uint32 signal_keycode,
								uint8 *use_data_ptr,
								uint32 reserved_data);

/*****************************************************************************/
//  Description:根据坐标，发送按键事件
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL void Atest_SendKbdMessage(
								uint32 signal_keycode);	 //按键事件类型


/*****************************************************************************/
//  Description: 将消息发送到APP task处理
//  Global resource dependence :none
//  Author: linchen
//  Note:缓解P_ATC压力，开一块内存，扔给P_APP处理
/*****************************************************************************/
LOCAL void Atest_SendSignalToAppTask( 
								uint8 *user_data_ptr,	 // 用户发过来的AT命令
								uint32 len,				 // 用户发过来的AT命令的长度
								uint32 reserved_data,	 // 发送时附加的数据
								uint16 signalType);		 // 发送到APP的消息类型

/*****************************************************************************/
//  Description: 根据当前lcd旋转的情况，对坐标进行转换
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_ConvertPositionByLcd(	uint16 *rect_x,		//需要转换的坐标x
											uint16 *rect_y);	//需要转换的坐标y

/*****************************************************************************/
//  Description: 获得当前的分辨率
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetCurResolution(void);


/*****************************************************************************/
//  Description: 获取当前语言
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetCurLang(void);

/*****************************************************************************/
//  Description: 获取当前list或icon list的总个数
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetListNum(uint8 *user_data_ptr);

/*****************************************************************************/
//  Description: 获取当前主题
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetCurStyle(uint8 *user_data_ptr);

/*****************************************************************************/
//  Description: 触笔对应的坐标
//  Global resource dependence :
//  Author:linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_TouchPanelPoint( uint8 *user_data_ptr);

/*****************************************************************************/
//  Description: 触笔down
//  Global resource dependence :
//  Author:linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_TouchPanelDown( uint8 *user_data_ptr);


/*****************************************************************************/
//  Description: 按键down
//  Global resource dependence :
//  Author:linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_KBDown( uint8 *user_data_ptr);

/*****************************************************************************/
//  Description: 触笔move
//  Global resource dependence :
//  Author:linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_TouchPanelMove( uint8 *user_data_ptr);

/*****************************************************************************/
//  Description: 触笔up
//  Global resource dependence :
//  Author:linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_TouchPanelUp( uint8 *user_data_ptr);

/*****************************************************************************/
//  Description:比较AT发送过来的数据和从控件取到的数据
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_Compare_content(ATEST_ID_TYPE_E id_type,	//查找类型
									MMI_HANDLE_T ctrl_handle,	//控件handle
									MMI_STRING_T ctrl_str,	    //遍历控件的字符串数据
									uint8 *at_data,			    //AT收到的字符串数据
									uint32 id_data);			//遍历控件的id数据

/*****************************************************************************/
//  Description:计算宽字符的长度
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL uint16 Atest_wcslen(	wchar *s,			//宽字符串
							uint16 limit_len);	//限制长度

/*****************************************************************************/
//  Description:根据item所在的控件的位置，返回对应的触笔坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:主要针对list，pop menu
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_GetValidTPPoint(	GUI_RECT_T item_rect,	//item的区域
										GUI_RECT_T ctrl_rect,	//item所在的控件的区域
										uint16 *rect_x,			//out:坐标x
										uint16 *rect_y);		//out:坐标y
										
/*****************************************************************************/
//  Description:查找控件LABLE，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchLableControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件EditBbox，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchEditBoxControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件SoftKey，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchSoftKeyControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件Menu，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchMenuControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y
/*****************************************************************************/
//  Description:查找控件Menu，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchMainMenuControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y
#ifdef QBTHEME_SUPPORT
/*****************************************************************************/
//  Description:查找控件QbMenu的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:GUIMENU_STYLE_QBTHEME
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchQbMainMenuControlItem(
										CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										MMI_CTRL_ID_T ctrl_id,		//控件id
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y);				//out,查找到的控件坐标y
#endif
/*****************************************************************************/
//  Description:查找控件CycloneMenu的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:GUIMENU_STYLE_CYCLONE
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchCycloneMenuControlItem(
										CTRLMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										IGUICTRL_T *ctrl_ptr,			//控件指针
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y);				//out,查找到的控件坐标y

/*****************************************************************************/
//  Description:查找控件CrystalMenu的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:GUIMENU_STYLE_CRYSTAL_CUBE
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchCrystalMenuControlItem(
										CTRLMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										IGUICTRL_T *ctrl_ptr,			//控件指针
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y);				//out,查找到的控件坐标y
										
#ifdef PDA_UI_SUPPORT_MANIMENU_GO										 
/*****************************************************************************/
//  Description: 获取SlideMenu每页的item数
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_SLIDE_PAGE 
/*****************************************************************************/
LOCAL uint16 Atest_GetSlideMenuPageItemNum( MMIMAINMENU_SLIDEPAGE_DATA_T  *menu_ctrl_ptr);


/*****************************************************************************/
//  Description:查找控件SlideMenu的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:针对slide menu
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchSlideMainMenuControlItem(
										CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										MMI_CTRL_ID_T ctrl_id,		//控件id
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y);				//out,查找到的控件坐标y
#endif

#ifdef MMI_ISTYLE_SUPPORT
/*****************************************************************************/
//  Description:查找控件SlideMenu的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:针对slide menu
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchIStyleMainMenuControlItem(
										CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										MMI_CTRL_ID_T ctrl_id,		//控件id
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y);				//out,查找到的控件坐标y
#endif

#ifdef MATRIX_MAIN_MENU_SUPPORT
/*****************************************************************************/
//  Description:查找控件SlideMenu的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:针对slide menu
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchMatrixMainMenuControlItem(
										CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										MMI_CTRL_ID_T ctrl_id,		//控件id,			//控件指针
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y);				//out,查找到的控件坐标y
#endif										

#ifdef MENU_SWEETS_SUPPORT
/*****************************************************************************/
//  Description:查找控件SlideMenu的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:针对slide menu
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchSweetMainMenuControlItem(
										CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										MMI_CTRL_ID_T ctrl_id,		//控件id
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y);				//out,查找到的控件坐标y
#endif

/*****************************************************************************/
//  Description:查找控件PopMenu的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:针对second，third，pop menu
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchPopMenuControlItem(
										CTRLMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										IGUICTRL_T *ctrl_ptr,			//控件指针
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16  item_height,			//item高度
										uint16  item_space,				//item之间的距离
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y);				//out,查找到的控件坐标y




/*****************************************************************************/
//  Description:查找控件OptionMenu的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_OPTIONS
/*****************************************************************************/
LOCAL BOOLEAN Atest_SearchOptionMenuControlItem( 
										CTRLMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										IGUICTRL_T *ctrl_ptr,			//控件指针
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y);				//out,查找到的控件坐标y

/*****************************************************************************/
//  Description:查找控件list 的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note: byIndex
/*****************************************************************************/
LOCAL BOOLEAN Atest_SearchListByIndex(
									    CTRLLIST_OBJ_T *list_ctrl_ptr,	//list控件指针
									    MMI_HANDLE_T ctrl_handle,		//控件handle
									    uint16 page_item_num,			//每页的item数
									    uint8 *user_data_ptr,			//查找数据
									    uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y);				//out,查找到的控件坐标y

/*****************************************************************************/
//  Description:查找控件list 的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note: byimgIndex
/*****************************************************************************/
LOCAL BOOLEAN Atest_SearchListByImgIndex(
										    CTRLLIST_OBJ_T *list_ctrl_ptr,	//list控件指针
										    MMI_HANDLE_T ctrl_handle,		//控件handle
										    MMI_CTRL_ID_T ctrl_id,			//控件id
										    uint16 page_item_num,			//每页的item数
										    uint8 *user_data_ptr,			//查找数据
										    uint16 *rect_x,					//out,查找到的控件坐标x
											uint16 *rect_y);				//out,查找到的控件坐标y


/*****************************************************************************/
//  Description:查找控件list 的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note: bytextimg
/*****************************************************************************/
LOCAL BOOLEAN Atest_SearchListByTextImg(
										    CTRLLIST_OBJ_T *list_ctrl_ptr,	//list控件指针
										    MMI_HANDLE_T ctrl_handle,		//控件handle
										    MMI_CTRL_ID_T ctrl_id,			//控件id
										    uint16 page_item_num,			//每页的item数
										    uint8 *user_data_ptr,			//查找数据
										    uint16 *rect_x,					//out,查找到的控件坐标x
											uint16 *rect_y);				//out,查找到的控件坐标y

/*****************************************************************************/
//  Description:查找控件list 的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note: bytext imgid
/*****************************************************************************/
LOCAL BOOLEAN Atest_SearchListByTextAndImgID(
										    CTRLLIST_OBJ_T *list_ctrl_ptr,	//list控件指针
										    MMI_HANDLE_T ctrl_handle,		//控件handle
										    MMI_CTRL_ID_T ctrl_id,			//控件id
										    ATEST_ID_TYPE_E id_type,		//查找类型
										    uint16 page_item_num,			//每页的item数
										    uint8 *user_data_ptr,			//查找数据
										    uint16 *rect_x,					//out,查找到的控件坐标x
											uint16 *rect_y);				//out,查找到的控件坐标y
											
/*****************************************************************************/
//  Description:查找控件list，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchListControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件Setlist，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持控件id查找
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchSetlistControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件Button，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持控件id查找
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchButtonControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y
	
/*****************************************************************************/
//  Description:查找控件tab，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持id查找
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchTabControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件RichText，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持all
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchRichTextControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件Anim，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持控件ID
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchAnimControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件Msgbox，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持控件ID
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchMsgboxControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件Dropdownlist，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持控件ID
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchDropdownlistControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y


/*****************************************************************************/
//  Description:查找控件Iconlist，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持控件ID
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchIconlistControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件Title，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持文本ID，image id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchTitleControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件Textbox，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持控件ID
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchTextboxControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件IM，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持按键code
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchIMControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件ToolBar，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持文本ID，image id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchToolBarControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件Tips，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持文本,控件id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchTipsControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件Statusbar，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持文本,image id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchStatusbarControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件Owndraw，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持control id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchOwndrawControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件Prgbox，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持control id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchPrgboxControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件Form，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持control id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchFormControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y

/*****************************************************************************/
//  Description:查找控件Iconfolder，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持control id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchIconfolderControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y);			//out:坐标y


 /*****************************************************************************/
//  Description: 设置闹钟时间
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_SetAlarmTime(uint8 *user_data_ptr);

/*****************************************************************************/
//  Description: 获取下个闹钟的时间
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetLatestAlarmTime(uint8 *user_data_ptr);

/*****************************************************************************/
//  Description: 获取当前手机的时间
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetCurSysTime(uint8 *user_data_ptr);

/*****************************************************************************/
//  Description: 获得前日历的焦点日期
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetCalendarCurDate(uint8 *user_data_ptr);

/*****************************************************************************/
//  Description: 进入日历上的某个日期
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_ClickCalendarDate(uint8 *user_data_ptr);

#endif // ATEST_SUPPORT

/*---------------------------------------------------------------------------*/
/*****************************************************************************/
/*                                    End of Atest  Function Declare                                                       */
/* Description:  Hanlde at cmd for auto test cases                                                                    */
/* Author: Shuyan.hu                                                                                                          */
/* Date: 30/12/2010                                                                                                           */ 
/*****************************************************************************/
/*---------------------------------------------------------------------------*/




/*-------------------------------------------------------------------------*/
/*                         FUNCTIONS                                       */
/*-------------------------------------------------------------------------*/
/*****************************************************************************/
// 	Description : This function call parse function to get result of command response
//	Global resource dependence : none
//  Author:       Jassmine.Meng
//	Note:
/*****************************************************************************/
#if defined (MODEM_SUPPORT_SPRD)
uint32 ATC_ExtCmd(DPARAM param)
{
	AT_AUTO_TEST_CMD_IND_T *atc_cmd_str = (AT_AUTO_TEST_CMD_IND_T*)param;
	uint8 *cmd = PNULL;  // Point to the command infomation buffer
	uint32 len ;  // The length of command infomation buffer	
	uint16 ind_len = 0;
	MN_DUAL_SYS_E sim_type =  MN_DUAL_SYS_1; 
	uint8      atc_str[MMI_SIM_VERSION_LEN] = {0};
    uint8      sim_valid_flag = 0x00;
	
	if(atc_cmd_str == PNULL || atc_cmd_str->data == PNULL || atc_cmd_str->len == 0)
	{
		SCI_TRACE_LOW("[mmi_atc.c] ATC_ExtCmd atc_cmd_str %d !", atc_cmd_str);
		//parameter error
		ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
		return 0;
	}
    cmd = atc_cmd_str->data;
	len = atc_cmd_str->len;

    SCI_TRACE_LOW("mmi_atc.c: ATC_ExtCmd(), received AT command %s, len = %d",cmd, len);
    //SCI_TRACE_LOW:"mmi_atc.c: ATC_ExtCmd(), received AT command , len = %d"
    //SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_1904_112_2_18_1_59_28_11,(uint8*)"d", len);

    if(IsMatchIndication(cmd, len, (char *)MMI_SYNC_INDICATE))
    {
        ind_len = strlen((char *)MMI_SYNC_INDICATE);
        cmd += ind_len;
        len -= ind_len;

        if(IsMatchIndication(cmd, len, (char*)MMI_SYNC_START))
        {
            if (MMIAPIUdisk_VUARTIsRun())
            {
				for(sim_type = MN_DUAL_SYS_1; sim_type < MMI_DUAL_SYS_MAX; sim_type++)
				{
					if(MMIAPIPHONE_GetSimExistedStatus(sim_type))
					{
                        sim_valid_flag += 0x01 << sim_type;
					}
				}
				if(sim_valid_flag > 0)
				{
					//exist valid sim 
#ifndef _WIN32
					s_atc_is_run = TRUE;
#endif
					MMIAPIUDISK_HandleATCExtCmd();
					sprintf((char *)atc_str, "%s%02d%s",MMI_SYNC_VERSION, sim_valid_flag, MMI_TO_SYNC_OK_SYMBOL);
					ReturnResponse((uint8 *)atc_str, (uint16)strlen((char*)atc_str));




				}
                else
                {
#ifndef _WIN32
                    s_atc_is_run = FALSE;
#endif
                    ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
                }
            }
            else
            {
#ifndef _WIN32
                s_atc_is_run = FALSE;
#endif
                ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
            }
        }
        else
        {
            if(!ParseSyncAtCmd(cmd, len))
            {
                ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
            }
        }
    }
	else if(IsMatchIndication(cmd, len, (char *)MMI_SYNC_UT_INDICATE_UP) || IsMatchIndication(cmd, len, (char *)MMI_SYNC_UT_INDICATE_LOW))
	{
		//auto test
        ind_len = strlen((char *)MMI_SYNC_UT_INDICATE_UP);
        cmd += ind_len;
        len -= ind_len;
		//Auto Test ATC
		if(!ParseSyncUTAtCmd(cmd, len))
		{
			ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
		}
		else
		{
			//ok
			 ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_OK_SYMBOL));
		}
	}
	else if(IsMatchIndication(cmd, len, (char *)MMI_AT_TEST) )
	{  
	       //atest for at+sytin and at+ftin
        	ind_len = strlen((char *)MMI_AT_TEST);
        	cmd += ind_len;
        	len -= ind_len;
		if(Atest_HandleAtMMI(cmd, len))
		{
			ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_OK_SYMBOL));
		}
		else
		{
			 ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
		}
	}
	/*+cr251711,for TD UEIT auto test*/
	else if(IsMatchIndication(cmd, len, (char *)UEIT_TEST_INDICATE) )
	{  
#ifdef ENG_SUPPORT
		BOOLEAN is_on = FALSE;
		MMINV_WRITE(MMIENG_NV_CALLFORWARD_QUERY_ID, &is_on);//close call forward query
				
		is_on = TRUE;
		MMINV_WRITE(MMINV_ENG_USBLOG,&is_on);//open usb log
#endif

#ifdef DCD_SUPPORT
		MMIAPIDCD_SetDCDEnable(FALSE);		//close DCD
#endif
		
#ifdef MMI_GPRS_SUPPORT
		MMIAPICONNECTION_SetGPRSStatus(MMICONNECTION_GPRS_ALWAYS); //set GPRS alwarys connection
#endif

#ifdef DM_SUPPORT
    MMIDM_SetDmRegSwitchState(FALSE);  //Automatic Software update switch (close)
#endif

#ifdef DSP_USB_LOG
    REFPARAM_SetDspDebugPortPhyNo(2);   //dsp log: usb
#endif

    ReturnResponse((uint8 *)UEIT_TEST_OK_SYMBOL, (uint16)strlen((char*)UEIT_TEST_OK_SYMBOL));
	}
	/*-cr251711*/	
	//bruce, add , for compile
    //释放数据
    SCI_FREE(atc_cmd_str->data);
    
	return 0;
}
#elif defined(PLATFORM_UWS6121E)
uint32 ATC_ExtCmd(DPARAM param)
    {
#ifdef MMI_COMPILE_E
        AT_AUTO_TEST_CMD_IND_T *atc_cmd_str = (AT_AUTO_TEST_CMD_IND_T*)param;
        uint8 *cmd = PNULL;  // Point to the command infomation buffer
        uint32 len ;  // The length of command infomation buffer
        uint16 ind_len = 0;
        MN_DUAL_SYS_E sim_type =  MN_DUAL_SYS_1;
        uint8      atc_str[MMI_SIM_VERSION_LEN] = {0};
        uint8      sim_valid_flag = 0x00;

        if(atc_cmd_str == PNULL || atc_cmd_str->data == PNULL || atc_cmd_str->len == 0)
        {
            SCI_TRACE_LOW("[mmi_atc.c] ATC_ExtCmd atc_cmd_str %d !", atc_cmd_str);
            //parameter error
            ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
            return 0;
        }
        cmd = atc_cmd_str->data;
        len = atc_cmd_str->len;

        SCI_TRACE_LOW("mmi_atc.c: ATC_ExtCmd(), received AT command %s, len = %d",cmd, len);
        //SCI_TRACE_LOW:"mmi_atc.c: ATC_ExtCmd(), received AT command , len = %d"
        //SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_1904_112_2_18_1_59_28_11,(uint8*)"d", len);

        if(IsMatchIndication(cmd, len, (char *)MMI_SYNC_INDICATE))
        {
            ind_len = strlen((char *)MMI_SYNC_INDICATE);
            cmd += ind_len;
            len -= ind_len;

            if(IsMatchIndication(cmd, len, (char*)MMI_SYNC_START))
            {
                if (MMIAPIUdisk_VUARTIsRun())
                {
                    for(sim_type = MN_DUAL_SYS_1; sim_type < MMI_DUAL_SYS_MAX; sim_type++)
                    {
                        if(MMIAPIPHONE_GetSimExistedStatus(sim_type))
                        {
                            sim_valid_flag += 0x01 << sim_type;
                        }
                    }
                    if(sim_valid_flag > 0)
                    {
                        //exist valid sim
#ifndef _WIN32
                        s_atc_is_run = TRUE;
#endif
                        MMIAPIUDISK_HandleATCExtCmd();
                        sprintf((char *)atc_str, "%s%02d%s",MMI_SYNC_VERSION, sim_valid_flag, MMI_TO_SYNC_OK_SYMBOL);
                        ReturnResponse((uint8 *)atc_str, (uint16)strlen((char*)atc_str));
                    }
                    else
                    {
#ifndef _WIN32
                        s_atc_is_run = FALSE;
#endif
                        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
                    }
                }
                else
                {
#ifndef _WIN32
                    s_atc_is_run = FALSE;
#endif
                    ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
                }
            }
            else
            {
                if(!ParseSyncAtCmd(cmd, len))
                {
                    ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
                }
            }
        }
        else if(IsMatchIndication(cmd, len, (char *)MMI_SYNC_UT_INDICATE_UP) || IsMatchIndication(cmd, len, (char *)MMI_SYNC_UT_INDICATE_LOW))
        {
            //auto test
            ind_len = strlen((char *)MMI_SYNC_UT_INDICATE_UP);
            cmd += ind_len;
            len -= ind_len;
            //Auto Test ATC
            if(!ParseSyncUTAtCmd(cmd, len))
            {
                ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
            }
            else
            {
                //ok
                 ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_OK_SYMBOL));
            }
        }
        else if(IsMatchIndication(cmd, len, (char *)MMI_AT_TEST) )
        {  
               //atest for at+sytin and at+ftin
                ind_len = strlen((char *)MMI_AT_TEST);
                cmd += ind_len;
                len -= ind_len;
            if(Atest_HandleAtMMI(cmd, len))
            {
                ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_OK_SYMBOL));
            }
            else
            {
                 ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
            }
        }
        /*+cr251711,for TD UEIT auto test*/
        else if(IsMatchIndication(cmd, len, (char *)UEIT_TEST_INDICATE) )
        {
#ifdef ENG_SUPPORT
            BOOLEAN is_on = FALSE;
            MMINV_WRITE(MMIENG_NV_CALLFORWARD_QUERY_ID, &is_on);//close call forward query
       
            is_on = TRUE;
            MMINV_WRITE(MMINV_ENG_USBLOG,&is_on);//open usb log
#endif

#ifdef DCD_SUPPORT
            MMIAPIDCD_SetDCDEnable(FALSE);      //close DCD
#endif
        
#ifdef MMI_GPRS_SUPPORT
            MMIAPICONNECTION_SetGPRSStatus(MMICONNECTION_GPRS_ALWAYS); //set GPRS alwarys connection
#endif

#ifdef DM_SUPPORT
        MMIDM_SetDmRegSwitchState(FALSE);  //Automatic Software update switch (close)
#endif

#ifdef DSP_USB_LOG
        REFPARAM_SetDspDebugPortPhyNo(2);   //dsp log: usb
#endif

        ReturnResponse((uint8 *)UEIT_TEST_OK_SYMBOL, (uint16)strlen((char*)UEIT_TEST_OK_SYMBOL));
        }
        /*-cr251711*/
        //bruce, add , for compile
        //释放数据
        SCI_FREE(atc_cmd_str->data);
#endif 
        return 0;
    }

#endif

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/*                                    Start of Atest  Function                                                                */
/* Description:  Hanlde at cmd for auto test cases                                                                    */
/* Author: Shuyan.hu                                                                                                          */
/* Date: 30/12/2010                                                                                                           */ 
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

/*****************************************************************************/
// 	Description : This function  handle atest pb create from at+sytin  at cmd
//	Global resource dependence : none
//  Author:       shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandlePhoneBook(
 								uint8 *cmd,                   //point to the at information buffer
 								uint32 len                       //length of information
                                                               )
{
	uint8 pb_type = 0;
     BOOLEAN res= FALSE;

     //check input at cmd  
     if(NULL == cmd)
     {
          return FALSE;
     }
     //get the handle connection configuration type
     pb_type = *(cmd++);
     len = len -1;

      
     switch(pb_type)
     {
          //handle internal memory pb create
          case 'n':
          case 'N':
	       res = Atest_HandlePbNv(cmd, len);
	       break;
          //handle sim pb create
          case 's':
          case 'S':
	       res = Atest_HandlePbSim(cmd, len);
	       break;
       default:
	       //SCI_TRACE_LOW:"[ATC:][ATEST:][Atest_HandlePhoneBook:] %c"
	       SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_2264_112_2_18_1_59_29_12,(uint8*)"c", (char)pb_type);
	       break;
     }
     return res;

}



/*****************************************************************************/
// 	Description : This function get sim status  
//	Global resource dependence :  
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_CheckSim(uint16 sim_id )
{  
    uint16 item;  

   if(sim_id > MMIPB_STORAGE_SIM4)//MMIPB_Create_ID
   {
        return FALSE;  //MN_DUAL_SYS_1
   }
   item =sim_id;
   for(; item<MMI_DUAL_SYS_MAX; item++)
   {
        if( SIM_STATUS_OK != MMIAPIPHONE_GetSimStatus((MN_DUAL_SYS_E) item))
        {
              continue;
        }
	  else
	  {
	       s_MMIPB_Create_ID = item;
		return TRUE;
	  }
	  	
   }
   return FALSE;      	 
    
}


/*****************************************************************************/
// 	Description : This function  handle creat pb in sim from at cmd
//	Global resource dependence : g_mmipb_entry_list
//  Author:       shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandlePbSim(
 								uint8 *cmd,                   //point to the at information buffer
 								uint32 len                       //length of information
                                                               )
{
   
           if(NULL != cmd)
	{
	      Atest_GetPbPara(cmd, len);
		s_pbcreatesim = TRUE;
		if(Atest_CheckSim(MN_DUAL_SYS_1))
		{
		      Atest_HandlePbPhone(s_MMIPB_Create_ID);
		  	return TRUE;
		}
        }
        return  FALSE;		   

}



/*****************************************************************************/
// 	Description : This function get pb name and phone number
//	Global resource dependence : s_pb_name, s_pb_number
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetPbPara(
	                                                        uint8 * cmd,                             //input at cmd
                                                               uint32 len                                 //input at length
	                                                             )
{
    char *tmp_ptr= NULL;
    uint16 name_len, number_len;	 


    if(NULL == cmd)
    {
        return FALSE;
    }
    tmp_ptr = strchr((char *)cmd, '#');
    if(NULL == tmp_ptr)
    {
        return FALSE;
    }

    name_len = tmp_ptr - (char *)cmd;
    number_len = len -name_len -1;
    //if the name length or number length more than max length
    if(name_len > MMI_SYNC_PB_NAME_MAX_LEN ||number_len > MMI_SYNC_PB_NUM_MAX_LEN)
    {
        return FALSE;
    }

    //get space for name and number  
    s_pb_name =  (uint8 *)SCI_ALLOC_APP(MMI_SYNC_PB_NAME_MAX_LEN*sizeof(uint8)+1);
    if(NULL == s_pb_name)
    {
        return FALSE;
    }
    s_pb_number = (uint8 *)SCI_ALLOC_APP(MMI_SYNC_PB_NUM_MAX_LEN*sizeof(uint8)+1);
    if(NULL == s_pb_number)
    {
        return FALSE;
    }

    //copy name and number from at cmd
    SCI_MEMSET(s_pb_name, 0, MMI_SYNC_PB_NAME_MAX_LEN*sizeof(uint8) + 1);
    SCI_MEMSET(s_pb_number, 0, MMI_SYNC_PB_NUM_MAX_LEN*sizeof(uint8) + 1);

    SCI_MEMCPY(s_pb_name, cmd, name_len);
    s_pb_name[name_len] = '\0';
    SCI_MEMCPY(s_pb_number, tmp_ptr+1, number_len);
    s_pb_number[number_len] = '\0';

    return TRUE;

}




/*****************************************************************************/
// 	Description : This function handle ateat pb create in internal storage  from at cmd
//	Global resource dependence : g_mmipb_entry_list
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandlePbNv(
	                                                        uint8 * cmd,                             //input at cmd
                                                               uint32 len                                 //input at length
	                                                             )
{
    	if(NULL != cmd)
	{
	      Atest_GetPbPara(cmd, len);
	      s_MMIPB_Create_ID  = MMIPB_STORAGE_PHONE;
		s_pbcreatesim = FALSE;
	      Atest_HandlePbPhone(s_MMIPB_Create_ID);	 
		return TRUE;  
	}
	return FALSE;	
}  


/*****************************************************************************/
// 	Description : This function handle ateat pb create in internal storage  
//	Global resource dependence : s_pb_name, s_pb_number, s_handle_pb
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandlePbPhone(uint16 create_id )
{  
    MMIPB_CONTACT_T *contact_ptr = NULL;	 
    uint16 i;
    uint8 ftinput_arr[MAX_CMD_LEN] = {0};
    uint8 tmp[CMD_TEM_LEN];
    uint32 ilen;
    wchar *pb_name_ptr;
    MMI_PARTY_NUMBER_T  party_num = {MN_NUM_TYPE_UNKNOW, 0, 0};
    MMIPB_ERROR_E iret;	 

    s_handle_pb = MMIAPIPB_CreateHandle();
    contact_ptr = (MMIPB_CONTACT_T *)SCI_ALLOC_APP(sizeof(MMIPB_CONTACT_T));

    if(NULL != contact_ptr && NULL != s_handle_pb)
    {   
        SCI_MEMSET(ftinput_arr, 0, MAX_CMD_LEN);
        SCI_MEMSET(tmp, 0, CMD_TEM_LEN);	 
        SCI_MEMSET(contact_ptr, 0, sizeof(MMIPB_CONTACT_T));
        for(i=0; i<strlen((char *)s_pb_name); i++)
        {	
            sprintf((char *)tmp, "%2x", s_pb_name[i]);
            strcat((char *)ftinput_arr, (char *)tmp);
            SCI_MEMSET(tmp, 0, CMD_TEM_LEN);

        }
        ilen = SCI_STRLEN((char *)ftinput_arr);
        if(s_pbcreatesim)
        {
            contact_ptr->storage_id = create_id + MMIPB_STORAGE_SIM1;
        }
        else
        {
            contact_ptr->storage_id = create_id;
        }  

        pb_name_ptr = (wchar *)GetATCParameter(MMI_UT_UTF8, ftinput_arr, ilen, 0);
        MMIAPICOM_Wstrncpy(contact_ptr->name.wstr, pb_name_ptr, MMIAPICOM_Wstrlen(pb_name_ptr));
        contact_ptr->name.wstr_len = MMIAPICOM_Wstrlen(pb_name_ptr);
        if (strlen((char *)s_pb_number)>0  && MMIAPICOM_GenPartyNumber(s_pb_number, strlen((char *)s_pb_number), &party_num))
        {
            contact_ptr->number[0].npi_ton = (uint8)((party_num.number_type << 0X04) | MMIPB_DEFAULT_NPI);
            contact_ptr->number[0].number_len = (uint8)MIN(MMIPB_BCD_NUMBER_MAX_LEN, party_num.num_len);
            SCI_MEMCPY(contact_ptr->number[0].number, party_num.bcd_num, contact_ptr->number[0].number_len);
        }
        iret =  MMIAPIPB_AddContactAsyn(s_handle_pb, contact_ptr, Atest_pbcreate_callback);
        SCI_FREE(contact_ptr);
        contact_ptr = NULL;
        if(MMIPB_ERROR_PENDING != iret)
        {   
            if(s_pbcreatesim)
            {
                if(Atest_CheckSim(s_MMIPB_Create_ID+1))
                {
                    Atest_HandlePbPhone(s_MMIPB_Create_ID);
                }
                else
                {
                    SCI_TRACE_LOW("[att][pbcreate]---!= MMIPB_ERROR_PENDING!");
                    if(NULL != s_pb_name)
                    {
                        SCI_FREE(s_pb_name);
                        s_pb_name = NULL;
                    }
                    if(NULL != s_pb_number)
                    {
                        SCI_FREE(s_pb_number);
                        s_pb_number = NULL;
                    }
                    if(NULL != s_handle_pb)
                    {
                        MMIAPIPB_CloseHandle(s_handle_pb);
                        s_handle_pb = NULL;
                    }
                    return FALSE;
                }

            }
            else
            {
                SCI_TRACE_LOW("[att][pbcreate]--Not In sim  MMIPB_ERROR_PENDING!");
                if(NULL != s_pb_name)
                {
                    SCI_FREE(s_pb_name);
                    s_pb_name = NULL;
                }
                if(NULL != s_pb_number)
                {
                    SCI_FREE(s_pb_number);
                    s_pb_number = NULL;
                }
                if(NULL != s_handle_pb)
                {
                    MMIAPIPB_CloseHandle(s_handle_pb);
                    s_handle_pb = NULL;
                }
                return FALSE;
            }	      

        }
        else
        {	       
            SCI_TRACE_LOW("[att][pbcreate]---MMIPB_ERROR_PENDING!");

        }
        return TRUE;
    }     	 
    return FALSE;
}


/*****************************************************************************/
// 	Description : This function handle ateat pb create in internal storage  
//	Global resource dependence : s_pb_name, s_pb_number, s_handle_pb
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL void Atest_pbcreate_callback(MMIPB_HANDLE_T handle, MMIPB_ERROR_E error)
{

    if(NULL != s_handle_pb)
    {
        MMIAPIPB_CloseHandle(s_handle_pb);
        s_handle_pb = NULL;	
    }     
    switch(error)
    {
        case MMIPB_ERROR_SUCCESS:
        {    

            Atest_HandlePbPhone(s_MMIPB_Create_ID);

        }
        break;

        case MMIPB_ERROR_ERROR:
        {

            if(NULL != s_pb_name)
            {
                SCI_FREE(s_pb_name);
                s_pb_name = NULL;
            }
            if(NULL != s_pb_number)
            {
                SCI_FREE(s_pb_number);
                s_pb_number = NULL;
            }	
            SCI_TRACE_LOW("[ATEST] mmipb_create_callback error!");

        }
        break;

        default:
        {               
            if(NULL != s_pb_name)
            {
                SCI_FREE(s_pb_name);
                s_pb_name = NULL;
            }
            if(NULL != s_pb_number)
            {
                SCI_FREE(s_pb_number);
                s_pb_number = NULL;
            }	
            SCI_TRACE_LOW("[ATEST] mmipb_create_callback default!");		   
        }            
        break;

    }	

}


/*****************************************************************************/
// 	Description : This function  handle  URL input from at+sytin cmd
//	Global resource dependence : none
//  Author:       shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleURL(
	                                                 uint8 *cmd,                               //input at cmd for Bookmark url
 								uint32 len                                //input at cmd length
 								)
{
    #ifdef BROWSER_SUPPORT
     wchar *urlinput_ptr  = NULL;
     uint32 txt_type;
     BOOLEAN res= FALSE;
     uint8 urlinput_arr[MAX_CMD_LEN] = {0};
     uint8 tmp[CMD_TEM_LEN];	  
     uint32 i, ilen;  

	  
     if(NULL == cmd)
     {
		return FALSE;
     }

     //set the transform type
     txt_type = MMI_UT_UTF8;
     SCI_MEMSET(urlinput_arr, 0, MAX_CMD_LEN);

     //SCI_TRACE_LOW:"[MMIATC]:Atest_HandleURL:%s"
     SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_2539_112_2_18_1_59_29_14,(uint8*)"s", (char *)cmd);
     //transform to 16 hex
     for(i=0; i<len; i++)
     {	
		sprintf((char *)tmp, "%2x", cmd[i]);
		strcat((char *)urlinput_arr, (char *)tmp);
		
		SCI_MEMSET(tmp, 0, CMD_TEM_LEN);
		
     }
     ilen = SCI_STRLEN((char *)urlinput_arr);
     //SCI_TRACE_LOW:"[MMIATC]:Atest_HandleURL2:%s, %d"
     SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_2550_112_2_18_1_59_29_15,(uint8*)"sd", (char *)urlinput_arr, ilen);
     if(len > 0)
     {    
	       //transform to wchar
		urlinput_ptr = (wchar *)GetATCParameter(txt_type, urlinput_arr, ilen, 0);
		if(NULL != urlinput_ptr)
		{     
		       //insert to URL editbox
		       res = Atest_BROWSERInsertURL(urlinput_ptr, MMIAPICOM_Wstrlen(urlinput_ptr));
			//SCI_TRACE_LOW:"[ATC:][ATEST:][ST:]Atest_HandleURL:url_input:%x, %x, %d"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_2559_112_2_18_1_59_29_16,(uint8*)"ddd", urlinput_ptr[0], urlinput_ptr[1], res);
			SCI_FREE(urlinput_ptr);
			
		}
		else
		{
			return FALSE;
			
		}
     }
     //handle the result
     if(res)
     {
		ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)(strlen((char*)MMI_TO_SYNC_OK_SYMBOL)));
		return TRUE;
     }
     else
     {
		ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16) (strlen((char *)MMI_TO_SYNC_ERROR_SYMBOL)));
		return FALSE;
     }
     #else
         return FALSE;
     #endif//BROWSER_SUPPORT
	
}


/*****************************************************************************/
// 	Description : This function handle ft connect gatewayinput at cmd 
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleConnectGatewayDNS(
                                                             uint8 * cmd,                     //point ot input IP buffer
                                                             uint32 len                        //length of information buffer
                                                           )
{    
     BOOLEAN res = FALSE;

     //check input parameter   
     if(NULL == cmd)
     {
	    return FALSE;
     }
     if(len > 0)
     {  
	    //input ip address to editbox
	    res = Atest_CONNECTIONGATEWAY_DNS_InsertStr(cmd);
	    //SCI_TRACE_LOW:"[ATC:][ATEST:][FT:]Atest_HandleConnectGatewayDNS:%x, %x"
	    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_2607_112_2_18_1_59_29_17,(uint8*)"dd", cmd[0], cmd[1]);

     }
     //handle the result
     if(res)
     {
	    ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)(strlen((char*)MMI_TO_SYNC_OK_SYMBOL)));
	    return TRUE;
     }
     else
     {
	    ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16) (strlen((char *)MMI_TO_SYNC_ERROR_SYMBOL)));
	    return FALSE;
     }

}



/*****************************************************************************/
// 	Description : This function handle connection configuration from at+ftin cmd 
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleConnectOther(
                                                                  uint8 * cmd,                    //point to input connection information buffer
                                                                  uint32 len                        //length of  information buffer
                                                                  )
{
     wchar *conninput_ptr = NULL;
     uint32 txt_type;
     BOOLEAN res= FALSE;
     uint8 ftinput_arr[MAX_CMD_LEN] = {0};
     uint8 tmp[CMD_TEM_LEN];	  
     uint32 i, ilen;  

	  
     if(NULL == cmd)
     {
	   return FALSE;
     }

     //set the transform type
     txt_type = MMI_UT_UTF8;
     SCI_MEMSET(ftinput_arr, 0, MAX_CMD_LEN);

     //transform to the 16 hex
     for(i=0; i<len; i++)
     {	
	   sprintf((char *)tmp, "%2x", cmd[i]);
	   strcat((char *)ftinput_arr, (char *)tmp);
	   SCI_MEMSET(tmp, 0, CMD_TEM_LEN);
		
     }
     ilen = SCI_STRLEN((char *)ftinput_arr);
     if(len > 0)
     {         
          //transform to wchar
          conninput_ptr = (wchar *)GetATCParameter(txt_type, ftinput_arr, ilen, 0);
          if(NULL != conninput_ptr)
          {    
	        //insert string to mmi editbox
	        res = MMIAPICONNECTION_InsertStr(conninput_ptr, MMIAPICOM_Wstrlen(conninput_ptr));
	        //SCI_TRACE_LOW:"[ATC:][ATEST:][FT:]Atest_HandleConnectOther:conne_input:%x, %x"
	        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_2669_112_2_18_1_59_29_18,(uint8*)"dd", conninput_ptr[0], conninput_ptr[1]);
	        SCI_FREE(conninput_ptr);
			
          }
          else
          {
	        return FALSE;
			
          }
     }

     // handle the result 
     if(res)
     {
          ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)(strlen((char*)MMI_TO_SYNC_OK_SYMBOL)));
          return TRUE;
     }
     else
     {
          ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16) (strlen((char *)MMI_TO_SYNC_ERROR_SYMBOL)));
          return FALSE;
     }
	
	
}


/*****************************************************************************/
// 	Description : This function handle ft connection information
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleConnection(
	                                              uint8 * cmd,           //point to input connection information buffer
	                                              uint32 len               //length of  information buffer
	                                              )       
{
	
     uint8 con_type = 0;
     BOOLEAN res= FALSE;

     //check input at cmd  
     if(NULL == cmd)
     {
          return FALSE;
     }
     //get the handle connection configuration type
     con_type = *(cmd++);
     len = len -1;

      
     switch(con_type)
     {
          //handle gateway and dns ip address input
          case 'g':
          case 'G':
	       res = Atest_HandleConnectGatewayDNS(cmd, len);
	       break;
          //handle connection other page string input
          case 'p':
          case 'P':
	       res = Atest_HandleConnectOther(cmd, len);
	       break;
          //error type
          default:
	       //SCI_TRACE_LOW:"[ATC:][ATEST:][Atest_HandleConnection:] %c"
	       SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_2733_112_2_18_1_59_29_19,(uint8*)"c", (char)con_type);
	       break;
     }
     return res;
}


/*****************************************************************************/
// 	Description : This function handle  at cmd  from at+ftin
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleFtAtMMI(
 								uint8 *cmd,                               //input at cmd
 								uint32 len                                  //input at length
  								)
{
     uint8 funtype = 0;
     BOOLEAN res_code = FALSE;
	 
     funtype = *(cmd++);
     len = len -1;
	 
     switch(funtype)
     {     
           //connection configuration input
          case 'c':
          case 'C':
	       res_code = Atest_HandleConnection(cmd, len);
	       break;
          //bookmark configuration input		 
          case 'B':
          case 'b':
	       res_code = Atest_HandleBookmark(cmd, len);
	       break;

#ifdef ATEST_SUPPORT	       
        case 'I':
        case 'i':
            res_code = Atest_HandleControlInput(cmd, len);
        break;	    
#endif // ATEST_SUPPORT
           
          //error switch		 
          default:
	       //SCI_TRACE_LOW:"[ATC:][FT:][Atest_HandleFtAtMMI:]connection input type error!"
	       SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_2777_112_2_18_1_59_30_20,(uint8*)"");
	       break;
     }
     return res_code;

}



/*****************************************************************************/
// 	Description : This function handle ft bookmark title  input from at+ftin cmd 
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleBmTitle(
                                                             uint8 * cmd,      //at input title cmd
                                                             uint32 len         //input at length
                                                           )
{   
     #ifdef BROWSER_SUPPORT
     wchar *conninput_ptr = NULL;
     uint32 txt_type = 0;
     BOOLEAN res= FALSE;

	  
     if(NULL == cmd  )
     {
          return FALSE;
     }

     //set the transform type
     txt_type =  MMI_UT_UTF8;	
			
     if(len > 0)
     {     
          //transform to wchar
          conninput_ptr = (wchar *)GetATCParameter(txt_type, cmd, len, 0);
          if(NULL != conninput_ptr)
          {            
	       //input string to bookmark title editbox
	       res = Atest_BROWSERBookmarkTitleInput(conninput_ptr, MMIAPICOM_Wstrlen(conninput_ptr));
	       //SCI_TRACE_LOW:"[ATC:][ATEST:][FT:]Atest_HandleBmTitle:conne_input:%x, %x, %d"
	       SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_2817_112_2_18_1_59_30_21,(uint8*)"ddd", conninput_ptr[0], conninput_ptr[1], (int)txt_type);
	       SCI_FREE(conninput_ptr);
			
          }
          else
          {
	       return FALSE;
			
          }
     }
     //handle the result
     if(res)
     {
          ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)(strlen((char*)MMI_TO_SYNC_OK_SYMBOL)));
          return TRUE;
     }
     else
     {
          ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16) (strlen((char *)MMI_TO_SYNC_ERROR_SYMBOL)));
          return FALSE;
     }
     #else
         return FALSE;
     #endif //BROWSER_SUPPORT
	
	
}


/*****************************************************************************/
// 	Description : This function handle ft bookmark URL input  from at+ftin cmd  
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleBmURL(
                                                             uint8 * cmd,                  //input at cmd for bookmark url                     
                                                             uint32 len                     //input at length
                                                           )
{
     #ifdef BROWSER_SUPPORT	
     wchar *conninput_ptr = NULL;
     uint32 txt_type;
     BOOLEAN res= FALSE;

	  
     if(NULL == cmd )
     {
          return FALSE;
     }

     //set the transform type 
     txt_type = MMI_UT_UTF8;	
     if(len > 0)
     {      
          //transform to wchar
          conninput_ptr = (wchar *)GetATCParameter(txt_type, cmd, len, 0);
          if(NULL != conninput_ptr)
          {    
	       //input string to bookmark url editbox
	       res = Atest_BROWSERBookmarkURLInput(conninput_ptr, MMIAPICOM_Wstrlen(conninput_ptr));
	       //SCI_TRACE_LOW:"[ATC:][ATEST:][FT:]Atest_HandleBmURL:conne_input:%x, %x, %d"
	       SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_2876_112_2_18_1_59_30_22,(uint8*)"ddd", conninput_ptr[0], conninput_ptr[1], (int)txt_type);
	       SCI_FREE(conninput_ptr);
			
          }
          else
          {
	       return FALSE;
			
          }
     }
     //handle the result
     if(res)
     {
          ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)(strlen((char*)MMI_TO_SYNC_OK_SYMBOL)));
          return TRUE;
     }
     else
     {   
          ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16) (strlen((char *)MMI_TO_SYNC_ERROR_SYMBOL)));
          return FALSE;
     }
     #else
         return FALSE;
     #endif //BROWSER_SUPPORT
	
}




/*****************************************************************************/
// 	Description : This function handle  bookmark input from at+ftin cmd 
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleBookmark(
                                                             uint8 * cmd,                          //point to input connection information buffer
                                                             uint32 len                               //length of  information buffer
                                                             )
{    
     uint8 bm_type = 0;
     BOOLEAN res= FALSE;
     uint8 bm_arr[MAX_CMD_LEN] = {0};
     uint8 bm_tmp[CMD_TEM_LEN];
     uint32 i, ilen;
	  
     if(NULL == cmd)
     {
          return FALSE;
     }
     //get the book mark handle type
     bm_type = *(cmd++);
     len = len -1;

     SCI_MEMSET(bm_arr, 0, MAX_CMD_LEN);

     //transform to the 16 hex
     for(i=0; i<len; i++)
     {	
          sprintf((char *)bm_tmp, "%2x", cmd[i]);
          strcat((char *)bm_arr, (char *)bm_tmp);
          SCI_MEMSET(bm_tmp, 0, CMD_TEM_LEN);
		
     }
     ilen = SCI_STRLEN((char *)bm_arr);
     
     switch(bm_type)
     {
          //input bookmark title
          case 't':
          case 'T':
	       res = Atest_HandleBmTitle(bm_arr, ilen);
	       break;
          //input bookmark url
          case 'u':
          case 'U':
	       res = Atest_HandleBmURL(bm_arr, ilen);
	       break;
          default:
	       //SCI_TRACE_LOW:"[ATC:][ATEST:][Atest_HandleBookmark:] %c"
	       SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_2954_112_2_18_1_59_30_23,(uint8*)"c", (char)bm_type);
	       res = FALSE;
	       break;
     }
     return res;
	
}



/*****************************************************************************/
// 	Description : This function  handle  SMS input from at+sytin cmd
//	Global resource dependence : none
//  Author:       shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleSMS(
	                                                 uint8 *cmd,                                              //input at cmd for sms
 								uint32 len                                               //input at length 
 								)
{
     wchar *smsinput_ptr = NULL;
     uint32 txt_type;
     BOOLEAN res= FALSE;

	  
     if(NULL == cmd)
     {
          return FALSE;
     }

     //set the transform type
     txt_type = MMI_UT_UNICODE;
     if(len > 0)
     {     
          //transform to wchar
          smsinput_ptr = (wchar *)GetATCParameter(txt_type, cmd, len, 0);
          if(NULL != smsinput_ptr)
          {     
	       //insert to SMS editbox
	       res = MMIAPISMS_InsertMessage(smsinput_ptr, MMIAPICOM_Wstrlen(smsinput_ptr));
	       //SCI_TRACE_LOW:"[ATC:][ATEST:][ST:]Atest_HandleSMS:sms_input:%x, %x"
	       SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_2993_112_2_18_1_59_30_24,(uint8*)"dd", smsinput_ptr[0], smsinput_ptr[1]);
	       SCI_FREE(smsinput_ptr);
			
          }
          else
          {
	       return FALSE;
			
          }
     }
     //handle the result
     if(res)
     {
          ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)(strlen((char*)MMI_TO_SYNC_OK_SYMBOL)));
          return TRUE;
     }
     else
     {
          ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16) (strlen((char *)MMI_TO_SYNC_ERROR_SYMBOL)));
          return FALSE;
     }
	
}




/*****************************************************************************/
// 	Description : This function handle create vertilcal folder from at+sytin cmd
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleFolderVerti(
                                                            uint8 * cmd,                        //point to the folder information buffer
                                                             uint32 len                             //length of information
                                                           )
{   
     uint8 txt_type;
     uint16 folder_num;
     BOOLEAN res= FALSE;

	  
     if(NULL == cmd )
     {
          return FALSE;
     }

     //check the input is digit
     txt_type = *cmd;
     if(txt_type<'0' || txt_type>'9')
     {
          return FALSE;
     }
     if(len > 0)
     {
          //get the folder number
          folder_num = atoi((char *)cmd);
          if(folder_num>MMIFMM_PATH_DEPTH)
          {
	       return FALSE;
           }
          //create the folder
          res = Atest_FMMCreateFolderVerti( folder_num);
     }
     //handle the result
     if(res)
     {
          ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)(strlen((char*)MMI_TO_SYNC_OK_SYMBOL)));
          return TRUE;
     }
     else
     {
          ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16) (strlen((char *)MMI_TO_SYNC_ERROR_SYMBOL)));
          return FALSE;
     }
}


/*****************************************************************************/
// 	Description : This function handle create horizontal folder from at+sytin cmd
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleFolderHori(
                                                            uint8 * cmd,                        //point to the folder information buffer
                                                             uint32 len                             //length of information
                                                           )
{
     uint8 txt_type;
     uint16 folder_num;
     BOOLEAN res= FALSE;

     if(NULL == cmd )
     {
          return FALSE;
     }

     //check the input is digit
     txt_type = *cmd;
     if(txt_type<'0' || txt_type>'9')
     {
          return FALSE;
     }
     if(len > 0)
     {     
          //get the folder number
          folder_num = atoi((char *)cmd);
          if(folder_num>MMIFMM_FILE_NUM)
          {
	       return FALSE;
          }
          //create the horizontal folder
          res = Atest_FMMCreateFolderHori(folder_num);
     }
     //handle the result
     if(res)
     {
          ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)(strlen((char*)MMI_TO_SYNC_OK_SYMBOL)));
          return TRUE;
     }
     else
     {
          ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16) (strlen((char *)MMI_TO_SYNC_ERROR_SYMBOL)));
          return FALSE;
     }
}



/*****************************************************************************/
// 	Description : This function handle create folder creat from at+sytin cmd
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleFolder(
                                                            uint8 * cmd,                        //point to the folder information buffer
                                                             uint32 len                             //length of information
                                                           )
{
     uint8 bm_type = 0;
     BOOLEAN res= FALSE;
	  
     if(NULL == cmd)
     {
		return FALSE;
     }
     //get the create folder type
     bm_type = *(cmd++);
     len = len -1;

     
     switch(bm_type)
     {     
          //create horizontal folder
          case 'h':
          case 'H':
	       res = Atest_HandleFolderHori(cmd, len);
	       break;
          //create vertical folder
          case 'v':
          case 'V':
	       res = Atest_HandleFolderVerti(cmd, len);
	       break;
          //error switch
          default:
	       //SCI_TRACE_LOW:"[ATC:][ATEST:][Atest_HandleFolder:] %c"
	       SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_3155_112_2_18_1_59_30_25,(uint8*)"c", (char)bm_type);
	       res = FALSE;
	       break;
     }
     return res;

	
}



/*****************************************************************************/
// 	Description : This function  handle cmd  from at+sytin cmd
//	Global resource dependence : none
//  Author:       shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleStAtMMI(
 								uint8 *cmd,                                      //input st at cmd
 								uint32 len                                        //input at cmd length 
                                                               )
{
     uint8 funtype = 0;
     BOOLEAN res_code = FALSE;

     if(NULL == cmd)
     {
          return FALSE;
     }
     //get the funtion type	 
     funtype = *(cmd++);
     len = len -1;
     switch(funtype)
     {
          //handle sms input
          case 'S':
          case 's':
	       res_code = Atest_HandleSMS(cmd, len);
	       break;
          //handle url input
          case 'U':
          case 'u':
	       res_code = Atest_HandleURL(cmd, len);
	       break;
          //handle folder create
          case 'F':
          case 'f':
	       res_code = Atest_HandleFolder(cmd, len);
	       break;
	   //handle pb create
          case 'p':
	   case 'P':
	   	 res_code = Atest_HandlePhoneBook(cmd, len);
	   	 break;
          //erro switch
          default:
	       //SCI_TRACE_LOW:"[ATC:][FT:][Atest_HandleStAtMMI:]connection input type error!"
	       SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_3209_112_2_18_1_59_30_26,(uint8*)"");
	       res_code = FALSE;
	       break;
     }
     return res_code;

}



/*****************************************************************************/
// 	Description : This function handle Atest at cmd
//	Global resource dependence : none
//  Author:    shuyan.hu
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleAtMMI(
	                                                        uint8 * cmd,                             //input at cmd
                                                               uint32 len                                 //input at length
	                                                             )
{
     uint8 test_type = 0;
     BOOLEAN res = FALSE;

     //get the function type    
     test_type = *(cmd++);
     len = len - 1;
     switch(test_type)
     {     
          //handle at cmd from at+ftin
          case 'f':
          case 'F':
	       res = Atest_HandleFtAtMMI(cmd, len);
	       break;
          //handle at cmd from at+sytin
          case 's':
          case 'S':
	       res = Atest_HandleStAtMMI(cmd, len);
	       break;
          //erro switch
          default:
	       res = FALSE;
	       //SCI_TRACE_LOW:"[ATC:][MMI:][Atest_HandleAtMMI]input test type error!"
	       SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_3249_112_2_18_1_59_31_27,(uint8*)"");
	       break;
     }
     return res;
	
}

#ifdef ATEST_SUPPORT
// 控件输入自动测试
/*****************************************************************************/
// 	Description : ATEST拦截外部消息并处理
//	Global resource dependence : none
//  Author: xiaolei.zheng
//	Note:
/*****************************************************************************/
PUBLIC void ATest_DispatchExtSig(MmiSignalS **signal_pptr)
{   
	uint8 *user_data_ptr = PNULL;
	uint8 *start_ptr = PNULL;
	BOOLEAN result = FALSE;
	uint32 reseved_data = 0;
	uint32 rect_x = 0;
	uint32 rect_y = 0;
	uint32 rect_data = 0;	

	MmiOtherTaskMsgS* signal_ptr =  (MmiOtherTaskMsgS*)(*signal_pptr);
	user_data_ptr = (uint8 *)(signal_ptr->param_ptr);
	reseved_data = (signal_ptr->msg_id);


	switch((*signal_pptr)->SignalCode)
	{
		case ATEST_SIGNAL_IGCT:
			result = Atest_GetControlTree(user_data_ptr);
			SCI_FREE(user_data_ptr);
			break;

		case ATEST_SIGNAL_IGCD:
			result = Atest_GetControlData(user_data_ptr);
			SCI_FREE(user_data_ptr);
			break;

		case ATEST_SIGNAL_IFCD:
			result = Atest_FillControlData(user_data_ptr);
			SCI_FREE(user_data_ptr);
			break;

		case ATEST_SIGNAL_ISCP:
			result = Atest_ClickControl(user_data_ptr);	
			SCI_FREE(user_data_ptr);
			break;

		case ATEST_SIGNAL_IGCL:
			result = Atest_GetCurLang();
			SCI_FREE(user_data_ptr);
			break;

		case ATEST_SIGNAL_IGCR:
			result = Atest_GetCurResolution();	
			SCI_FREE(user_data_ptr);
			break;	

		case ATEST_SIGNAL_KB_DOWN:
			Atest_ResolveKbdSignal(SCI_VK_DOWN,user_data_ptr,reseved_data);	
			SCI_FREE(user_data_ptr);
			break;

		case ATEST_SIGNAL_KB_UP:
			Atest_ResolveKbdSignal(SCI_VK_UP,user_data_ptr,reseved_data);			
			SCI_FREE(user_data_ptr);
			break;

		case ATEST_SIGNAL_KB_RIGHT:
			Atest_ResolveKbdSignal(SCI_VK_RIGHT,user_data_ptr,reseved_data);			
			SCI_FREE(user_data_ptr);
			break;

		case ATEST_SIGNAL_KB_LEFT:
			Atest_ResolveKbdSignal(SCI_VK_LEFT,user_data_ptr,reseved_data);			
			SCI_FREE(user_data_ptr);
			break;

		case ATEST_SIGNAL_IGLN:
			result = Atest_GetListNum(user_data_ptr);
			SCI_FREE(user_data_ptr);
			break;
			
		case ATEST_SIGNAL_TPLONG:
			if(PNULL != user_data_ptr)
			{
				start_ptr = user_data_ptr;
				rect_x = Atest_GetTestMessageId(',',&start_ptr);
				rect_y = Atest_GetTestMessageId(',',&start_ptr);
			}
			rect_data = rect_x<<16|rect_y;
			#ifdef TOUCH_PANEL_SUPPORT
			MMK_DispatchMSGTpLong(rect_x, rect_y);
			#endif
			SCI_FREE(user_data_ptr);
			break;
			
		case ATEST_SIGNAL_IRIW:
			MMK_ReturnIdleWin();
			SCI_FREE(user_data_ptr);
			break;
			
		case ATEST_SIGNAL_ICES:
			Atest_ClearAllStr(user_data_ptr);
			SCI_FREE(user_data_ptr);
			break;

		case ATEST_SIGNAL_ITPR:
			Atest_TouchPanelPoint(user_data_ptr);
			SCI_FREE(user_data_ptr);
			break;
		case ATEST_SIGNAL_ITPD:
			Atest_TouchPanelDown(user_data_ptr);
			SCI_FREE(user_data_ptr);
			break;
		case ATEST_SIGNAL_ITPM:
			Atest_TouchPanelMove(user_data_ptr);
			SCI_FREE(user_data_ptr);
			break;
		case ATEST_SIGNAL_ITPU:
			Atest_TouchPanelUp(user_data_ptr);
			SCI_FREE(user_data_ptr);
			break;
		case ATEST_SIGNAL_IKBD:
			Atest_KBDown(user_data_ptr);
			SCI_FREE(user_data_ptr);
			break;
		case ATEST_SIGNAL_IGCS:
			result = Atest_GetCurStyle(user_data_ptr);			 
			SCI_FREE(user_data_ptr);
			break;		
			
		case ATEST_SIGNAL_IGST:
			result = Atest_GetCurSysTime(user_data_ptr);			 
			SCI_FREE(user_data_ptr);
			break;

		case ATEST_SIGNAL_ISAT:
			result = Atest_SetAlarmTime(user_data_ptr);			 
			SCI_FREE(user_data_ptr);
			break;

		case ATEST_SIGNAL_IGAT:
			result = Atest_GetLatestAlarmTime(user_data_ptr);			 
			SCI_FREE(user_data_ptr);
			break;
			
		case ATEST_SIGNAL_ICCD:
			result = Atest_ClickCalendarDate(user_data_ptr);			 
			SCI_FREE(user_data_ptr);
			break;

		default:
			break;
	}

	if((*signal_pptr)->SignalCode >= ATEST_SIGNAL_KB_DOWN && (*signal_pptr)->SignalCode < ATEST_SIGNAL_MAX)
	{
		//SCI_TRACE_LOW:"[AT][ATEST]:ATest_DispatchExtSig--signalType=0x%x,handleresult=%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_3380_112_2_18_1_59_31_28,(uint8*)"dd",(*signal_pptr)->SignalCode,result);
	}
    return;    
}

/*****************************************************************************/
//  Description: 将十六进制字符串从手机端传回PC端
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL int32 Atest_TransmitATString( // 返回校验码: 传输的数据部分的累加，参数is_need_check=TRUE有效
    uint8 *data_ptr,                // 传输的数据
    uint16 data_len,                // 传输的数据长度
    BOOLEAN is_unicode,             // 判定是否需要将Unicode编码转换为十六进制字符串
    BOOLEAN is_need_checksum)       // 判定是否需要计算校验和
{
    uint16 max_trans_len = 0, trans_data_len = 0, code_convert_len = 0, data_index = 0;
    uint8 *code_convert_ptr = PNULL, *trans_data_ptr = PNULL;
    int32 data_checksum = 0;

    // 传输数据超过一次能传输的最大长度，按照最大长度分段传输
    while (data_len > 0)
    {
        if (data_len > ATEST_MAX_SEND_LEN)
        {
            max_trans_len = ATEST_MAX_SEND_LEN;
        }
        else // 传输最后一段
        {
            max_trans_len = data_len;
        }

        // 如果是Unicode，则需要转换为十六进制字符，因为AT只能传输ASCII字符
        if (is_unicode)
        {
            // 按照最大传输长度转换Unciode编码
            if (PNULL == code_convert_ptr)
            {
                code_convert_ptr = (uint8 *)SCI_ALLOC_APP(ATEST_MAX_SEND_LEN * 2 + 1);
                SCI_MEMSET(code_convert_ptr, 0, ATEST_MAX_SEND_LEN *2 + 1);
            }

            MMIAPICOM_BinaryToHexChar(data_ptr, max_trans_len, code_convert_ptr, &code_convert_len);

            // 修正传输数据为编码转换后的数据，长度为编码转换后长度
            trans_data_ptr = code_convert_ptr;
            trans_data_len = code_convert_len;
        }
        else // 不需要编码转换的，直接传回
        {
            trans_data_ptr = data_ptr;
            trans_data_len = max_trans_len;
        }

        if (is_need_checksum) // 生成数据校验和，将各个字符编码值累加
        {
            for (data_index = 0; data_index < trans_data_len; data_index++)
            {
                data_checksum += trans_data_ptr[data_index];
            }
        }

         ReturnResponse(trans_data_ptr, trans_data_len);
        // 用AT通道传回
        //SIO_ATC_WriteCmdRes(trans_data_ptr, trans_data_len);

        // 修正剩余长度，和下一次传输位置
        data_ptr += max_trans_len;
        data_len -= max_trans_len;
    };

    if (code_convert_ptr)
    {
        SCI_FREE(code_convert_ptr);
    }
	
#ifndef WIN32
	SCI_SLEEP(1);
#endif //WIN32

    return data_checksum;
}
/*****************************************************************************/
//  Description: 获取控件属性
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetControlProperty(
    IGUICTRL_T *ctrl_ptr,    
    BOOLEAN is_mark_end,    // 控件遍历结束标记: </CONTROL>
    uint8 *data_ptr,        // 需要传输的控件属性数据
    uint32 *data_size_ptr)  // 传输数据大小
{
    char *ctrl_name_ptr = PNULL;
	wchar *user_item_ptr = NULL;
    uint16 data_len = 0;

    // 根据GUID判定控件类型
    CAF_GUID_T ctrl_guid = GUICTRL_GetCtrlGuid((IGUICTRL_T *)ctrl_ptr);
	
	// 根据控件指针获取控件handle，根据handle获取控件id 
	MMI_HANDLE_T ctrl_handle = GUICTRL_GetCtrlHandle((IGUICTRL_T *)ctrl_ptr);
    MMI_CTRL_ID_T ctrl_id = MMK_GetCtrlId(ctrl_handle);
	if(!ctrl_id)
	{
		return;
	}

	ctrl_ptr = MMK_GetCtrlPtrByWin(MMK_GetFocusWinHandle(), ctrl_id);
    if (PNULL == ctrl_ptr)
    {
        return;
    }

	user_item_ptr = (wchar *)SCI_ALLOC_APP(8192);
    if (user_item_ptr == PNULL)
    {
        return;    
    }
	SCI_MEMSET(user_item_ptr, 0, 8192);
   
    switch (ctrl_guid)
    {
        case SPRD_GUI_RICHTEXT_ID :
        {
            ctrl_name_ptr = "richtext";        
    		if (is_mark_end)
    		{
    			break;
    		}
			Atest_GetRichTextControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }
        break;
        
        case SPRD_GUI_EDITBOX_ID : // 处理编辑框
        {
            ctrl_name_ptr = "editbox";                
    		if (is_mark_end)
    		{
    			break;
    		}
			Atest_GetEditControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }
        break;
	  case SPRD_GUI_TEXTEDIT_ID : // 处理编辑框
        {
            ctrl_name_ptr = "editbox";                
    		if (is_mark_end)
    		{
    			break;
    		}
			Atest_GetTextEditControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }
        break;
	 case SPRD_GUI_PHONENUMEDIT_ID : // 处理编辑框
        {
            ctrl_name_ptr = "editbox";                
    		if (is_mark_end)
    		{
    			break;
    		}
			Atest_GetTextEditControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }
        break;
	case SPRD_GUI_DIGITALEDIT_ID : // 处理编辑框
        {
            ctrl_name_ptr = "editbox";                
    		if (is_mark_end)
    		{
    			break;
    		}
			Atest_GetTextEditControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }
        break;
	case SPRD_GUI_PSWEDIT_ID : // 处理编辑框
        {
            ctrl_name_ptr = "editbox";                
    		if (is_mark_end)
    		{
    			break;
    		}
			Atest_GetTextEditControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }
        break;

        case SPRD_GUI_DROPDOWNLIST_ID : // 处理下拉列表
        {
            ctrl_name_ptr = "dropdownlist";
    		if (is_mark_end)
    		{
    			break;
    		}
			Atest_GetDropListControlProperty( ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }
        break;
	 case SPRD_GUI_LISTEDIT_ID:
        case SPRD_GUI_LIST_ID :
        {                       
            ctrl_name_ptr = "list";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetListControlProperty( ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
	    }
        break;

        case SPRD_GUI_ANIM_ID :
        {   
			ctrl_name_ptr = "anim";
			if (is_mark_end)
			{
				break;
			} 
			Atest_GetAnimControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }
		break;
        case SPRD_GUI_MAINMENU_ID:
	{
			ctrl_name_ptr = "mainmenu";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetMainMenuControlProperty( ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }
	break;

        case SPRD_GUI_MENU_ID :
        {
			ctrl_name_ptr = "menu";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetMenuControlProperty( ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }	
        break;

        case SPRD_GUI_MSGBOX_ID :
        {
			ctrl_name_ptr = "msgbox";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetMsgBoxControlProperty( ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }
        break;

        case SPRD_GUI_PRGBOX_ID :
        {    ctrl_name_ptr = "prgbox";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetPrgBoxControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }
		break;

        case SPRD_GUI_TEXTBOX_ID :
        {    ctrl_name_ptr = "textbox";
			if (is_mark_end)
			{
				break;
			} 
			Atest_GetTextControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }
        break;

        case SPRD_GUI_LABEL_ID :
         {   ctrl_name_ptr = "label";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetLableControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        
		}
		break;
        
        case SPRD_GUI_PUNCTUATION_ID :
        {    ctrl_name_ptr = "punctuation";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetPunctuationControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }   
        break;            

        case SPRD_GUI_BUTTON_ID :
        {    ctrl_name_ptr = "button";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetButtonControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }	
        break;

        case SPRD_GUI_ICONLIST_ID :
        {    
			ctrl_name_ptr = "iconlist";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetIconlistControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }	
        break;

        case SPRD_GUI_TAB_ID :
         {
		 	ctrl_name_ptr = "tab";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetTabControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }	
        break;

        case SPRD_GUI_STATUSBAR_ID :
        {    ctrl_name_ptr = "statusbar";
			if (is_mark_end)
			{
				break;
			} 
			Atest_GetStatusBarControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }
        break;

        case SPRD_GUI_SOFTKEY_ID :
        {    ctrl_name_ptr = "softkey";
			if (is_mark_end)
			{
				break;
			}
            Atest_GetsoftkeyControlProperty(ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);		
        }
		break;

        case SPRD_GUI_TIPS_ID :            
		{	ctrl_name_ptr = "tips";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetTipsControlProperty( ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
		}	
	    break;

	    case SPRD_GUI_TITLE_ID :
	    {
			ctrl_name_ptr = "title";
			if (is_mark_end)
			{
				break;
			} 
			Atest_GetTitleControlProperty( ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);				
	    }    
	    break;

	    case SPRD_GUI_IM_ID :
	     {
		 	ctrl_name_ptr = "im";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetIMControlProperty( ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);	
	    }
	    break;

	    case SPRD_GUI_SETLIST_ID :
	    {
			ctrl_name_ptr = "setlist";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetSetListControlProperty( ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
	    }
		break;

	    case SPRD_GUI_FORM_ID :
	    {
			ctrl_name_ptr = "form";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetFormControlProperty( ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
	    }
		break;

        case SPRD_GUI_OWNDRAW_ID :
        {
			ctrl_name_ptr = "owndraw";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetOwndrawControlProperty( ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }	
        break;

        case SPRD_GUI_TOOLBAR_ID :
		{
			ctrl_name_ptr = "toolbar";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetToolbarControlProperty( ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }			
        break;

		case SPRD_GUI_ICONFOLDER_ID:
		{
			ctrl_name_ptr = "iconfolder";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetIconfolderControlProperty( ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }			
        break;
			
#ifdef GUI_CTRL_SCROLL_KEY
		case SPRD_GUI_SCROLLKEY_ID:
		{
			ctrl_name_ptr = "scrollkey";
			if (is_mark_end)
			{
				break;
			}
			Atest_GetScrollkeyControlProperty( ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
        }			
        break;
#endif
       
        default : 
            ctrl_name_ptr = "unknown";
			if (is_mark_end)
			{
				break;
			}            
            data_len = sprintf((char *)data_ptr, "<%s>", ctrl_name_ptr);
            Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
            *data_size_ptr += data_len;        
        break;
    }

    if (is_mark_end) // 结束标签
    {
        data_len = sprintf((char *)data_ptr, "</%s>", ctrl_name_ptr);
        // 累计传输数据长度
        *data_size_ptr += data_len;
        // 将XML数据传回，这些数据都是ASCII，不需要Unciode转换，不存在数据错误，不需要校验
        Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
    }
	
    SCI_FREE(user_item_ptr);
}

/*****************************************************************************/
//  Description: 解析PC端发过来的消息内容: 窗体ID，长度，位置等，用逗号分隔
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL uint32 Atest_GetTestMessageId( // 返回消息内容: 窗体ID，长度，位置
    char separator,                  // ID分隔符
    uint8 **message_pptr)            // 返回指向下一个要解析的位置
{
    uint8 mssage_id_arr[16] = { 0 }, *start_ptr = *message_pptr, *end_ptr = PNULL;
    uint32 mssage_id = 0;

    // 解析两个逗号之间的部分，为mssage_id
    while ( ('\0' != *start_ptr) && (*start_ptr != separator) )
    {
        start_ptr++;
    }

    end_ptr = ++start_ptr;
    start_ptr = mssage_id_arr;

    while ( ('\0' != *end_ptr) && (*end_ptr != separator) )
    {
        *start_ptr++ = *end_ptr++;
    }

    mssage_id = atoi((char *)mssage_id_arr);

    // *message_pptr指向下一个待解析的消息
    *message_pptr = end_ptr;

    return mssage_id;
}

/*****************************************************************************/
//  Description: 解析PC端指令，填充控件数据，返回填充结果
//               AT+SFTIN="IFCD,393435,31002D4E" -> 10,20
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_FillControlData( // 填充失败，返回FALSE
    uint8 *user_data_ptr)            // 用户填充指令和数据
{
    uint16 fill_str_len = 0, data_len = 0, max_len = 0, max_num = 0, year;
    uint8 month, day, hour, minute, second;
    uint32 ip_addr;
    wchar *fill_str_ptr = PNULL;
    char *special_str_ptr = PNULL;
    uint8 *start_ptr = user_data_ptr;
    uint8 *end_ptr = user_data_ptr + strlen((char *)user_data_ptr);
    uint8 special_data[16] = { 0 };
    MMI_CTRL_ID_T ctrl_id;
    CAF_GUID_T ctrl_guid;
    MMI_HANDLE_T win_handle;
	MMI_HANDLE_T ctrl_handle;

    IGUICTRL_T *ctrl_ptr = PNULL;
    CTRLBASEEDIT_OBJ_T *edit_ctrl_ptr = PNULL;
    CTRLDROPDOWNLIST_OBJ_T *dropdownlist_ctrl_ptr = PNULL;	

    // 解析控件ID，计算要填充的控件数据长度
    ctrl_id = Atest_GetTestMessageId(',', &start_ptr);
    // 跳过分隔符，指向数据部分
    if (end_ptr > start_ptr)
    {
        start_ptr++;
    }
    // 计算数据部分的长度
    fill_str_len = end_ptr - start_ptr;

    // 获取焦点窗体handle
    win_handle = MMK_GetFocusWinHandle();
    // 从焦点窗体搜索与客户端控件ID相同的控件
    ctrl_ptr = MMK_GetCtrlPtrByWin(win_handle, ctrl_id);
    if (PNULL == ctrl_ptr)
    {
        return FALSE;
    }

	ctrl_handle = GUICTRL_GetCtrlHandle(ctrl_ptr);

    // 客户端传回的是十六进制UNICODE字符，转换为UNICODE编码，再填充目标控件
    fill_str_ptr = (wchar *)GetATCParameter(MMI_UT_UNICODE, start_ptr, fill_str_len, 0);
    if (PNULL == fill_str_ptr)
    {
        return FALSE;
    }

    ctrl_guid = GUICTRL_GetCtrlGuid(ctrl_ptr);
    // 根据控件GUID判定要处理的目标控件
    if (SPRD_GUI_EDITBOX_ID == ctrl_guid
	|| (SPRD_GUI_TEXTEDIT_ID == ctrl_guid) 
		|| (SPRD_GUI_PHONENUMEDIT_ID == ctrl_guid) 
		|| (SPRD_GUI_DIGITALEDIT_ID == ctrl_guid) 
		|| (SPRD_GUI_PSWEDIT_ID == ctrl_guid) 
		|| (SPRD_GUI_LISTEDIT_ID == ctrl_guid) ) // 处理编辑框
    {
        edit_ctrl_ptr = (CTRLBASEEDIT_OBJ_T *)ctrl_ptr;

        // 列表类型，列表项最大长度即为边界，逐项添加
        switch (edit_ctrl_ptr->type)
        {
            case GUIEDIT_TYPE_LIST :
            {
                GUIEDIT_AddListItem(ctrl_id, fill_str_ptr, fill_str_len);
                max_len = edit_ctrl_ptr->str_max_len;
                max_num = edit_ctrl_ptr->total_line_num;
            }
            break;

            // 对于时间的数据，由H，M，S构成
            case GUIEDIT_TYPE_TIME :
            case GUIEDIT_TYPE_TOUCH_TIME :
            // 对于日期的数据，由Y，M，D构成
            case GUIEDIT_TYPE_DATE :
            case GUIEDIT_TYPE_TOUCH_DATE :
            // IP是一个uint32类型
            case GUIEDIT_TYPE_IP :
            {
                special_str_ptr = GetATCParameter(MMI_UT_STRUCT, start_ptr, fill_str_len, fill_str_len);
                if (PNULL == special_str_ptr)
                {
                    return FALSE;
                }

                start_ptr = (uint8 *)special_str_ptr;

                if (GUIEDIT_TYPE_IP == edit_ctrl_ptr->type)
                {
                    ip_addr = (uint32)Atest_GetTestMessageId(',', &start_ptr);
                    GUIEDIT_SetIP(ctrl_handle, ip_addr);
                }
                else if (GUIEDIT_TYPE_DATE == edit_ctrl_ptr->type
                    || GUIEDIT_TYPE_TOUCH_DATE == edit_ctrl_ptr->type)
                {
                    year = (uint16)Atest_GetTestMessageId(',', &start_ptr);
                    month = (uint8)Atest_GetTestMessageId(',', &start_ptr);
                    day = (uint8)Atest_GetTestMessageId(',', &start_ptr);
                    GUIEDIT_SetDate(ctrl_handle, year, month, day);
                }
                else
                {
                    hour = (uint8)Atest_GetTestMessageId(',', &start_ptr);
                    minute = (uint8)Atest_GetTestMessageId(',', &start_ptr);
                    second = (uint8)Atest_GetTestMessageId(',', &start_ptr);
                    GUIEDIT_SetTime(ctrl_handle, hour, minute, second);
                }

                SCI_FREE(special_str_ptr);
            }
            break;

            // 缺省按照文本类型，直接输入字符
            default :
            {
                GUIEDIT_InsertString(ctrl_handle, fill_str_ptr, fill_str_len);
               	max_len = edit_ctrl_ptr->str_max_len-edit_ctrl_ptr->str_len;
            }
            break;
        }

        // 设置为Active，重画
        GUICTRL_SetActive((IGUICTRL_T *)edit_ctrl_ptr, TRUE);
        GUICTRL_Redraw((IGUICTRL_T *)edit_ctrl_ptr);
        SCI_FREE(fill_str_ptr);
    }
    else if (SPRD_GUI_DROPDOWNLIST_ID == ctrl_guid) // 处理下拉列表框
    {
        dropdownlist_ctrl_ptr = (CTRLDROPDOWNLIST_OBJ_T *)ctrl_ptr;
        // 获取下拉列表总长度和最大长度
		switch (dropdownlist_ctrl_ptr->ctrl_type_info.ctrl_type)
		{
			case GUIDNLIST_EDITABLE_TEXT:
			case GUIDNLIST_EDITABLE_NUMLIST:
			case GUIDNLIST_EDITABLE_PHONENUM:		
				max_len = dropdownlist_ctrl_ptr->ctrl_type_info.editable_max_text_num;
				max_num = dropdownlist_ctrl_ptr->ctrl_type_info.editable_max_listitem_num;
				if (0 != fill_str_len)
				{
					ctrl_ptr = (IGUICTRL_T *)MMK_GetCtrlPtr(dropdownlist_ctrl_ptr->edit_handle);
					edit_ctrl_ptr = (CTRLBASEEDIT_OBJ_T *)ctrl_ptr;
					
					GUIEDIT_InsertString(dropdownlist_ctrl_ptr->edit_handle, fill_str_ptr, fill_str_len);
					max_len = max_len-edit_ctrl_ptr->str_len;
				}				
				break;
			case GUIDNLIST_NORMAL:
				max_len = dropdownlist_ctrl_ptr->max_item_num;
				max_num = dropdownlist_ctrl_ptr->total_item_num;
				
				if (0 == fill_str_len) // 下界测试
				{
					GUIDROPDOWNLIST_SetMaxItem(ctrl_handle, max_len);
				}
				else // 添加列表项
				{
					//modify by linchen
					GUIEDIT_InsertString(dropdownlist_ctrl_ptr->edit_handle, fill_str_ptr, fill_str_len);
					//	GUIEDIT_MoveCursor( (CTRLBASEEDIT_OBJ_T  *)MMK_GetCtrlPtr(dropdownlist_ctrl_ptr->edit_handle),GUIEDIT_CURSOR_MOVE_RIGHT);
				}
				break;
			default:
				break;		
        }

        // 设置Active
        GUICTRL_SetActive((IGUICTRL_T *)dropdownlist_ctrl_ptr, TRUE);
    }

    // 将控件允许输入的最大长度和最多项目传回，客户端判定是否需要调整传输量
    data_len = sprintf((char *)special_data, "0,%d,%d", max_len, max_num);
    Atest_TransmitATString(special_data, data_len, FALSE, FALSE);

    return TRUE;
}

/*****************************************************************************/
//  Description:一次性删除edit输入的数据
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_ClearAllStr(  uint8 *user_data_ptr)
{
	uint8 *start_ptr = user_data_ptr;
	uint32 ctrl_id;
	MMI_HANDLE_T win_handle;
	MMI_HANDLE_T ctrl_handle;	
	CAF_GUID_T ctrl_guid;
	IGUICTRL_T *ctrl_ptr = PNULL;
	CTRLDROPDOWNLIST_OBJ_T *dropdownlist_ctrl_ptr = PNULL;
	
    ctrl_id = Atest_GetTestMessageId(',', &start_ptr);
	
    // 获取焦点窗体handle
    win_handle = MMK_GetFocusWinHandle();
    // 从焦点窗体搜索与客户端控件ID相同的控件
    ctrl_ptr = MMK_GetCtrlPtrByWin(win_handle, ctrl_id);
    if (PNULL == ctrl_ptr)
    {
        return;
    }

	ctrl_handle = GUICTRL_GetCtrlHandle(ctrl_ptr);
	ctrl_guid = GUICTRL_GetCtrlGuid(ctrl_ptr);

	if ((SPRD_GUI_EDITBOX_ID == ctrl_guid) 
		|| (SPRD_GUI_TEXTEDIT_ID == ctrl_guid) 
		|| (SPRD_GUI_PHONENUMEDIT_ID == ctrl_guid) 
		|| (SPRD_GUI_DIGITALEDIT_ID == ctrl_guid) 
		|| (SPRD_GUI_PSWEDIT_ID == ctrl_guid) 
		|| (SPRD_GUI_LISTEDIT_ID == ctrl_guid) )// 处理编辑框
    {
    	if(!GUIEDIT_ClearAllStr(ctrl_handle))
		{
			return;
		}
	}
	else if (SPRD_GUI_DROPDOWNLIST_ID == ctrl_guid)
	{
		
		dropdownlist_ctrl_ptr = (CTRLDROPDOWNLIST_OBJ_T *)ctrl_ptr;
		if(!GUIEDIT_ClearAllStr(dropdownlist_ctrl_ptr->edit_handle))
		{
			return;
		}
	}
	else
	{
		return;
	}	
}

/*****************************************************************************/
//  Description: 遍历控件树，提取控件属性描述，传回PC端
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL void Atest_TravelControlTree(
    MMI_TREE_NODE_T *root_ptr, // 控件树根节点
    uint8 *data_ptr,           // 传回PC端的数据
    uint32 *data_size_ptr)     // 累计传输的数据大小
{
    IGUICTRL_T *ctrl_ptr = PNULL;
    MMI_TREE_NODE_T *find_node_ptr = root_ptr;

    // 从控件树根开始搜索
    if (PNULL == root_ptr)
    {
        return ;
    }

    // 递归遍历窗体控件
    do {
        // 通过控件节点获取控件指针
        ctrl_ptr = MMK_GetCtrlPtr(find_node_ptr->data);
        // 控件起始属性标记 <EDITBOX>
        Atest_GetControlProperty(ctrl_ptr, FALSE, data_ptr, data_size_ptr);

        // 先遍历子节点
        if (PNULL != find_node_ptr->child_ptr)
        {
            Atest_TravelControlTree(find_node_ptr->child_ptr, data_ptr, data_size_ptr);
            // 获取控件结束标记 </EDITBOX>
            Atest_GetControlProperty(ctrl_ptr, TRUE, data_ptr, data_size_ptr);
        }
        else
        {
            // 获取控件结束标记 </EDITBOX>
            Atest_GetControlProperty(ctrl_ptr, TRUE, data_ptr, data_size_ptr);
        }

        // 再遍历兄弟节点
        find_node_ptr = find_node_ptr->next_ptr;
    } while (find_node_ptr != root_ptr);
}

/*****************************************************************************/
//  Description: 获取指定控件的数据，返回满足客户端要求的内容、长度和校验信息
//               AT+SFTIN="IGCD,393435,0,20" -> 00314E2D,4,16
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetControlData( // 提取控件数据失败，返回FALSE
    uint8 *user_data_ptr)           // 客户端发出的提取指令
{
    uint16 trans_start = 0, trans_len = 0, check_len = 0, list_item_num = 0, year;
    uint8 special_data[16] = { 0 }, *start_ptr = user_data_ptr;
    uint8 month, day, hour, miniute, second;
    int32 check_sum = 0;
    MMI_STRING_T ctrl_str = { 0 };

    MMI_CTRL_ID_T ctrl_id;
    CAF_GUID_T ctrl_guid;
    MMI_HANDLE_T win_handle;
	MMI_HANDLE_T ctrl_handle;

    IGUICTRL_T *ctrl_ptr = PNULL;
    CTRLBASEEDIT_OBJ_T *edit_ctrl_ptr = PNULL;
    CTRLDROPDOWNLIST_OBJ_T *dropdownlist_ctrl_ptr = PNULL;
    GUIEDIT_LIST_ITEM_STR_T *item_array_ptr = PNULL;
	CTRLLIST_OBJ_T *list_ctrl_ptr = PNULL;
	GUILIST_ITEM_DATA_T* item_data_ptr = PNULL;
	const CTRLLIST_ITEM_T *list_item_ptr = PNULL;
	CTRLLABEL_OBJ_T *label_ctrl_ptr = PNULL;


    // 获取需要传输控件ID，数据传输起点，数据传输长度
    ctrl_id = Atest_GetTestMessageId(',', &start_ptr);
    trans_start = Atest_GetTestMessageId(',', &start_ptr);
    trans_len = Atest_GetTestMessageId(',', &start_ptr);

    // 从焦点窗体查指定ID的目标控件
    win_handle = MMK_GetFocusWinHandle();
    ctrl_ptr = MMK_GetCtrlPtrByWin(win_handle, ctrl_id);
    if (PNULL == ctrl_ptr)
    {
        return FALSE;
    }

	ctrl_handle = GUICTRL_GetCtrlHandle(ctrl_ptr);
    ctrl_guid = GUICTRL_GetCtrlGuid(ctrl_ptr);
    // 通过GUID判定需要处理的目标控件
    if (SPRD_GUI_TEXTEDIT_ID == ctrl_guid) // 处理编辑框
    {
        edit_ctrl_ptr = (CTRLBASEEDIT_OBJ_T *)ctrl_ptr;

        switch (edit_ctrl_ptr->type)
        {
            // 处理列表类型
			case GUIEDIT_TYPE_TEXT:
            case GUIEDIT_TYPE_LIST :
            {
                // 判定传输起点是否超越列表项目边界
                list_item_num = edit_ctrl_ptr->total_line_num;
                if (trans_start >= list_item_num)
                {
                    return FALSE;
                }

                // 存放所有列表项的结构
                item_array_ptr = (GUIEDIT_LIST_ITEM_STR_T *)SCI_ALLOC_APP(
                    sizeof(GUIEDIT_LIST_ITEM_STR_T) * list_item_num);
                SCI_MEMSET(item_array_ptr, 0, sizeof(GUIEDIT_LIST_ITEM_STR_T) * list_item_num);
                // 取回所有列表项
                GUIEDIT_GetListItemString(ctrl_handle, list_item_num, item_array_ptr);
                // 返回客户指定的列表项
                ctrl_str.wstr_ptr = item_array_ptr[trans_start].str_ptr;
                ctrl_str.wstr_len = item_array_ptr[trans_start].str_len;
                trans_len = ctrl_str.wstr_len;
                // 每个列表项的数据都是从0开始传，所以trans_start=0
                trans_start = 0;
            }
            break;

            // 对于时间的数据，由H，M，S构成
            case GUIEDIT_TYPE_TIME :
            case GUIEDIT_TYPE_TOUCH_TIME :
            // 对于日期的数据，由Y，M，D构成
            case GUIEDIT_TYPE_DATE :
            case GUIEDIT_TYPE_TOUCH_DATE :
            // IP是一个uint32类型
            case GUIEDIT_TYPE_IP :
            {
                if (GUIEDIT_TYPE_IP == edit_ctrl_ptr->type)
                {
                    trans_len = sprintf((char *)special_data, "%u", GUIEDIT_GetIP(ctrl_id));
                }
                else if ( (GUIEDIT_TYPE_DATE == edit_ctrl_ptr->type)
                    || (GUIEDIT_TYPE_TOUCH_DATE == edit_ctrl_ptr->type) )
                {
                    GUIEDIT_GetDate(ctrl_handle, &year, &month, &day);
                    trans_len = sprintf((char *)special_data, "%d,%d,%d", year, month, day);
                }
                else
                {
                    GUIEDIT_GetTime(ctrl_handle, &hour, &miniute, &second);
                    trans_len = sprintf((char *)special_data, "%d,%d,%d", hour, miniute, second);
                }
            }
            break;

            default :
            {
                GUIEDIT_GetString(ctrl_handle, &ctrl_str);
                // 如果传输起点超过文本长度，则返回失败
                if (trans_start > ctrl_str.wstr_len)
                {
                    return FALSE;
                }
                else if (trans_start + trans_len > ctrl_str.wstr_len)
                {   // 如果“传输起点 + 传输长度”超过文本长度则截断，只传输有数据的部分
                    trans_len = ctrl_str.wstr_len - trans_start;
                }
            }
            break;
        }

        // 设置传回客户端的文本数据起点
        ctrl_str.wstr_ptr = ctrl_str.wstr_ptr + trans_start;
    }
    else if (SPRD_GUI_DROPDOWNLIST_ID == ctrl_guid) // 处理下拉列表
    {
        dropdownlist_ctrl_ptr = (CTRLDROPDOWNLIST_OBJ_T *)ctrl_ptr;	
		switch (dropdownlist_ctrl_ptr->ctrl_type_info.ctrl_type)
		{
			case GUIDNLIST_NORMAL:
				ctrl_str.wstr_ptr = (dropdownlist_ctrl_ptr->all_item_ptr+trans_start)->wstr_ptr;
				ctrl_str.wstr_len = (dropdownlist_ctrl_ptr->all_item_ptr+trans_start)->wstr_len;
        		// 处理无效传输起点
				if ( trans_start > dropdownlist_ctrl_ptr->total_item_num )
        		{
           			 return FALSE;
       			 }
        		else // 设置传输长度为文本长度，因为列表项长度有限
       			{
            		trans_len = ctrl_str.wstr_len;
       			}
				break;
			case GUIDNLIST_EDITABLE_TEXT:
			case GUIDNLIST_EDITABLE_NUMLIST:
			case GUIDNLIST_EDITABLE_PHONENUM:		
				GUIEDIT_GetString(dropdownlist_ctrl_ptr->edit_handle, &ctrl_str);
				// 如果传输起点超过文本长度，则返回失败
				if (trans_start > ctrl_str.wstr_len)
				{
					return FALSE;
				}
				else if (trans_start + trans_len > ctrl_str.wstr_len)
				{   // 如果“传输起点 + 传输长度”超过文本长度则截断，只传输有数据的部分
					trans_len = ctrl_str.wstr_len - trans_start;
				}
				// 设置传回客户端的文本数据起点
				ctrl_str.wstr_ptr = ctrl_str.wstr_ptr + trans_start;
				break;
			default:
				break;		
		} 
	}
	else if(SPRD_GUI_LIST_ID == ctrl_guid)	//add by lin.chen
	{
	//	trans_start为index; trans_len为content index;			
		list_ctrl_ptr = (CTRLLIST_OBJ_T *)ctrl_ptr;

		if(trans_start >= list_ctrl_ptr->total_item_num)
		{
			return FALSE;		
		}	
		
		list_item_ptr = CTRLLIST_GetItem(ctrl_handle, trans_start);
		if (PNULL == list_item_ptr)
		{
			return FALSE;
		}
		
		item_data_ptr = list_item_ptr->data_ptr;
		if(PNULL == item_data_ptr)
		{
			return FALSE;
		}
		
		if(GUIITEM_DATA_TEXT_ID == item_data_ptr->item_content[trans_len].item_data_type)
		{
			MMITHEME_GetResText(item_data_ptr->item_content[trans_len].item_data.text_id, ctrl_handle, &ctrl_str);
		}
		else if(GUIITEM_DATA_TEXT_BUFFER == item_data_ptr->item_content[trans_len].item_data_type)
		{
			ctrl_str.wstr_ptr = item_data_ptr->item_content[trans_len].item_data.text_buffer.wstr_ptr;
			ctrl_str.wstr_len = item_data_ptr->item_content[trans_len].item_data.text_buffer.wstr_len;
		}
		else
		{
			return FALSE;
		}
		trans_len = ctrl_str.wstr_len;
	}
	else if(SPRD_GUI_LABEL_ID == ctrl_guid) //add by lin.chen
	{
		label_ctrl_ptr = (CTRLLABEL_OBJ_T	*)ctrl_ptr;
		GUILABEL_GetText(ctrl_handle,&ctrl_str);
		trans_len = ctrl_str.wstr_len;
	}

    if (ctrl_str.wstr_len > 0)  // 传输需要转码的部分
    {
        // 转为UNICODE传输，因为数据存在转码，长度较大，所以需要校验正确性
        // 一个UNICODE编码2个字节，转换为十六进制字符4个字节，乘以2
        check_sum = Atest_TransmitATString((uint8 *)ctrl_str.wstr_ptr, trans_len << 1, TRUE, TRUE);
        // 一个UNICODE字符转换为4个十六进制字符，宽字符长乘以4
        check_len = sprintf((char *)special_data, ",%d,%d,%d", ctrl_str.wstr_len, trans_len << 2, check_sum);
        // 传输长度不需要转换为UNICODE和校验
        Atest_TransmitATString((uint8 *)special_data, check_len, FALSE, FALSE);
    }
    else // 传输不需要转码的数据
    {
        // 需要校验数据正确性
        check_sum = Atest_TransmitATString(special_data, trans_len, FALSE, TRUE);
        check_len = sprintf((char *)special_data, ",%d,%d", trans_len, check_sum);
        Atest_TransmitATString(special_data, check_len, FALSE, FALSE);
    }

    if (item_array_ptr)
    {
        SCI_FREE(item_array_ptr);
    }

    return TRUE;
}

/*****************************************************************************/
//  Description: 遍历窗体
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL void Atest_TravelWindowTree(
    MMI_TREE_NODE_T *root_ptr, // 窗体树根节点
    MMI_TREE_NODE_T *next_ptr,
    uint8 *data_ptr,           // 传回PC端的数据
    uint32 *data_size_ptr)     // 累计传输的数据大小
{
    MMI_TREE_NODE_T *find_node_ptr = root_ptr;
    MMI_TREE_NODE_T *ctrl_tree_root_ptr = PNULL;
    uint16 data_len = 0;
    GUI_RECT_T rect = { 0 };

    // 从树根开始搜索
    if (PNULL == root_ptr)
    {
        return;
    }

    // 递归遍历窗体
    do {
        ctrl_tree_root_ptr = MMK_GetCtrlTreeRootByWin(find_node_ptr->data);

		rect = MMITHEME_GetClientRectEx(find_node_ptr->data);
        data_len = sprintf((char *)data_ptr, "<window id='%d' rect='%d %d %d %d'>",
            MMK_GetWinId(find_node_ptr->data), rect.left, rect.top, rect.right, rect.bottom);
        Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	*data_size_ptr += data_len;
		if (ctrl_tree_root_ptr)
		{
			// 存在子控件的情况下，遍历控件树
			Atest_TravelControlTree(ctrl_tree_root_ptr, data_ptr, data_size_ptr);
		}

        // 先遍历子节点
        if (PNULL != find_node_ptr->child_ptr)
        {
            Atest_TravelWindowTree(find_node_ptr->child_ptr, next_ptr, data_ptr, data_size_ptr);
        }

		data_len = sprintf((char *)data_ptr, "</window>");
		Atest_TransmitATString(data_ptr, 9, FALSE, FALSE);
		*data_size_ptr += 9;

        // 再遍历兄弟节点
        find_node_ptr = find_node_ptr->next_ptr;

        if (next_ptr == find_node_ptr)
        {
            break;
        }
    } while (find_node_ptr != root_ptr);
}

/*****************************************************************************/
//  Description: 递归焦点窗体控件树，获取控件属性，传回PC端，加上总长度校验
//               AT+SFTIN="IGCT" -> <EDITBOX id='393435' type='TEXT' maxLen='612' maxNum='0'></EDITBOX>,67
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetControlTree( // 取到控件内容，返回TRUE
    uint8 *user_data_ptr)           // 客户端的提取控件属性指令
{
	uint8 *data_ptr = PNULL;
    uint16 trans_size = 0;
    uint32 total_trans_size = 0;

    MMI_HANDLE_T win_handle = 0;
	MMI_TREE_NODE_T *win_tree_ptr = PNULL;

	//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_GetControlTree"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_4298_112_2_18_1_59_33_29,(uint8*)"");

    // 传输控件树的缓冲区，最大设置为4KB，输入控件量不大
    data_ptr = (uint8 *)SCI_ALLOC_APP(4096);
    if (PNULL == data_ptr)
    {
        return FALSE;
    }

    SCI_MEMSET(data_ptr, 0, 4096);

	win_handle = MMK_GetTopmostWindow();
    win_tree_ptr = MMK_GetWinTreeNode(win_handle);
    Atest_TravelWindowTree(win_tree_ptr, win_tree_ptr->next_ptr, data_ptr, &total_trans_size);

    // 因为传输数据量较大，传回总长度，进行数据传输校验
    trans_size = sprintf((char *)data_ptr, ",%d", total_trans_size);
    // 不需要UNICODE转换和逐个数据校验
    Atest_TransmitATString(data_ptr, trans_size, FALSE, FALSE);

    SCI_FREE(data_ptr);

    return TRUE;
}
/*****************************************************************************/
//  Description: 解析客户端AT指令，调用不同处理逻辑
//  Global resource dependence :
//  Author: xiaolei.zheng
//  Note: 
/*****************************************************************************/
LOCAL BOOLEAN Atest_HandleControlInput( // 用户命令处理无错，返回TRUE
    uint8 *user_data_ptr,               // 用户发过来的AT命令
    uint32 len)
{
	ATEST_SIGNAL_TYPE_E signalType = ATEST_SIGNAL_NONE;
	
	if (strncmp((char *)user_data_ptr, "GCT", 3) == 0)
    {
        signalType = ATEST_SIGNAL_IGCT;
    }
    else if (strncmp((char *)user_data_ptr, "GCD", 3) == 0)
    {
        signalType = ATEST_SIGNAL_IGCD;
    }
    else if (strncmp((char *)user_data_ptr, "FCD", 3) == 0)	
    {
       	signalType = ATEST_SIGNAL_IFCD;
    }
	else if (strncmp((char *)user_data_ptr, "SCP", 3) == 0) //add by lin.chen
    {
		signalType = ATEST_SIGNAL_ISCP;
    }
	else if (strncmp((char *)user_data_ptr, "GCR", 3) == 0)//add by lin.chen
    {
		signalType = ATEST_SIGNAL_IGCR;
	}
	else if (strncmp((char *)user_data_ptr, "GCL", 3) == 0)//add by lin.chen
    {
		signalType = ATEST_SIGNAL_IGCL;
    }
	else if (strncmp((char *)user_data_ptr, "GLN", 3) == 0)//add by lin.chen
    {
		signalType = ATEST_SIGNAL_IGLN;
    }
	else if (strncmp((char *)user_data_ptr, "RIW", 3) == 0)//add by lin.chen
    {
		signalType = ATEST_SIGNAL_IRIW;		
	}
	else if (strncmp((char *)user_data_ptr, "CES", 3) == 0)//add by lin.chen
    {
		signalType = ATEST_SIGNAL_ICES;		
	}
	else if (strncmp((char *)user_data_ptr, "TPR", 3) == 0)//add by lin.chen
    {
		signalType = ATEST_SIGNAL_ITPR;		
	}
	else if (strncmp((char *)user_data_ptr, "TPD", 3) == 0)//add by lin.chen
    {
		signalType = ATEST_SIGNAL_ITPD;		
	}
	else if (strncmp((char *)user_data_ptr, "TPM", 3) == 0)//add by lin.chen
    {
		signalType = ATEST_SIGNAL_ITPM;		
	}
	else if (strncmp((char *)user_data_ptr, "TPU", 3) == 0)//add by lin.chen
    {
		signalType = ATEST_SIGNAL_ITPU;		
	}
	else if (strncmp((char *)user_data_ptr, "KBD", 3) == 0)//add by lin.chen
    {
		signalType = ATEST_SIGNAL_IKBD;		
	}
	else if (strncmp((char *)user_data_ptr, "GCS", 3) == 0)//add by lin.chen
    {
		signalType = ATEST_SIGNAL_IGCS;			
	}
	else if (strncmp((char *)user_data_ptr, "SAT", 3) == 0)//在闹钟时间设置界面，设置闹钟时间
	{
		signalType = ATEST_SIGNAL_ISAT;			
	}
	else if (strncmp((char *)user_data_ptr, "GST", 3) == 0)//获得当前手机的系统时间
	{
		signalType = ATEST_SIGNAL_IGST;			
	}
	else if (strncmp((char *)user_data_ptr, "GAT", 3) == 0)//获得最近的闹钟时间
	{
		signalType = ATEST_SIGNAL_IGAT;			
	}
	else if (strncmp((char *)user_data_ptr, "CCD", 3) == 0)//点击日历上的某个日期
	{
		signalType = ATEST_SIGNAL_ICCD;		
	}
	else if (strncmp((char *)user_data_ptr, "CAL", 3) == 0)//获得计算器计算数据
	{
		signalType = ATEST_SIGNAL_ICAL;		
	}	
    else
    {
        return FALSE;
    }

	//SCI_TRACE_LOW:"[AT][ATEST]:Atest_HandleControlInput--signalType=0x%x"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_4391_112_2_18_1_59_33_30,(uint8*)"d",signalType);
	Atest_SendSignalToAppTask(user_data_ptr,len,0,signalType);
	return TRUE;	
}

/*****************************************************************************/
//  Description: 获取控件RichText描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetRichTextControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	uint16 i,data_len = 0; 
	uint16 user_data_len = 0;
	wchar *user_data_ptr = NULL;
	GUIRICHTEXT_ITEM_T richedit_item = { 0 };
	CTRLRICHTEXT_OBJ_T *richtext_ptr = PNULL;
	
	richtext_ptr = (CTRLRICHTEXT_OBJ_T *)ctrl_ptr;
	if(PNULL == richtext_ptr)
	{
		return;
	}
	
	for (i = 0; ; i++)
    {
        if(!CTRLRICHTEXT_GetItem(ctrl_handle, i, &richedit_item))
        {
			break;
		}
		
		if ( (GUIRICHTEXT_TEXT_INVALID == richedit_item.text_type ) && (GUIRICHTEXT_IMAGE_INVALID == richedit_item.img_type) )
        {
            break;
        }		
	}
	
	data_len = sprintf((char *)data_ptr, 
		"<%s id='%d' totalnum='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr, ctrl_id,i,
		richtext_ptr->base_ctrl.rect.left,richtext_ptr->base_ctrl.rect.top,
		richtext_ptr->base_ctrl.rect.right,richtext_ptr->base_ctrl.rect.bottom);
    Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
    *data_size_ptr += data_len;
	
    for (i = 0; ; i++)
    {
		SCI_MEMSET(&richedit_item, 0, sizeof(GUIRICHTEXT_ITEM_T));
        if(!CTRLRICHTEXT_GetItem(ctrl_handle, i, &richedit_item))
        {
			break;
		}
		
		if ( (GUIRICHTEXT_TEXT_INVALID == richedit_item.text_type ) && (GUIRICHTEXT_IMAGE_INVALID == richedit_item.img_type) )
        {
            break;
        }
		
		data_len = sprintf((char *)data_ptr,"<item imgid='%d' index='%d'>",richedit_item.img_data.res.id,i);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
        
		if(GUIRICHTEXT_TEXT_RES == richedit_item.text_type || GUIRICHTEXT_TEXT_BUF == richedit_item.text_type)
		{
			user_data_ptr = richedit_item.text_data.buf.str_ptr;
			user_data_len = richedit_item.text_data.buf.len;	     
			
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';	    
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;
		}
		
		data_len = sprintf((char *)data_ptr, "</item>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
    }
}

/*****************************************************************************/
//  Description: 获取控件Anim描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetAnimControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	uint16 data_len = 0; 
	CTRLANIM_OBJ_T  *anim_ctrl_ptr = PNULL;
	MMI_IMAGE_ID_T user_data_id = 0;

	anim_ctrl_ptr = (CTRLANIM_OBJ_T  *)ctrl_ptr;
	if(PNULL == anim_ctrl_ptr)
	{
		return;
	}

	if(anim_ctrl_ptr->data_info.anim_id)
	{
		 user_data_id = anim_ctrl_ptr->data_info.anim_id;
	}
	else
	{
		 user_data_id = anim_ctrl_ptr->data_info.img_id;
	}

	data_len = sprintf((char *)data_ptr,
		"<%s id='%d' visible='%d' focus='%d' type='%d' imgid='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr,ctrl_id,
		anim_ctrl_ptr->is_visible,anim_ctrl_ptr->is_focus,
		anim_ctrl_ptr->type,user_data_id,
		anim_ctrl_ptr->base_ctrl.rect.left,anim_ctrl_ptr->base_ctrl.rect.top,
		anim_ctrl_ptr->base_ctrl.rect.right,anim_ctrl_ptr->base_ctrl.rect.bottom);
	  Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	  *data_size_ptr += data_len;
}


/*****************************************************************************/
//  Description: 获取PrgBox控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetPrgBoxControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	 uint16 j,data_len = 0; 
	 uint16 user_data_len = 0;
	 wchar *user_data_ptr = NULL;
	 CTRLPROGRESSBAR_OBJ_T *prgbox_ctrl_ptr = PNULL;
	 wchar letter_arr[MAX_CMD_LEN] = { 0 };

	 prgbox_ctrl_ptr = (CTRLPROGRESSBAR_OBJ_T *)ctrl_ptr;
	 if (PNULL == prgbox_ctrl_ptr)
	 {
		 return;
	 }

     data_len = sprintf((char *)data_ptr, 
		"<%s id='%d' style='%d' themetype='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr,ctrl_id,prgbox_ctrl_ptr->prgbox_style,
		prgbox_ctrl_ptr->theme_type,
		prgbox_ctrl_ptr->base_ctrl.rect.left,prgbox_ctrl_ptr->base_ctrl.rect.top,
		prgbox_ctrl_ptr->base_ctrl.rect.right,prgbox_ctrl_ptr->base_ctrl.rect.bottom);
     Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
     *data_size_ptr += data_len;

	switch (prgbox_ctrl_ptr->prgbox_style)
	{
		case GUIPRGBOX_STYLE_VERTICAL_SCROLL:       /*!< 纵向滚动条 */
			data_len = sprintf((char *)data_ptr, 
				"<ver_scroll is_loop='%d' upid='%d' upfocusid='%d' downid='%d' downfocusid='%d' barid='%d' grooveid='%d'></ver_scroll>", 
				prgbox_ctrl_ptr->is_loop_scroll,
				prgbox_ctrl_ptr->ver_scroll_theme.up_arrow_id,
				prgbox_ctrl_ptr->ver_scroll_theme.up_focus_arrow_id,
				prgbox_ctrl_ptr->ver_scroll_theme.down_arrow_id,
				prgbox_ctrl_ptr->ver_scroll_theme.down_focus_arrow_id,
				prgbox_ctrl_ptr->ver_scroll_theme.scroll_bar_id,
				prgbox_ctrl_ptr->ver_scroll_theme.groove_bg_id);
	        Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	        *data_size_ptr += data_len;					
			break;
	    case GUIPRGBOX_STYLE_HORIZONTAL_SCROLL:      /*!< 横向滚动条 */ 
			data_len = sprintf((char *)data_ptr, 
				"<hor_scroll isloop='%d' leftid='%d' leftfocusid='%d' rightid='%d' rightfocusid='%d' barid='%d' grooveid='%d'></hor_scroll>", 
				prgbox_ctrl_ptr->is_loop_scroll,
				prgbox_ctrl_ptr->hor_scroll_theme.left_arrow_id,
				prgbox_ctrl_ptr->hor_scroll_theme.left_focus_arrow_id,
				prgbox_ctrl_ptr->hor_scroll_theme.right_arrow_id,
				prgbox_ctrl_ptr->hor_scroll_theme.right_focus_arrow_id,
				prgbox_ctrl_ptr->hor_scroll_theme.scroll_bar_id,
				prgbox_ctrl_ptr->hor_scroll_theme.groove_bg_id);
	        Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	        *data_size_ptr += data_len;	
			break; 
	    case GUIPRGBOX_STYLE_VERTICAL_PROCESS:  
	    case GUIPRGBOX_STYLE_HORIZONTAL_PROCESS:     /*!<进度条 */ 
			data_len = sprintf((char *)data_ptr, 
				"<process_theme bgtype='%d' fgcolor='%d' bgcolor='%d'></process_theme>", 
				prgbox_ctrl_ptr->process_theme.bg_type,
				prgbox_ctrl_ptr->process_theme.fg_color,
				prgbox_ctrl_ptr->process_theme.bg_color);
	        Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	        *data_size_ptr += data_len;	
			break; 
	    case GUIPRGBOX_STYLE_VERTICAL_WINDOWS:       /*!< 保留 */ 
	    case GUIPRGBOX_STYLE_HORIZONTAL_WINDOWS:     /*!< 保留 */
			break;
		case GUIPRGBOX_STYLE_LETTERS_SCROLL:     /*字母滚动条*/
			data_len = sprintf((char *)data_ptr, 
				"<letter totalnum='%d' curindex='%d' postion='%d'></letter>", 
				prgbox_ctrl_ptr->total_item_num,
				prgbox_ctrl_ptr->cur_item_index,
				*(prgbox_ctrl_ptr->letter_postion_table));
	        Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	        *data_size_ptr += data_len;

			for(j=0;j<prgbox_ctrl_ptr->total_item_num;j++)
			{
				letter_arr[j]=GUIPRGBOX_GetWcharByPos((IGUICTRL_T *)prgbox_ctrl_ptr, j);
			}
			letter_arr[j]=L'\0';

			user_data_ptr = letter_arr;
			user_data_len = j;
			if (user_data_len != 0)
			{
		    	SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;									
			break;
		default:
			break;
	}
}

/*****************************************************************************/
//  Description: 获取Text控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetTextControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	uint16 data_len = 0; 
	uint16 user_data_len = 0;
	wchar *user_data_ptr = NULL;
	MMI_STRING_T text_ptr = { 0 };
	CTRLTEXT_OBJ_T	*text_ctrl_ptr = PNULL;

	text_ctrl_ptr = (CTRLTEXT_OBJ_T *)ctrl_ptr;
	if(PNULL == text_ctrl_ptr)
	{
		return;
	}	

    data_len = sprintf((char *)data_ptr,
		"<%s id='%d' active='%d' pagelinenum='%d' totallinenum='%d' topline='%d' bottomline='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr,ctrl_id,text_ctrl_ptr->base_ctrl.is_active,
		text_ctrl_ptr->page_line_num,text_ctrl_ptr->total_line_num,
		text_ctrl_ptr->top_line_index,text_ctrl_ptr->bottom_line_index,
		text_ctrl_ptr->base_ctrl.rect.left,text_ctrl_ptr->base_ctrl.rect.top,
		text_ctrl_ptr->base_ctrl.rect.right,text_ctrl_ptr->base_ctrl.rect.bottom);
    Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
    *data_size_ptr += data_len;

	GUITEXT_GetString(ctrl_handle,&text_ptr);
	user_data_ptr = text_ptr.wstr_ptr;
	user_data_len = text_ptr.wstr_len;
	
	if (user_data_len != 0)
	{
		SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
	}
	user_item_ptr[user_data_len] = L'\0';
	Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
	*data_size_ptr += user_data_len * 4;
}

/*****************************************************************************/
//  Description: 获取Lable控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetLableControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	 uint16 data_len = 0; 
	 uint16 user_data_len = 0;
	 wchar 	*user_data_ptr = NULL;
	 MMI_STRING_T text_ptr = {0};
	 CTRLLABEL_OBJ_T *label_ctrl_ptr = PNULL;
	 
	 label_ctrl_ptr = (CTRLLABEL_OBJ_T	*)ctrl_ptr;
	 if(PNULL == label_ctrl_ptr)
	 {
		return;
	 }

     data_len = sprintf((char *)data_ptr, 
		"<%s id='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr,ctrl_id,
		label_ctrl_ptr->base_ctrl.rect.left,label_ctrl_ptr->base_ctrl.rect.top,
		label_ctrl_ptr->base_ctrl.rect.right,label_ctrl_ptr->base_ctrl.rect.bottom);
     Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
     *data_size_ptr += data_len;

	 GUILABEL_GetText(ctrl_handle,&text_ptr);
	 user_data_ptr = text_ptr.wstr_ptr;
	 user_data_len = text_ptr.wstr_len;	
	 if (user_data_len != 0)
	 {
	 	SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
	 }
	 user_item_ptr[user_data_len] = L'\0';
	 Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
	 *data_size_ptr += user_data_len * 4;                                
}

/*****************************************************************************/
//  Description: 获取MsgBox控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetMsgBoxControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	uint16 data_len = 0; 
	wchar *user_data_ptr = NULL;
	uint16 user_data_len = 0;

	CTRLMSGBOX_OBJ_T* msgbox_ptr = PNULL;
	uint32 i=0;
	uint32 image_id = 0;

	msgbox_ptr = (CTRLMSGBOX_OBJ_T*)ctrl_ptr;
	if(PNULL == msgbox_ptr)
	{
		return;
	}

	data_len = sprintf((char *)data_ptr, 
		"<%s id='%d' focus='%d' active='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr,ctrl_id,msgbox_ptr->is_focus,msgbox_ptr->is_active,
		msgbox_ptr->base_ctrl.rect.left,msgbox_ptr->base_ctrl.rect.top,
		msgbox_ptr->base_ctrl.rect.right,msgbox_ptr->base_ctrl.rect.bottom);
    Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
    *data_size_ptr += data_len;

	data_len = sprintf((char *)data_ptr,"<item>");
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	*data_size_ptr += data_len;

	if(GUIMSGBOX_IMAGE_ANIMA == msgbox_ptr->image_type || 
		GUIMSGBOX_IMAGE_BMP == msgbox_ptr->image_type)
	{
	 	if(GUIMSGBOX_IMAGE_ANIMA == msgbox_ptr->image_type)
		{
			image_id = msgbox_ptr->anim_id;
		}
		else 
		{
			image_id = msgbox_ptr->image_id;
		}
		data_len = sprintf((char *)data_ptr,
			"<image id='%d' rect='%d %d %d %d'></image>",
			msgbox_ptr->anim_id,
			msgbox_ptr->image_rect.left,msgbox_ptr->image_rect.bottom,
			msgbox_ptr->image_rect.right,msgbox_ptr->image_rect.top);
	     Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	     *data_size_ptr += data_len;
	}

	if(PNULL != msgbox_ptr->text_info.string.wstr_ptr)
	{
		data_len = sprintf((char *)data_ptr,
			"<text rect='%d %d %d %d'>",
			msgbox_ptr->text_info.text_rect.left,
			msgbox_ptr->text_info.text_rect.bottom,
			msgbox_ptr->text_info.text_rect.right,
			msgbox_ptr->text_info.text_rect.top);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
		
		user_data_ptr = msgbox_ptr->text_info.string.wstr_ptr;
		user_data_len = msgbox_ptr->text_info.string.wstr_len;
		if (user_data_len != 0)
		{
			SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
		}
		user_item_ptr[user_data_len] = L'\0';
		Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
		*data_size_ptr += user_data_len * 4; 
		data_len = sprintf((char *)data_ptr,"</text>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
	}

	if(msgbox_ptr->title_text_id)
	{
		data_len = sprintf((char *)data_ptr,
			"<title id='%d'></title>",
			msgbox_ptr->title_text_id);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
	}

	for(i=0;i<GUISOFTKEY_BUTTON_NUM;i++)
	{
		if(msgbox_ptr->softkey_id[i])
		{
			data_len = sprintf((char *)data_ptr,
				"<softkey id='%d' rect='%d %d %d %d'></softkey>",
				msgbox_ptr->softkey_id[i],
				msgbox_ptr->sk_rect.left,
				msgbox_ptr->sk_rect.bottom,
				msgbox_ptr->sk_rect.right,
				msgbox_ptr->sk_rect.top);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
		}
	}

	data_len = sprintf((char *)data_ptr,"</item>");
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	*data_size_ptr += data_len;
}

/*****************************************************************************/
//  Description: 获取Punctuation控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetPunctuationControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	 uint16 data_len = 0; 

	 data_len = sprintf((char *)data_ptr, "<%s id='%d'>", ctrl_name_ptr,ctrl_id);
     Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
     *data_size_ptr += data_len;
}

/*****************************************************************************/
//  Description: 获取Button控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetButtonControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	uint16 data_len = 0; 
	uint16 user_data_len = 0;
	wchar *user_data_ptr = PNULL;

	CTRLBUTTON_OBJ_T  *button_ctrl_ptr = PNULL;
	MMI_STRING_T    str_info = {0};

    button_ctrl_ptr = (CTRLBUTTON_OBJ_T *)ctrl_ptr;
	if(PNULL == button_ctrl_ptr)
	{
		return;
	}
	
    data_len = sprintf((char *)data_ptr,
		//"<%s id='%d' type='%d' gray='%d' rect='%d %d %d %d'>",
		"<%s id='%d' gray='%d' rect='%d %d %d %d'>",
		ctrl_name_ptr,ctrl_id,
		//button_ctrl_ptr->type,button_ctrl_ptr->is_gray,
		button_ctrl_ptr->is_gray,
		button_ctrl_ptr->base_ctrl.display_rect.left,button_ctrl_ptr->base_ctrl.display_rect.top,
		button_ctrl_ptr->base_ctrl.display_rect.right,button_ctrl_ptr->base_ctrl.display_rect.bottom);
    Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
    *data_size_ptr += data_len;

	if (GUISTR_TEXT_ID == button_ctrl_ptr->text_info.text_type)
    {
        MMITHEME_GetResText( button_ctrl_ptr->text_info.text_id, button_ctrl_ptr->win_handle, &str_info );
		user_data_ptr = str_info.wstr_ptr;
		user_data_len = str_info.wstr_len;	
	}
    else if (GUISTR_TEXT_BUFFER == button_ctrl_ptr->text_info.text_type)
    {
        user_data_ptr = button_ctrl_ptr->text_info.str_info.wstr_ptr;
        user_data_len = button_ctrl_ptr->text_info.str_info.wstr_len;
    }

	if(PNULL != user_data_ptr)
	{
		if (user_data_len != 0)
		{
			SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
		}
		user_item_ptr[user_data_len] = L'\0';
		Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
		*data_size_ptr += user_data_len * 4;
	}
}

/*****************************************************************************/
//  Description: 获取Iconlist控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetIconlistControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	uint16 data_len = 0; 
	uint16 user_data_len = 0;
	uint16 index_ptr = 0;
	wchar *user_data_ptr = NULL;

	CTRLICONLIST_OBJ_T  *iconlist_ctrl_ptr = PNULL;
	GUIICONLIST_ITEM_T  *item_ptr = PNULL;
	GUI_RECT_T   icon_rect={0};

	iconlist_ctrl_ptr = (CTRLICONLIST_OBJ_T  *)ctrl_ptr;
	if(PNULL == iconlist_ctrl_ptr)
	{
		return;
	}
	
    data_len = sprintf((char *)data_ptr, 
    "<%s id='%d' loadingicon='%d' totalnum='%d' selectednum='%d' rect='%d %d %d %d'>", 
    ctrl_name_ptr,ctrl_id,iconlist_ctrl_ptr->is_loading_icon,
    iconlist_ctrl_ptr->total_num,iconlist_ctrl_ptr->selected_num,
    iconlist_ctrl_ptr->base_ctrl.rect.left,iconlist_ctrl_ptr->base_ctrl.rect.top,
	iconlist_ctrl_ptr->base_ctrl.rect.right,iconlist_ctrl_ptr->base_ctrl.rect.bottom);
    Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
    *data_size_ptr += data_len;

	item_ptr = iconlist_ctrl_ptr->item_ptr;
	for(index_ptr = 0; index_ptr < iconlist_ctrl_ptr->total_num; index_ptr++)
	{
		if(PNULL == item_ptr)
		{
			break;
		}

		icon_rect = ICONLIST_GetItemRect(index_ptr,iconlist_ctrl_ptr);
		data_len = sprintf((char *)data_ptr,
			"<item selected='%d' index='%d'>",
			item_ptr->is_selected,index_ptr);
	    Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	    *data_size_ptr += data_len;

		user_data_ptr = item_ptr->text.display.name_str.wstr_ptr;
		user_data_len = item_ptr->text.display.name_str.wstr_len;
		if (user_data_len != 0)
		{
			SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
		}
		user_item_ptr[user_data_len] = L'\0';
		Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
		*data_size_ptr += user_data_len * 4;

		data_len = sprintf((char *)data_ptr,"</item>");
	    Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	    *data_size_ptr += data_len;

		item_ptr++;
	}
}

/*****************************************************************************/
//  Description: 获取TAB控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetTabControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	uint16 data_len = 0; 
	uint16 user_data_len = 0; 
	uint16 index = 0; 
	wchar *user_data_ptr = NULL;
	CTRLTAB_OBJ_T *tab_ptr = NULL;
	GUITAB_ITEM_T *item_ptr = PNULL;
	BOOL is_select = FALSE;
	MMI_IMAGE_ID_T image_id = 0;

	tab_ptr = (CTRLTAB_OBJ_T *)ctrl_ptr;
	if (PNULL == tab_ptr)
	{
		 return;
	} 
	
    data_len = sprintf((char *)data_ptr, 
		"<%s id='%d' totalnum='%d' maxnum='%d' shownum='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr,ctrl_id,tab_ptr->total_item_num,
		tab_ptr->max_item_num,tab_ptr->show_item_num,
		tab_ptr->base_ctrl.rect.left,tab_ptr->base_ctrl.rect.top,
		tab_ptr->base_ctrl.rect.right,tab_ptr->base_ctrl.rect.bottom);
    Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
    *data_size_ptr += data_len;

	item_ptr = tab_ptr->valid_item_list.item_ptr;
	if(PNULL == item_ptr)
	{
		return;
	}

	for(index=0;index<tab_ptr->valid_item_list.item_num;index++)
	{
		if(tab_ptr->cur_sel_item_index == index)
		{
			is_select = TRUE;		
		}
		else
		{
			is_select = FALSE;	
		}

		switch (item_ptr->item_data_ptr->image_data.image_data_type)
		{
			case TABITEM_DATA_IMAGE_ID:		/*!< 图片资源ID*/
				image_id = item_ptr->item_data_ptr->image_data.image_data_u.anim_data.img_id;
				break;						
		    case TABITEM_DATA_ANIM_ID:			/*!< 动画资源ID*/
				image_id = item_ptr->item_data_ptr->image_data.image_data_u.anim_data.anim_id;
				break;						
		    case TABITEM_DATA_ANIM_DATA:	/*!< 动画数据*/
		    case TABITEM_DATA_ANIM_PATH:/*!< 动画路径*/
			default:
				break;
		}

		data_len = sprintf((char *)data_ptr,
			"<item select='%d' imgid='%d' rect='%d %d %d %d'>", 
			is_select,image_id,
			item_ptr->rect.left,item_ptr->rect.top,
			item_ptr->rect.right,item_ptr->rect.bottom);
	     Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	     *data_size_ptr += data_len;
		 
		user_data_ptr = item_ptr->item_data_ptr->text_data.text.text_buffer.wstr;
		user_data_len = item_ptr->item_data_ptr->text_data.text.text_buffer.wstr_len;
		if (user_data_len != 0)
		{
			SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
		}
		user_item_ptr[user_data_len] = L'\0';
		Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
		*data_size_ptr += user_data_len * 4;

		data_len = sprintf((char *)data_ptr,"</item>");
	     Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	     *data_size_ptr += data_len;

		 item_ptr = item_ptr->next_ptr;
	}
}

/*****************************************************************************/
//  Description: 获取Edit控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetStatusBarControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	 uint16 data_len = 0; 
	 uint16 user_data_len = 0;
	 wchar *user_data_ptr = NULL;
	 uint16 item_total_num = 0;
	 uint16 item_index = 0;
	 BOOLEAN is_visible = FALSE;
	 CTRLSTATUSBAR_OBJ_T *statusbar_ptr = PNULL;
	 GUISTBDATA_ITEM_DATA_T *stb_item_ptr = PNULL;

	 statusbar_ptr = (CTRLSTATUSBAR_OBJ_T *)ctrl_ptr;
	 if (PNULL == statusbar_ptr)
	 {
		 return;
	 } 
	 item_total_num = GUISTBDATA_GetItemTotalNum();
			
     data_len = sprintf((char *)data_ptr, 
		"<%s id='%d' state='%d' shown='%d' totalnum='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr,ctrl_id,statusbar_ptr->ctrl_state,
		statusbar_ptr->is_shown,item_total_num,
		statusbar_ptr->base_ctrl.rect.left,statusbar_ptr->base_ctrl.rect.top,
		statusbar_ptr->base_ctrl.rect.right,statusbar_ptr->base_ctrl.rect.bottom);
     Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
     *data_size_ptr += data_len;
	   
	 if(statusbar_ptr->is_shown)
	 {
		 for(item_index=0;item_index<item_total_num;item_index++)
		 {
			is_visible = GUISTBDATA_IsItemVisible(item_index);
			if(is_visible)
			{
				stb_item_ptr = GUISTBDATA_GetItemData(item_index);
				if (PNULL == stb_item_ptr)
				 {
					 return;
				 } 

				data_len = sprintf((char *)data_ptr,
					"<item type='%d' imgid='%d' rect='%d %d %d %d'>",
					statusbar_ptr->ctrl_type,
					stb_item_ptr->icon_info.icon_array[stb_item_ptr->cur_frame],
					stb_item_ptr->item_rect.left,stb_item_ptr->item_rect.bottom,
					stb_item_ptr->item_rect.right,stb_item_ptr->item_rect.top);
		        Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			    *data_size_ptr += data_len;

				user_data_ptr = stb_item_ptr->text_info.wstr_ptr;
				user_data_len = stb_item_ptr->text_info.wstr_len;
				if (user_data_len != 0)
				{
					SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
				}
				user_item_ptr[user_data_len] = L'\0';
				Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
				*data_size_ptr += user_data_len * 4;
				data_len = sprintf((char *)data_ptr,"</item>");
		        Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			    *data_size_ptr += data_len;
			}
		}
	}
}

/*****************************************************************************/
//  Description: 获取im控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetIMControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
#if defined (MMI_IM_PDA_SUPPORT)
	uint16 data_len = 0; 
	CTRLIM_OBJ_T *im_ptr = PNULL;
	GUI_RECT_T  rect_ptr = {0};
	int32 key_idx = 0;
	IM_DATA_T *im_data_ptr = PNULL;
	uint16 user_data_len = 0;
	wchar *user_data_ptr = NULL;

	im_ptr = (CTRLIM_OBJ_T *)ctrl_ptr;
	if (PNULL == im_ptr)
	{
		return;
	}

	GUIIM_GetImRect(ctrl_handle,&rect_ptr);
	
	data_len = sprintf((char *)data_ptr, 
		"<%s id='%d' method='%d' lang='%d' type='%d' input='%d' capital='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr,ctrl_id,im_ptr->method_param.im_set.method,
		im_ptr->method_param.im_set.lang,im_ptr->method_param.im_set.type,
		im_ptr->method_param.im_set.input,im_ptr->method_param.im_set.capital,
		rect_ptr.left,rect_ptr.bottom,rect_ptr.right,rect_ptr.top);
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	*data_size_ptr += data_len;
	
	im_data_ptr = im_ptr->im_handle;
	if (PNULL == im_data_ptr)
	{
		return;
	}

	for (key_idx = 0; key_idx < im_data_ptr->vkb.key_cnt; key_idx++)
    {
		if(!im_data_ptr->vkb.keys[key_idx].is_hide)
		{
			data_len = sprintf((char *)data_ptr,
				"<key code='%d' imgid='%d' rect='%d %d %d %d'>",
				im_data_ptr->vkb.keys[key_idx].code,im_data_ptr->vkb.keys[key_idx].icon,
				im_data_ptr->vkb.keys[key_idx].rect.left,im_data_ptr->vkb.keys[key_idx].rect.top,
				im_data_ptr->vkb.keys[key_idx].rect.right,im_data_ptr->vkb.keys[key_idx].rect.bottom);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;

			user_data_ptr = im_data_ptr->vkb.keys[key_idx].text;
			user_data_len = im_data_ptr->vkb.keys[key_idx].text_len;			
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;
			data_len = sprintf((char *)data_ptr,"</key>");
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
		}
	}
#endif
}

/*****************************************************************************/
//  Description: 获取SetList控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetSetListControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	 uint16 data_len = 0; 
	 uint16 user_data_len = 0;
	 wchar *user_data_ptr = NULL;
	 
	 CTRLSETLIST_OBJ_T *setlist_ptr = PNULL;
	 MMI_LINK_NODE_T *next_item_info_ptr = PNULL;


	 setlist_ptr = (CTRLSETLIST_OBJ_T *)ctrl_ptr;
	 if (PNULL == setlist_ptr)
	 {
		return;
	 }
	
	 data_len = sprintf((char *)data_ptr, 
		"<%s id='%d' type='%d' valid='%d' totalnum='%d' selectedcnt='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr,ctrl_id,setlist_ptr->list_type,setlist_ptr->is_valid,
		setlist_ptr->item_info.item_total_num,setlist_ptr->selected_cnt,
		setlist_ptr->base_ctrl.rect.left,setlist_ptr->base_ctrl.rect.top,
		setlist_ptr->base_ctrl.rect.right,setlist_ptr->base_ctrl.rect.bottom);
	 Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	 *data_size_ptr += data_len;

	 next_item_info_ptr = setlist_ptr->item_info.item_head_ptr;
	 if (PNULL == next_item_info_ptr)
	 {
		return;
	 }

	user_data_ptr = setlist_ptr->disp_str.wstr_ptr;
	user_data_len = setlist_ptr->disp_str.wstr_len;
	if (user_data_len != 0)
	{
		SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
	}
	user_item_ptr[user_data_len] = L'\0';
	Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
	*data_size_ptr += user_data_len * 4;
}

/*****************************************************************************/
//  Description: 获取Form控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetFormControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	 uint16 data_len = 0; 
	 	 
	 CTRLFORM_OBJ_T  *form_ctrl_ptr = PNULL;

	 form_ctrl_ptr = (CTRLFORM_OBJ_T *)ctrl_ptr;
	 if (PNULL == form_ctrl_ptr)
	 {
		return;
	 }
	
	  data_len = sprintf((char *)data_ptr, 
		"<%s id='%d' type='%d' style='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr,ctrl_id,form_ctrl_ptr->type,form_ctrl_ptr->style,
		form_ctrl_ptr->base_ctrl.rect.left,form_ctrl_ptr->base_ctrl.rect.top,
		form_ctrl_ptr->base_ctrl.rect.right,form_ctrl_ptr->base_ctrl.rect.bottom);
	  Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	  *data_size_ptr += data_len;
}

/*****************************************************************************/
//  Description: 获取Owndraw控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetOwndrawControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	uint16 data_len = 0; 
	CTRLOWNERDRAW_OBJ_T  *owndraw_ctrl_ptr = PNULL;

    owndraw_ctrl_ptr = (CTRLOWNERDRAW_OBJ_T *)ctrl_ptr;
    if (PNULL == owndraw_ctrl_ptr)
    {
		return;
	}

	data_len = sprintf((char *)data_ptr, 
		"<%s id='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr,ctrl_id,
		owndraw_ctrl_ptr->base_ctrl.rect.left,owndraw_ctrl_ptr->base_ctrl.rect.top,
		owndraw_ctrl_ptr->base_ctrl.rect.right,owndraw_ctrl_ptr->base_ctrl.rect.bottom);
	 Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	 *data_size_ptr += data_len;
}

/*****************************************************************************/
//  Description: 获取Toolbar控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetToolbarControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
#ifdef GUIF_TOOLBAR
	uint16 data_len = 0; 
	 uint16 index = 0;
	 GUITOOLBAR_ITEM_T* toolbar_item_ptr = PNULL;
	 CTRLTOOLBAR_OBJ_T* toolbar_ptr = PNULL;
	 GUITOOLBAR_ITEM_INFO_T* item_info_ptr = PNULL;
	 MMI_STRING_T text_ptr = { 0 };
	 uint16 user_data_len = 0;
	 wchar *user_data_ptr = NULL;
	 
	 toolbar_ptr = (CTRLTOOLBAR_OBJ_T*)ctrl_ptr;
	 if(PNULL == toolbar_ptr)
	 {
		return;
	 }

	 data_len = sprintf((char *)data_ptr, 
		"<%s id='%d' showtype='%d' totalnum='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr,ctrl_id,toolbar_ptr->show_type,toolbar_ptr->total_num,
		toolbar_ptr->rect.left,toolbar_ptr->rect.top,
		toolbar_ptr->rect.right,toolbar_ptr->rect.bottom);
      Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
      *data_size_ptr += data_len;

	index = toolbar_ptr->click_index;
	item_info_ptr = toolbar_ptr->item_info_ptr;
	for(toolbar_ptr->click_index=0;toolbar_ptr->click_index<toolbar_ptr->total_num;toolbar_ptr->click_index++)
	{
		if(PNULL == item_info_ptr)
		{
			break;
		}

		toolbar_item_ptr = &(item_info_ptr->item);

		data_len = sprintf((char *)data_ptr, 
			"<item imgid='%d' textid='%d' rect='%d %d %d %d'>",
			toolbar_item_ptr->image_id, toolbar_item_ptr->text_id,
			item_info_ptr->rect.left,item_info_ptr->rect.top,
			item_info_ptr->rect.right,item_info_ptr->rect.bottom);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;

		if(toolbar_item_ptr->text_id)
		{
			MMITHEME_GetResText(toolbar_item_ptr->text_id, toolbar_ptr->win_handle,&text_ptr);
			user_data_ptr = text_ptr.wstr_ptr;
			user_data_len = text_ptr.wstr_len;
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;
		}
		data_len = sprintf((char *)data_ptr,"</item>");
 		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);            
 		*data_size_ptr += data_len; 
		
		item_info_ptr = item_info_ptr + 1;
	}
	toolbar_ptr->click_index = index;
#endif
}

/*****************************************************************************/
//  Description: 获取Edit控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetTextEditControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	uint16 data_len = 0; 
	uint16 user_data_len = 0;
	wchar *user_data_ptr = NULL;

	CTRLBASEEDIT_OBJ_T *edit_ctrl_ptr = PNULL;
	uint8 hour_ptr = 0;
	uint8 minute_ptr = 0;
	uint8 second_ptr = 0;
	uint16 year_ptr = 0;
	
	edit_ctrl_ptr = (CTRLBASEEDIT_OBJ_T *)ctrl_ptr;
	if (PNULL == edit_ctrl_ptr)
	{
		return;
	}

	switch (edit_ctrl_ptr->type)
	{
		case GUIEDIT_TYPE_TEXT:      /*!<文本编辑框*/
    	case GUIEDIT_TYPE_PHONENUM:  /*!<电话号码编辑框,[0-9,*,#]*/
    	case GUIEDIT_TYPE_DIGITAL:   /*!<数字编辑框,[0-9]*/
    	case GUIEDIT_TYPE_PASSWORD:  /*!<密码编辑框,[0-9,*,#]*/
			data_len = sprintf((char *)data_ptr, 
		     "<%s id='%d' type='%d' focus='%d' style='%d' im='%d' maxLen='%d' rect='%d %d %d %d'>",
		         ctrl_name_ptr, ctrl_id, edit_ctrl_ptr->type, edit_ctrl_ptr->base_ctrl.is_active,
		          edit_ctrl_ptr->style,
				  //edit_ctrl_ptr->add_theme.text.im.allow_im,
				  edit_ctrl_ptr->is_create_im_active,
				  edit_ctrl_ptr->str_max_len,
		         edit_ctrl_ptr->original_rect.left,edit_ctrl_ptr->original_rect.top,
		         edit_ctrl_ptr->original_rect.right,edit_ctrl_ptr->original_rect.bottom);            
		     Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);            
		     *data_size_ptr += data_len;

			 if(0 != edit_ctrl_ptr->str_len)
			 {
				 data_len = sprintf((char *)data_ptr,"<text>");
				 Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);            
				 *data_size_ptr += data_len;
				 user_data_ptr = edit_ctrl_ptr->str_ptr;
				 user_data_len = edit_ctrl_ptr->str_len;
				 if (user_data_len != 0)
				 {
				 	SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
				 }
				 user_item_ptr[user_data_len] = L'\0';

				 Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
				 *data_size_ptr += user_data_len * 4;
				 data_len = sprintf((char *)data_ptr,"</text>");
				 Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);            
				 *data_size_ptr += data_len;
			}
			break;			
		case GUIEDIT_TYPE_IP:        /*!<IP编辑框*/	
			data_len = sprintf((char *)data_ptr, 
		     "<%s id='%d' type='%d' focus='%d' style='%d' IP='%d' rect='%d %d %d %d'>",
		         ctrl_name_ptr, ctrl_id, edit_ctrl_ptr->type, edit_ctrl_ptr->base_ctrl.is_active,
		          edit_ctrl_ptr->style,GUIEDIT_GetIP(ctrl_handle),
		         edit_ctrl_ptr->original_rect.left,edit_ctrl_ptr->original_rect.top,
		         edit_ctrl_ptr->original_rect.right,edit_ctrl_ptr->original_rect.bottom);            
		     Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);            
		     *data_size_ptr += data_len;
			break;
    	case GUIEDIT_TYPE_DATE:      /*!<日期编辑框*/
			GUIEDIT_GetDate(ctrl_handle,&year_ptr,&minute_ptr,&second_ptr);
			data_len = sprintf((char *)data_ptr, 
		     "<%s id='%d' type='%d' focus='%d' style='%d' Date='%d %d %d' rect='%d %d %d %d'>",
		         ctrl_name_ptr, ctrl_id, edit_ctrl_ptr->type, edit_ctrl_ptr->base_ctrl.is_active,
		          edit_ctrl_ptr->style,hour_ptr,minute_ptr,second_ptr,
		         edit_ctrl_ptr->original_rect.left,edit_ctrl_ptr->original_rect.top,
		         edit_ctrl_ptr->original_rect.right,edit_ctrl_ptr->original_rect.bottom);            
		     Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);            
		     *data_size_ptr += data_len;
			 break;
    	case GUIEDIT_TYPE_TIME:      /*!<时间编辑框*/
			GUIEDIT_GetTime(ctrl_handle,&hour_ptr,&minute_ptr,&second_ptr);
			data_len = sprintf((char *)data_ptr, 
		     "<%s id='%d' type='%d' focus='%d' style='%d' time='%d %d %d' rect='%d %d %d %d'>",
		         ctrl_name_ptr, ctrl_id, edit_ctrl_ptr->type, edit_ctrl_ptr->base_ctrl.is_active,
		          edit_ctrl_ptr->style,hour_ptr,minute_ptr,second_ptr,
		         edit_ctrl_ptr->original_rect.left,edit_ctrl_ptr->original_rect.top,
		         edit_ctrl_ptr->original_rect.right,edit_ctrl_ptr->original_rect.bottom);            
		     Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);            
		     *data_size_ptr += data_len;
			 break;					 
		case GUIEDIT_TYPE_TOUCH_DATE:/*!<全触摸屏日期*/
    	case GUIEDIT_TYPE_TOUCH_TIME:/*!<全触摸屏时间*/
			 //GUIEDIT_GetTouchTime(edit_ctrl_ptr,&hour_ptr,&minute_ptr,&second_ptr);
			 data_len = sprintf((char *)data_ptr, 
		     "<%s id='%d' type='%d' focus='%d' style='%d' time='%d %d %d' rect='%d %d %d %d'>",
		         ctrl_name_ptr, ctrl_id, edit_ctrl_ptr->type, edit_ctrl_ptr->base_ctrl.is_active,
		          edit_ctrl_ptr->style,hour_ptr,minute_ptr,second_ptr,
		         edit_ctrl_ptr->original_rect.left,edit_ctrl_ptr->original_rect.top,
		         edit_ctrl_ptr->original_rect.right,edit_ctrl_ptr->original_rect.bottom);            
		     Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);            
		     *data_size_ptr += data_len;
			 break;
			default:
				break;
	}
}
/*****************************************************************************/
//  Description: 获取Edit控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetEditControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	uint16 data_len = 0,i; 
	uint16 user_data_len = 0;
	wchar *user_data_ptr = NULL;
	uint16 max_len = 0;
	uint16 item_num = 0;

	CTRLLISTEDIT_OBJ_T *edit_ctrl_ptr = PNULL;
	GUIEDIT_OBJ_INFO_T *obj_info_ptr = PNULL;
	//uint8 hour_ptr = 0;
	//uint8 minute_ptr = 0;
	//uint8 second_ptr = 0;
	//uint16 year_ptr = 0;
	
	edit_ctrl_ptr = (CTRLLISTEDIT_OBJ_T *)ctrl_ptr;
	if (PNULL == edit_ctrl_ptr)
	{
		return;
	}


	// 如果是编辑框中的列表类型，max_len为列表项的最大文本长度，max_num为列表最大长度
	max_len = edit_ctrl_ptr->item_max_len;
	//max_num = edit_ctrl_ptr->add_data.list.total_line_num;
	item_num = edit_ctrl_ptr->max_num;
	data_len = sprintf((char *)data_ptr, 
		//"<%s id='%d' type='%d' focus='%d' style='%d' im='%d' totalnum='%d' maxLen='%d' maxNum='%d' rect='%d %d %d %d'>",
		"<%s id='%d'  focus='%d'  totalnum='%d' maxLen='%d' rect='%d %d %d %d'>",
		ctrl_name_ptr, ctrl_id, edit_ctrl_ptr->baseflex_ctrl.baseedit_ctrl.base_ctrl.is_active,
		//edit_ctrl_ptr->style,
		//edit_ctrl_ptr->add_theme.text.im.allow_im, 
		item_num,max_len, 
		//max_num,
		edit_ctrl_ptr->baseflex_ctrl.baseedit_ctrl.base_ctrl.rect.left,edit_ctrl_ptr->baseflex_ctrl.baseedit_ctrl.base_ctrl.rect.top,
		edit_ctrl_ptr->baseflex_ctrl.baseedit_ctrl.base_ctrl.rect.right,edit_ctrl_ptr->baseflex_ctrl.baseedit_ctrl.base_ctrl.rect.bottom);            
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);            
	*data_size_ptr += data_len;
	
	for(i=0;i<item_num;i++)
	{	
		obj_info_ptr = edit_ctrl_ptr->obj_info_ptr + i;
		if(obj_info_ptr->user_data.wstr_len)
		{
			data_len = sprintf((char *)data_ptr,"<item>");
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);            
			*data_size_ptr += data_len;			 
			
			user_data_ptr = obj_info_ptr->user_data.wstr_ptr;
			user_data_len = obj_info_ptr->user_data.wstr_len;
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;
			data_len = sprintf((char *)data_ptr,"</item>");
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);            
			*data_size_ptr += data_len;
		}
	}				

}

/*****************************************************************************/
//  Description: 获取DropList控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetDropListControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	uint16 data_len = 0,j; 
	uint16 user_data_len = 0;
	wchar *user_data_ptr = NULL;
	BOOL is_show = FALSE;
	CTRLDROPDOWNLIST_OBJ_T *dropdownlist_ctrl_ptr = PNULL;
	MMI_STRING_T ctrl_str = { 0 };
	
	dropdownlist_ctrl_ptr = (CTRLDROPDOWNLIST_OBJ_T *)ctrl_ptr;
	if (PNULL == dropdownlist_ctrl_ptr)
	{
		return;
	}
	
	switch (dropdownlist_ctrl_ptr->ctrl_type_info.ctrl_type)
	{
		case GUIDNLIST_EDITABLE_TEXT:
		case GUIDNLIST_EDITABLE_NUMLIST:
		case GUIDNLIST_EDITABLE_PHONENUM:
			// totalNum:总长度 maxNum:最大长度
			data_len = sprintf((char *)data_ptr, 
				"<%s id='%d' focus='%d' type='%d' active='%d' totalNum='%d' maxNum='%d' show_type='%d' cur_status='%d' rect='%d %d %d %d'>",
				ctrl_name_ptr, ctrl_id, dropdownlist_ctrl_ptr->is_focus,
				dropdownlist_ctrl_ptr->ctrl_type_info.ctrl_type,
				dropdownlist_ctrl_ptr->base_ctrl.is_active,
				dropdownlist_ctrl_ptr->ctrl_type_info.editable_max_text_num,
				dropdownlist_ctrl_ptr->ctrl_type_info.editable_max_listitem_num,
				dropdownlist_ctrl_ptr->show_type,dropdownlist_ctrl_ptr->cur_status,
				dropdownlist_ctrl_ptr->orig_rect.left,dropdownlist_ctrl_ptr->orig_rect.top,
				dropdownlist_ctrl_ptr->orig_rect.right,dropdownlist_ctrl_ptr->orig_rect.bottom);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;

			GUIEDIT_GetString(dropdownlist_ctrl_ptr->edit_handle, &ctrl_str);
			user_data_ptr = ctrl_str.wstr_ptr;
			user_data_len = ctrl_str.wstr_len;
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;
			break;
		case GUIDNLIST_NORMAL:	
			// totalNum:总长度 maxNum:最大长度
			data_len = sprintf((char *)data_ptr, 
				"<%s id='%d' focus='%d' type='%d' active='%d' totalNum='%d' maxNum='%d' show_type='%d' cur_status='%d' rect='%d %d %d %d'>",
				ctrl_name_ptr, ctrl_id, dropdownlist_ctrl_ptr->is_focus,
				dropdownlist_ctrl_ptr->ctrl_type_info.ctrl_type,
				dropdownlist_ctrl_ptr->base_ctrl.is_active,
				dropdownlist_ctrl_ptr->max_item_num,
				dropdownlist_ctrl_ptr->total_item_num,
				dropdownlist_ctrl_ptr->show_type,dropdownlist_ctrl_ptr->cur_status,
				dropdownlist_ctrl_ptr->orig_rect.left,dropdownlist_ctrl_ptr->orig_rect.top,
				dropdownlist_ctrl_ptr->orig_rect.right,dropdownlist_ctrl_ptr->orig_rect.bottom);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
			
			for(j=0;j<dropdownlist_ctrl_ptr->total_item_num;j++)
			{
				if(dropdownlist_ctrl_ptr->current_index == j)
				{
					is_show = TRUE;
				}
				else
				{
					is_show = FALSE;
				}
				
				data_len = sprintf((char *)data_ptr, "<item shown='%d'>",is_show);
				Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
				*data_size_ptr += data_len;	
				
				user_data_ptr = (dropdownlist_ctrl_ptr->all_item_ptr+j)->wstr_ptr;
				user_data_len = (dropdownlist_ctrl_ptr->all_item_ptr+j)->wstr_len;
				if (user_data_len != 0)
				{
					SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
				}
				user_item_ptr[user_data_len] = L'\0';
				
				Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
				*data_size_ptr += user_data_len * 4;
				
				data_len = sprintf((char *)data_ptr, "</item>");
				Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
				*data_size_ptr += data_len;
			}
			break;
		default:
			break;		
	}	
}

/*****************************************************************************/
//  Description: 获取softkey控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetsoftkeyControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	 uint16 data_len = 0,j; 
	 uint16 user_data_len = 0;
	 wchar *user_data_ptr = NULL;
	 
	 CTRLSOFTKEY_OBJ_T	*softkey_ptr = PNULL;
	 MMI_STRING_T text_ptr = { 0 };

	 softkey_ptr = (CTRLSOFTKEY_OBJ_T*)ctrl_ptr;
	 if (PNULL == softkey_ptr)
	 {
		return;
	 }

	 data_len = sprintf((char *)data_ptr, 
		"<%s id='%d' style='%d' visible='%d' bgtype='%d' bgid='%d' bgcolor='%d'>", 
		ctrl_name_ptr,ctrl_id,softkey_ptr->style,softkey_ptr->is_visible,
		softkey_ptr->bg_type,softkey_ptr->bg_image,softkey_ptr->bg_color);
     Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
     *data_size_ptr += data_len;

	for(j=0;j < GUISOFTKEY_BUTTON_NUM;j++)
	{
		if(softkey_ptr->button_arr[j].is_show)
		{
			switch(softkey_ptr->button_arr[j].content.data_type)
			{	
				case GUISK_DATA_TEXT_ID:
				case GUISK_DATA_TEXT_BUFFER:
					data_len = sprintf((char *)data_ptr,
						"<text id='%d' fontcolor='%d' font='%d' gray='%d' rect='%d %d %d %d'>",
						softkey_ptr->button_arr[j].content.data_u.text_id,
						softkey_ptr->font_color,softkey_ptr->font,
						softkey_ptr->button_arr[j].is_gray,
						softkey_ptr->button_arr[j].rect.left,
						softkey_ptr->button_arr[j].rect.top,
						softkey_ptr->button_arr[j].rect.right,
						softkey_ptr->button_arr[j].rect.bottom);
					Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	        		*data_size_ptr += data_len;	
					
					SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
					if(GUISK_DATA_TEXT_ID == softkey_ptr->button_arr[j].content.data_type)
					{
						MMITHEME_GetResText(softkey_ptr->button_arr[j].content.data_u.text_id, softkey_ptr->win_handle, &text_ptr);
					}
					else
					{
						text_ptr.wstr_ptr = softkey_ptr->button_arr[j].content.data_u.text_buffer.wstr_ptr;
						text_ptr.wstr_len = softkey_ptr->button_arr[j].content.data_u.text_buffer.wstr_len;
					}

					user_data_ptr = text_ptr.wstr_ptr;
					user_data_len = text_ptr.wstr_len;
					if (user_data_len != 0)
					{
			    		SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
					}
					user_item_ptr[user_data_len] = L'\0';
					Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
					*data_size_ptr += user_data_len * 4;
					data_len = sprintf((char *)data_ptr,"</text>");
					Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			        *data_size_ptr += data_len;
					break;
				case GUISK_DATA_IMAGE_ID:
					data_len = sprintf((char *)data_ptr,
						"<img id='%d' gray='%d' rect='%d %d %d %d'/>",
						softkey_ptr->button_arr[j].content.data_u.image_id,
						softkey_ptr->button_arr[j].is_gray,
						softkey_ptr->button_arr[j].rect.left,
						softkey_ptr->button_arr[j].rect.top,
						softkey_ptr->button_arr[j].rect.right,
						softkey_ptr->button_arr[j].rect.bottom);
					Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	        		*data_size_ptr += data_len;
					break;
				default:
						break;
			}			
		}
	}			
}

/*****************************************************************************/
//  Description: 获取Tips控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetTipsControlProperty( 
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	uint16 data_len = 0;
	uint16 user_data_len = 0;
	wchar *user_data_ptr = NULL;
		
	TIPS_OBJ_T *tips_ptr  = PNULL;

	tips_ptr  = (TIPS_OBJ_T *)ctrl_ptr;
	if (PNULL == tips_ptr)
	{
		return;
	}
	
	data_len = sprintf((char *)data_ptr, 
		"<%s id='%d' valid='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr,ctrl_id,tips_ptr->is_valid,
		tips_ptr->base_ctrl.rect.left,tips_ptr->base_ctrl.rect.top,
		tips_ptr->base_ctrl.rect.right,tips_ptr->base_ctrl.rect.bottom);
	   Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	   *data_size_ptr += data_len;

	if(tips_ptr->is_valid) //tip是否有效
	{
		data_len = sprintf((char *)data_ptr, 
			"<text fonttype='%d' fontcolor='%d' align='%d' strstate='%d'>", 
			tips_ptr->style_info.text_style.font_type,
			tips_ptr->style_info.text_style.font_color,
			tips_ptr->style_info.text_style.align,
			tips_ptr->style_info.text_style.str_state);
	      Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	      *data_size_ptr += data_len;

		user_data_ptr = tips_ptr->text_info.wstr_ptr;
		user_data_len = tips_ptr->text_info.wstr_len;
		if (user_data_len != 0)
		{
			SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
		}
		user_item_ptr[user_data_len] = L'\0';
		Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
		*data_size_ptr += user_data_len * 4;
		data_len = sprintf((char *)data_ptr, "</text>");
	      Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	      *data_size_ptr += data_len;
	}
}

/*****************************************************************************/
//  Description: 获取Title控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetTitleControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	uint16 i,data_len = 0; 
	uint16 user_data_len = 0;
	wchar *user_data_ptr = NULL;
	CTRLTITLE_OBJ_T  *title_ptr = PNULL;
	MMI_STRING_T  text_ptr = {0};

	title_ptr = (CTRLTITLE_OBJ_T  *)ctrl_ptr;
	if (PNULL == title_ptr)
	{
		return;
	}

	 data_len = sprintf((char *)data_ptr, 
	 	"<%s id='%d' rect='%d %d %d %d'>",
	 	ctrl_name_ptr,ctrl_id,
		title_ptr->base_ctrl.rect.left,title_ptr->base_ctrl.rect.top,
		title_ptr->base_ctrl.rect.right,title_ptr->base_ctrl.rect.bottom);
	 Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	 *data_size_ptr += data_len;

	//文本内容
	data_len = sprintf((char *)data_ptr, 
	"<text id='%d' aligntype='%d' font='%d' fontcolor='%d' charspace='%d'>",
		title_ptr->text_id,title_ptr->str_style.align,title_ptr->str_style.font,
		title_ptr->str_style.font_color,title_ptr->str_style.char_space);
	 Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	 *data_size_ptr += data_len;

	if(!title_ptr->title_str.wstr_len)
	{
		MMITHEME_GetResText(title_ptr->text_id, title_ptr->win_handle, &text_ptr);
		user_data_ptr = text_ptr.wstr_ptr;
		user_data_len = text_ptr.wstr_len;;
	}
	else
	{
		user_data_ptr = title_ptr->title_str.wstr_ptr;
		user_data_len = title_ptr->title_str.wstr_len;
	}	
	 
	if (user_data_len != 0)
	{
		SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
	}
	user_item_ptr[user_data_len] = L'\0';
	Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
	*data_size_ptr += user_data_len * 4;

	data_len = sprintf((char *)data_ptr, "</text>");
	 Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	 *data_size_ptr += data_len;

	//背景图片
	if(title_ptr->is_need_bg)
	{
		data_len = sprintf((char *)data_ptr, "<bg id='%d'/>",
		title_ptr->bg_image);
	    Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	    *data_size_ptr += data_len;
	}

	if(title_ptr->icon_id)
	{
		//小图标
		data_len = sprintf((char *)data_ptr, "<icon id='%d'/>",title_ptr->icon_id);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
	}

	//子字符串
	if(title_ptr->is_need_sub_text)
	{
		data_len = sprintf((char *)data_ptr,
			"<sub_text font='%d' subalign='%d' rect='%d %d %d %d'>",
		title_ptr->sub_font,title_ptr->sub_align,
		title_ptr->sub_text_rect.left,title_ptr->sub_text_rect.top,
		title_ptr->sub_text_rect.right,title_ptr->sub_text_rect.bottom);
	    Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	    *data_size_ptr += data_len;

		user_data_ptr = title_ptr->sub_str;
		user_data_len = title_ptr->sub_str_len;		
		if (user_data_len != 0)
		{
			SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
		}
		user_item_ptr[user_data_len] = L'\0';
		Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
		*data_size_ptr += user_data_len * 4;

		data_len = sprintf((char *)data_ptr, "</sub_text>");
	    Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	    *data_size_ptr += data_len;
	}

	//箭头
	if(title_ptr->is_need_button)
	{
		for(i=0;i<GUITITLE_BUTTON_NUM;i++)
		{
			if(!title_ptr->button_state[i])
			{
				data_len = sprintf((char *)data_ptr, 
					"<button state='%d' imgid='%d' textid='%d' rect='%d %d %d %d'>",
				title_ptr->button_state[i],title_ptr->button_info[i].image_id,
				title_ptr->button_info[i].text_id,
				title_ptr->button_rect[i].left,title_ptr->button_rect[i].top,
				title_ptr->button_rect[i].right,title_ptr->button_rect[i].bottom);
			    Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			    *data_size_ptr += data_len;

				if(GUITITLE_DATA_TEXT_ID == title_ptr->button_info[i].text_type)
				{
					MMITHEME_GetResText(title_ptr->button_info[i].text_id, title_ptr->win_handle, &text_ptr);
					user_data_ptr = text_ptr.wstr_ptr;
					user_data_len = text_ptr.wstr_len;
				}
				else if(GUITITLE_DATA_TEXT_BUFFER == title_ptr->button_info[i].text_type)
				{
					user_data_ptr = title_ptr->button_info[i].icon_str_ptr;
					user_data_len = title_ptr->button_info[i].str_len;
				}
				 
				if (user_data_len != 0)
				{
					SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
				}
				user_item_ptr[user_data_len] = L'\0';
				Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
				*data_size_ptr += user_data_len * 4;
				data_len = sprintf((char *)data_ptr, "</button>");
			    Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			    *data_size_ptr += data_len;
			}
		}
	}
}

/*****************************************************************************/
//  Description: 获取List控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetListControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	 uint16 j,data_len = 0;
	 uint16 user_data_len = 0;
	 uint16  item_index = 0;
	 GUI_RECT_T  rect_ptr = {0};
	 MMI_STRING_T text_ptr = {0};
	 MMI_IMAGE_ID_T user_data_id = 0;
	 wchar *user_data_ptr = NULL;
	 BOOL is_focus = FALSE;
	 
	 CTRLLIST_OBJ_T *list_ctrl_ptr = PNULL;
	 GUILIST_ITEM_DATA_T* item_data_ptr = PNULL;
	 const CTRLLIST_ITEM_T *list_item_ptr = PNULL;

	 list_ctrl_ptr = (CTRLLIST_OBJ_T *)ctrl_ptr;
	 if (PNULL == list_ctrl_ptr)
	 {
		 return;
	 }

	// totalNum:总长度 maxNum:最大长度
	 data_len = sprintf((char *)data_ptr, 
	 "<%s id='%d' type='%d' totalnum='%d' rect='%d %d %d %d'>",
	     ctrl_name_ptr, ctrl_id,list_ctrl_ptr->mark_type,
	     list_ctrl_ptr->total_item_num,
	     list_ctrl_ptr->base_ctrl.rect.left,list_ctrl_ptr->base_ctrl.rect.top,
		 list_ctrl_ptr->base_ctrl.rect.right,list_ctrl_ptr->base_ctrl.rect.bottom);
	 Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	 *data_size_ptr += data_len;

	if(list_ctrl_ptr->total_item_num >0)
	{
		for(item_index = 0; item_index < list_ctrl_ptr->total_item_num; item_index++)
		{
			list_item_ptr = CTRLLIST_GetItem(ctrl_handle, item_index);
			if (PNULL == list_item_ptr)
			{
				 break;
			}

			item_data_ptr = list_item_ptr->data_ptr;
			if(PNULL == item_data_ptr)
			{
				continue;
			}

			if(list_ctrl_ptr->cur_item_idx == item_index)
			{
				is_focus = TRUE;
			}
			else
			{
				is_focus = FALSE;
			}

			if(!GUILIST_GetItemRect(ctrl_handle,item_index,&rect_ptr))
			{
				break;
			}

			data_len = sprintf((char *)data_ptr, 
				"<item focus='%d' index='%d' rect='%d %d %d %d'>",
				is_focus,item_index,
				rect_ptr.left,rect_ptr.top,
				rect_ptr.right,rect_ptr.bottom);
			 Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			 *data_size_ptr += data_len;	

			 for (j = 0; j < GUIITEM_CONTENT_MAX_NUM; j++)
			 {
				switch (item_data_ptr->item_content[j].item_data_type)
				{
					case GUIITEM_DATA_IMAGE_ID:						
						user_data_id = item_data_ptr->item_content[j].item_data.image_id;
						if(user_data_id == list_ctrl_ptr->display_style.radio_unselected_image_id)
						{
							data_len = sprintf((char *)data_ptr, "<image id='%d'/>",list_ctrl_ptr->display_style.radio_unselected_image_id);
						}
						else if(user_data_id == list_ctrl_ptr->display_style.radio_selected_image_id)
						{
							data_len = sprintf((char *)data_ptr, "<image id='%d' selected_id='%d'/>",
								list_ctrl_ptr->display_style.radio_unselected_image_id,list_ctrl_ptr->display_style.radio_selected_image_id);
						}
						else if(user_data_id == list_ctrl_ptr->display_style.check_unselected_image_id)
						{
							data_len = sprintf((char *)data_ptr, "<image id='%d'/>",list_ctrl_ptr->display_style.check_unselected_image_id);
						}
				 		else if(user_data_id == list_ctrl_ptr->display_style.check_selected_image_id)
						{
							data_len = sprintf((char *)data_ptr, "<image id='%d' selected_id='%d'/>",
								list_ctrl_ptr->display_style.check_unselected_image_id,list_ctrl_ptr->display_style.check_selected_image_id);
						}
						else
						{
							data_len = sprintf((char *)data_ptr, "<image id='%d'/>",user_data_id);
						}
					    Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
					    *data_size_ptr += data_len;
					break;

					case GUIITEM_DATA_TEXT_ID:
					case GUIITEM_DATA_TEXT_BUFFER:
						user_data_id = item_data_ptr->item_content[j].item_data.text_id;
					    data_len = sprintf((char *)data_ptr, "<text id='%d'>",
				   		user_data_id);
					    Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
					    *data_size_ptr += data_len;

						if(GUIITEM_DATA_TEXT_ID == item_data_ptr->item_content[j].item_data_type)
						{
							SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
							MMITHEME_GetResText(item_data_ptr->item_content[j].item_data.text_id, ctrl_handle, &text_ptr);
						}
						else if(GUIITEM_DATA_TEXT_BUFFER == item_data_ptr->item_content[j].item_data_type)
						{
							text_ptr.wstr_ptr = item_data_ptr->item_content[j].item_data.text_buffer.wstr_ptr;
							text_ptr.wstr_len = item_data_ptr->item_content[j].item_data.text_buffer.wstr_len;
						}

					    user_data_ptr = text_ptr.wstr_ptr;
						user_data_len = text_ptr.wstr_len;
						if (user_data_len != 0)
						{
							SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
						}
						user_item_ptr[user_data_len] = L'\0';
						
						Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
						*data_size_ptr += user_data_len * 4;
					    data_len = sprintf((char *)data_ptr, "</text>");
						Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
						*data_size_ptr += data_len;	
						break;

					case GUIITEM_DATA_ANIM_DATA:
						data_len = sprintf((char *)data_ptr, "<anim id='%d'/>",item_data_ptr->item_content[j].item_data.anim_data_ptr->anim_id);
					   Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
					   *data_size_ptr += data_len;
					   break;
					 case GUIITEM_DATA_ANIM_PATH:
						data_len = sprintf((char *)data_ptr, "<anim></anim>");
						Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
						*data_size_ptr += data_len;
						break;
					default:
					   break;
				}
			 }
			 data_len = sprintf((char *)data_ptr, "</item>");
			 Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			 *data_size_ptr += data_len;	
		}
	}
}


/*****************************************************************************/
//  Description: 获取MainMenu控件描述
//  Global resource dependence :none
//  Author: 
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetMainMenuControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr = PNULL;
	uint16 data_len=0;
	
	menu_ctrl_ptr = (CTRLMAINMENU_OBJ_T *)ctrl_ptr;
	if (PNULL == menu_ctrl_ptr)
	{
		return;
	}

	switch (menu_ctrl_ptr->type)
	{   
		#ifdef MATRIX_MAIN_MENU_SUPPORT
	 	case MMIMAINMENU_MATRIX_E :  
		case MMIMAINMENU_MATRIX_TITLE_E :  
			Atest_GetMatrixMainMenuControlProperty	( menu_ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);		
    		break;
		#endif
		#ifdef QBTHEME_SUPPORT
	 	case MMIMAINMENU_QBTHEME_E : 			
			Atest_GetQbMainMenuControlProperty	( menu_ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);		
			break;
		#endif
	    #ifdef MMI_ISTYLE_SUPPORT
	    case MMIMAINMENU_ISTYLE_E : 
			
			Atest_GetIStyleMainMenuControlProperty	( menu_ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);		
			break;
	   #endif
		#ifdef PDA_UI_SUPPORT_MANIMENU_GO										 
		case MMIMAINMENU_GO_SLIDE_E :
			Atest_GetSlideMainMenuControlProperty	( menu_ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);		
			break;
		#endif
	   #ifdef MENU_SWEETS_SUPPORT
	    case MMIMAINMENU_SWEETS_E :
			Atest_GetSweetMainMenuControlProperty	( menu_ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);		
			break;
	   #endif
		default:
			data_len = sprintf((char *)data_ptr,"<%s style='%d'>",ctrl_name_ptr,menu_ctrl_ptr->type);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
			break;
	}
	
}

#ifdef MENU_SWEETS_SUPPORT
/*****************************************************************************/
//  Description: 获取SweetMainMenu控件描述
//  Global resource dependence :none
//  Author: 
/*****************************************************************************/
LOCAL void Atest_GetSweetMainMenuControlProperty( 
										 CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,//MENU指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr)			//传输的数据text
{
	uint16 data_len = 0;
	uint16 item_index = 0;
	uint16 user_data_len = 0;
	MMI_STRING_T text_ptr = { 0 };
    	//MMI_IMAGE_ID_T  icon_id_ptr = { 0 };
    	BOOLEAN  is_grayed_ptr = FALSE;
	BOOLEAN  is_focus_icon = FALSE;
	wchar *user_data_ptr = NULL;
	MMIMAINMENU_SWEETS_DATA_T *mainmenu = NULL;
	MMIMAINMENU_ITEM_INFO_T item_ptr = {0};
    	CTRLMAINMENU_ITEM_T item_info = {0};
	mainmenu =  (MMIMAINMENU_SWEETS_DATA_T*)menu_ctrl_ptr->pm_data_ptr;

	data_len = sprintf((char *)data_ptr,
		"<%s id='%d' style='%d' totalnum='%d' rect='%d %d %d %d'>",
		ctrl_name_ptr,ctrl_id,menu_ctrl_ptr->type,/*mainmenu->is_static,menu_ctrl_ptr->is_transparent,*/mainmenu->item_total_num,
		menu_ctrl_ptr->base_ctrl.rect.left,menu_ctrl_ptr->base_ctrl.rect.top,
		menu_ctrl_ptr->base_ctrl.rect.right,menu_ctrl_ptr->base_ctrl.rect.bottom);
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	*data_size_ptr += data_len;

	for (item_index = 0; item_index < mainmenu->item_total_num; item_index++)
	{
		MMIMAINMENU_GetItem(&mainmenu->menu_list_info, item_index, &item_ptr);
		MMIMAINMENU_GetItemData(item_ptr.menu_id, item_ptr.group_id, &item_info);

		if(item_index == mainmenu->cur_item_index)
		{
			is_focus_icon = 1;
		}
		else
		{
			is_focus_icon = 0;
		}
		
		data_len = sprintf((char *)data_ptr,
			"<item focus='%d' grayed='%d'>",
			is_focus_icon,is_grayed_ptr);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;	
  
		//title
	/*
		if(menu_ctrl_ptr->title_len != 0)
		{
			data_len = sprintf((char *)data_ptr, 
				"<title rect='%d %d %d %d'>",
				menu_ctrl_ptr->title_rect.left,menu_ctrl_ptr->title_rect.bottom,
				menu_ctrl_ptr->title_rect.right,menu_ctrl_ptr->title_rect.top);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;

			user_data_ptr = menu_ctrl_ptr->title_wstr;
			user_data_len = menu_ctrl_ptr->title_len;
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;
			data_len = sprintf((char *)data_ptr, "</title>");
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
		}
*/


		//图片
		data_len = sprintf((char *)data_ptr, "<image id='%d'/>", item_info.icon.data.icon_id);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
		

		//文本
		
		data_len = sprintf((char *)data_ptr, "<text>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
			
		if (CTRL_TEXT_ID == item_info.text.type )
            {
            	   	MMITHEME_GetResText(item_info.text.data.text_id, mainmenu->win_handle, &text_ptr);	
            }
            else
            {
                text_ptr.wstr_ptr = item_info.text.data.str_info.wstr_ptr;
                text_ptr.wstr_len = item_info.text.data.str_info.wstr_len;
            }
		user_data_ptr = text_ptr.wstr_ptr;
		user_data_len = text_ptr.wstr_len;
		if (user_data_len != 0)
		{
			SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
		}
		user_item_ptr[user_data_len] = L'\0';
		Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
		*data_size_ptr += user_data_len * 4;	
		data_len = sprintf((char *)data_ptr, "</text>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;

						
		data_len = sprintf((char *)data_ptr, "</item>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;	
	}
}
#endif

#ifdef PDA_UI_SUPPORT_MANIMENU_GO										 
/*****************************************************************************/
//  Description: 获取SlideMainMenu控件描述
//  Global resource dependence :none
//  Author: 
/*****************************************************************************/
LOCAL void Atest_GetSlideMainMenuControlProperty( 
										 CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,//MENU指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr)			//传输的数据text
{
	uint16 data_len = 0;
	uint16 item_index = 0;
	uint16 user_data_len = 0;
	MMI_STRING_T text_ptr = { 0 };
    	//MMI_IMAGE_ID_T  icon_id_ptr = { 0 };
    	BOOLEAN  is_grayed_ptr = FALSE;
	BOOLEAN  is_focus_icon = FALSE;
	wchar *user_data_ptr = NULL;
	MMIMAINMENU_ITEM_INFO_T *item_ptr = {0};
	CTRLMAINMENU_ITEM_T item_info = {0};
	MMIMAINEMENU_ITEM_LIST_T  *page_item_info_ptr = PNULL;
	MMIMAINMENU_SLIDEPAGE_DATA_T* mainmenu = NULL;
	mainmenu =  (MMIMAINMENU_SLIDEPAGE_DATA_T*)menu_ctrl_ptr->pm_data_ptr;
	if(PNULL == mainmenu)
	{
	    return;
	}
	page_item_info_ptr = Atest_GetSlidePageMenuLinkListPtr(mainmenu, mainmenu->cur_page_index);
	if (PNULL == page_item_info_ptr)
	{
	    return;
       }

	data_len = sprintf((char *)data_ptr,
		"<%s id='%d' style='%d' totalnum='%d' rect='%d %d %d %d'>",
		ctrl_name_ptr,ctrl_id,menu_ctrl_ptr->type,/*mainmenu->is_static,menu_ctrl_ptr->is_transparent,*/page_item_info_ptr->item_count,
		menu_ctrl_ptr->base_ctrl.rect.left,menu_ctrl_ptr->base_ctrl.rect.top,
		menu_ctrl_ptr->base_ctrl.rect.right,menu_ctrl_ptr->base_ctrl.rect.bottom);
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	*data_size_ptr += data_len;
	
	for (item_index = 0; item_index < page_item_info_ptr->item_count; item_index++)
	{
	       item_ptr = Atest_SlidePageMenuGetItemInfoByIndex(page_item_info_ptr, item_index);

	        if (PNULL != item_ptr)
	        {
	            	MMIMAINMENU_GetItemData(item_ptr->menu_id,item_ptr->group_id,&item_info);
	        }

		if(item_index == mainmenu->cur_item_index)
		{
			is_focus_icon = 1;
		}
		else
		{
			is_focus_icon = 0;
		}
		
		data_len = sprintf((char *)data_ptr,
			"<item focus='%d' grayed='%d'>",
			is_focus_icon,is_grayed_ptr);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;	
  
		//title
	/*
		if(menu_ctrl_ptr->title_len != 0)
		{
			data_len = sprintf((char *)data_ptr, 
				"<title rect='%d %d %d %d'>",
				menu_ctrl_ptr->title_rect.left,menu_ctrl_ptr->title_rect.bottom,
				menu_ctrl_ptr->title_rect.right,menu_ctrl_ptr->title_rect.top);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;

			user_data_ptr = menu_ctrl_ptr->title_wstr;
			user_data_len = menu_ctrl_ptr->title_len;
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;
			data_len = sprintf((char *)data_ptr, "</title>");
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
		}
*/


		//图片
		data_len = sprintf((char *)data_ptr, "<image id='%d'/>", item_info.icon.data.icon_id);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
		

		//文本
		
		data_len = sprintf((char *)data_ptr, "<text>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;

		if (CTRL_TEXT_ID == item_info.text.type )
            {
			MMITHEME_GetResText(item_info.text.data.text_id, mainmenu->win_handle, &text_ptr);
            }
            else
            {
                text_ptr.wstr_ptr = item_info.text.data.str_info.wstr_ptr;
                text_ptr.wstr_len = item_info.text.data.str_info.wstr_len;
            }
		user_data_ptr = text_ptr.wstr_ptr;
		user_data_len = text_ptr.wstr_len;
		if (user_data_len != 0)
		{
			SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
		}
		user_item_ptr[user_data_len] = L'\0';
		Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
		*data_size_ptr += user_data_len * 4;	
		data_len = sprintf((char *)data_ptr, "</text>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;

						
		data_len = sprintf((char *)data_ptr, "</item>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;	
	}
}
#endif
#ifdef QBTHEME_SUPPORT
/*****************************************************************************/
//  Description: 获取QbMainMenu控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_SECOND\GUIMENU_STYLE_THIRD\GUIMENU_STYLE_POPUP  
// 	      GUIMENU_STYLE_POPUP_AUTO\GUIMENU_STYLE_POPUP_RECT
//		  GUIMENU_STYLE_POPUP_RADIO\GUIMENU_STYLE_POPUP_CHECK
/*****************************************************************************/
LOCAL void Atest_GetQbMainMenuControlProperty( 
										 CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,//MENU指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr)			//传输的数据text
{
	uint16 data_len = 0;
	uint16 item_index = 0;
	uint16 user_data_len = 0;
	uint16 item_total_num = 0;
	MMI_STRING_T text_ptr = { 0 };
	//MMI_IMAGE_ID_T  icon_id_ptr = { 0 };
	BOOLEAN  is_grayed_ptr = FALSE;
	BOOLEAN  is_focus_icon = FALSE;
	wchar *user_data_ptr = NULL;
	//MMIMAINMENU_ITEM_INFO_T *item_ptr = {0};
	CTRLMAINMENU_ITEM_T item_info = {0};
	MMIMAINMENU_QBTHEME_DATA_T *mainmenu = NULL;
	GUIMENU_ITEM_POSITION_E position = GUIMENU_ITEM_IN_PAGE;
	 MMIMAINEMENU_ITEM_LIST_T  *page_item_info_ptr = PNULL;
	mainmenu =  (MMIMAINMENU_QBTHEME_DATA_T*)menu_ctrl_ptr->pm_data_ptr;


    if ( mainmenu->is_bar_item  )
    {
        return ;
    }

       page_item_info_ptr = MMIMENU_GetItemList(&mainmenu->menu_page_info, mainmenu->cur_page_index);


	item_total_num = Atest_GetSlideMenuPageItemNum((MMIMAINMENU_SLIDEPAGE_DATA_T *)mainmenu);

	data_len = sprintf((char *)data_ptr,
		"<%s id='%d' style='%d' totalnum='%d' rect='%d %d %d %d'>",
		ctrl_name_ptr,ctrl_id,menu_ctrl_ptr->type,/*mainmenu->is_static,menu_ctrl_ptr->is_transparent,*/page_item_info_ptr->item_count,
		menu_ctrl_ptr->base_ctrl.rect.left,menu_ctrl_ptr->base_ctrl.rect.top,
		menu_ctrl_ptr->base_ctrl.rect.right,menu_ctrl_ptr->base_ctrl.rect.bottom);
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	*data_size_ptr += data_len;
	
	for (item_index = 0; item_index < page_item_info_ptr->item_count; item_index++)
	{		
		if ( mainmenu->is_bar_item )
		{
			position = GUIMENU_ITEM_IN_BAR;
		}
		else
		{
			position = GUIMENU_ITEM_IN_PAGE;
		}
		Atest_QbThemeMenuGetItemInfo(mainmenu, position, mainmenu->cur_page_index, item_index, &item_info);

		if(item_index == mainmenu->cur_item_index)
		{
			is_focus_icon = 1;
		}
		else
		{
			is_focus_icon = 0;
		}
		
		data_len = sprintf((char *)data_ptr,
			"<item focus='%d' grayed='%d'>",
			is_focus_icon,is_grayed_ptr);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;	
  
		//title
	/*
		if(menu_ctrl_ptr->title_len != 0)
		{
			data_len = sprintf((char *)data_ptr, 
				"<title rect='%d %d %d %d'>",
				menu_ctrl_ptr->title_rect.left,menu_ctrl_ptr->title_rect.bottom,
				menu_ctrl_ptr->title_rect.right,menu_ctrl_ptr->title_rect.top);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;

			user_data_ptr = menu_ctrl_ptr->title_wstr;
			user_data_len = menu_ctrl_ptr->title_len;
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;
			data_len = sprintf((char *)data_ptr, "</title>");
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
		}
*/


		//图片
		data_len = sprintf((char *)data_ptr, "<image id='%d'/>", item_info.icon.data.icon_id);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
		

		//文本
		
		data_len = sprintf((char *)data_ptr, "<text>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
		
		if (CTRL_TEXT_ID == item_info.text.type )
            {
		  MMITHEME_GetResText(item_info.text.data.text_id, mainmenu->win_handle, &text_ptr);
            }
            else
            {
                text_ptr.wstr_ptr = item_info.text.data.str_info.wstr_ptr;
                text_ptr.wstr_len = item_info.text.data.str_info.wstr_len;
            }
		user_data_ptr = text_ptr.wstr_ptr;
		user_data_len = text_ptr.wstr_len;
		
		if (user_data_len != 0)
		{
			SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
		}
		user_item_ptr[user_data_len] = L'\0';
		Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
		*data_size_ptr += user_data_len * 4;	
		data_len = sprintf((char *)data_ptr, "</text>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;

						
		data_len = sprintf((char *)data_ptr, "</item>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;	
	}
}
#endif

#ifdef MMI_ISTYLE_SUPPORT
/*****************************************************************************/
//  Description: 获取IStyleMainMenu控件描述
//  Global resource dependence :none
//  Author: 
/*****************************************************************************/
LOCAL void Atest_GetIStyleMainMenuControlProperty( 
										 CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,//MENU指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr)			//传输的数据text
{
	uint16 data_len = 0;
	uint16 item_index = 0;
	uint16 user_data_len = 0;
	MMI_STRING_T text_ptr = { 0 };
    	//MMI_IMAGE_ID_T  icon_id_ptr = { 0 };
    	BOOLEAN  is_grayed_ptr = FALSE;
	BOOLEAN  is_focus_icon = FALSE;
	wchar *user_data_ptr = NULL;
	MMIMAINMENU_ITEM_INFO_T *item_ptr = {0};
    	CTRLMAINMENU_ITEM_T item_info = {0};
	MMIMAINMENU_ISTYLE_DATA_T *mainmenu = NULL;
	mainmenu =  (MMIMAINMENU_ISTYLE_DATA_T*)menu_ctrl_ptr->pm_data_ptr;

	
	data_len = sprintf((char *)data_ptr,
		"<%s id='%d' style='%d' totalnum='%d' rect='%d %d %d %d'>",
		ctrl_name_ptr,ctrl_id,menu_ctrl_ptr->type, mainmenu->page_info.page[mainmenu->cur_page_index].cnt,
		menu_ctrl_ptr->base_ctrl.rect.left,menu_ctrl_ptr->base_ctrl.rect.top,
		menu_ctrl_ptr->base_ctrl.rect.right,menu_ctrl_ptr->base_ctrl.rect.bottom);
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	*data_size_ptr += data_len;

	for (item_index = 0; item_index < mainmenu->page_info.page[mainmenu->cur_page_index].cnt; item_index++)
	{
		item_ptr = mainmenu->page_info.page[mainmenu->cur_page_index].item + item_index;
		if(!IStyleGetItemData(mainmenu, item_ptr->menu_id, item_ptr->group_id, &item_info))
		{
			break;
		}

		if(item_index == mainmenu->cur_item_index)
		{
			is_focus_icon = 1;
		}
		else
		{
			is_focus_icon = 0;
		}
		
		data_len = sprintf((char *)data_ptr,
			"<item focus='%d' grayed='%d'>",
			is_focus_icon,is_grayed_ptr);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;	
  
		//title
	/*
		if(menu_ctrl_ptr->title_len != 0)
		{
			data_len = sprintf((char *)data_ptr, 
				"<title rect='%d %d %d %d'>",
				menu_ctrl_ptr->title_rect.left,menu_ctrl_ptr->title_rect.bottom,
				menu_ctrl_ptr->title_rect.right,menu_ctrl_ptr->title_rect.top);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;

			user_data_ptr = menu_ctrl_ptr->title_wstr;
			user_data_len = menu_ctrl_ptr->title_len;
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;
			data_len = sprintf((char *)data_ptr, "</title>");
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
		}
*/


		//图片
		data_len = sprintf((char *)data_ptr, "<image id='%d'/>", item_info.icon.data.icon_id);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
		

		//文本

		data_len = sprintf((char *)data_ptr, "<text>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;

		if (CTRL_TEXT_ID == item_info.text.type )
            {
			MMITHEME_GetResText(item_info.text.data.text_id, mainmenu->win_handle, &text_ptr);
            }
            else
            {
                text_ptr.wstr_ptr = item_info.text.data.str_info.wstr_ptr;
                text_ptr.wstr_len = item_info.text.data.str_info.wstr_len;
            }
		user_data_ptr = text_ptr.wstr_ptr;
		user_data_len = text_ptr.wstr_len;
		if (user_data_len != 0)
		{
			SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
		}
		user_item_ptr[user_data_len] = L'\0';
		Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
		*data_size_ptr += user_data_len * 4;	
		data_len = sprintf((char *)data_ptr, "</text>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;

						
		data_len = sprintf((char *)data_ptr, "</item>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;	
	}
}
#endif

 #ifdef MATRIX_MAIN_MENU_SUPPORT
/*****************************************************************************/
//  Description: 获取MaxtricMainMenu控件描述
//  Global resource dependence :none
//  Author:
/*****************************************************************************/
LOCAL void Atest_GetMatrixMainMenuControlProperty( 
										 CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,//MENU指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr)			//传输的数据text
{
	uint16 data_len = 0;
	uint16 item_index = 0;
	uint16 user_data_len = 0;
	MMI_STRING_T text_ptr = { 0 };
    	//MMI_IMAGE_ID_T  icon_id_ptr = { 0 };
    	BOOLEAN  is_grayed_ptr = FALSE;
	BOOLEAN  is_focus_icon = FALSE;
	wchar *user_data_ptr = NULL;
	MMIMAINMENU_ITEM_INFO_T item_ptr = {0};
    	CTRLMAINMENU_ITEM_T item_info = {0};

	MMIMAINMENU_MATRIX_DATA_T *mainmenu = NULL;
	mainmenu = (MMIMAINMENU_MATRIX_DATA_T *)menu_ctrl_ptr->pm_data_ptr;

	data_len = sprintf((char *)data_ptr,
		"<%s id='%d' style='%d' static='%d' totalnum='%d' rect='%d %d %d %d'>",
		ctrl_name_ptr,ctrl_id,menu_ctrl_ptr->type,mainmenu->is_static,/*menu_ctrl_ptr->is_transparent,*/mainmenu->item_total_num,
		menu_ctrl_ptr->base_ctrl.rect.left,menu_ctrl_ptr->base_ctrl.rect.top,
		menu_ctrl_ptr->base_ctrl.rect.right,menu_ctrl_ptr->base_ctrl.rect.bottom);
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	*data_size_ptr += data_len;

	for (item_index = 0; item_index < mainmenu->item_total_num; item_index++)
	{
		MMIMAINMENU_GetItem(&mainmenu->menu_list_info, item_index, &item_ptr);
		MMIMAINMENU_GetItemData(item_ptr.menu_id, item_ptr.group_id, &item_info);

		if(item_index == mainmenu->cur_item_index)
		{
			is_focus_icon = 1;
		}
		else
		{
			is_focus_icon = 0;
		}
		
		data_len = sprintf((char *)data_ptr,
			"<item focus='%d' grayed='%d'>",
			is_focus_icon,is_grayed_ptr);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;	
  
		//title
	/*
		if(menu_ctrl_ptr->title_len != 0)
		{
			data_len = sprintf((char *)data_ptr, 
				"<title rect='%d %d %d %d'>",
				menu_ctrl_ptr->title_rect.left,menu_ctrl_ptr->title_rect.bottom,
				menu_ctrl_ptr->title_rect.right,menu_ctrl_ptr->title_rect.top);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;

			user_data_ptr = menu_ctrl_ptr->title_wstr;
			user_data_len = menu_ctrl_ptr->title_len;
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;
			data_len = sprintf((char *)data_ptr, "</title>");
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
		}
*/


		//图片
		data_len = sprintf((char *)data_ptr, "<image id='%d'/>", item_info.icon.data.icon_id);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
		

		//文本
		
		data_len = sprintf((char *)data_ptr, "<text>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
		
		if (CTRL_TEXT_ID == item_info.text.type )
            {
			MMITHEME_GetResText(item_info.text.data.text_id, mainmenu->win_handle, &text_ptr);
            }
            else
            {
                text_ptr.wstr_ptr = item_info.text.data.str_info.wstr_ptr;
                text_ptr.wstr_len = item_info.text.data.str_info.wstr_len;
            }
		user_data_ptr = text_ptr.wstr_ptr;
		user_data_len = text_ptr.wstr_len;
		if (user_data_len != 0)
		{
			SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
		}
		user_item_ptr[user_data_len] = L'\0';
		Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
		*data_size_ptr += user_data_len * 4;	
		data_len = sprintf((char *)data_ptr, "</text>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;

						
		data_len = sprintf((char *)data_ptr, "</item>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;	
	}
}
#endif

/*****************************************************************************/
//  Description: 获取Menu控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetMenuControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	CTRLMENU_OBJ_T  *menu_ctrl_ptr = PNULL;
	uint16 data_len=0;
	
	menu_ctrl_ptr = (CTRLMENU_OBJ_T *)ctrl_ptr;
	if (PNULL == menu_ctrl_ptr)
	{
		return;
	}

	switch (menu_ctrl_ptr->cur_style)
	{
	    case GUIMENU_STYLE_SECOND :      /* 1 !< 二级菜单风格，显示为列表形式，多用于由主菜单进入的二级菜单 */
	    //case GUIMENU_STYLE_THIRD: 		 /* 2 !< 已去掉此风格，其显示同GUIMENU_STYLE_SECOND */
		case GUIMENU_STYLE_POPUP :       /* 6 !< 弹出式菜单，由系统统一计算它的位置和宽度，用户不能设置 */
	    case GUIMENU_STYLE_POPUP_AUTO :  /* 11 !< 弹出式菜单，其坐标可由用户设置，且会根据文本自适应宽度 */
	    case GUIMENU_STYLE_POPUP_RECT :  /* 12 !< 弹出式菜单，其坐标和宽度可由用户设置，系统不会做自适应 */
		case GUIMENU_STYLE_POPUP_RADIO : /* 7 !< 弹出式菜单，菜单项带有单选的radio风格 */
	    case GUIMENU_STYLE_POPUP_CHECK : /* 8 !< 弹出式菜单，菜单项带有多选的check风格 */
			{
				Atest_GetPopMenuControlProperty( menu_ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
			}
			break;

		case GUIMENU_STYLE_OPTIONS  :    /* 15 !< OptionsMenu */
			{
				Atest_GetOptionMenuControlProperty( menu_ctrl_ptr,ctrl_id,ctrl_handle,ctrl_name_ptr,data_size_ptr,data_ptr,user_item_ptr);
			}
			break;

		default:
			data_len = sprintf((char *)data_ptr,"<%s style='%d'>",ctrl_name_ptr,menu_ctrl_ptr->cur_style);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
			break;
	}
}

/*****************************************************************************/
//  Description: 获取PopMenu控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_SECOND\GUIMENU_STYLE_THIRD\GUIMENU_STYLE_POPUP  
// 	      GUIMENU_STYLE_POPUP_AUTO\GUIMENU_STYLE_POPUP_RECT
//		  GUIMENU_STYLE_POPUP_RADIO\GUIMENU_STYLE_POPUP_CHECK
/*****************************************************************************/
LOCAL void Atest_GetPopMenuControlProperty( 
										 CTRLMENU_OBJ_T  *menu_ctrl_ptr,//MENU指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr)			//传输的数据text
{
	uint16 data_len = 0;
	uint16 item_index = 0;
	uint16 user_data_len = 0;
	MMI_STRING_T text_ptr = { 0 };
    MMI_IMAGE_ID_T  icon_id_ptr = { 0 };
    BOOLEAN  is_grayed_ptr = FALSE;
	BOOLEAN  is_focus_icon = FALSE;
	wchar *user_data_ptr = NULL;

	data_len = sprintf((char *)data_ptr,
		"<%s id='%d' style='%d' static='%d' transparent='%d' totalnum='%d' rect='%d %d %d %d'>",
		ctrl_name_ptr,ctrl_id,menu_ctrl_ptr->cur_style,menu_ctrl_ptr->is_static,menu_ctrl_ptr->is_transparent,menu_ctrl_ptr->item_total_num,
		menu_ctrl_ptr->base_ctrl.rect.left,menu_ctrl_ptr->base_ctrl.rect.top,
		menu_ctrl_ptr->base_ctrl.rect.right,menu_ctrl_ptr->base_ctrl.rect.bottom);
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	*data_size_ptr += data_len;

	for (item_index = 0; item_index < menu_ctrl_ptr->item_total_num; item_index++)
	{
		if(!CTRLMENU_GetItem(menu_ctrl_ptr,item_index,&text_ptr,&icon_id_ptr,&is_grayed_ptr))
		{
			break;
		}

		if(item_index == menu_ctrl_ptr->cur_item_index)
		{
			is_focus_icon = 1;
		}
		else
		{
			is_focus_icon = 0;
		}
		
		data_len = sprintf((char *)data_ptr,
			"<item focus='%d' grayed='%d'>",
			is_focus_icon,is_grayed_ptr);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;	

		//title
		if(menu_ctrl_ptr->title_len != 0)
		{
			data_len = sprintf((char *)data_ptr, 
				"<title rect='%d %d %d %d'>",
				menu_ctrl_ptr->title_rect.left,menu_ctrl_ptr->title_rect.bottom,
				menu_ctrl_ptr->title_rect.right,menu_ctrl_ptr->title_rect.top);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;

			user_data_ptr = menu_ctrl_ptr->title_wstr;
			user_data_len = menu_ctrl_ptr->title_len;
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;
			data_len = sprintf((char *)data_ptr, "</title>");
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
		}


		if(icon_id_ptr)
		{
			//图片
			data_len = sprintf((char *)data_ptr, "<image id='%d'/>",icon_id_ptr);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
		}

		if(PNULL != text_ptr.wstr_ptr)
		{
			//文本
			data_len = sprintf((char *)data_ptr, "<text fontcolor='%d'>",menu_ctrl_ptr->font_color);
				Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
				*data_size_ptr += data_len;
				
			user_data_ptr = text_ptr.wstr_ptr;
			user_data_len = text_ptr.wstr_len;
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;	
			data_len = sprintf((char *)data_ptr, "</text>");
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
		}
						
		data_len = sprintf((char *)data_ptr, "</item>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;	
	}
}

/*****************************************************************************/
//  Description: 获取SlideMenu控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_SLIDE_PAGE\GUIMENU_STYLE_TRAPEZOID
//		 GUIMENU_STYLE_SPHERE\GUIMENU_STYLE_CYLINDER
//		 GUIMENU_STYLE_BINARY_STAR\GUIMENU_STYLE_SHUTTER
//	     GUIMENU_STYLE_CHARIOT\GUIMENU_STYLE_CUBE
//		 GUIMENU_ISTYLEGUIMENU_STYLE_QBTHEME
/*****************************************************************************/
LOCAL void Atest_GetSlideMenuControlProperty(
										 CTRLMENU_OBJ_T  *menu_ctrl_ptr,//MENU指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr)			//传输的数据text
{
#if 0 
	uint16 data_len = 0;
	uint16 item_index = 0;
	uint16 user_data_len = 0;
	uint16 page_item_num = 0;
	MMI_STRING_T text_ptr = { 0 };
       MMI_IMAGE_ID_T  icon_id_ptr = { 0 };
       BOOLEAN  is_grayed_ptr  = FALSE;
	BOOLEAN is_focus_icon = FALSE;
	wchar *user_data_ptr = NULL;	
	uint32 text_id = 0;

	CTRLMAINMENU_ITEM_T cur_item_info = {0};

	page_item_num = Atest_GetSlideMenuPageItemNum(menu_ctrl_ptr);//获得该page的所显示的item的个数:page_item_num

	data_len = sprintf((char *)data_ptr,
		"<%s id='%d' style='%d' static='%d' itemnum='%d' curpage ='%d' totalpage='%d' rect='%d %d %d %d'>",
		ctrl_name_ptr,ctrl_id,menu_ctrl_ptr->cur_style,menu_ctrl_ptr->is_static,
		page_item_num,menu_ctrl_ptr->cur_page_index,menu_ctrl_ptr->item_total_num,
		menu_ctrl_ptr->base_ctrl.rect.left,menu_ctrl_ptr->base_ctrl.rect.top,
		menu_ctrl_ptr->base_ctrl.rect.right,menu_ctrl_ptr->base_ctrl.rect.bottom);
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	*data_size_ptr += data_len;

	item_index = menu_ctrl_ptr->cur_item_index;//焦点所在的item
	for (menu_ctrl_ptr->cur_item_index = 0; menu_ctrl_ptr->cur_item_index < page_item_num; menu_ctrl_ptr->cur_item_index++)
	{
		if(item_index == menu_ctrl_ptr->cur_item_index)
		{
			is_focus_icon = 1;
		}
		else
		{
			is_focus_icon = 0;
		}

		data_len = sprintf((char *)data_ptr, 
			"<item focus='%d' grayed='%d'>",
			is_focus_icon,is_grayed_ptr);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;

		//title
		if(menu_ctrl_ptr->title_len != 0)
		{
			data_len = sprintf((char *)data_ptr, 
				"<title rect='%d %d %d %d'>",
				menu_ctrl_ptr->title_rect.left,menu_ctrl_ptr->title_rect.bottom,
				menu_ctrl_ptr->title_rect.right,menu_ctrl_ptr->title_rect.top);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;

			user_data_ptr = menu_ctrl_ptr->title_wstr;
			user_data_len = menu_ctrl_ptr->title_len;
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;
			data_len = sprintf((char *)data_ptr, "</title>");
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
		}

		if (PNULL == ((GUIMENU_PROCESS_T*)(menu_ctrl_ptr->process_func[menu_ctrl_ptr->cur_style]))->GetItemPtr)
	 	{
			break;
		}
		else
		{
			((GUIMENU_PROCESS_T*)(menu_ctrl_ptr->process_func[menu_ctrl_ptr->cur_style]))->GetItemPtr(menu_ctrl_ptr, menu_ctrl_ptr->cur_page_index, menu_ctrl_ptr->cur_item_index,&cur_item_info);
		}
		
		switch (cur_item_info.menu_data_type)
		{
			case GUIMENU_MAINMENU_DATA_TYPE_STATIC: //静态菜单信息
				if(cur_item_info.menu_data.static_menu_ptr->unselect_icon_id)
				{
					data_len = sprintf((char *)data_ptr,"<icon id='%d'/>",								
					cur_item_info.menu_data.static_menu_ptr->unselect_icon_id);
					Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
					*data_size_ptr += data_len;
				}

				text_id = cur_item_info.menu_data.static_menu_ptr->text_str_id;
				data_len = sprintf((char *)data_ptr,"<text id='%d'>",text_id);
				Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
				*data_size_ptr += data_len;
				break;
			case GUIMENU_MAINMENU_DATA_TYPE_DYNAMIC:
			    /* ERROR+++++++++++++++++++++++++++++++++++++++++++
				if(cur_item_info.menu_data.dynamic_menu_ptr->ori_data_ptr->dynamic_menu_info.has_icon)
				{
					data_len = sprintf((char *)data_ptr,"<icon id='%d'/>",								
					*(cur_item_info.menu_data.dynamic_menu_ptr->ori_data_ptr->dynamic_menu_info.icon_ptr));
					Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
					*data_size_ptr += data_len;
				}
				data_len = sprintf((char *)data_ptr,"<text>");
				Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
				*data_size_ptr += data_len;*/
				break;
			case GUIMENU_MAINMENU_DATA_TYPE_FILEFOLD:
			    /* ERROR+++++++++++++++++++++++++++++++++++++++++++
				text_id = cur_item_info.menu_data.filefold_menu_ptr->text_str_id;
				data_len = sprintf((char *)data_ptr,"<text id='%d'>",text_id);
				Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
				*data_size_ptr += data_len;*/
				break;
			default:
				break;
		}
		SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
		CTRLMENU_GetItem(menu_ctrl_ptr,item_index,&text_ptr,&icon_id_ptr,&is_grayed_ptr);
		if(!text_ptr.wstr_len)
		{
			MMITHEME_GetResText(text_id, menu_ctrl_ptr->win_handle, &text_ptr);
		}
		
		user_data_ptr = text_ptr.wstr_ptr;
		user_data_len = text_ptr.wstr_len;						
		if (user_data_len != 0)
		{
			SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
		}
		user_item_ptr[user_data_len] = L'\0';
		Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
		*data_size_ptr += user_data_len * 4;
		data_len = sprintf((char *)data_ptr,"</text>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
		
		data_len = sprintf((char *)data_ptr, "</item>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;	
	}
	menu_ctrl_ptr->cur_item_index = item_index;	
#endif
}

/*****************************************************************************/
//  Description: 获取IconMenu控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_ICON \GUIMENU_STYLE_CYCLONE
/*****************************************************************************/
LOCAL void Atest_GetIconMenuControlProperty( 
										 CTRLMENU_OBJ_T  *menu_ctrl_ptr,//MENU指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,		//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr)			//传输的数据text
{
	uint16 data_len = 0;
	uint16 item_index = 0;
	uint16 user_data_len = 0;
	MMI_STRING_T text_ptr = { 0 };
    MMI_IMAGE_ID_T  icon_id_ptr = { 0 };
    BOOLEAN  is_grayed_ptr = FALSE;
	BOOLEAN  is_focus_icon = FALSE;
	wchar *user_data_ptr = NULL;
	//CTRLMAINMENU_ITEM_T cur_item_info = {0};

	data_len = sprintf((char *)data_ptr,
		"<%s id='%d' style='%d' static='%d' transparent='%d' totalnum='%d' rect='%d %d %d %d'>",
		ctrl_name_ptr,ctrl_id,menu_ctrl_ptr->cur_style,menu_ctrl_ptr->is_static,menu_ctrl_ptr->is_transparent,menu_ctrl_ptr->item_total_num,
		menu_ctrl_ptr->base_ctrl.rect.left,menu_ctrl_ptr->base_ctrl.rect.top,
		menu_ctrl_ptr->base_ctrl.rect.right,menu_ctrl_ptr->base_ctrl.rect.bottom);
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	*data_size_ptr += data_len;

	item_index = menu_ctrl_ptr->cur_item_index;

	for (menu_ctrl_ptr->cur_item_index = 0; menu_ctrl_ptr->cur_item_index < menu_ctrl_ptr->item_total_num; menu_ctrl_ptr->cur_item_index++)
	{
		if(!CTRLMENU_GetItem(menu_ctrl_ptr,menu_ctrl_ptr->cur_item_index,&text_ptr,&icon_id_ptr,&is_grayed_ptr))
		{
			break;
		}
		if(item_index == menu_ctrl_ptr->cur_item_index)
		{
			is_focus_icon = 1;
		}
		else
		{
			is_focus_icon = 0;
		}

		data_len = sprintf((char *)data_ptr, 
			"<item focus='%d' grayed='%d'>",
			is_focus_icon,is_grayed_ptr);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;

		//title
		if(menu_ctrl_ptr->title_len != 0)
		{
			data_len = sprintf((char *)data_ptr, 
				"<title rect='%d %d %d %d'>",
				menu_ctrl_ptr->title_rect.left,menu_ctrl_ptr->title_rect.bottom,
				menu_ctrl_ptr->title_rect.right,menu_ctrl_ptr->title_rect.top);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;

			user_data_ptr = menu_ctrl_ptr->title_wstr;
			user_data_len = menu_ctrl_ptr->title_len;
			 
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;
			data_len = sprintf((char *)data_ptr, "</title>");
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
		}

		/*
		if (PNULL == ((GUIMENU_PROCESS_T*)(menu_ctrl_ptr->process_func[menu_ctrl_ptr->cur_style]))->GetItemPtr)
	 	{
			break;
		}
		else
		{
			((GUIMENU_PROCESS_T*)(menu_ctrl_ptr->process_func[menu_ctrl_ptr->cur_style]))->GetItemPtr(menu_ctrl_ptr, menu_ctrl_ptr->cur_page_index, menu_ctrl_ptr->cur_item_index,&cur_item_info);
		}*/
		
		if(is_focus_icon)
		{
			/*
			data_len = sprintf((char *)data_ptr, 
				"<icon id='%d' selectid='%d'/>",
			cur_item_info.menu_data.static_menu_ptr->unselect_icon_id,
			cur_item_info.menu_data.static_menu_ptr->select_icon_id);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
			*/
		}
		else
		{
			/*
			data_len = sprintf((char *)data_ptr, 
				"<icon id='%d'/>",								
			cur_item_info.menu_data.static_menu_ptr->unselect_icon_id);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
			*/
		}

		data_len = sprintf((char *)data_ptr,"<text>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;

		user_data_ptr = text_ptr.wstr_ptr;
		user_data_len = text_ptr.wstr_len;						
		if (user_data_len != 0)
		{
			SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
		}
		user_item_ptr[user_data_len] = L'\0';
		Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
		*data_size_ptr += user_data_len * 4;
		data_len = sprintf((char *)data_ptr,"</text>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;
		
		data_len = sprintf((char *)data_ptr, "</item>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;	
	}
	menu_ctrl_ptr->cur_item_index = item_index;
}

/*****************************************************************************/
//  Description: 获取OptionMenu控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_OPTIONS  :    /* 15 !< OptionsMenu */
/*****************************************************************************/
LOCAL void Atest_GetOptionMenuControlProperty( 
										 CTRLMENU_OBJ_T  *menu_ctrl_ptr,//MENU指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr)			//传输的数据text
{
	uint16 data_len = 0;
	uint16 item_index = 0;
	uint16 user_data_len = 0;
	MMI_STRING_T text_ptr = { 0 };
    MMI_IMAGE_ID_T  icon_id_ptr = { 0 };
    BOOLEAN  is_grayed_ptr = FALSE;
	wchar *user_data_ptr = NULL;

	data_len = sprintf((char *)data_ptr,
		"<%s id='%d' style='%d' static='%d' transparent='%d' totalnum='%d' linecnt='%d' numinline='%d' rect='%d %d %d %d'>",
		ctrl_name_ptr,ctrl_id,menu_ctrl_ptr->cur_style,menu_ctrl_ptr->is_static,
		menu_ctrl_ptr->is_transparent,menu_ctrl_ptr->item_total_num,
		menu_ctrl_ptr->line_count,*(menu_ctrl_ptr->num_in_line_ptr),
		menu_ctrl_ptr->base_ctrl.rect.left,menu_ctrl_ptr->base_ctrl.rect.top,
		menu_ctrl_ptr->base_ctrl.rect.right,menu_ctrl_ptr->base_ctrl.rect.bottom);
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	*data_size_ptr += data_len;

	for (item_index = 0; item_index < menu_ctrl_ptr->item_total_num; item_index++)
	{
		SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
		if(!CTRLMENU_GetItem(menu_ctrl_ptr,item_index,&text_ptr,&icon_id_ptr,&is_grayed_ptr))
		{
			break;
		}

		if(!menu_ctrl_ptr->options_item_info_ptr[item_index].is_more_item)
		{
			data_len = sprintf((char *)data_ptr, 
				"<item imgid='%d' rect='%d %d %d %d'>",
				icon_id_ptr,
				menu_ctrl_ptr->options_item_info_ptr[item_index].rect.left,
				menu_ctrl_ptr->options_item_info_ptr[item_index].rect.top,
				menu_ctrl_ptr->options_item_info_ptr[item_index].rect.right,
				menu_ctrl_ptr->options_item_info_ptr[item_index].rect.bottom);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;	

			user_data_ptr = text_ptr.wstr_ptr;
			user_data_len = text_ptr.wstr_len;						
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;
			
			data_len = sprintf((char *)data_ptr, "</item>");
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
		}
		else
		{	
			data_len = sprintf((char *)data_ptr, 
				"<item imgid='%d' textid='%d' rect='%d %d %d %d'>",
				menu_ctrl_ptr->options_theme.more_item_image_id,
				menu_ctrl_ptr->options_theme.more_item_text_id,
				menu_ctrl_ptr->options_item_info_ptr[item_index].rect.left,
				menu_ctrl_ptr->options_item_info_ptr[item_index].rect.top,
				menu_ctrl_ptr->options_item_info_ptr[item_index].rect.right,
				menu_ctrl_ptr->options_item_info_ptr[item_index].rect.bottom);
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;	

			MMITHEME_GetResText(menu_ctrl_ptr->options_theme.more_item_text_id, menu_ctrl_ptr->win_handle, &text_ptr);

			user_data_ptr = text_ptr.wstr_ptr;
			user_data_len = text_ptr.wstr_len;						
			if (user_data_len != 0)
			{
				SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
			}
			user_item_ptr[user_data_len] = L'\0';
			Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
			*data_size_ptr += user_data_len * 4;
			
			data_len = sprintf((char *)data_ptr, "</item>");
			Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
			*data_size_ptr += data_len;
			
			break;
		}
	}
}

/*****************************************************************************/
//  Description: 获取CrystalMenu控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_CRYSTAL_CUBE:/*! 17 < 水晶立方体风格 */
/*****************************************************************************/
LOCAL void Atest_GetCrystalMenuControlProperty(
										 CTRLMENU_OBJ_T  *menu_ctrl_ptr,//MENU指针
										 MMI_CTRL_ID_T ctrl_id,			//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,			//控件类型
 										 uint32 *data_size_ptr,			//返回的数据长度
 										 uint8 *data_ptr,				//返回的数据
 										 wchar *user_item_ptr)			//传输的数据text
{
#ifdef MENU_CRYSTALCUBE_SUPPORT
	uint16 data_len = 0;
	uint16 item_index = 0;
	uint16 user_data_len = 0;
	MMI_STRING_T text_ptr = { 0 };
    MMI_IMAGE_ID_T icon_id_ptr = { 0 };
    BOOLEAN  is_grayed_ptr = FALSE;
	BOOLEAN  is_focus = FALSE;
	wchar *user_data_ptr = NULL;
	GUIMENU_CRYSTALCUBEMENU_DATA_T menu_data = { 0 };
	CTRLMAINMENU_ITEM_T cur_item_info = { 0 };
	
	menu_data = menu_ctrl_ptr->main_menu_data.crystalcube_menu_data; //crystal nemu data

	data_len = sprintf((char *)data_ptr,
		"<%s id='%d' style='%d' cubemode='%d' static='%d' transparent='%d' pagenum='%d' rownum='%d' colnum='%d' rect='%d %d %d %d'>",
		ctrl_name_ptr,ctrl_id,menu_ctrl_ptr->cur_style,
		menu_ctrl_ptr->cube_mode,menu_ctrl_ptr->is_static,
		menu_ctrl_ptr->is_transparent,menu_data.page_num,
		menu_data.page_row_num,menu_data.page_col_num,
		menu_data.page_rect.left,menu_data.page_rect.top,
		menu_data.page_rect.right,menu_data.page_rect.bottom);
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	*data_size_ptr += data_len;

	item_index = menu_ctrl_ptr->cur_item_index;

	for (menu_ctrl_ptr->cur_item_index = 0;menu_ctrl_ptr->cur_item_index < CRYSTALCUBE_MENUMAIN_ICON_ITEM_MAX_NUM ; menu_ctrl_ptr->cur_item_index++)
	{
		if(!CTRLMENU_GetItem(menu_ctrl_ptr,menu_ctrl_ptr->cur_item_index,&text_ptr,&icon_id_ptr,&is_grayed_ptr))
		{
			break;
		}

		if(item_index == menu_ctrl_ptr->cur_item_index)
		{
			is_focus= 1;
		}
		else
		{
			is_focus = 0;
		}

		if(!icon_id_ptr)
		{
		/*
			if (PNULL == ((GUIMENU_PROCESS_T*)(menu_ctrl_ptr->process_func[menu_ctrl_ptr->cur_style]))->GetItemPtr)
		 	{
				break;
			}
			else
			{
				((GUIMENU_PROCESS_T*)(menu_ctrl_ptr->process_func[menu_ctrl_ptr->cur_style]))->GetItemPtr(menu_ctrl_ptr, menu_ctrl_ptr->cur_page_index, menu_ctrl_ptr->cur_item_index,&cur_item_info);
			}*/

			if(PNULL != cur_item_info.menu_data.static_menu_ptr)
			{
				icon_id_ptr = cur_item_info.menu_data.static_menu_ptr->unselect_icon_id;
			}
		}

		data_len = sprintf((char *)data_ptr, 
			"<item iconid='%d' focus='%d' rect='%d %d %d %d'>",
			icon_id_ptr,is_focus,
			menu_data.item_image_display_rect[menu_ctrl_ptr->cur_item_index].left,
			menu_data.item_image_display_rect[menu_ctrl_ptr->cur_item_index].top,
			menu_data.item_image_display_rect[menu_ctrl_ptr->cur_item_index].right,
			menu_data.item_image_display_rect[menu_ctrl_ptr->cur_item_index].bottom);
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;	

		user_data_ptr = text_ptr.wstr_ptr;
		user_data_len = text_ptr.wstr_len;						
		if (user_data_len != 0)
		{
			SCI_MEMCPY((char *)user_item_ptr, (char *)user_data_ptr, user_data_len * 2);
		}
		user_item_ptr[user_data_len] = L'\0';
		Atest_TransmitATString((uint8*)user_item_ptr, user_data_len * 2, TRUE, FALSE);
		*data_size_ptr += user_data_len * 4;
		
		data_len = sprintf((char *)data_ptr, "</item>");
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
		*data_size_ptr += data_len;		
	}
	menu_ctrl_ptr->cur_item_index = item_index;
#endif
}

/*****************************************************************************/
//  Description: 获取Scrollkey控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetScrollkeyControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
#ifdef GUIF_SCROLLKEY
	uint16 data_len = 0; 
	CTRLSCROLLKEY_OBJ_T* scrollkey_ptr = PNULL;

	scrollkey_ptr = (CTRLSCROLLKEY_OBJ_T *)ctrl_ptr;
	if (PNULL == scrollkey_ptr)
	{
		 return;
	}

	data_len = sprintf((char *)data_ptr, 
		"<%s id='%d' visible='%d' tpdisable='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr,ctrl_id,scrollkey_ptr->is_visible,scrollkey_ptr->tp_disable,
		scrollkey_ptr->base_ctrl.rect.left,scrollkey_ptr->base_ctrl.rect.top,
		scrollkey_ptr->base_ctrl.rect.right,scrollkey_ptr->base_ctrl.rect.bottom);
	 Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	 *data_size_ptr += data_len;
#endif
}

/*****************************************************************************/
//  Description: 获取Iconfolder控件描述
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetIconfolderControlProperty(
										 IGUICTRL_T *ctrl_ptr,		//控件指针
										 MMI_CTRL_ID_T ctrl_id,		//控件id
										 MMI_HANDLE_T ctrl_handle,	//控件handle
 										 char *ctrl_name_ptr,		//控件类型
 										 uint32 *data_size_ptr,		//返回的数据长度
 										 uint8 *data_ptr,			//返回的数据
 										 wchar *user_item_ptr)		//传输的数据text
{
	uint16 data_len = 0; 
	
	CTRLICONLIST_OBJ_T    *iconfolder_ctrl_ptr = PNULL;
	//GUI_RECT_T rect = {0};

	iconfolder_ctrl_ptr = (CTRLICONLIST_OBJ_T *)ctrl_ptr;
	if (PNULL == iconfolder_ctrl_ptr)
	{
		 return;
	}

	data_len = sprintf((char *)data_ptr, 
		"<%s id='%d' totalnum='%d' rect='%d %d %d %d'>", 
		ctrl_name_ptr,ctrl_id,iconfolder_ctrl_ptr->total_num,
		iconfolder_ctrl_ptr->base_ctrl.rect.left,iconfolder_ctrl_ptr->base_ctrl.rect.top,
		iconfolder_ctrl_ptr->base_ctrl.rect.right,iconfolder_ctrl_ptr->base_ctrl.rect.bottom);
	 Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	 *data_size_ptr += data_len;
}

/*****************************************************************************/
//  Description:触摸对应的控件
//				AT+SFTIN="ISCP,text,0,1,0061"			//字符串
//				AT+SFTIN="ISCP,control,0,1,4556622"		//控件id
//				AT+SFTIN="ISCP,image,0,1,1023645"		//图片id 
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_ClickControl( // 取到控件内容，返回TRUE
    uint8 *user_data_ptr)
{
	uint8 *start_ptr = user_data_ptr;
	uint8 find_content[ATEST_MAX_STR_LEN] = {0};
	uint16 rect_x,rect_y = 0;
	ATEST_ID_TYPE_E id_type;
	uint32 delay_time = 0;
	uint8 rect_arr[32] ={0};
	BOOLEAN result= FALSE;
	int user_data_len = 0;

	if(PNULL == user_data_ptr)
	{
		return FALSE;
	}
	
	user_data_len = strlen((char *)user_data_ptr);	
	receive_data_arr = (uint8 *)SCI_ALLOC_APP(user_data_len + 1);
	if (PNULL == receive_data_arr)
	{
	    return FALSE;
	}
		
	if(user_data_len)
	{
		SCI_MEMSET(receive_data_arr, 0, user_data_len + 1);
	    SCI_MEMCPY(receive_data_arr, user_data_ptr, user_data_len);
	}

	// 解析两个逗号之间的部分，为要触发的字符串命令
	Atest_GetMessageContent(find_content,',',&start_ptr);	
	if(!stricmp((char*)find_content,"text"))
	{
		id_type = TEXT_TYPE;
	}
	else if(!stricmp((char*)find_content,"textid"))
	{
		id_type = TEXT_ID_TYPE;
	}
	else if(!stricmp((char*)find_content,"control"))
	{
		id_type = CONTROL_ID_TYPE;
	}
	else if(!stricmp((char*)find_content,"image"))
	{
		id_type = IMAGE_ID_TYPE;
	}
	else if(!stricmp((char*)find_content,"index"))
	{
		id_type = INDEX_ID_TYPE;
	}
	else if(!stricmp((char*)find_content,"imgindex"))
	{
		id_type = IMAGE_INDEX_TYPE;
	}
	else if(!stricmp((char*)find_content,"textimg"))
	{
		id_type = TEXT_IMG_TYPE;
	}
	else
	{
		id_type = NONE_ID_TYPE;
		return FALSE;
	}

	//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_ClickControl--%d"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_6912_112_2_18_1_59_39_31,(uint8*)"d",id_type);

	delay_time = Atest_GetTestMessageId(',',&start_ptr); //获得延时时间

	if(Atest_SearchControlPosition(id_type,start_ptr,&rect_x,&rect_y))
	{
		//SCI_TRACE_LOW:"[ATC:][ATEST:]find Control position succeed--%d--%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_6918_112_2_18_1_59_39_32,(uint8*)"dd",rect_x,rect_y);

		if(Atest_ConvertPositionByLcd(&rect_x,&rect_y))
		{
			Atest_SendTouchMessage(MMI_TP_DOWN,rect_x,rect_y);
			if(delay_time>=MMI_TP_LONG_PRESS_VALUE)
			{
				sprintf((char *)rect_arr,",%d,%d,",rect_x,rect_y);			
				Atest_SendSignalToAppTask( rect_arr,strlen((char *)rect_arr),delay_time,ATEST_SIGNAL_TPLONG);			
			}
			
			Atest_SendTouchMessage(MMI_TP_UP,rect_x,rect_y);			
			result= TRUE;
		}
		else
		{
			//SCI_TRACE_LOW:"[ATC:][ATEST:] ConvertPosition failed"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_6934_112_2_18_1_59_39_33,(uint8*)"");
			result= FALSE;
		}
	}
	else
	{
		//SCI_TRACE_LOW:"[ATC:][ATEST:]find Control failed"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_6940_112_2_18_1_59_39_34,(uint8*)"");
		result= FALSE;
	}

	SCI_FREE(receive_data_arr);
	return result;
}

/*****************************************************************************/
//  Description:解析命令,获取内容
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_GetMessageContent( 
									uint8 *message_content,		// 解析的内容
								    char separator,             // ID分隔符
								    uint8 **message_pptr)      // 返回指向下一个要解析的位置

{
    char mssage_id_arr[MAX_CMD_LEN] = { 0 };
	char *end_ptr = PNULL;
	uint8 i = 0;
	char *start_ptr = (char*)*message_pptr; 

    // 解析两个逗号之间的部分
    while ( ('\0' != *start_ptr) && (*start_ptr != separator) )
    {
        start_ptr++;
    }

    end_ptr = ++start_ptr;
    start_ptr = mssage_id_arr;

    while ( ('\0' != *end_ptr) && (*end_ptr != separator) )
    {
		*(message_content+i)= (uint8)*end_ptr;
		end_ptr++;
		i++;
    }
	*(message_content+i) = '\0';

    // *message_pptr指向下一个待解析的消息
    *message_pptr = (uint8*)end_ptr;	
}

/*****************************************************************************/
//  Description:查找对应的控件，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_SearchControlPosition(
										ATEST_ID_TYPE_E id_type,	//查找类型
										uint8 *find_data_ptr,		//所需查找的数据
										uint16 *rect_x,				//返回的坐标
										uint16 *rect_y)				//返回的坐标
{
	MMI_HANDLE_T win_handle = MMK_GetTopmostWindow();
    MMI_TREE_NODE_T *win_tree_ptr = MMK_GetWinTreeNode(win_handle);
	if (PNULL == win_tree_ptr)
    {
        return FALSE;
    }
	
	if(!Atest_SearchWindowTree(win_tree_ptr,win_tree_ptr->next_ptr,id_type,find_data_ptr,rect_x,rect_y))
	{
		return FALSE;
	}

	return TRUE;
}

/*****************************************************************************/
//  Description: 查找窗体
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_SearchWindowTree(
									MMI_TREE_NODE_T *root_ptr,	//窗体的根节点指针
									MMI_TREE_NODE_T *next_ptr,	//窗体根节点的兄弟指针
									ATEST_ID_TYPE_E id_type,	//查找类型
									uint8 *find_data_ptr,		//所需查找的数据
									uint16 *rect_x,				//返回的坐标
									uint16 *rect_y)				//返回的坐标
{
    MMI_TREE_NODE_T *find_node_ptr = root_ptr;
    MMI_TREE_NODE_T *ctrl_tree_root_ptr = PNULL;
    
    // 从树根开始搜索
    if (PNULL == find_node_ptr)
    {
        return FALSE;
    }

    // 递归遍历窗体
    do {
        ctrl_tree_root_ptr = MMK_GetCtrlTreeRootByWin(find_node_ptr->data);
		//SCI_TRACE_LOW:"[ATC:][ATEST:]Search Window--%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7033_112_2_18_1_59_39_35,(uint8*)"d",find_node_ptr->data);
		
		if (ctrl_tree_root_ptr)
		{
			if(Atest_SearchControlTree(ctrl_tree_root_ptr,id_type,find_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}

        // 先遍历子节点
        if (PNULL != find_node_ptr->child_ptr)
        {
            if(Atest_SearchWindowTree(find_node_ptr->child_ptr,next_ptr,id_type,find_data_ptr,rect_x,rect_y))
            {
				return TRUE;
			}
        }
        // 再遍历兄弟节点
        find_node_ptr = find_node_ptr->next_ptr;
		if (next_ptr == find_node_ptr)
        {
            break;
        }
    } while (find_node_ptr != root_ptr); 

	return FALSE;
}

/*****************************************************************************/
//  Description:遍历该窗口的控件，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/  
LOCAL BOOLEAN Atest_SearchControlTree(
								    MMI_TREE_NODE_T *root_ptr,	// 控件树根节点
								    ATEST_ID_TYPE_E id_type,	//查找类型
								    uint8 *user_data_ptr,		//所需查找的数据
								    uint16 *rect_x,				//返回的坐标
									uint16 *rect_y)				//返回的坐标
{
    IGUICTRL_T *ctrl_ptr = PNULL;
    MMI_TREE_NODE_T *find_node_ptr = root_ptr;

    // 从控件树根开始搜索
    if (PNULL == root_ptr)
    {
        return FALSE;
    }

    // 递归遍历窗体控件
    do {
        // 通过控件节点获取控件指针
        ctrl_ptr = MMK_GetCtrlPtr(find_node_ptr->data);
        // 控件起始属性标记 <EDITBOX>
        if(Atest_SearchControlProperty(ctrl_ptr,id_type,user_data_ptr,rect_x,rect_y))
        {
			return TRUE;
		}
		else
		{
			// 先遍历子节点
			if (PNULL != find_node_ptr->child_ptr)
			{
				if(Atest_SearchControlTree(find_node_ptr->child_ptr,id_type,user_data_ptr,rect_x,rect_y))
				{
					return TRUE;
				}				
			}

			// 再遍历兄弟节点
			find_node_ptr = find_node_ptr->next_ptr;
		}
    } while (find_node_ptr != root_ptr);

	return FALSE;
}

/*****************************************************************************/
//  Description:查找各控件，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchControlProperty(
	IGUICTRL_T *ctrl_ptr,
    ATEST_ID_TYPE_E id_type,
    uint8 *user_data_ptr,
    uint16 *rect_x,
	uint16 *rect_y)
{
	MMI_HANDLE_T ctrl_handle = GUICTRL_GetCtrlHandle(ctrl_ptr);
	MMI_CTRL_ID_T ctrl_id = MMK_GetCtrlId(ctrl_handle);	
	CAF_GUID_T ctrl_guid = GUICTRL_GetCtrlGuid(ctrl_ptr);

	//SCI_TRACE_LOW:"[ATC:][ATEST:]Search Control,ctrl_guid=%d"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7125_112_2_18_1_59_39_36,(uint8*)"d",ctrl_guid);

	if(!ctrl_id)
	{
		return FALSE;
	}

	ctrl_ptr = MMK_GetCtrlPtrByWin(MMK_GetFocusWinHandle(), ctrl_id);
    if (PNULL == ctrl_ptr)
    {
        return FALSE;
    }

	switch (ctrl_guid)		
	{
		case SPRD_GUI_EDITBOX_ID:
		case SPRD_GUI_TEXTEDIT_ID:
        	case SPRD_GUI_PHONENUMEDIT_ID:
        	case SPRD_GUI_DIGITALEDIT_ID:
        	case SPRD_GUI_PSWEDIT_ID:
	       case SPRD_GUI_LISTEDIT_ID:
		{
			if(Atest_SearchEditBoxControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;

		case SPRD_GUI_LIST_ID :
	    {
			if(Atest_SearchListControlItem(ctrl_ptr,ctrl_handle,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
	    }
		break;

        case SPRD_GUI_MAINMENU_ID:
		{
			if(Atest_SearchMainMenuControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
   	    }
		break;
		case SPRD_GUI_MENU_ID :
	    {
			if(Atest_SearchMenuControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
	    }
		break;

		case SPRD_GUI_SOFTKEY_ID:
	    {
			if(Atest_SearchSoftKeyControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
	    }
		break; 

		case SPRD_GUI_LABEL_ID:
	    {
			if(Atest_SearchLableControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
	    }
		break; 
		
		case SPRD_GUI_SETLIST_ID:
		{
			if(Atest_SearchSetlistControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
	    }
		break;

		case SPRD_GUI_BUTTON_ID:
		{
			if(Atest_SearchButtonControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
	    }
		break;

		case SPRD_GUI_RICHTEXT_ID:
		{
			if(Atest_SearchRichTextControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;

		case SPRD_GUI_TAB_ID:
		{
			if(Atest_SearchTabControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;

		case SPRD_GUI_ANIM_ID :
		{
			if(Atest_SearchAnimControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;
		
		case SPRD_GUI_MSGBOX_ID:
		{
			if(Atest_SearchMsgboxControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;        

		case SPRD_GUI_TEXTBOX_ID: 
		{
			if(Atest_SearchTextboxControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;      

		case SPRD_GUI_DROPDOWNLIST_ID:
		{
			if(Atest_SearchDropdownlistControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;  
		
		case SPRD_GUI_ICONLIST_ID: 
		{
			if(Atest_SearchIconlistControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;

		case SPRD_GUI_TITLE_ID: 
		{
			if(Atest_SearchTitleControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;

		case SPRD_GUI_IM_ID :
		{
			if(Atest_SearchIMControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;

		case SPRD_GUI_TOOLBAR_ID : 
		{
			if(Atest_SearchToolBarControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;

		case SPRD_GUI_TIPS_ID:
		{
			if(Atest_SearchTipsControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;
		
		case SPRD_GUI_STATUSBAR_ID: 
		{
			if(Atest_SearchStatusbarControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;

		case SPRD_GUI_OWNDRAW_ID :
		{
			if(Atest_SearchOwndrawControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;
		
		case SPRD_GUI_PRGBOX_ID:
		{
			if(Atest_SearchPrgboxControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;
		
		case SPRD_GUI_FORM_ID:
		{
			if(Atest_SearchFormControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;
		
		case SPRD_GUI_ICONFOLDER_ID: 
		{
			if(Atest_SearchIconfolderControlItem(ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y))
			{
				return TRUE;
			}
		}
		break;
		
		case SPRD_GUI_PUNCTUATION_ID:		
		default:
			break;
	}
	return FALSE;
}

/*****************************************************************************/
//  Description:根据rotate lcd对按键事件进行转换
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL void Atest_KbdConvert(uint32 *signal_keycode)		//按键事件类型
{
    switch (GUILCD_GetRotateAngle((LCD_ID_E)GUI_MAIN_LCD_ID))
    {
	case LCD_ANGLE_90:
		switch (*signal_keycode)
	    {
		case SCI_VK_UP:
			*signal_keycode = SCI_VK_RIGHT;
	        break;
		case SCI_VK_DOWN:
			*signal_keycode = SCI_VK_LEFT;
	        break;
		case SCI_VK_LEFT:	
			*signal_keycode = SCI_VK_DOWN;
	        break;
	    case SCI_VK_RIGHT:
			*signal_keycode = SCI_VK_UP;
	        break;
	    default:
	        break;
	    }
        break;
	case LCD_ANGLE_270:	
		switch (*signal_keycode)
	    {
		case SCI_VK_UP:
			*signal_keycode = SCI_VK_LEFT;
	        break;
		case SCI_VK_DOWN:
			*signal_keycode = SCI_VK_RIGHT;
	        break;
		case SCI_VK_LEFT:	
			*signal_keycode = SCI_VK_UP;
	        break;
	    case SCI_VK_RIGHT:
			*signal_keycode = SCI_VK_DOWN;
	        break;
	    default:
	        break;
	    }
        break;
    case LCD_ANGLE_180:
		switch (*signal_keycode)
	    {
		case SCI_VK_UP:
			*signal_keycode = SCI_VK_DOWN;
	        break;
		case SCI_VK_DOWN:
			*signal_keycode = SCI_VK_UP;
	        break;
		case SCI_VK_LEFT:	
			*signal_keycode = SCI_VK_RIGHT;
	        break;
	    case SCI_VK_RIGHT:
			*signal_keycode = SCI_VK_LEFT;
	        break;
	    default:
	        break;
	    }
        break;
    default:
        break;
    }
	//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_KbdConvert,keycode--%d"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7416_112_2_18_1_59_40_37,(uint8*)"d",*signal_keycode);
}

/*****************************************************************************/
//  Description: 将消息发送到APP task处理
//  Global resource dependence :none
//  Author: linchen
//  Note:缓解P_ATC压力，开一块内存，扔给P_APP处理
/*****************************************************************************/
LOCAL void Atest_SendSignalToAppTask( 
								uint8 *user_data_ptr,	 // 用户发过来的AT命令
								uint32 len,				 // 用户发过来的AT命令的长度
								uint32 reserved_data,	 // 发送时附加的数据
								uint16 signalType)		 // 发送到APP的消息类型
{
    MmiOtherTaskMsgS*signal_ptr = PNULL;
    uint8 *send_data_ptr = PNULL;

    MmiCreateSignal(signalType, sizeof(MmiOtherTaskMsgS), (MmiSignalS**)&signal_ptr);
    signal_ptr->Sender = P_APP;	

    //申请一块内存保存用户数据
    send_data_ptr = (uint8 *)SCI_ALLOC_APP(len + 1);
    if (PNULL == send_data_ptr)
    {
        return;
    }
	if(PNULL != user_data_ptr && 0 != len)
	{
	    SCI_MEMSET(send_data_ptr, 0, len + 1);
	    SCI_MEMCPY(send_data_ptr, user_data_ptr, len);
	    
	    signal_ptr->param_ptr = (void *)send_data_ptr;
	}
	signal_ptr->msg_id = reserved_data;
		
    MmiSendSignal(TASK_FL_ID, (MmiSignalS*)signal_ptr);
}

/*****************************************************************************/
//  Description:处理atc按键消息
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL void Atest_ResolveKbdSignal(
								uint32 signal_keycode,
								uint8 *use_data_ptr,
								uint32 reserved_data)	 
{
//	if(reserved_data != 0)
//	{
		Atest_SendKbdMessage(signal_keycode);	
		Atest_SendSignalToAppTask(use_data_ptr,strlen((char *)use_data_ptr),0,ATEST_SIGNAL_ISCP);
//	}
}

/*****************************************************************************/
//  Description:根据坐标，发送按键事件
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL void Atest_SendKbdMessage(
								uint32 signal_keycode)	 //按键事件类型
{
	MmiKeyPress* KeysendSignal  = PNULL;

	Atest_KbdConvert(&signal_keycode);
	//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SendKbdMessage,signal_keycode=%d"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7479_112_2_18_1_59_40_38,(uint8*)"d",signal_keycode);

	//虚拟物理按键消息，KEY_DOWN/KEY_UP要成对
    MmiCreateSignal(KPD_DOWN, sizeof(MmiKeyPress), (MmiSignalS**)&KeysendSignal);
    KeysendSignal->keyCode = signal_keycode;
    KeysendSignal->Sender = KPDSVR;
    MmiSendSignal(TASK_FL_ID, (MmiSignalS*)KeysendSignal);
  
    //key up msg
    MmiCreateSignal(KPD_UP, sizeof(MmiKeyPress), (MmiSignalS**)&KeysendSignal);
    KeysendSignal->keyCode = signal_keycode;
    KeysendSignal->Sender = KPDSVR;
    MmiSendSignal(TASK_FL_ID, (MmiSignalS*)KeysendSignal);
}

/*****************************************************************************/
//  Description:根据坐标，发送触屏事件
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL void Atest_SendTouchMessage(
									MMI_TP_STATUS_E tp_type,	//TP类型
									uint16 rect_x,				//TP 坐标x
									uint16 rect_y)				//TP 坐标y
{
	MmiTPPress* sendSignal  = PNULL;

	//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SendTouchMessage,tp_type--%d"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7505_112_2_18_1_59_40_39,(uint8*)"d",tp_type);

	MmiCreateSignal((uint16)tp_type, sizeof(MmiTPPress), (MmiSignalS**)&sendSignal);    
    sendSignal->x  = rect_x;
    sendSignal->y  = rect_y;
    sendSignal->Sender = P_TPP;
    
    MmiSendSignal(TASK_FL_ID, (MmiSignalS*)sendSignal);	
}

/*****************************************************************************/
//  Description: 获得当前的分辨率
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetCurResolution()
{
	LCD_ANGLE_E RotateAngle = {0} ;
	uint16 logic_width = 0;
    uint16 logic_height = 0;
	uint8 data_len = 0;
	uint8 *data_ptr = PNULL;

	data_ptr = (uint8 *)SCI_ALLOC_APP(64);
    if (PNULL == data_ptr)
    {
        return FALSE;
    }
    SCI_MEMSET(data_ptr, 0, 64);

	//get rotate angle
	RotateAngle = GUILCD_GetRotateAngle((LCD_ID_E)GUI_MAIN_LCD_ID);
	//get lcd width and height
	if(GUILCD_GetWidthHeightByAngle((LCD_ID_E)GUI_MAIN_LCD_ID,RotateAngle,&logic_width,&logic_height))
	{
		data_len = sprintf((char *)data_ptr,"%dx%d",logic_width,logic_height);
		SCI_MEMSET(data_ptr, 0, 64);
		data_len = sprintf((char *)data_ptr,"<Reso>%dx%d</Reso><Len>%d</Len>",logic_width,logic_height,data_len);		
		Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);
	}

	SCI_FREE(data_ptr);
	return TRUE;
}

/*****************************************************************************/
//  Description: 获取当前语言
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetCurLang()
{
	uint8 data_len = 0;
	uint8 *data_ptr = PNULL;
	uint8 language_type = MMISET_GetCurrentLanguageType();

	//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_GetCurLang-%d-%s"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7559_112_2_18_1_59_40_40,(uint8*)"ds",language_type,cur_lang[language_type].language_name);

	data_ptr = (uint8 *)SCI_ALLOC_APP(64);
    if (PNULL == data_ptr)
    {
        return FALSE;
    }
    SCI_MEMSET(data_ptr, 0, 64);

	data_len = sprintf((char *)data_ptr,"<Lang>%s</Lang><Len>%d</Len>",cur_lang[language_type].language_name,strlen(cur_lang[language_type].language_name));
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);

	SCI_FREE(data_ptr);
	return TRUE;
}

/*****************************************************************************/
//  Description: 获取当前list或icon list的总个数
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetListNum(uint8 *user_data_ptr)
{
	uint32 ctrl_id = 0;
	IGUICTRL_T* ctrl_ptr = PNULL;
	CAF_GUID_T ctrl_guid = {0};
	CTRLLIST_OBJ_T *list_ctrl_ptr = PNULL;
	CTRLICONLIST_OBJ_T  *iconlist_ctrl_ptr = PNULL;
	CTRLRICHTEXT_OBJ_T *richtext_ptr = PNULL;
	GUIRICHTEXT_ITEM_T richedit_item = { 0 };
	uint8 data_len = 0;
	uint8 *data_ptr = PNULL;
	uint16 total_num = 0;
	MMI_HANDLE_T win_handle;
	
	uint8 *start_ptr = user_data_ptr;	
	
	ctrl_id = Atest_GetTestMessageId(',',&start_ptr); 
	ctrl_ptr = MMK_GetCtrlPtr(ctrl_id);

	// 获取焦点窗体handle
    win_handle = MMK_GetFocusWinHandle();
    ctrl_ptr = MMK_GetCtrlPtrByWin(win_handle, ctrl_id);

	if(PNULL == ctrl_ptr)
	{
		return FALSE;
	}

	data_ptr = (uint8 *)SCI_ALLOC_APP(64);
    if (PNULL == data_ptr)
    {
        return FALSE;
    }
	
		ctrl_guid= GUICTRL_GetCtrlGuid(ctrl_ptr);
	if(SPRD_GUI_LIST_ID == ctrl_guid)
	{
		list_ctrl_ptr = (CTRLLIST_OBJ_T *)ctrl_ptr;
		total_num = list_ctrl_ptr->total_item_num;
	}
	else if(SPRD_GUI_ICONLIST_ID == ctrl_guid)
	{
		iconlist_ctrl_ptr = (CTRLICONLIST_OBJ_T *)ctrl_ptr;
		total_num = iconlist_ctrl_ptr->total_num;
	}
	else if(SPRD_GUI_RICHTEXT_ID == ctrl_guid)
	{
		richtext_ptr = (CTRLRICHTEXT_OBJ_T *)ctrl_ptr;
		for (total_num = 0; ; total_num++)
	    {
	        if(!CTRLRICHTEXT_GetItem(GUICTRL_GetCtrlHandle(ctrl_ptr), total_num, &richedit_item))
	        {
				break;
			}
			
			if ( (GUIRICHTEXT_TEXT_INVALID == richedit_item.text_type ) && (GUIRICHTEXT_IMAGE_INVALID == richedit_item.img_type) )
	        {
	            break;
	        }
			
			if(total_num > 20)
			{
				total_num = 0;
				break;
			}
		}
	}

	data_len = sprintf((char *)data_ptr,"<TotalNum>%d</TotalNum>",total_num);
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);

	SCI_FREE(data_ptr);
	return TRUE;	
}


/*****************************************************************************/
//  Description: 获取当前主题
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetCurStyle(uint8 *user_data_ptr)
{
	uint8 data_len = 0;
	uint8 *data_ptr = PNULL;
	char strstyle[16] = {0};
	MMISET_IDLE_STYLE_E style = MMIAPISET_GetIdleStyle();

	data_ptr = (uint8 *)SCI_ALLOC_APP(64);
    if (PNULL == data_ptr)
    {
        return FALSE;
    }
	
	switch (style)
	{
		case MMISET_IDLE_STYLE_COMMON:
			sprintf(strstyle,"COMMON");
			break;
		case MMISET_IDLE_STYLE_SMART:
			sprintf(strstyle,"SMART");
			break;			
		case MMISET_IDLE_STYLE_WIDGET:
			sprintf(strstyle,"WIDGET");
			break;			
		case MMISET_IDLE_STYLE_GRID:
			sprintf(strstyle,"GRID");
			break;			
		case MMISET_IDLE_ISTYLE:
			sprintf(strstyle,"ISTYLE");
			break;			
		case MMISET_IDLE_QBTHEME:
			sprintf(strstyle,"QBTHEME");
			break;	
		default:
			sprintf(strstyle,"UNKNOW");
			break;			
	}	

	data_len = sprintf((char *)data_ptr,"<CurStyle>%s</CurStyle><Len>%d</Len>",strstyle,strlen(strstyle));
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);

	SCI_FREE(data_ptr);
	return TRUE;
}


/*****************************************************************************/
//  Description: 触笔对应的坐标
//  Global resource dependence :
//  Author:linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_TouchPanelPoint( uint8 *user_data_ptr)
{
	uint32 delay_time = 0;
	uint8 *start_ptr = PNULL;
	uint32 rect_x = 0;
	uint32 rect_y = 0;
	uint8 rect_arr[32] ={0};

	if(PNULL != user_data_ptr)
	{
		start_ptr = user_data_ptr;

		delay_time = Atest_GetTestMessageId(',',&start_ptr);
		rect_x = Atest_GetTestMessageId(',',&start_ptr);
		rect_y = Atest_GetTestMessageId(',',&start_ptr);
		
		Atest_SendTouchMessage(MMI_TP_DOWN,rect_x,rect_y);
		if(delay_time>=MMI_TP_LONG_PRESS_VALUE)
		{
			sprintf((char *)rect_arr,",%d,%d,",rect_x,rect_y);			
			Atest_SendSignalToAppTask( rect_arr,strlen((char *)rect_arr),delay_time,ATEST_SIGNAL_TPLONG);			
		}
		
		Atest_SendTouchMessage(MMI_TP_UP,rect_x,rect_y);
	}
}

/*****************************************************************************/
//  Description: 触笔down
//  Global resource dependence :
//  Author:linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_TouchPanelDown( uint8 *user_data_ptr)
{
	uint8 *start_ptr = PNULL;
	uint32 rect_x = 0;
	uint32 rect_y = 0;

	if(PNULL != user_data_ptr)
	{
		start_ptr = user_data_ptr;
		rect_x = Atest_GetTestMessageId(',',&start_ptr);
		rect_y = Atest_GetTestMessageId(',',&start_ptr);

		//SCI_TRACE_LOW:"[AT][ATEST]:Atest_TouchPanelDown,-%d,%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7677_112_2_18_1_59_40_41,(uint8*)"dd",rect_x,rect_y);
		
		Atest_SendTouchMessage(MMI_TP_DOWN,rect_x,rect_y);		
	}
}

/*****************************************************************************/
//  Description: 按键down
//  Global resource dependence :
//  Author:linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_KBDown( uint8 *user_data_ptr)
{
	uint32 signal_keycode = 0;
	uint8 *start_ptr = PNULL;

	if(PNULL != user_data_ptr)
	{
		start_ptr = user_data_ptr;
		signal_keycode = Atest_GetTestMessageId(',',&start_ptr);

		//SCI_TRACE_LOW:"[AT][ATEST]:Atest_KBDown,-%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7697_112_2_18_1_59_40_42,(uint8*)"d",signal_keycode);

		Atest_SendKbdMessage(signal_keycode);
	}
}

/*****************************************************************************/
//  Description: 触笔move
//  Global resource dependence :
//  Author:linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_TouchPanelMove( uint8 *user_data_ptr)
{
	uint8 *start_ptr = PNULL;
	uint32 rect_x = 0;
	uint32 rect_y = 0;

	if(PNULL != user_data_ptr)
	{
		start_ptr = user_data_ptr;
		rect_x = Atest_GetTestMessageId(',',&start_ptr);
		rect_y = Atest_GetTestMessageId(',',&start_ptr);

		//SCI_TRACE_LOW:"[AT][ATEST]:Atest_TouchPanelMove,-%d,%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7719_112_2_18_1_59_40_43,(uint8*)"dd",rect_x,rect_y);
		
		Atest_SendTouchMessage(MMI_TP_MOVE,rect_x,rect_y);		
	}
}

/*****************************************************************************/
//  Description: 触笔move
//  Global resource dependence :
//  Author:linchen
//  Note:
/*****************************************************************************/
LOCAL void Atest_TouchPanelUp( uint8 *user_data_ptr)
{
	uint8 *start_ptr = PNULL;
	uint32 rect_x = 0;
	uint32 rect_y = 0;

	if(PNULL != user_data_ptr)
	{
		start_ptr = user_data_ptr;
		rect_x = Atest_GetTestMessageId(',',&start_ptr);
		rect_y = Atest_GetTestMessageId(',',&start_ptr);

		//SCI_TRACE_LOW:"[AT][ATEST]:Atest_TouchPanelUp,-%d,%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7741_112_2_18_1_59_40_44,(uint8*)"dd",rect_x,rect_y);
		
		Atest_SendTouchMessage(MMI_TP_UP,rect_x,rect_y);		
	}
}


/*****************************************************************************/
//  Description: 根据当前lcd旋转的情况，对坐标进行转换
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_ConvertPositionByLcd(
											uint16 *rect_x,		//需要转换的坐标x
											uint16 *rect_y)		//需要转换的坐标y
{
	LCD_ANGLE_E RotateAngle = {0} ;
	uint16 logic_width = 0;
    uint16 logic_height = 0;
	uint16 old_x = 0;
	uint16 old_y = 0;
	GUI_POINT_T  point = {0};
	LCD_INFO_T  lcd_info = {0};
	GUI_RECT_T  rect = {0}; 

	//get rotate angle
	RotateAngle = GUILCD_GetRotateAngle((LCD_ID_E)GUI_MAIN_LCD_ID);
	//get lcd width and height
	GUILCD_GetWidthHeightByAngle((LCD_ID_E)GUI_MAIN_LCD_ID,RotateAngle,&logic_width,&logic_height);
	//SCI_TRACE_LOW:"[ATC:][ATEST:] Atest_ConvertPositionByLcd,%d,%d*%d"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7769_112_2_18_1_59_40_45,(uint8*)"ddd",RotateAngle,logic_width,logic_height);
		
    switch (RotateAngle)
    {
    case LCD_ANGLE_270:		
        old_x  = *rect_x;
        *rect_x = *rect_y;
        *rect_y = logic_width - old_x;
        break;

    case LCD_ANGLE_180:
        *rect_x = logic_width - *rect_x;
        *rect_y = logic_height - *rect_y;
        break;

    case LCD_ANGLE_90:
        old_y  = *rect_y;
        *rect_y = *rect_x;
        *rect_x = logic_height - old_y;
        break;

    default:
        break;
    }
	
	//SCI_TRACE_LOW:"[ATC:][ATEST:]ConvertPosition-%d-%d"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7794_112_2_18_1_59_40_46,(uint8*)"dd",*rect_x,*rect_y);

	point.x = (int16)*rect_x;
	point.y = (int16)*rect_y;
	if(!GUILCD_GetInfo((LCD_ID_E)GUI_MAIN_LCD_ID,&lcd_info))
	{
		return FALSE;
	}
	
	rect.left = 0;
	rect.right = lcd_info.lcd_width;
	rect.top = 0;
	rect.bottom = lcd_info.lcd_height;	

	if(!GUI_PointIsInRect(point,rect))
	{
		//SCI_TRACE_LOW:"[ATC:][ATEST:] invalid point"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7810_112_2_18_1_59_40_47,(uint8*)"");
		return FALSE;
	}
	
	return TRUE;
}

/*****************************************************************************/
//  Description:比较AT发送过来的数据和从控件取到的数据
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_Compare_content(ATEST_ID_TYPE_E id_type,	//查找类型
									MMI_HANDLE_T ctrl_handle,	//控件handle
									MMI_STRING_T ctrl_str,	    //遍历控件的字符串数据
									uint8 *at_data,			    //AT收到的字符串数据
									uint32 id_data)				//遍历控件的id数据
{	
	int j= 0;
	uint32 i=0;
	uint8  find_content[ATEST_MAX_STR_LEN]={0};	
	uint16 at_str_len = 0;
	uint16 ctrl_str_len = 0;
	uint32 string_num = 0;
	uint32 message_decode = 0;
	MMI_STRING_T at_str_ptr = {0};
	uint8 *start_ptr = at_data;

	switch(id_type) //compare text
	{	
		case TEXT_TYPE:
		case TEXT_ID_TYPE:
		case TEXT_IMG_TYPE:
 			if(!ctrl_str.wstr_len)	//从控件取到的数据为0直接返回，不比较
			{
				return FALSE;
			}
			
			if(TEXT_IMG_TYPE == id_type)
			{
				Atest_GetTestMessageId(',',&start_ptr);	//去掉img id部分
			}

			string_num = Atest_GetTestMessageId(',',&start_ptr); //获得字符串个数
			//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_Compare_content:AT string Num=%d"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7853_112_2_18_1_59_40_48,(uint8*)"d",message_decode);

			for(i=0;i<string_num;i++)
			{
				SCI_MEMSET(&at_str_ptr,0,sizeof(MMI_STRING_T));
				if(TEXT_TYPE == id_type || TEXT_IMG_TYPE == id_type)	//取AT发过来的字符串内容，并转为wchar类型
				{
					SCI_MEMSET(find_content,0,ATEST_MAX_STR_LEN);
					Atest_GetMessageContent(find_content,',',&start_ptr);
					at_str_ptr.wstr_ptr = (wchar *)GetATCParameter(MMI_UT_UNICODE, find_content, (uint32)strlen((char *)find_content), 0);
					at_str_ptr.wstr_len = (uint16)strlen((char *)find_content)/2;
				}
				else	//TEXT_ID_TYPE  取AT发过来的id，取字符串
				{
					message_decode = Atest_GetTestMessageId(',',&start_ptr); //text_id
				//	MMITHEME_GetResText(message_decode,ctrl_handle,&at_str_ptr);
					 MMITHEME_GetLabelTextByLang(message_decode, &at_str_ptr);
				}
				if (PNULL == at_str_ptr.wstr_ptr)
			    {
			       continue;
			    }

				//计算AT和控件的宽字符串长度
				ctrl_str_len = Atest_wcslen(ctrl_str.wstr_ptr,ctrl_str.wstr_len);
				at_str_len = Atest_wcslen(at_str_ptr.wstr_ptr,at_str_ptr.wstr_len);
				//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_Compare_content:Atest_wcslen:ctrl=%d--at=%d"
				SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7879_112_2_18_1_59_40_49,(uint8*)"dd",ctrl_str_len,at_str_len);
				//矫正长度，去末尾空格
				for(j=ctrl_str_len-1;j>=0;j--)
				{
					if(' ' == ctrl_str.wstr_ptr[j])
					{
						//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_Compare_content:remove the last word if is space of ctrl_str"
						SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7885_112_2_18_1_59_40_50,(uint8*)"");
						ctrl_str_len--;				
					}
					else
					{
						break;
					}
				}
				for(j=at_str_len-1;j>=0;j--)
				{
					if(' ' == at_str_ptr.wstr_ptr[j])
					{
						//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_Compare_content:remove the last word if is space of at_str"
						SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7897_112_2_18_1_59_40_51,(uint8*)"");
						at_str_len--;				
					}
					else
					{
						break;
					}
				}
				//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_Compare_content:Atest_wcslen:ctrl=%d--at=%d"
				SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7905_112_2_18_1_59_40_52,(uint8*)"dd",ctrl_str_len,at_str_len);

				if(!MMIAPICOM_CompareTwoWstrExt(ctrl_str.wstr_ptr,ctrl_str_len,at_str_ptr.wstr_ptr,at_str_len,FALSE))
				{
					//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_Compare_content:compare text TRUE"
					SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7909_112_2_18_1_59_40_53,(uint8*)"");
					if(TEXT_TYPE == id_type || TEXT_IMG_TYPE == id_type)
					{
						SCI_FREE(at_str_ptr.wstr_ptr);
					}
 					return TRUE;
				}

				if(TEXT_TYPE == id_type || TEXT_IMG_TYPE == id_type)
				{
					if(PNULL != at_str_ptr.wstr_ptr)
					{
						SCI_FREE(at_str_ptr.wstr_ptr);
					}
				}
			}			
			break;
		case CONTROL_ID_TYPE:
	    case IMAGE_ID_TYPE:
	    case INDEX_ID_TYPE:
			string_num = Atest_GetTestMessageId(',',&start_ptr);	//id个数，默认为1
			message_decode = Atest_GetTestMessageId(',',&start_ptr);	//id
			if(message_decode == id_data )
			{
				//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_Compare_content:compare id TRUE"
				SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7933_112_2_18_1_59_41_54,(uint8*)"");
				return TRUE;
			}
		break;
		default:
			break;
	}

	//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_Compare_content:FALSE"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7941_112_2_18_1_59_41_55,(uint8*)"");
	return FALSE;
}

/*****************************************************************************/
//  Description:计算宽字符的长度
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL uint16 Atest_wcslen(	wchar *s,			//宽字符串
							uint16 limit_len)	//限制长度
{
	uint16 len = 0;

	if(PNULL != s)
	{
		while (s[len] != L'\0') 
	    {
			if(len > limit_len-1)
			{
				break;
			}
			len++;
	    }
	}
	
	return len;
}

/*****************************************************************************/
//  Description:根据item所在的控件的位置，返回对应的触笔坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:主要针对list，pop menu
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_GetValidTPPoint(	GUI_RECT_T item_rect,	//item的区域
										GUI_RECT_T ctrl_rect,	//item所在的控件的区域
										uint16 *rect_x,			//out:坐标x
										uint16 *rect_y)			//out:坐标y
{
	GUI_POINT_T  point = {0}; 

	//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_GetValidTPPoint item_rect:%d %d %d %d--ctrl_rect:%d %d %d %d"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_7982_112_2_18_1_59_41_56,(uint8*)"dddddddd",item_rect.left,item_rect.top,item_rect.right,item_rect.bottom,ctrl_rect.left,ctrl_rect.top,ctrl_rect.right,ctrl_rect.bottom);

	point.x = (int16)(item_rect.left+item_rect.right)/2;
	point.y = (int16)(item_rect.top+item_rect.bottom)/2;

	if(!GUI_PointIsInRect(point,ctrl_rect))
	{
		if(point.y < (int16)ctrl_rect.top)
		{
			*rect_x = (item_rect.left +item_rect.right)/2;
			*rect_y = item_rect.bottom-1; 
		}
		else if(point.y > (int16)ctrl_rect.bottom)
		{
			*rect_x = (item_rect.left +item_rect.right)/2;
			*rect_y = item_rect.top+1; 
		}
		else if(point.x < (int16)ctrl_rect.left)
		{
			*rect_x = item_rect.right - 1;
			*rect_y = (item_rect.bottom+item_rect.top)/2;; 
		}
		else if(point.y > (int16)ctrl_rect.right)
		{
			*rect_x = item_rect.left + 1;
			*rect_y = (item_rect.bottom+item_rect.top)/2;; 
		}		
		else
		{
			//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_GetValidTPPoint failed"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8011_112_2_18_1_59_41_57,(uint8*)"");
			return FALSE;
		}
	}
	else
	{
		*rect_x =(item_rect.left +item_rect.right)/2;
		*rect_y =(item_rect.top +item_rect.bottom)/2; 
	}

	point.x = (int16)(item_rect.left+item_rect.right)/2;
	point.y = (int16)(item_rect.top+item_rect.bottom)/2;

	if(!GUI_PointIsInRect(point,ctrl_rect))
	{
		return FALSE;
	}

	//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_GetValidTPPoint:%d %d"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8029_112_2_18_1_59_41_58,(uint8*)"dd",*rect_x,*rect_y);
	return TRUE;
}

/*****************************************************************************/
//  Description:查找控件LABLE，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持name查找
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchLableControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	uint32  user_data_id = 0;
	MMI_STRING_T text_ptr = {0};
	
	CTRLLABEL_OBJ_T	*label_ctrl_ptr = PNULL;

	label_ctrl_ptr = (CTRLLABEL_OBJ_T *)ctrl_ptr; 
	if(PNULL == label_ctrl_ptr)
	{
		return FALSE;
	}

	switch (id_type)
	{
		case CONTROL_ID_TYPE:
			user_data_id = ctrl_id;
			break;
		case TEXT_TYPE:
		case TEXT_ID_TYPE:
			GUILABEL_GetText(ctrl_id,&text_ptr);
			break;
			default:
				return FALSE;
	}
	
	if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
	{
		if(0 == label_ctrl_ptr->base_ctrl.display_rect.bottom
			&& 0 == label_ctrl_ptr->base_ctrl.display_rect.left
			&& 0 == label_ctrl_ptr->base_ctrl.display_rect.top
			&& 0 == label_ctrl_ptr->base_ctrl.display_rect.right) //未显示
		{
			if(label_ctrl_ptr->base_ctrl.rect.top < ATEST_RECT_LIMIT) //需上翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_UP);
				return FALSE;
						
			}
			else if(label_ctrl_ptr->base_ctrl.rect.bottom > ATEST_RECT_LIMIT) //需下翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_DOWN);
				return FALSE;
			}
		}
		
		*rect_x = (label_ctrl_ptr->base_ctrl.display_rect.left+label_ctrl_ptr->base_ctrl.display_rect.right)/2;
		*rect_y = (label_ctrl_ptr->base_ctrl.display_rect.bottom+label_ctrl_ptr->base_ctrl.display_rect.top)/2;
		return TRUE;
	}
	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件EditBbox，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持id查找
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchEditBoxControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	
	CTRLBASEEDIT_OBJ_T *edit_ctrl_ptr = PNULL;
	uint32  user_data_id = 0;
	MMI_STRING_T text_ptr = {0};

	edit_ctrl_ptr = (CTRLBASEEDIT_OBJ_T *)ctrl_ptr;
	if(PNULL == edit_ctrl_ptr)
	{
		return FALSE;
	}
	
	switch (id_type)
	{
		case CONTROL_ID_TYPE:
			user_data_id = ctrl_id;
			break;
			default:
				return FALSE;
	}

	if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
	{
		if(0 == edit_ctrl_ptr->base_ctrl.display_rect.bottom
			&& 0 == edit_ctrl_ptr->base_ctrl.display_rect.left
			&& 0 == edit_ctrl_ptr->base_ctrl.display_rect.top
			&& 0 == edit_ctrl_ptr->base_ctrl.display_rect.right) //未显示
		{
			if(edit_ctrl_ptr->base_ctrl.rect.top < ATEST_RECT_LIMIT) //需上翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_UP);
				return FALSE;
			}
			else if(edit_ctrl_ptr->base_ctrl.rect.bottom > ATEST_RECT_LIMIT) //需下翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_DOWN);
				return FALSE;
			}			
		}

		*rect_x = (edit_ctrl_ptr->base_ctrl.display_rect.left+edit_ctrl_ptr->base_ctrl.display_rect.right)/2;
		*rect_y = (edit_ctrl_ptr->base_ctrl.display_rect.bottom+edit_ctrl_ptr->base_ctrl.display_rect.top)/2;
		return TRUE;
	}

	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件SoftKey，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持name查找
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchSoftKeyControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	uint16 j = 0;
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_IMAGE_ID_T image_id = 0;
	MMI_TEXT_ID_T text_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	CTRLSOFTKEY_OBJ_T	*softkey_ptr = PNULL;
	GUI_BUTTON_T    *button_ptr = PNULL;
	
	softkey_ptr = (CTRLSOFTKEY_OBJ_T*)ctrl_ptr;
	if(PNULL == softkey_ptr)
	{
		return FALSE;
	}
	
	for(j=0;j < GUISOFTKEY_BUTTON_NUM;j++)
	{
		button_ptr = &softkey_ptr->button_arr[j];
		if(softkey_ptr->button_arr[j].is_show)
		{
			SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
			switch(softkey_ptr->button_arr[j].content.data_type)
			{	
				case GUISK_DATA_TEXT_ID:
					text_id = button_ptr->content.data_u.text_id;
					MMITHEME_GetResText(text_id, softkey_ptr->win_handle, &text_ptr);
					break;
				case GUISK_DATA_TEXT_BUFFER:
					text_ptr.wstr_ptr = softkey_ptr->button_arr[j].content.data_u.text_buffer.wstr_ptr;
					text_ptr.wstr_len = softkey_ptr->button_arr[j].content.data_u.text_buffer.wstr_len;
					break;
				case GUISK_DATA_IMAGE_ID:
					image_id = button_ptr->content.data_u.image_id;
					break;
				default:
						break;
			}

			switch (id_type)
			{
		    	case CONTROL_ID_TYPE:
					user_data_id = ctrl_id;					
					break;
				case TEXT_TYPE:
				case TEXT_ID_TYPE:
					break;
		    	case IMAGE_ID_TYPE:
					user_data_id = image_id;
					break;
					default:
						return FALSE;
			}
			
			if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
			{
				if(Atest_GetValidTPPoint(softkey_ptr->button_arr[j].rect,softkey_ptr->base_ctrl.display_rect,rect_x,rect_y))
				{			
					return TRUE;
				}
			}
		}
	}
	return FALSE;
}
/*****************************************************************************/
//  Description:查找控件Menu，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: 
//  Note:支持name查找
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchMainMenuControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr = (CTRLMAINMENU_OBJ_T *)ctrl_ptr;
	BOOL flag = FALSE;
	if(PNULL == menu_ctrl_ptr)
	{
		return FALSE;
	}

	switch (menu_ctrl_ptr->type)
	{   
		#ifdef MATRIX_MAIN_MENU_SUPPORT
	 	case MMIMAINMENU_MATRIX_E :  
		case MMIMAINMENU_MATRIX_TITLE_E :  
			flag = Atest_SearchMatrixMainMenuControlItem(menu_ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y);		
    		break;
		#endif
		#ifdef QBTHEME_SUPPORT
	 	case MMIMAINMENU_QBTHEME_E : 			
			flag = Atest_SearchQbMainMenuControlItem(menu_ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y);		
			break;
		#endif
	    #ifdef MMI_ISTYLE_SUPPORT
	    case MMIMAINMENU_ISTYLE_E : 			
			flag = Atest_SearchIStyleMainMenuControlItem(menu_ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y);		
			break;
	    #endif
		#ifdef PDA_UI_SUPPORT_MANIMENU_GO										 
		case MMIMAINMENU_GO_SLIDE_E :
			flag =Atest_SearchSlideMainMenuControlItem(menu_ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y);		
			break;
		#endif
	    #ifdef MENU_SWEETS_SUPPORT
	    case MMIMAINMENU_SWEETS_E :
			flag = Atest_SearchSweetMainMenuControlItem(menu_ctrl_ptr,ctrl_id,ctrl_handle,id_type,user_data_ptr,rect_x,rect_y);		
			break;
	    #endif
		default:
			break;
	}

	return flag;
}

/*****************************************************************************/
//  Description:查找控件Menu，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持name查找
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchMenuControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	CTRLMENU_OBJ_T  *menu_ctrl_ptr = (CTRLMENU_OBJ_T *)ctrl_ptr;
	if(PNULL == menu_ctrl_ptr)
	{
		return FALSE;
	}

	switch (menu_ctrl_ptr->cur_style)
	{
	    case GUIMENU_STYLE_SECOND :      /* 1 !< 二级菜单风格，显示为列表形式，多用于由主菜单进入的二级菜单 */
	    //case GUIMENU_STYLE_THIRD: 		 /* 2 !< 已去掉此风格，其显示同GUIMENU_STYLE_SECOND */
			if(Atest_SearchPopMenuControlItem(
				menu_ctrl_ptr,
				ctrl_ptr,
				ctrl_handle,
				id_type,
				user_data_ptr,
				menu_ctrl_ptr->sec_theme.item_height,
				menu_ctrl_ptr->sec_theme.item_space,
				rect_x,
				rect_y))
			{
				return TRUE;
			}										
			break;
		case GUIMENU_STYLE_POPUP :       /* 6 !< 弹出式菜单，由系统统一计算它的位置和宽度，用户不能设置 */
	    case GUIMENU_STYLE_POPUP_AUTO :  /* 11 !< 弹出式菜单，其坐标可由用户设置，且会根据文本自适应宽度 */
	    case GUIMENU_STYLE_POPUP_RECT :  /* 12 !< 弹出式菜单，其坐标和宽度可由用户设置，系统不会做自适应 */
		case GUIMENU_STYLE_POPUP_RADIO : /* 7 !< 弹出式菜单，菜单项带有单选的radio风格 */
	    case GUIMENU_STYLE_POPUP_CHECK : /* 8 !< 弹出式菜单，菜单项带有多选的check风格 */
			if(Atest_SearchPopMenuControlItem(
				menu_ctrl_ptr,
				ctrl_ptr,
				ctrl_handle,
				id_type,
				user_data_ptr,
				menu_ctrl_ptr->pop_theme.item_height,
				menu_ctrl_ptr->pop_theme.item_space,
				rect_x,
				rect_y))
			{
				return TRUE;
			}
			break;			
		case GUIMENU_STYLE_OPTIONS:     /* 15 !< OptionsMenu */
			if(Atest_SearchOptionMenuControlItem(menu_ctrl_ptr,
										ctrl_ptr,
										ctrl_handle,
										id_type,
										user_data_ptr,
										rect_x,
										rect_y))
			{
				return TRUE;
			}
			break;
			default:
				break;
	}

	return FALSE;
}

#ifdef QBTHEME_SUPPORT
/*****************************************************************************/
//  Description:查找控件MENU 的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:GUIMENU_STYLE_QBTHEME
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchQbMainMenuControlItem(
										CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										MMI_CTRL_ID_T ctrl_id,		//控件id
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y)					//out,查找到的控件坐标y
{

	uint16 page_item_num = 0;
	MMI_STRING_T text_ptr = { 0 };
       //MMI_IMAGE_ID_T  icon_id_ptr = { 0 };
	CTRLMAINMENU_ITEM_T cur_item_info = { 0 };
	uint32 text_id = 0,icon_id = 0,user_data_id = 0;
	GUIMENU_QBTHEME_DATA_T qb_menu_info_ptr = { 0 };
	GUI_RECT_T item_image_rect = { 0 };
	uint16 pre_item_index = 0;
	uint16 pre_page_index = 0;
	uint16 move_page_num = 0;
	MMIMAINMENU_QBTHEME_DATA_T *mainmenu = NULL;
	GUIMENU_ITEM_POSITION_E position = GUIMENU_ITEM_IN_PAGE;

	if(PNULL == menu_ctrl_ptr)
	{
		return FALSE;
	}

	mainmenu =  (MMIMAINMENU_QBTHEME_DATA_T*)menu_ctrl_ptr->pm_data_ptr;
	if(!mainmenu->page_total_num)
	{
		return FALSE;
	}
	page_item_num =  Atest_GetSlideMenuPageItemNum((MMIMAINMENU_SLIDEPAGE_DATA_T *)mainmenu);

	
	//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchQbMainMenuControlItem,cur_page=%d,item_num=%d,totalpage='%d'"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8421_112_2_18_1_59_42_59,(uint8*)"ddd",mainmenu->cur_page_index,page_item_num,mainmenu->page_total_num);

	pre_page_index = mainmenu->cur_page_index; //保存当前page index
	for(;;mainmenu->cur_page_index++)
	{
		if(mainmenu->cur_page_index >= mainmenu->page_total_num)
		{
			mainmenu->cur_page_index = 0;
		}
		
		//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchQbMainMenuControlItem:page=%d/%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8431_112_2_18_1_59_42_60,(uint8*)"dd",mainmenu->cur_page_index ,mainmenu->page_total_num);

		if(mainmenu->page_total_num == move_page_num)
		{
			//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchQbMainMenuControlItem:move_page_num=%d stop"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8435_112_2_18_1_59_42_61,(uint8*)"d",move_page_num);
			break;
		}

		if(!move_page_num)
		{
			pre_item_index = mainmenu->cur_item_index;//保存当前item index
		}

		pre_item_index = mainmenu->cur_item_index;//焦点所在的item
		for (mainmenu->cur_item_index = 0; mainmenu->cur_item_index < page_item_num; mainmenu->cur_item_index++)
		{
			if ( mainmenu->is_bar_item )
			{
				position = GUIMENU_ITEM_IN_BAR;
			}
			else
			{
				position = GUIMENU_ITEM_IN_PAGE;
			}
			Atest_QbThemeMenuGetItemInfo(mainmenu, position, mainmenu->cur_page_index, mainmenu->cur_item_index, &cur_item_info);

			text_id = cur_item_info.text.data.text_id;
			icon_id = cur_item_info.icon.data.icon_id;

		    if (CTRL_TEXT_ID == cur_item_info.text.type )
	            {
				MMITHEME_GetResText(cur_item_info.text.data.text_id, mainmenu->win_handle, &text_ptr);
	            }
	            else
	            {
	                text_ptr.wstr_ptr = cur_item_info.text.data.str_info.wstr_ptr;
	                text_ptr.wstr_len = cur_item_info.text.data.str_info.wstr_len;
	            }			//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchQbMainMenuControlItem,MMITHEME_GetResText,icon_id=%d,text_id=%d,text=%x"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8479_112_2_18_1_59_42_64,(uint8*)"ddd",icon_id,text_id,*(text_ptr.wstr_ptr));

			switch (id_type)
			{
				case TEXT_TYPE:
				case TEXT_ID_TYPE:
					break;
				case IMAGE_ID_TYPE:
					user_data_id = icon_id;
					break;
					default:
						return FALSE;
			}

			if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
			{
				MMITHEME_GetQbthemeMenuInfo(ctrl_handle,&qb_menu_info_ptr);
				item_image_rect = qb_menu_info_ptr.item_rect[mainmenu->cur_item_index];

				*rect_x = (item_image_rect.left + item_image_rect.right)/2;
				*rect_y = (item_image_rect.bottom + item_image_rect.top)/2;
				return TRUE;
			}
		}
		move_page_num ++;
	}
	mainmenu->cur_page_index = pre_page_index;
	mainmenu->cur_item_index = pre_item_index;

	return FALSE;
}

#endif	
/*****************************************************************************/
//  Description:查找控件MENU 的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:GUIMENU_STYLE_CYCLONE
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchCycloneMenuControlItem(
										CTRLMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										IGUICTRL_T *ctrl_ptr,			//控件指针
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y)					//out,查找到的控件坐标y
{
	MMI_STRING_T text_ptr = { 0 };
    MMI_IMAGE_ID_T  user_data_id = 0;
    MMI_IMAGE_ID_T  icon_id_ptr = 0;
    BOOLEAN  is_grayed_ptr = FALSE;
	//CTRLMAINMENU_ITEM_T cur_item_info = { 0 };
	uint16 pre_item_index = 0;
	MMI_LINK_NODE_T  *item_head_ptr = PNULL;

	if(PNULL == menu_ctrl_ptr)
	{
		return FALSE;
	}

	 item_head_ptr= (MMI_LINK_NODE_T  *)menu_ctrl_ptr->cur_group_ptr->item_ptr;	
	if(PNULL == item_head_ptr)
	{
		return FALSE;
	}
	
	if(!menu_ctrl_ptr->item_total_num)
	{
		return FALSE;
	}

	pre_item_index = menu_ctrl_ptr->cur_item_index;

	for (menu_ctrl_ptr->cur_item_index = 0;menu_ctrl_ptr->cur_item_index < menu_ctrl_ptr->item_total_num ; menu_ctrl_ptr->cur_item_index++)
	{
		if(PNULL == item_head_ptr)
		{
			break;
		}		
		SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
		if(!CTRLMENU_GetItem(menu_ctrl_ptr,menu_ctrl_ptr->cur_item_index,&text_ptr,&icon_id_ptr,&is_grayed_ptr))
		{
			break;
		}
		if(!icon_id_ptr)
		{
			/*
			if (PNULL == ((GUIMENU_PROCESS_T*)(menu_ctrl_ptr->process_func[menu_ctrl_ptr->cur_style]))->GetItemPtr)
		 	{
				break;
			}
			else
			{
				((GUIMENU_PROCESS_T*)(menu_ctrl_ptr->process_func[menu_ctrl_ptr->cur_style]))->GetItemPtr(menu_ctrl_ptr, menu_ctrl_ptr->cur_page_index, menu_ctrl_ptr->cur_item_index,&cur_item_info);
			}

			if(PNULL != cur_item_info.menu_data.static_menu_ptr)
			{
				icon_id_ptr = cur_item_info.menu_data.static_menu_ptr->unselect_icon_id;
			}*/
		}

		switch (id_type)
		{
			case TEXT_TYPE:
			case TEXT_ID_TYPE:
				break;
			case IMAGE_ID_TYPE:
				user_data_id = icon_id_ptr;
				break;
				default:
					return FALSE;
		}

		if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
		{
			MMK_PostMsg(ctrl_handle,MSG_NOTIFY_OK,0,0);
			*rect_x = 0;
			*rect_y = 0;					
			return TRUE;
		}
		item_head_ptr = item_head_ptr->next_ptr;
	}

	menu_ctrl_ptr->cur_item_index = pre_item_index;
	return FALSE;
}


/*****************************************************************************/
//  Description:查找控件MENU 的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:GUIMENU_STYLE_CRYSTAL_CUBE
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchCrystalMenuControlItem(
										CTRLMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										IGUICTRL_T *ctrl_ptr,			//控件指针
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y)					//out,查找到的控件坐标y
{
#ifdef MENU_CRYSTALCUBE_SUPPORT
	uint16 item_index = 0;
	uint16 move_page_num= 0;
	MMI_STRING_T text_ptr = { 0 };
    MMI_IMAGE_ID_T user_data_id = { 0 };
	MMI_IMAGE_ID_T icon_id_ptr = { 0 };
    BOOLEAN  is_grayed_ptr = FALSE;
	GUIMENU_CRYSTALCUBEMENU_DATA_T menu_data = { 0 };
	GUI_RECT_T item_image_rect = { 0 };
	CTRLMAINMENU_ITEM_T cur_item_info = { 0 };
	uint16 pre_item_index = 0;
	uint16 pre_page_index = 0;

	if(PNULL == menu_ctrl_ptr)
	{
		return FALSE;
	}
	
	if(!menu_ctrl_ptr->item_total_num)
	{
		return FALSE;
	}
	
	menu_data = menu_ctrl_ptr->main_menu_data.crystalcube_menu_data; //crystal nemu data

	pre_page_index = menu_ctrl_ptr->cur_page_index;
		
	for(;;menu_ctrl_ptr->cur_page_index++)
	{
		if(menu_ctrl_ptr->cur_page_index >= menu_data.page_num)
		{
			menu_ctrl_ptr->cur_page_index = 0;
		}

		if(menu_data.page_num == move_page_num)
		{
			break;
		}
		item_index = menu_ctrl_ptr->cur_item_index;
		pre_item_index = item_index;

		for (menu_ctrl_ptr->cur_item_index = 0;menu_ctrl_ptr->cur_item_index < CRYSTALCUBE_MENUMAIN_ICON_ITEM_MAX_NUM ; menu_ctrl_ptr->cur_item_index++)
		{
			SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
			if(!CTRLMENU_GetItem(menu_ctrl_ptr,menu_ctrl_ptr->cur_item_index,&text_ptr,&icon_id_ptr,&is_grayed_ptr))
			{
				break;
			}
			if(!icon_id_ptr)
			{
			/*
				if (PNULL == ((GUIMENU_PROCESS_T*)(menu_ctrl_ptr->process_func[menu_ctrl_ptr->cur_style]))->GetItemPtr)
			 	{
					break;
				}
				else
				{
					((GUIMENU_PROCESS_T*)(menu_ctrl_ptr->process_func[menu_ctrl_ptr->cur_style]))->GetItemPtr(menu_ctrl_ptr, menu_ctrl_ptr->cur_page_index, menu_ctrl_ptr->cur_item_index,&cur_item_info);
				}*/

				if(PNULL != cur_item_info.menu_data.static_menu_ptr)
				{
					icon_id_ptr = cur_item_info.menu_data.static_menu_ptr->unselect_icon_id;
				}
			}

			switch (id_type)
			{
				case TEXT_TYPE:
				case TEXT_ID_TYPE:					
					break;
				case IMAGE_ID_TYPE:
					user_data_id = icon_id;
					break;
					default:
						return FALSE;
			}
			
			if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
			{
				item_image_rect = menu_data.item_image_display_rect[menu_ctrl_ptr->cur_item_index];
				*rect_x = item_image_rect.left + 1;
				*rect_y = item_image_rect.top + 1;
				return TRUE;
			}
		}
		move_page_num++;
		menu_ctrl_ptr->cur_item_index = item_index;
	}

	menu_ctrl_ptr->cur_page_index = pre_page_index;
	menu_ctrl_ptr->cur_item_index = pre_item_index;
#endif

	return FALSE;
}

#ifdef PDA_UI_SUPPORT_MANIMENU_GO										 
/*****************************************************************************/
//  Description: 获取Slide Menu每页的item数
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_SLIDE_PAGE 
/*****************************************************************************/
LOCAL uint16 Atest_GetSlideMenuPageItemNum(MMIMAINMENU_SLIDEPAGE_DATA_T *menu_ctrl_ptr)
{
	//MMI_LINK_NODE_T     *link_node_ptr = PNULL;
	MMIMAINEMENU_ITEM_LIST_T *page_item_info_ptr = PNULL;	
	uint16 page_item_num = 0;
	MMIMAINMENU_SLIDEPAGE_DATA_T* mainmenu = (MMIMAINMENU_SLIDEPAGE_DATA_T*)menu_ctrl_ptr;

	page_item_info_ptr = MMIMENU_GetItemList(&mainmenu->menu_page_info, mainmenu->cur_page_index);

	if (PNULL != page_item_info_ptr)
	{
        	page_item_num = page_item_info_ptr->item_count;
	}
	
	return page_item_num;
}
#endif

#ifdef MATRIX_MAIN_MENU_SUPPORT
/*****************************************************************************/
//  Description:查找控件slide menu的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchMatrixMainMenuControlItem(
										CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										MMI_CTRL_ID_T ctrl_id,		//控件id,			//控件指针
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y)					//out,查找到的控件坐标y
{
	uint16 item_index = 0, cur_item_index = 0;
	uint16 first_item_index= 0;
	uint16 page_item_num = 0;
	MMI_STRING_T text_ptr = { 0 };
       MMI_IMAGE_ID_T  user_data_id = 0;
       //BOOLEAN  is_grayed_ptr = FALSE;
	CTRLMAINMENU_ITEM_T cur_item_info = { 0 };
	GUI_RECT_T rect ={0};
	MMIMAINMENU_MATRIX_DATA_T *mainmenu = { 0 };
	uint16 text_id =0, icon_id = 0;
	MMIMAINMENU_ITEM_INFO_T item_ptr = {0};

	mainmenu = (MMIMAINMENU_MATRIX_DATA_T *)menu_ctrl_ptr->pm_data_ptr;	
	if(PNULL == mainmenu)
	{
		return FALSE;
	}
	
	if(!mainmenu->item_total_num)
	{
		return FALSE;
	}
	
	page_item_num = mainmenu->icon_data.page_col_num * mainmenu->icon_data.page_row_num;; //每页的item数
	if(!page_item_num)
	{
		return FALSE;
	}

	//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchIconMenuControlItem:page_col=%d,page_row=%d,page_item=%d"
//	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_9055_112_2_18_1_59_43_68,(uint8*)"ddd",page_col_num,page_row_num,page_item_num);
	first_item_index = mainmenu->first_item_index;
	cur_item_index = mainmenu->cur_item_index; //初始时焦点所在的item

	for (mainmenu->cur_item_index = 0; mainmenu->cur_item_index < mainmenu->item_total_num; mainmenu->cur_item_index++)
	{
			MMIMAINMENU_GetItem(&mainmenu->menu_list_info, mainmenu->cur_item_index, &item_ptr);
			MMIMAINMENU_GetItemData(item_ptr.menu_id, item_ptr.group_id, &cur_item_info);

			text_id = cur_item_info.text.data.text_id;
			icon_id = cur_item_info.icon.data.icon_id;

		    if (CTRL_TEXT_ID == cur_item_info.text.type )
	            {
				MMITHEME_GetResText(cur_item_info.text.data.text_id, mainmenu->win_handle, &text_ptr);
	            }
	            else
	            {
	                text_ptr.wstr_ptr = cur_item_info.text.data.str_info.wstr_ptr;
	                text_ptr.wstr_len = cur_item_info.text.data.str_info.wstr_len;
	            }
				
			//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchQbMainMenuControlItem,MMITHEME_GetResText,icon_id=%d,text_id=%d,text=%x"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8479_112_2_18_1_59_42_64,(uint8*)"ddd",icon_id,text_id,*(text_ptr.wstr_ptr));

			switch (id_type)
			{
				case TEXT_TYPE:
				case TEXT_ID_TYPE:
					break;
				case IMAGE_ID_TYPE:
					user_data_id = icon_id;
					break;
					default:
						return FALSE;
			}

		if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
		{
			item_index = mainmenu->cur_item_index;  //所要选择的item的index

			if(item_index >= mainmenu->first_item_index  + page_item_num) //需要下移
			{	
				//mainmenu->first_item_index = mainmenu->icon_data.page_row_num;
				mainmenu->first_item_index += 4;
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_DOWN);
				return FALSE;
			}
			else if((mainmenu->first_item_index != 0) && (item_index <  mainmenu->first_item_index + 4)) //需要上移
			{
				//mainmenu->first_item_index = mainmenu->icon_data.page_row_num;
				mainmenu->first_item_index -= 4;
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_UP);
				return FALSE;
			}
			
			 rect = Atest_MatrixMenuGetItemRect(mainmenu, mainmenu->cur_item_index);
			 *rect_x = (rect.left + rect.right)/2;
			 *rect_y = (rect.bottom + rect.top)/2;

			return TRUE;
		}
	}
	
	mainmenu->cur_item_index = cur_item_index;

	return FALSE;
}
#endif

#ifdef MENU_SWEETS_SUPPORT
/*****************************************************************************/
//  Description:查找控件slide menu的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchSweetMainMenuControlItem(
										CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										MMI_CTRL_ID_T ctrl_id,		//控件id
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y)					//out,查找到的控件坐标y
{
	uint16 page_item_num = 0;
	MMI_STRING_T text_ptr = { 0 };
    	//MMI_IMAGE_ID_T  icon_id_ptr = { 0 };
    	//BOOLEAN is_grayed_ptr = FALSE;
	CTRLMAINMENU_ITEM_T cur_item_info = { 0 };
	uint32 text_id = 0,icon_id = 0,user_data_id = 0;
	MMIMAINMENU_SWEETS_DATA_T *mainmenu = NULL;
	MMIMAINMENU_ITEM_INFO_T item_ptr = {0};
	//IMGREF_POINT_T point = {0};

	GUI_RECT_T item_image_rect = { 0 };
	uint16 pre_item_index = 0;
	uint16 pre_page_index = 0;
	uint16 move_page_num = 0;
	uint16 pre_item_nums = 0;
	uint16 i = 0;

	if(PNULL == menu_ctrl_ptr)
	{
		return FALSE;
	}
	mainmenu =  (MMIMAINMENU_SWEETS_DATA_T*)menu_ctrl_ptr->pm_data_ptr;
	if(!mainmenu->item_total_num)
	{
		return FALSE;
	}

	pre_page_index = mainmenu->cur_page_index; //保存当前page index
	for(;;mainmenu->cur_page_index++)
	{
		if(mainmenu->cur_page_index >= (mainmenu->item_total_num/12 + 1))
		{
			mainmenu->cur_page_index = 0;
		}
		pre_item_nums = 0;
		
		//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchQbMainMenuControlItem:page=%d/%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8431_112_2_18_1_59_42_60,(uint8*)"dd",mainmenu->cur_page_index, ISTYLE_PAGE_CNT_MAX);

		if(ISTYLE_PAGE_CNT_MAX == move_page_num)
		{
			//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchQbMainMenuControlItem:move_page_num=%d stop"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8435_112_2_18_1_59_42_61,(uint8*)"d",move_page_num);
			break;
		}

		if(!move_page_num)
		{
			pre_item_index = mainmenu->cur_item_index;//保存当前item index
		}

		pre_item_index = mainmenu->cur_item_index;//焦点所在的item
		page_item_num = Atest_SWEETS_GetPageItemNum(mainmenu, mainmenu->cur_page_index);
		for(i=0; i < mainmenu->cur_page_index; i++)
		{
			 pre_item_nums += Atest_SWEETS_GetPageItemNum(mainmenu, i);
		}
		for (mainmenu->cur_item_index = 0; mainmenu->cur_item_index <  page_item_num; mainmenu->cur_item_index++)
		{
			MMIMAINMENU_GetItem(&mainmenu->menu_list_info, mainmenu->cur_item_index + pre_item_nums, &item_ptr);
			MMIMAINMENU_GetItemData(item_ptr.menu_id, item_ptr.group_id, &cur_item_info);
			text_id = cur_item_info.text.data.text_id;
			icon_id = cur_item_info.icon.data.icon_id;

			
		    if (CTRL_TEXT_ID == cur_item_info.text.type )
	            {
				MMITHEME_GetResText(cur_item_info.text.data.text_id, mainmenu->win_handle, &text_ptr);
	            }
	            else
	            {
	                text_ptr.wstr_ptr = cur_item_info.text.data.str_info.wstr_ptr;
	                text_ptr.wstr_len = cur_item_info.text.data.str_info.wstr_len;
	            }			//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchQbMainMenuControlItem,MMITHEME_GetResText,icon_id=%d,text_id=%d,text=%x"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8479_112_2_18_1_59_42_64,(uint8*)"ddd",icon_id,text_id,*(text_ptr.wstr_ptr));

			switch (id_type)
			{
				case TEXT_TYPE:
				case TEXT_ID_TYPE:
					break;
				case IMAGE_ID_TYPE:
					user_data_id = icon_id;
					break;
					default:
						return FALSE;
			}

			if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
			{
				item_image_rect  = Atest_SWEETS_GetItemDisRect(mainmenu, mainmenu->cur_item_index);

				*rect_x = (item_image_rect.left + item_image_rect.right)/2;
				*rect_y = (item_image_rect.bottom + item_image_rect.top)/2;
				return TRUE;
			}
		}
		move_page_num ++;
	}

	mainmenu->cur_page_index = pre_page_index;
	mainmenu->cur_item_index = pre_item_index;
	return FALSE;
}
#endif

#ifdef MMI_ISTYLE_SUPPORT
/*****************************************************************************/
//  Description:查找控件slide menu的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchIStyleMainMenuControlItem(
										CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										MMI_CTRL_ID_T ctrl_id,		//控件id
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y)					//out,查找到的控件坐标y
{
	uint16 page_item_num = 0;
	MMI_STRING_T text_ptr = { 0 };
       //MMI_IMAGE_ID_T  icon_id_ptr = { 0 };
       //BOOLEAN is_grayed_ptr = FALSE;
	CTRLMAINMENU_ITEM_T cur_item_info = { 0 };
	uint32 text_id = 0,icon_id = 0,user_data_id = 0;
	MMIMAINMENU_ISTYLE_DATA_T *mainmenu = NULL;
	MMIMAINMENU_ITEM_INFO_T *item_ptr = {0};

	GUI_RECT_T item_image_rect = { 0 };
	uint16 pre_item_index = 0;
	uint16 pre_page_index = 0;
	uint16 move_page_num = 0;

	if(PNULL == menu_ctrl_ptr)
	{
		return FALSE;
	}

	mainmenu =  (MMIMAINMENU_ISTYLE_DATA_T*)menu_ctrl_ptr->pm_data_ptr;
	if(!mainmenu->page_info.cnt)
	{
		return FALSE;
	}
	page_item_num = mainmenu->page_info.cnt;

	pre_page_index = mainmenu->cur_page_index; //保存当前page index
	for(;;mainmenu->cur_page_index++)
	{
		if(mainmenu->cur_page_index >= ISTYLE_PAGE_CNT_MAX)
		{
			mainmenu->cur_page_index = 0;
		}
		
		//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchQbMainMenuControlItem:page=%d/%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8431_112_2_18_1_59_42_60,(uint8*)"dd",mainmenu->cur_page_index, ISTYLE_PAGE_CNT_MAX);

		if(ISTYLE_PAGE_CNT_MAX == move_page_num)
		{
			//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchQbMainMenuControlItem:move_page_num=%d stop"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8435_112_2_18_1_59_42_61,(uint8*)"d",move_page_num);
			break;
		}

		if(!move_page_num)
		{
			pre_item_index = mainmenu->cur_item_index;//保存当前item index
		}

		pre_item_index = mainmenu->cur_item_index;//焦点所在的item
		for (mainmenu->cur_item_index = 0; mainmenu->cur_item_index <  mainmenu->page_info.page[mainmenu->cur_page_index].cnt; mainmenu->cur_item_index++)
		{
			item_ptr = mainmenu->page_info.page[mainmenu->cur_page_index].item + mainmenu->cur_item_index;
			IStyleGetItemData(mainmenu, item_ptr->menu_id, item_ptr->group_id, &cur_item_info);
			text_id = cur_item_info.text.data.text_id;
			icon_id = cur_item_info.icon.data.icon_id;

		    if (CTRL_TEXT_ID == cur_item_info.text.type )
	            {
				MMITHEME_GetResText(cur_item_info.text.data.text_id, mainmenu->win_handle, &text_ptr);
	            }
	            else
	            {
	                text_ptr.wstr_ptr = cur_item_info.text.data.str_info.wstr_ptr;
	                text_ptr.wstr_len = cur_item_info.text.data.str_info.wstr_len;
	            }			//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchQbMainMenuControlItem,MMITHEME_GetResText,icon_id=%d,text_id=%d,text=%x"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8479_112_2_18_1_59_42_64,(uint8*)"ddd",icon_id,text_id,*(text_ptr.wstr_ptr));

			switch (id_type)
			{
				case TEXT_TYPE:
				case TEXT_ID_TYPE:
					break;
				case IMAGE_ID_TYPE:
					user_data_id = icon_id;
					break;
					default:
						return FALSE;
			}

			if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
			{
				//item_image_rect = IStyleMenuGetItemRect(mainmenu, mainmenu->cur_item_index);
				item_image_rect = mainmenu->default_data.item_rect[mainmenu->cur_item_index];

				*rect_x = (item_image_rect.left + item_image_rect.right)/2;
				*rect_y = (item_image_rect.bottom + item_image_rect.top)/2;
				return TRUE;
			}
		}
		move_page_num ++;
	}

	mainmenu->cur_page_index = pre_page_index;
	mainmenu->cur_item_index = pre_item_index;
	return FALSE;
}
#endif

#ifdef PDA_UI_SUPPORT_MANIMENU_GO										 
/*****************************************************************************/
//  Description:查找控件slide menu的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchSlideMainMenuControlItem(
										CTRLMAINMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										MMI_CTRL_ID_T ctrl_id,		//控件id
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y)					//out,查找到的控件坐标y
{
	uint16 page_item_num = 0;
	MMI_STRING_T text_ptr = { 0 };
	//MMI_IMAGE_ID_T  icon_id_ptr = { 0 };
	//BOOLEAN is_grayed_ptr = FALSE;
	CTRLMAINMENU_ITEM_T cur_item_info = { 0 };
	MMIMAINMENU_ITEM_INFO_T *item_ptr = {0};
	MMIMAINEMENU_ITEM_LIST_T  *page_item_info_ptr = PNULL;
	MMIMAINMENU_SLIDEPAGE_DATA_T* mainmenu = NULL;
	uint32 text_id = 0,icon_id = 0,user_data_id = 0;

	GUI_RECT_T item_image_rect = { 0 };
	uint16 pre_item_index = 0;
	uint16 pre_page_index = 0;
	uint16 move_page_num = 0;

	if(PNULL == menu_ctrl_ptr)
	{
		return FALSE;
	}

	mainmenu =  (MMIMAINMENU_SLIDEPAGE_DATA_T*)menu_ctrl_ptr->pm_data_ptr;
	if(!mainmenu->item_total_num)
	{
		return FALSE;
	}
	page_item_num = mainmenu->item_total_num;

	pre_page_index = mainmenu->cur_page_index; //保存当前page index
	for(;;mainmenu->cur_page_index++)
	{
		if(mainmenu->cur_page_index >= mainmenu->item_total_num)
		{
			mainmenu->cur_page_index = 0;
		}
		
		//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchQbMainMenuControlItem:page=%d/%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8431_112_2_18_1_59_42_60,(uint8*)"dd",mainmenu->cur_page_index ,mainmenu->item_total_num);

		if(mainmenu->item_total_num == move_page_num)
		{
			//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchQbMainMenuControlItem:move_page_num=%d stop"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8435_112_2_18_1_59_42_61,(uint8*)"d",move_page_num);
			break;
		}

		if(!move_page_num)
		{
			pre_item_index = mainmenu->cur_item_index;//保存当前item index
		}

		page_item_info_ptr = Atest_GetSlidePageMenuLinkListPtr(mainmenu, mainmenu->cur_page_index);
		pre_item_index = mainmenu->cur_item_index;//焦点所在的item
		for (mainmenu->cur_item_index = 0; mainmenu->cur_item_index <page_item_info_ptr->item_count; mainmenu->cur_item_index++)
		{
			if (PNULL == page_item_info_ptr)
		    	{
		    		break;
			}

			item_ptr = Atest_SlidePageMenuGetItemInfoByIndex(page_item_info_ptr, mainmenu->cur_item_index);

		        if (PNULL != item_ptr)
		        {
		            	MMIMAINMENU_GetItemData(item_ptr->menu_id,item_ptr->group_id,&cur_item_info);
		        }

			text_id = cur_item_info.text.data.text_id;
			icon_id = cur_item_info.icon.data.icon_id;

		    if (CTRL_TEXT_ID == cur_item_info.text.type )
	            {
				MMITHEME_GetResText(cur_item_info.text.data.text_id, mainmenu->win_handle, &text_ptr);
	            }
	            else
	            {
	                text_ptr.wstr_ptr = cur_item_info.text.data.str_info.wstr_ptr;
	                text_ptr.wstr_len = cur_item_info.text.data.str_info.wstr_len;
	            }			//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchQbMainMenuControlItem,MMITHEME_GetResText,icon_id=%d,text_id=%d,text=%x"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8479_112_2_18_1_59_42_64,(uint8*)"ddd",icon_id,text_id,*(text_ptr.wstr_ptr));

			switch (id_type)
			{
				case TEXT_TYPE:
				case TEXT_ID_TYPE:
					break;
				case IMAGE_ID_TYPE:
					user_data_id = icon_id;
					break;
					default:
						return FALSE;
			}

			if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
			{
				item_image_rect = Atest_GetSlideMenuItemRect(mainmenu, mainmenu->cur_item_index);

				*rect_x = (item_image_rect.left + item_image_rect.right)/2;
				*rect_y = (item_image_rect.top + item_image_rect.bottom)/2;
				return TRUE;
			}
		}
		move_page_num ++;
	}

	mainmenu->cur_page_index = pre_page_index;
	mainmenu->cur_item_index = pre_item_index;
	return FALSE;
}
#endif

/*****************************************************************************/
//  Description:查找控件pop menu的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:针对second，third，pop menu
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchPopMenuControlItem(
										CTRLMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										IGUICTRL_T *ctrl_ptr,			//控件指针
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16  item_height,			//item高度
										uint16  item_space,				//item之间的距离
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y)					//out,查找到的控件坐标y
{
	uint16 item_index = 0;
	uint16 cur_item_index = 0;
	uint16 index_offset = 0;
	MMI_STRING_T text_ptr = {0};
	MMI_IMAGE_ID_T  icon_id_ptr = 0;
	uint32 icon_id = 0,user_data_id = 0;
	BOOLEAN is_grayed_ptr = FALSE;
	GUI_RECT_T item_rect = {0};

	if(PNULL == menu_ctrl_ptr)
	{
		return FALSE;
	}

	if(!((item_height+item_space) && menu_ctrl_ptr->item_total_num))
	{
		return FALSE;
	}

	cur_item_index = menu_ctrl_ptr->cur_item_index;

	for ( menu_ctrl_ptr->cur_item_index = 0;  menu_ctrl_ptr->cur_item_index < menu_ctrl_ptr->item_total_num; menu_ctrl_ptr->cur_item_index++)
	{
		SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
		CTRLMENU_GetItem(menu_ctrl_ptr,menu_ctrl_ptr->cur_item_index,&text_ptr,&icon_id_ptr,&is_grayed_ptr);
		switch (id_type)
		{
			case TEXT_TYPE:
			case TEXT_ID_TYPE:
				break;
			case IMAGE_ID_TYPE:
				user_data_id = icon_id;
				break;
				default:
					return FALSE;
		}

		if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
		{
			item_index = menu_ctrl_ptr->cur_item_index;
			menu_ctrl_ptr->cur_item_index = cur_item_index;

			if(item_index > menu_ctrl_ptr->cur_item_index) //需要下移
			{	
				index_offset = item_index - cur_item_index;
				
				//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchPopMenuControlItem,down:cur_item_index=%d,index_offset=%d"
				SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8957_112_2_18_1_59_43_66,(uint8*)"dd",cur_item_index,index_offset);

				if(index_offset >0 )
				{
					Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),index_offset,ATEST_SIGNAL_KB_DOWN);
					return FALSE;
				}
			}
			else if(item_index < menu_ctrl_ptr->cur_item_index) //需要上移
			{
				index_offset = cur_item_index - item_index;

				//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchPopMenuControlItem,up:cur_item_index=%d,index_offset=%d"
				SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_8969_112_2_18_1_59_43_67,(uint8*)"dd",cur_item_index,index_offset);
				
				if(index_offset >0 )
				{
					Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),index_offset,ATEST_SIGNAL_KB_UP);
					return FALSE;
				}
			}

			if(GUIMENU_STYLE_SECOND == menu_ctrl_ptr->cur_style 	//second third
				|| GUIMENU_STYLE_THIRD == menu_ctrl_ptr->cur_style )
			{
				item_rect = menu_ctrl_ptr->item_pos_info_ptr[item_index].item_rect;
			}
			else		//pop
			{
				Atest_GetPopmenuItemTextRect( item_index,menu_ctrl_ptr,&item_rect);
			}

			if(Atest_GetValidTPPoint(item_rect,menu_ctrl_ptr->base_ctrl.rect,rect_x,rect_y))
			{			
				return TRUE;
			}
		}
	}

	menu_ctrl_ptr->cur_item_index = cur_item_index;	
	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件MENU 的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note: GUIMENU_STYLE_OPTIONS 
/*****************************************************************************/
LOCAL BOOLEAN Atest_SearchOptionMenuControlItem( 
										CTRLMENU_OBJ_T  *menu_ctrl_ptr,	//menu指针
										IGUICTRL_T *ctrl_ptr,			//控件指针
										MMI_HANDLE_T ctrl_handle,		//控件handle
										ATEST_ID_TYPE_E id_type,		//查找类型
										uint8 *user_data_ptr,			//查找的数据
										uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y)					//out,查找到的控件坐标y
{
	uint16 item_index = 0; 
	MMI_STRING_T text_ptr = { 0 };
    MMI_IMAGE_ID_T  user_data_id = 0,icon_id_ptr = 0;
    BOOLEAN  is_grayed_ptr = FALSE;

	if(PNULL == menu_ctrl_ptr)
	{
		return FALSE;
	}
	
	if(!menu_ctrl_ptr->item_total_num)
	{
		return FALSE;
	}

	for (item_index = 0; item_index < menu_ctrl_ptr->item_total_num; item_index++)
	{
		switch (id_type)
		{
			case TEXT_TYPE:
			case TEXT_ID_TYPE:
				break;
			case IMAGE_ID_TYPE:
				user_data_id = icon_id_ptr;
				break;
				default:
					return FALSE;
		}

		if(!menu_ctrl_ptr->options_item_info_ptr[item_index].is_more_item)
		{
			SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
			if(!CTRLMENU_GetItem(menu_ctrl_ptr,item_index,&text_ptr,&icon_id_ptr,&is_grayed_ptr))
			{
				break;
			}			
		}
		else	//more item
		{	
			MMITHEME_GetResText(menu_ctrl_ptr->options_theme.more_item_text_id, menu_ctrl_ptr->win_handle, &text_ptr);
		}

		if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
		{
			//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchOptionMenuControlItem:Find index=%d"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_9210_112_2_18_1_59_44_71,(uint8*)"d",item_index);
			if(Atest_GetValidTPPoint(menu_ctrl_ptr->options_item_info_ptr[item_index].rect,menu_ctrl_ptr->base_ctrl.rect,rect_x,rect_y))
			{			
				return TRUE;
			}
		}
	}

	return FALSE;
}


/*****************************************************************************/
//  Description:查找控件list 的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note: byIndex
/*****************************************************************************/
LOCAL BOOLEAN Atest_SearchListByIndex(
									    CTRLLIST_OBJ_T *list_ctrl_ptr,	//list控件指针
									    MMI_HANDLE_T ctrl_handle,		//控件handle
									    uint16 page_item_num,			//每页的item数
									    uint8 *user_data_ptr,			//查找数据
									    uint16 *rect_x,					//out,查找到的控件坐标x
										uint16 *rect_y)					//out,查找到的控件坐标y
{
	uint32 message_decode = 0;
	uint16 item_index = 0;
	uint16 cur_item_idx = 0;
	uint16 index_offset = 0;
	CTRLLIST_ITEM_T *list_item_ptr = PNULL;
	GUI_RECT_T  clip_rect_ptr = {0};

	uint8 *start_ptr = user_data_ptr;
	if(PNULL == start_ptr)
	{
		return FALSE;
	}

	message_decode = Atest_GetTestMessageId(',',&start_ptr);
	message_decode = Atest_GetTestMessageId(',',&start_ptr);	//at收到的index

	for(item_index = 0; item_index < list_ctrl_ptr->total_item_num; item_index++)
	{
		//SCI_TRACE_LOW:"[Atest_SearchListByIndex]-searchitemindex=%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_9252_112_2_18_1_59_44_72,(uint8*)"d",item_index);

		list_item_ptr = (CTRLLIST_ITEM_T*)CTRLLIST_GetItem(ctrl_handle, item_index);
		if (PNULL == list_item_ptr)
		{
			continue;
		}

		if(item_index!=message_decode)
		{
			continue;
		}
		else
		{
			if(item_index > list_ctrl_ptr->cur_item_idx)
			{
				cur_item_idx = list_ctrl_ptr->cur_item_idx;
				index_offset = item_index - cur_item_idx;
				if(index_offset >0 )
				{
					Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),index_offset,ATEST_SIGNAL_KB_DOWN);
					return FALSE;
				}
			}
			else if(item_index <  list_ctrl_ptr->cur_item_idx)//上移
			{
				cur_item_idx = list_ctrl_ptr->cur_item_idx;
				index_offset = cur_item_idx - item_index;
				if(index_offset >0 )
				{
					Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),index_offset,ATEST_SIGNAL_KB_UP);
					return FALSE;
				}
			}

			GUILIST_GetItemRect(ctrl_handle,item_index,&clip_rect_ptr);
			if(Atest_GetValidTPPoint(clip_rect_ptr,list_ctrl_ptr->base_ctrl.rect,rect_x,rect_y))
			{			
				return TRUE;
			}
		}
	}

	return FALSE; 		
}


/*****************************************************************************/
//  Description:查找控件list 的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note: byimgIndex
/*****************************************************************************/
LOCAL BOOLEAN Atest_SearchListByImgIndex(
										    CTRLLIST_OBJ_T *list_ctrl_ptr,	//list控件指针
										    MMI_HANDLE_T ctrl_handle,		//控件handle
										    MMI_CTRL_ID_T ctrl_id,			//控件id
										    uint16 page_item_num,			//每页的item数
										    uint8 *user_data_ptr,			//查找数据
										    uint16 *rect_x,					//out,查找到的控件坐标x
											uint16 *rect_y)					//out,查找到的控件坐标y

{

	uint32 message_decode = 0;
	uint16 item_index = 0;
	uint16 cur_item_idx = 0;
	uint16 index_offset = 0;
	CTRLLIST_ITEM_T *list_item_ptr = PNULL;
	GUI_RECT_T  clip_rect_ptr = {0};
	GUI_RECT_T  disp_rect_ptr = {0};
	GUI_RECT_T con_rect = {0};
	GUILIST_ITEM_DATA_T *item_data_ptr = PNULL;
	uint32 user_data_id =0;
	int j = 0;
	uint32 SelectFlag = 0;

	uint8 *start_ptr = user_data_ptr;
	if(PNULL == start_ptr)
	{
		return FALSE;
	}

	message_decode = Atest_GetTestMessageId(',',&start_ptr);	//at收到的index

	for(item_index = 0; item_index < list_ctrl_ptr->total_item_num; item_index++)
	{
		//SCI_TRACE_LOW:"[Atest_SearchListByImgIndex]-searchitemindex=%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_9334_112_2_18_1_59_44_73,(uint8*)"d",item_index);

		list_item_ptr = (CTRLLIST_ITEM_T*)CTRLLIST_GetItem(ctrl_handle, item_index);
		if (PNULL == list_item_ptr)
		{
			continue;
		}

		if(item_index!=message_decode)
		{
			continue;
		}
		else
		{
			item_data_ptr = list_item_ptr->data_ptr;
			if (PNULL == item_data_ptr)
			{
				break;
			}

			message_decode = Atest_GetTestMessageId(',',&start_ptr);	//at收到的image id
			SelectFlag = Atest_GetTestMessageId(',',&start_ptr);
			
			for (j = 0; j < GUIITEM_CONTENT_MAX_NUM; j++)
			{
				if(GUIITEM_DATA_IMAGE_ID == item_data_ptr->item_content[j].item_data_type)
				{
					con_rect = list_item_ptr->style_ptr->content[j].rect;
					user_data_id = item_data_ptr->item_content[j].item_data.image_id;
					if(2 == SelectFlag)	//click
					{
						 if(user_data_id == list_ctrl_ptr->display_style.radio_selected_image_id ||
						 	user_data_id == list_ctrl_ptr->display_style.radio_unselected_image_id)
						 {
							 user_data_id = list_ctrl_ptr->display_style.radio_unselected_image_id;
						 }
						 else if(user_data_id == list_ctrl_ptr->display_style.check_selected_image_id ||
							 user_data_id == list_ctrl_ptr->display_style.check_unselected_image_id)
						 {
							 user_data_id = list_ctrl_ptr->display_style.check_unselected_image_id;
						 }
					}
					else if(1 == SelectFlag)	//select
					{
						if(user_data_id == list_ctrl_ptr->display_style.radio_selected_image_id ||
							user_data_id == list_ctrl_ptr->display_style.check_selected_image_id)
						{
							return FALSE; 
						}
					}
					else if(0 == SelectFlag)	//unselect
					{
						if(user_data_id == list_ctrl_ptr->display_style.radio_selected_image_id)
						{
							user_data_id = list_ctrl_ptr->display_style.radio_unselected_image_id;
						}
						else if(user_data_id == list_ctrl_ptr->display_style.check_selected_image_id)
						{
							user_data_id = list_ctrl_ptr->display_style.check_unselected_image_id;
						}
						else
						{
							return FALSE; 
						}
				}
				}
				else
				{
					continue;
				}

				if(item_index > list_ctrl_ptr->cur_item_idx)
				{
					cur_item_idx = list_ctrl_ptr->cur_item_idx;
					index_offset = item_index - cur_item_idx;
					if(index_offset >0 )
					{
						Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),index_offset,ATEST_SIGNAL_KB_DOWN);
						return FALSE;
					}
				}
				else if(item_index <  list_ctrl_ptr->cur_item_idx)//上移
				{
					cur_item_idx = list_ctrl_ptr->cur_item_idx;
					index_offset = cur_item_idx - item_index;
					if(index_offset >0 )
					{
						Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),index_offset,ATEST_SIGNAL_KB_UP);
						return FALSE;
					}
				}

				if(user_data_id == message_decode)
				{
					if(Atest_GetItemContentRect(ctrl_id,item_index,j,&disp_rect_ptr,&clip_rect_ptr))
					//if(GUILIST_GetItemRect(ctrl_id,item_index,&clip_rect_ptr))
					{
						clip_rect_ptr.left = con_rect.left;
						clip_rect_ptr.right = con_rect.right;
						if(Atest_GetValidTPPoint(clip_rect_ptr,list_ctrl_ptr->base_ctrl.rect,rect_x,rect_y))
						{			
							return TRUE;
						}
					}
				}
			}
		}
	}

	return FALSE; 
}

/*****************************************************************************/
//  Description:查找控件list 的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note: bytextimg
/*****************************************************************************/
LOCAL BOOLEAN Atest_SearchListByTextImg(
										    CTRLLIST_OBJ_T *list_ctrl_ptr,	//list控件指针
										    MMI_HANDLE_T ctrl_handle,		//控件handle
										    MMI_CTRL_ID_T ctrl_id,			//控件id
										    uint16 page_item_num,			//每页的item数
										    uint8 *user_data_ptr,			//查找数据
										    uint16 *rect_x,					//out,查找到的控件坐标x
											uint16 *rect_y)					//out,查找到的控件坐标y
{
	uint32 message_decode = 0;
	uint16 item_index = 0;
	uint16 cur_item_idx = 0;
	uint16 index_offset = 0;
	CTRLLIST_ITEM_T *list_item_ptr = PNULL;
	GUI_RECT_T  clip_rect_ptr = {0};
	GUI_RECT_T  disp_rect_ptr = {0};
	GUI_RECT_T con_rect = {0};
	GUILIST_ITEM_DATA_T *item_data_ptr = PNULL;
	uint32 user_data_id =0;
	int j = 0;
	MMI_STRING_T text_ptr = {0};

	//解决buffer地址变化，导致字节对齐错误assert
	wchar *temp_buffer_ptr = PNULL;
	uint16 temp_buffer_len = 0;
	wchar *user_item_ptr = NULL;

	uint8 *start_ptr = user_data_ptr;
	if(PNULL == start_ptr)
	{
		return FALSE;
	}

	user_item_ptr = (wchar *)SCI_ALLOC_APP(ATEST_MAX_STR_LEN);
	if (user_item_ptr == PNULL)
	{
	    return FALSE;    
	}
	//SCI_TRACE_LOW:"[Atest_SearchListByTextImg]--%x--%x--%x--%x--%x,"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_9455_112_2_18_1_59_44_74,(uint8*)"ddddd",user_item_ptr,user_item_ptr[0],user_item_ptr[1],user_item_ptr[ATEST_MAX_STR_LEN-2],user_item_ptr[ATEST_MAX_STR_LEN-1]);
	message_decode = Atest_GetTestMessageId(',',&start_ptr);	//at收到的img id

	for(item_index = 0; item_index < list_ctrl_ptr->total_item_num; item_index++)
	{
		//SCI_TRACE_LOW:"[Atest_SearchListByTextImg]-searchitemindex=%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_9460_112_2_18_1_59_45_75,(uint8*)"d",item_index);

		list_item_ptr = (CTRLLIST_ITEM_T*)CTRLLIST_GetItem(ctrl_handle, item_index);
		if (PNULL == list_item_ptr)
		{
			continue;
		}
		
		item_data_ptr = list_item_ptr->data_ptr;
		if (PNULL == item_data_ptr)
		{
			continue;
		}
		
		for (j = 0; j < GUIITEM_CONTENT_MAX_NUM; j++)
		{
			con_rect = list_item_ptr->style_ptr->content[j].rect;
			if(GUIITEM_DATA_TEXT_ID == item_data_ptr->item_content[j].item_data_type)
			{
				SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
				MMITHEME_GetResText(item_data_ptr->item_content[j].item_data.text_id, ctrl_handle, &text_ptr);
			}
			else if(GUIITEM_DATA_TEXT_BUFFER == item_data_ptr->item_content[j].item_data_type)
			{
				temp_buffer_ptr = item_data_ptr->item_content[j].item_data.text_buffer.wstr_ptr;
				temp_buffer_len = item_data_ptr->item_content[j].item_data.text_buffer.wstr_len;
				//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchListByTextImg:Save buffer data! len=%d\n"
				SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_9486_112_2_18_1_59_45_76,(uint8*)"d", temp_buffer_len);
				
				// 写越界可能
				if (temp_buffer_len >= ATEST_MAX_STR_LEN/2)
				{
				    temp_buffer_len = ATEST_MAX_STR_LEN/2 - 1;
				}
				        
				// 解决buffer地址变化，导致字节对齐错误assert						 					
				if (temp_buffer_len != 0)
				{
					SCI_MEMCPY((char *)user_item_ptr, (char *)temp_buffer_ptr, temp_buffer_len * 2);
				}
				user_item_ptr[temp_buffer_len] = L'\0';
				text_ptr.wstr_ptr = user_item_ptr;
				text_ptr.wstr_len = temp_buffer_len;
			}
			else
			{
				continue;
			}

			cur_item_idx = list_ctrl_ptr->cur_item_idx;

			//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchListByTextImg:item_index-%d,content_index=%d"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_9510_112_2_18_1_59_45_77,(uint8*)"dd",item_index,j);
			
			if(Atest_Compare_content(TEXT_IMG_TYPE,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
			{
				for (j = 0; j < GUIITEM_CONTENT_MAX_NUM; j++)
				{
					if(GUIITEM_DATA_IMAGE_ID == item_data_ptr->item_content[j].item_data_type)
					{
						con_rect = list_item_ptr->style_ptr->content[j].rect;
						user_data_id = item_data_ptr->item_content[j].item_data.image_id;
						if(user_data_id == list_ctrl_ptr->display_style.radio_selected_image_id ||
							user_data_id == list_ctrl_ptr->display_style.radio_unselected_image_id)
						{
						   user_data_id = list_ctrl_ptr->display_style.radio_unselected_image_id;
						}
						else if(user_data_id == list_ctrl_ptr->display_style.check_selected_image_id ||
						 user_data_id == list_ctrl_ptr->display_style.check_unselected_image_id)
						{
							user_data_id = list_ctrl_ptr->display_style.check_unselected_image_id;
						}

						if(message_decode == user_data_id)
						{
							if(Atest_GetItemContentRect(ctrl_id,item_index,j,&disp_rect_ptr,&clip_rect_ptr))
							//if(GUILIST_GetItemRect(ctrl_id,item_index,&clip_rect_ptr))
							{
								clip_rect_ptr.left = con_rect.left;
								clip_rect_ptr.right = con_rect.right;
								if(!Atest_GetValidTPPoint(clip_rect_ptr,list_ctrl_ptr->base_ctrl.display_rect,rect_x,rect_y))
								{			
									if(item_index > list_ctrl_ptr->cur_item_idx) //下移
									{
										list_ctrl_ptr->cur_item_idx = list_ctrl_ptr->top_item_idx + page_item_num;
										cur_item_idx = list_ctrl_ptr->cur_item_idx;
										index_offset = item_index - cur_item_idx;
										if(index_offset >0 )
										{
											Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),index_offset,ATEST_SIGNAL_KB_DOWN);
											SCI_FREE(user_item_ptr);
											return FALSE;
										}
									}
									else if(item_index < list_ctrl_ptr->cur_item_idx)//上移
									{
										list_ctrl_ptr->cur_item_idx = list_ctrl_ptr->top_item_idx;
										cur_item_idx = list_ctrl_ptr->cur_item_idx;
										index_offset = cur_item_idx - item_index;
										if(index_offset >0 )
										{
											Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),index_offset,ATEST_SIGNAL_KB_UP);
											SCI_FREE(user_item_ptr);
											return FALSE;
										}
									}
									else
									{
										if(clip_rect_ptr.bottom > list_ctrl_ptr->base_ctrl.display_rect.bottom)
										{
											Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),index_offset,ATEST_SIGNAL_KB_DOWN);
											SCI_FREE(user_item_ptr);
											return FALSE;								
										}
										else if(clip_rect_ptr.top < list_ctrl_ptr->base_ctrl.display_rect.top)
										{
											Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),index_offset,ATEST_SIGNAL_KB_UP);
											SCI_FREE(user_item_ptr);
											return FALSE;
										}
									}
								}
							}

							if(Atest_GetItemContentRect(ctrl_handle,item_index,j,&disp_rect_ptr,&clip_rect_ptr))
							//if(GUILIST_GetItemRect(ctrl_id,item_index,&clip_rect_ptr))
							{
								clip_rect_ptr.left = con_rect.left;
								clip_rect_ptr.right = con_rect.right;
								if(Atest_GetValidTPPoint(clip_rect_ptr,list_ctrl_ptr->base_ctrl.display_rect,rect_x,rect_y))
								{			
									SCI_FREE(user_item_ptr);
									return TRUE;
								}
							}
						}
					}
				}
			}
		}
	}

	SCI_FREE(user_item_ptr);
	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件list 的有效item，返回其对应的坐标
//  Global resource dependence :none
//  Author: linchen
//  Note: bytext imgid
/*****************************************************************************/
LOCAL BOOLEAN Atest_SearchListByTextAndImgID(
										    CTRLLIST_OBJ_T *list_ctrl_ptr,	//list控件指针
										    MMI_HANDLE_T ctrl_handle,		//控件handle
										    MMI_CTRL_ID_T ctrl_id,			//控件id
										    ATEST_ID_TYPE_E id_type,		//查找类型
										    uint16 page_item_num,			//每页的item数
										    uint8 *user_data_ptr,			//查找数据
										    uint16 *rect_x,					//out,查找到的控件坐标x
											uint16 *rect_y)					//out,查找到的控件坐标y

{
	uint32 message_decode = 0;
	uint16 item_index = 0;
	uint16 cur_item_idx = 0;
	uint16 index_offset = 0;
	CTRLLIST_ITEM_T *list_item_ptr = PNULL;
	GUI_RECT_T  clip_rect_ptr = {0};
	GUI_RECT_T  disp_rect_ptr = {0};
	GUI_RECT_T con_rect = {0};
	GUILIST_ITEM_DATA_T *item_data_ptr = PNULL;
	uint32 user_data_id =0;
	int j = 0;
	MMI_STRING_T text_ptr = {0};

	//解决buffer地址变化，导致字节对齐错误assert
	wchar *temp_buffer_ptr = PNULL;
	uint16 temp_buffer_len = 0;
	wchar *user_item_ptr = NULL;

	uint8 *start_ptr = user_data_ptr;
	if(PNULL == start_ptr)
	{
		return FALSE;
	}

	user_item_ptr = (wchar *)SCI_ALLOC_APP(ATEST_MAX_STR_LEN);
	if (user_item_ptr == PNULL)
	{
	    return FALSE;    
	}

	//SCI_TRACE_LOW:"[Atest_SearchListByTextAndImgID]--%x--%x--%x--%x--%x,"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_9641_112_2_18_1_59_45_78,(uint8*)"ddddd",user_item_ptr,user_item_ptr[0],user_item_ptr[1],user_item_ptr[ATEST_MAX_STR_LEN-2],user_item_ptr[ATEST_MAX_STR_LEN-1]);

	message_decode = Atest_GetTestMessageId(',',&start_ptr);	//at收到的img id

	for(item_index = 0; item_index < list_ctrl_ptr->total_item_num; item_index++)
	{
		//SCI_TRACE_LOW:"[Atest_SearchListByTextAndImgID]-searchitemindex=%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_9647_112_2_18_1_59_45_79,(uint8*)"d",item_index);

		list_item_ptr = (CTRLLIST_ITEM_T *)CTRLLIST_GetItem(ctrl_handle, item_index);
		if (PNULL == list_item_ptr)
		{
			continue;
		}

		item_data_ptr = list_item_ptr->data_ptr;
		if (PNULL == item_data_ptr)
		{
			continue;
		}
		for (j = 0; j < GUIITEM_CONTENT_MAX_NUM; j++)
		{
			con_rect = list_item_ptr->style_ptr->content[j].rect;
			switch (id_type)
			{
				case TEXT_TYPE:
				case TEXT_ID_TYPE:
					if(GUIITEM_DATA_TEXT_ID == item_data_ptr->item_content[j].item_data_type)
					{
						SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
						MMITHEME_GetResText(item_data_ptr->item_content[j].item_data.text_id, ctrl_handle, &text_ptr);
					}
					else if(GUIITEM_DATA_TEXT_BUFFER == item_data_ptr->item_content[j].item_data_type)
					{
						temp_buffer_ptr = item_data_ptr->item_content[j].item_data.text_buffer.wstr_ptr;
						temp_buffer_len = item_data_ptr->item_content[j].item_data.text_buffer.wstr_len;
						//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchListByTextAndImgID:Save buffer data! len=%d\n"
						SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_9676_112_2_18_1_59_45_80,(uint8*)"d", temp_buffer_len);
						
						// 写越界可能
						if (temp_buffer_len >= ATEST_MAX_STR_LEN/2)
						{
						    temp_buffer_len = ATEST_MAX_STR_LEN/2 - 1;
						}
						        
						// 解决buffer地址变化，导致字节对齐错误assert						 					
						if (temp_buffer_len != 0)
						{
							SCI_MEMCPY((char *)user_item_ptr, (char *)temp_buffer_ptr, temp_buffer_len * 2);
						}
						user_item_ptr[temp_buffer_len] = L'\0';
						text_ptr.wstr_ptr = user_item_ptr;
						text_ptr.wstr_len = temp_buffer_len;
					}
					else
					{
						continue;
					}
					break;
				case IMAGE_ID_TYPE:
					if(GUIITEM_DATA_IMAGE_ID == item_data_ptr->item_content[j].item_data_type)
					{
						user_data_id = item_data_ptr->item_content[j].item_data.image_id;
						if(user_data_id == list_ctrl_ptr->display_style.radio_selected_image_id ||
						    user_data_id == list_ctrl_ptr->display_style.radio_unselected_image_id)
						{
						   user_data_id = list_ctrl_ptr->display_style.radio_unselected_image_id;
						}
						else if(user_data_id == list_ctrl_ptr->display_style.check_selected_image_id ||
						 user_data_id == list_ctrl_ptr->display_style.check_unselected_image_id)
						{
						    user_data_id = list_ctrl_ptr->display_style.check_unselected_image_id;
						}
					}
					else
					{
						continue;
					}
					break;
					default:
						break;
			}

			cur_item_idx = list_ctrl_ptr->cur_item_idx;

			//SCI_TRACE_LOW:"[ATC:][ATEST:]Atest_SearchListByTextAndImgID:item_index-%d,content_index=%d,content_type=%d"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_9724_112_2_18_1_59_45_81,(uint8*)"ddd",item_index,j,id_type);
			
			if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
			{
				Atest_GetItemContentRect(ctrl_id,item_index,j,&disp_rect_ptr,&clip_rect_ptr);
				//GUILIST_GetItemRect(ctrl_id,item_index,&clip_rect_ptr);
			
				if(!Atest_GetValidTPPoint(clip_rect_ptr,list_ctrl_ptr->base_ctrl.display_rect,rect_x,rect_y))
				{			
					if(item_index > list_ctrl_ptr->cur_item_idx) //下移
					{
						list_ctrl_ptr->cur_item_idx = list_ctrl_ptr->top_item_idx + page_item_num;
						cur_item_idx = list_ctrl_ptr->cur_item_idx;
						index_offset = item_index - cur_item_idx;
						if(index_offset >0 )
						{
							Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),index_offset,ATEST_SIGNAL_KB_DOWN);
							SCI_FREE(user_item_ptr);
							return FALSE;
						}
					}
					else if(item_index < list_ctrl_ptr->cur_item_idx)//上移
					{
						list_ctrl_ptr->cur_item_idx = list_ctrl_ptr->top_item_idx;
						cur_item_idx = list_ctrl_ptr->cur_item_idx;
						index_offset = cur_item_idx - item_index;
						if(index_offset >0 )
						{
							Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),index_offset,ATEST_SIGNAL_KB_UP);
							SCI_FREE(user_item_ptr);
							return FALSE;
						}
					}
					else
					{
						if(clip_rect_ptr.bottom > list_ctrl_ptr->base_ctrl.display_rect.bottom)
						{
							Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),index_offset,ATEST_SIGNAL_KB_DOWN);
							SCI_FREE(user_item_ptr);
							return FALSE;									
						}
						else if(clip_rect_ptr.top < list_ctrl_ptr->base_ctrl.display_rect.top)
						{
							Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),index_offset,ATEST_SIGNAL_KB_UP);
							SCI_FREE(user_item_ptr);
							return FALSE;
						}
					}
				}

				if(Atest_GetItemContentRect(ctrl_id,item_index,j,&disp_rect_ptr,&clip_rect_ptr))
				//if(GUILIST_GetItemRect(ctrl_id,item_index,&clip_rect_ptr))
				{
					clip_rect_ptr.left = con_rect.left;
					clip_rect_ptr.right = con_rect.right;
					if(Atest_GetValidTPPoint(clip_rect_ptr,list_ctrl_ptr->base_ctrl.display_rect,rect_x,rect_y))
					{			
						SCI_FREE(user_item_ptr);
						return TRUE;
					}
				}
			}
		}
	}

	SCI_FREE(user_item_ptr);
	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件list，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持name查找
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchListControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{

    CTRLLIST_OBJ_T *list_ctrl_ptr = PNULL;
    uint16 page_item_num = 0;
    uint16 getitemnum = 0;
    uint8 *start_ptr = user_data_ptr;
    if(PNULL == start_ptr)
    {
        return FALSE;
    }

    list_ctrl_ptr = ( CTRLLIST_OBJ_T *)ctrl_ptr;
    if(PNULL == list_ctrl_ptr)
    {
        return FALSE;
    }

    if(!list_ctrl_ptr->total_item_num)
    {
        return FALSE;
    }

    if(!(list_ctrl_ptr->total_item_height/list_ctrl_ptr->total_item_num))
    {
        return FALSE;
    }

    //SCI_TRACE_LOW:"[Atest_SearchListControlItem]totalnum=%d,itemheight=%d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_9827_112_2_18_1_59_45_82,(uint8*)"dd",list_ctrl_ptr->total_item_num,list_ctrl_ptr->total_item_height/list_ctrl_ptr->total_item_num);

    page_item_num =( list_ctrl_ptr->base_ctrl.display_rect.bottom-list_ctrl_ptr->base_ctrl.display_rect.top)/(list_ctrl_ptr->total_item_height/list_ctrl_ptr->total_item_num);
    getitemnum = GUILIST_GetPageItemNum(ctrl_handle);
    page_item_num = MIN(getitemnum,page_item_num);

    if(!page_item_num)//每页可存放的item数
    {
        return FALSE;
    }

    switch (id_type)
    {
        case INDEX_ID_TYPE:
            if(Atest_SearchListByIndex(list_ctrl_ptr,ctrl_handle,page_item_num,user_data_ptr,rect_x,rect_y))
            {
                return TRUE;
            }
        break;
        case IMAGE_INDEX_TYPE:
            if(Atest_SearchListByImgIndex(list_ctrl_ptr,ctrl_id,ctrl_handle,page_item_num,user_data_ptr,rect_x,rect_y))
            {
                return TRUE;
            }
        break;
        case TEXT_IMG_TYPE:
            if(Atest_SearchListByTextImg(list_ctrl_ptr,ctrl_id,ctrl_handle,page_item_num,user_data_ptr,rect_x,rect_y))
            {
                return TRUE;
            }
        break;
        default:
            if(TEXT_TYPE== id_type || IMAGE_ID_TYPE==id_type ||TEXT_ID_TYPE==id_type)
            {
                if(Atest_SearchListByTextAndImgID(list_ctrl_ptr,ctrl_id,ctrl_handle,id_type,page_item_num,user_data_ptr,rect_x,rect_y))
                {
                    return TRUE;
                }
            }				
        break;
    }
    return FALSE;
}

/*****************************************************************************/
//  Description:查找控件Setlist，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持控件id,字符串查找
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchSetlistControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	
	CTRLSETLIST_OBJ_T *setlist_ptr = PNULL;
	MMI_STRING_T text_ptr = {0};
	MMI_IMAGE_ID_T user_data_id = 0;

	setlist_ptr = (CTRLSETLIST_OBJ_T *)ctrl_ptr;
	if(PNULL == setlist_ptr)
	{
		return FALSE;
	}
	
	if(PNULL == user_data_ptr)
	{
		return FALSE;
	}

	switch (id_type)
	{
		case CONTROL_ID_TYPE:
			user_data_id = ctrl_id;
			break;
		case TEXT_TYPE:
		case TEXT_ID_TYPE:
			text_ptr.wstr_ptr = setlist_ptr->disp_str.wstr_ptr;
			text_ptr.wstr_len = setlist_ptr->disp_str.wstr_len;
			break;
			default:
				return FALSE;
	}

	if(setlist_ptr->is_valid)
	{
		if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
		{
			if(0 == setlist_ptr->base_ctrl.display_rect.bottom
				&& 0 == setlist_ptr->base_ctrl.display_rect.left
				&& 0 == setlist_ptr->base_ctrl.display_rect.top
				&& 0 == setlist_ptr->base_ctrl.display_rect.right) //未显示
			{
				if(setlist_ptr->base_ctrl.rect.top < ATEST_RECT_LIMIT) //需上翻
				{
					Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_UP);
					return FALSE;
							
				}
				else if(setlist_ptr->base_ctrl.rect.bottom > ATEST_RECT_LIMIT) //需下翻
				{
					Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_DOWN);
					return FALSE;
				}
			}
			
			*rect_x = (setlist_ptr->base_ctrl.display_rect.left+setlist_ptr->base_ctrl.display_rect.right)/2;
			*rect_y = (setlist_ptr->base_ctrl.display_rect.bottom+setlist_ptr->base_ctrl.display_rect.top)/2;
			return TRUE;
		}
	}

	return FALSE;
}


/*****************************************************************************/
//  Description:查找控件Button，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持控件id查找
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchButtonControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	CTRLBUTTON_OBJ_T  *button_ctrl_ptr = PNULL;
	
    button_ctrl_ptr = (CTRLBUTTON_OBJ_T *)ctrl_ptr;
	if(PNULL == button_ctrl_ptr)
	{
		return FALSE;
	}
	
	switch (id_type)
	{
		case CONTROL_ID_TYPE:
			user_data_id = ctrl_id;
			break;
		case TEXT_TYPE:
		case TEXT_ID_TYPE:
			if (GUISTR_TEXT_ID == button_ctrl_ptr->text_info.text_type)
			{
			   MMITHEME_GetResText( button_ctrl_ptr->text_info.text_id, button_ctrl_ptr->win_handle, &text_ptr );
			}
			else if (GUISTR_TEXT_BUFFER == button_ctrl_ptr->text_info.text_type)
			{
				text_ptr.wstr_ptr = button_ctrl_ptr->text_info.str_info.wstr_ptr;
				text_ptr.wstr_len = button_ctrl_ptr->text_info.str_info.wstr_len;
			}
			break;
			default:
				return FALSE;
	}
	
	if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
	{
		if(0 == button_ctrl_ptr->base_ctrl.display_rect.bottom
			&& 0 == button_ctrl_ptr->base_ctrl.display_rect.left
			&& 0 == button_ctrl_ptr->base_ctrl.display_rect.top
			&& 0 == button_ctrl_ptr->base_ctrl.display_rect.right) //未显示
		{
			if(button_ctrl_ptr->base_ctrl.rect.top < ATEST_RECT_LIMIT) //需上翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_UP);
				return FALSE;
						
			}
			else if(button_ctrl_ptr->base_ctrl.rect.bottom > ATEST_RECT_LIMIT) //需下翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_DOWN);
				return FALSE;
			}
		}
		
		*rect_x = (button_ctrl_ptr->base_ctrl.display_rect.left+button_ctrl_ptr->base_ctrl.display_rect.right)/2;
		*rect_y = (button_ctrl_ptr->base_ctrl.display_rect.bottom+button_ctrl_ptr->base_ctrl.display_rect.top)/2;
		return TRUE;
	}
	
	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件tab，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持text,image id查找
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchTabControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	uint8 index_offset = 0;
	uint16 index = 0;
	uint16 start_index = 0;
	uint16 end_index = 0;
	uint16 cur_index = 0;
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_IMAGE_ID_T image_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	CTRLTAB_OBJ_T *tab_ptr = NULL;
	GUITAB_ITEM_T	*item_ptr = PNULL;

	tab_ptr = (CTRLTAB_OBJ_T *)ctrl_ptr;
	if(PNULL == tab_ptr)
	{
		return FALSE;
	}

	item_ptr = tab_ptr->valid_item_list.item_ptr;

	start_index = tab_ptr->start_show_item_index;
	end_index = tab_ptr->show_item_num + tab_ptr->start_show_item_index - 1;
	cur_index = tab_ptr->cur_sel_item_index;

	for(index=0; index < tab_ptr->valid_item_list.item_num; index++)
	{
		if(PNULL == item_ptr)
		{
			return FALSE;
		}

		switch (item_ptr->item_data_ptr->image_data.image_data_type)
		{
		    case TABITEM_DATA_IMAGE_ID:		/*!< 图片资源ID*/
				image_id = item_ptr->item_data_ptr->image_data.image_data_u.anim_data.img_id;
				break;						
		    case TABITEM_DATA_ANIM_ID:			/*!< 动画资源ID*/
				image_id = item_ptr->item_data_ptr->image_data.image_data_u.anim_data.anim_id;
				break;						
		    case TABITEM_DATA_ANIM_DATA:	/*!< 动画数据*/
		    case TABITEM_DATA_ANIM_PATH:/*!< 动画路径*/
			default:
				break;
		}
		SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
		switch (id_type)
		{
			case TEXT_TYPE:
			case TEXT_ID_TYPE:
				text_ptr.wstr_ptr = item_ptr->item_data_ptr->text_data.text.text_buffer.wstr;
				text_ptr.wstr_len = item_ptr->item_data_ptr->text_data.text.text_buffer.wstr_len;
				break;
			case IMAGE_ID_TYPE:
				user_data_id = image_id;
				break;
				default:
					return FALSE;
		}

		if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
		{
			if(index < start_index)//左移
			{
				tab_ptr->cur_sel_item_index = start_index;
				index_offset = tab_ptr->cur_sel_item_index -index;
				if(index_offset>0)
				{
					Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_LEFT);
					return FALSE;
				}
				
			}
			else if(index > end_index)//右移
			{
				tab_ptr->cur_sel_item_index = end_index;
				index_offset = index-tab_ptr->cur_sel_item_index;
				if(index_offset>0)
				{
					Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_RIGHT);
					return FALSE;
				}
			}

			*rect_x = (item_ptr->rect.left+item_ptr->rect.right)/2;
			*rect_y = (item_ptr->rect.top+item_ptr->rect.bottom)/2;			
			return TRUE;
		}
		item_ptr = item_ptr->next_ptr;
	}
	
	return FALSE;
}


/*****************************************************************************/
//  Description:查找控件RichText，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持TEXT,IMAGE ID
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchRichTextControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	MMI_IMAGE_ID_T user_data_id = 0,image_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	uint16 item_index,focus_item = 0;
	GUIRICHTEXT_ITEM_T richedit_item = { 0 };
	CTRLRICHTEXT_OBJ_T *richtext_ptr = PNULL;
	RICHTEXT_ITEM_T *item_pptr = PNULL;

	richtext_ptr = (CTRLRICHTEXT_OBJ_T *)ctrl_ptr;
	if(PNULL == richtext_ptr)
	{
		return FALSE;
	}
 
	item_pptr = richtext_ptr->first_item_ptr;		
    for (item_index = 0; ; item_index++)
    {
		if(PNULL == item_pptr)
		{
			return FALSE;
		}
		
		SCI_MEMSET(&richedit_item, 0, sizeof(GUIRICHTEXT_ITEM_T));
        if(!CTRLRICHTEXT_GetItem(ctrl_handle, item_index, &richedit_item))
        {
			break;
		}

        if ( (GUIRICHTEXT_TEXT_INVALID == richedit_item.text_type ) && (GUIRICHTEXT_IMAGE_INVALID == richedit_item.img_type) )
        {
            break;
        }

		//text
		SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
		if(GUIRICHTEXT_TEXT_RES == richedit_item.text_type || GUIRICHTEXT_TEXT_BUF == richedit_item.text_type)
		{
			 text_ptr.wstr_ptr = richedit_item.text_data.buf.str_ptr;
			 text_ptr.wstr_len = richedit_item.text_data.buf.len;
		}

		image_id = richedit_item.img_data.res.id;

		switch (id_type)
		{
			case TEXT_TYPE:
			case TEXT_ID_TYPE:
				user_data_id = richedit_item.text_data.res.id;
				break;
			case IMAGE_ID_TYPE:
				user_data_id = image_id;
				break;
			case INDEX_ID_TYPE:
				item_index = Atest_GetTestMessageId(',',&user_data_ptr);	//
				item_index = Atest_GetTestMessageId(',',&user_data_ptr);	//id	
				break;
			default:
				return FALSE;
		}

		if((id_type == INDEX_ID_TYPE) || Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
		{
			if (item_index > 3)
			{
				item_index -= 1;
			}
			else
			{
				CTRLRICHTEXT_SetFocusItem(ctrl_id, 0);	
				CTRLRICHTEXT_ScrollToFocus(ctrl_id);
			}
			CTRLRICHTEXT_GetFocusItemIndex(ctrl_id,&focus_item);	

			CTRLRICHTEXT_SetFocusItem(ctrl_id, item_index);	

			switch (id_type)
			{
				case TEXT_TYPE:
				case TEXT_ID_TYPE:
					*rect_x = (item_pptr->data.txt_ext_data.disp_rect.left + item_pptr->data.txt_ext_data.disp_rect.right)/2 +richtext_ptr->base_ctrl.rect.left;
					*rect_y = (item_pptr->data.txt_ext_data.disp_rect.top + item_pptr->data.txt_ext_data.disp_rect.bottom)/2 + richtext_ptr->base_ctrl.rect.top;
					break;
				case IMAGE_ID_TYPE:
					*rect_x = (item_pptr->data.img_ext_data.disp_rect.left + item_pptr->data.img_ext_data.disp_rect.right)/2 +richtext_ptr->base_ctrl.rect.left;
					*rect_y = (item_pptr->data.img_ext_data.disp_rect.top + item_pptr->data.img_ext_data.disp_rect.bottom)/2 + richtext_ptr->base_ctrl.rect.top;
					break;
				case INDEX_ID_TYPE:
					*rect_x = (richtext_ptr->focus_item_ptr->virtual_rect.left + richtext_ptr->focus_item_ptr->virtual_rect.right)/2 + richtext_ptr->base_ctrl.rect.left;
					*rect_y = (richtext_ptr->focus_item_ptr->virtual_rect.top + richtext_ptr->focus_item_ptr->virtual_rect.bottom)/2 + richtext_ptr->base_ctrl.rect.top;
					break;
				default:
					return FALSE;
			}
			return TRUE;
		}
		item_pptr = item_pptr->next_ptr;
    }

	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件Anim，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持控件ID和动画id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchAnimControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	CTRLANIM_OBJ_T  *anim_ctrl_ptr = PNULL;

	anim_ctrl_ptr = (CTRLANIM_OBJ_T  *)ctrl_ptr;
	if(PNULL == anim_ctrl_ptr)
	{
		return FALSE;
	}

	switch (id_type)
	{
		case CONTROL_ID_TYPE:
			user_data_id = ctrl_id;
			break;
		case IMAGE_ID_TYPE:
			if(anim_ctrl_ptr->data_info.anim_id)
			{
				user_data_id = anim_ctrl_ptr->data_info.anim_id;
			}
			else
			{
				user_data_id = anim_ctrl_ptr->data_info.img_id;
			}
			break;
			default:
				return FALSE;
	}

	if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
	{
		if(0 == anim_ctrl_ptr->base_ctrl.display_rect.bottom
			&& 0 == anim_ctrl_ptr->base_ctrl.display_rect.left
			&& 0 == anim_ctrl_ptr->base_ctrl.display_rect.top
			&& 0 == anim_ctrl_ptr->base_ctrl.display_rect.right) //未显示
		{
			if(anim_ctrl_ptr->base_ctrl.rect.top < ATEST_RECT_LIMIT) //需上翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_UP);
				return FALSE;
						
			}
			else if(anim_ctrl_ptr->base_ctrl.rect.bottom > ATEST_RECT_LIMIT) //需下翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_DOWN);
				return FALSE;
			}
		}
		
		*rect_x = (anim_ctrl_ptr->base_ctrl.display_rect.left+anim_ctrl_ptr->base_ctrl.display_rect.right)/2;
		*rect_y = (anim_ctrl_ptr->base_ctrl.display_rect.bottom+anim_ctrl_ptr->base_ctrl.display_rect.top)/2;
		return TRUE;	
	}
	return FALSE;
}


/*****************************************************************************/
//  Description:查找控件Msgbox，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持控件ID
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchMsgboxControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	CTRLMSGBOX_OBJ_T* msgbox_ptr = PNULL;

	msgbox_ptr = (CTRLMSGBOX_OBJ_T*)ctrl_ptr;
	if(PNULL == msgbox_ptr)
	{
		return FALSE;
	}

	switch (id_type)
	{
		case CONTROL_ID_TYPE:
			user_data_id = ctrl_id;
			*rect_x = (msgbox_ptr->base_ctrl.rect.left + msgbox_ptr->base_ctrl.rect.right)/2;
			*rect_y = (msgbox_ptr->base_ctrl.rect.bottom + msgbox_ptr->base_ctrl.rect.top)/2;
			break;
		case IMAGE_ID_TYPE:
			switch(msgbox_ptr->image_type)
			{
				case GUIMSGBOX_IMAGE_ANIMA:/*!<动画 */
					user_data_id = msgbox_ptr->anim_id;
					break;					
   				case GUIMSGBOX_IMAGE_BMP:/*!<图片*/
					user_data_id = msgbox_ptr->image_id;
					break;
					default:
						break;
			}
			*rect_x = (msgbox_ptr->image_rect.left + msgbox_ptr->image_rect.right)/2;
			*rect_y = (msgbox_ptr->image_rect.bottom + msgbox_ptr->image_rect.top)/2;
			break;			
		case TEXT_TYPE:
		case TEXT_ID_TYPE:
			text_ptr.wstr_ptr = msgbox_ptr->text_info.string.wstr_ptr;
			text_ptr.wstr_len = msgbox_ptr->text_info.string.wstr_len;
			*rect_x = (msgbox_ptr->text_info.text_rect.left + msgbox_ptr->text_info.text_rect.right)/2;
			*rect_y = (msgbox_ptr->text_info.text_rect.bottom + msgbox_ptr->text_info.text_rect.top)/2;
			break;
			default:
				return FALSE;
	}

	if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
	{
		return TRUE;
	}

	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件Textbox，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持控件ID和文本id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchTextboxControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	CTRLTEXT_OBJ_T *text_ctrl_ptr = PNULL;

	text_ctrl_ptr = (CTRLTEXT_OBJ_T *)ctrl_ptr;
	if(PNULL == text_ctrl_ptr)
	{
		return FALSE;
	}

	switch (id_type)
	{
		case CONTROL_ID_TYPE:
			user_data_id = ctrl_id;
			break;
		case TEXT_TYPE:
		case TEXT_ID_TYPE:
			GUITEXT_GetString(ctrl_handle,&text_ptr);
			break;
			default:
				return FALSE;
	}

	if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
	{
		if(0 == text_ctrl_ptr->base_ctrl.display_rect.bottom
			&& 0 == text_ctrl_ptr->base_ctrl.display_rect.left
			&& 0 == text_ctrl_ptr->base_ctrl.display_rect.top
			&& 0 == text_ctrl_ptr->base_ctrl.display_rect.right) //未显示
		{
			if(text_ctrl_ptr->base_ctrl.rect.top < ATEST_RECT_LIMIT) //需上翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_UP);
				return FALSE;
						
			}
			else if(text_ctrl_ptr->base_ctrl.rect.bottom > ATEST_RECT_LIMIT) //需下翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_DOWN);
				return FALSE;
			}
		}
		
		*rect_x = (text_ctrl_ptr->base_ctrl.display_rect.left+text_ctrl_ptr->base_ctrl.display_rect.right)/2;
		*rect_y = (text_ctrl_ptr->base_ctrl.display_rect.bottom+text_ctrl_ptr->base_ctrl.display_rect.top)/2;
		return TRUE;
	}
	return FALSE;
}


/*****************************************************************************/
//  Description:查找控件Dropdownlist，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持控件ID,和文本字符
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchDropdownlistControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	CTRLDROPDOWNLIST_OBJ_T* dropdownlist_ptr = PNULL;

	dropdownlist_ptr = (CTRLDROPDOWNLIST_OBJ_T*)ctrl_ptr;
	if(PNULL == dropdownlist_ptr)
	{
		return FALSE;
	}

	switch (id_type)
	{
		case CONTROL_ID_TYPE:
			user_data_id = ctrl_id;
			break;
		case TEXT_TYPE:
		case TEXT_ID_TYPE:
			text_ptr = GUIDROPDOWNLIST_GetCurItem(ctrl_handle);
			break;
			default:
				return FALSE;
	}

	if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
	{
		if(0 == dropdownlist_ptr->base_ctrl.display_rect.bottom
			&& 0 == dropdownlist_ptr->base_ctrl.display_rect.left
			&& 0 == dropdownlist_ptr->base_ctrl.display_rect.top
			&& 0 == dropdownlist_ptr->base_ctrl.display_rect.right) //未显示
		{
			if(dropdownlist_ptr->base_ctrl.rect.top < ATEST_RECT_LIMIT) //需上翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_UP);
				return FALSE;
						
			}
			else if(dropdownlist_ptr->base_ctrl.rect.bottom > ATEST_RECT_LIMIT) //需下翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_DOWN);
				return FALSE;
			}
		}
		
		*rect_x = (dropdownlist_ptr->base_ctrl.display_rect.left+dropdownlist_ptr->base_ctrl.display_rect.right)/2;
		*rect_y = (dropdownlist_ptr->base_ctrl.display_rect.bottom+dropdownlist_ptr->base_ctrl.display_rect.top)/2;
		return TRUE;
	}
	return FALSE;
}


/*****************************************************************************/
//  Description:查找控件Iconlist，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持字符串
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchIconlistControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	uint32 index_ptr = 0;
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	GUI_RECT_T rect_ptr = { 0 };
	CTRLICONLIST_OBJ_T  *iconlist_ctrl_ptr = PNULL;
	GUIICONLIST_ITEM_T  *item_ptr = PNULL;

	iconlist_ctrl_ptr = (CTRLICONLIST_OBJ_T  *)ctrl_ptr;
	if(PNULL == iconlist_ctrl_ptr)
	{
		return FALSE;
	}

	item_ptr = iconlist_ctrl_ptr->item_ptr;
	for(index_ptr = 0; index_ptr < iconlist_ctrl_ptr->total_num; index_ptr++)
	{
		if(PNULL == item_ptr)
		{
			break;
		}

		switch (id_type)
		{
			case INDEX_ID_TYPE:
				user_data_id = index_ptr;
				break;
			case TEXT_TYPE:
			case TEXT_ID_TYPE:
				text_ptr.wstr_ptr = item_ptr->text.display.name_str.wstr_ptr;
				text_ptr.wstr_len = item_ptr->text.display.name_str.wstr_len;
				break;
				default:
					return FALSE;
		}
		
		//SCI_TRACE_LOW:"[ATC][ATEST]:Iconlist:index_ptr=%d,row=%d,col=%d,item=%d,top=%d,bottom=%d,cur=%d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_10517_112_2_18_1_59_47_83,(uint8*)"ddddddd",index_ptr,iconlist_ctrl_ptr->row_num_page,iconlist_ctrl_ptr->col_num_page,iconlist_ctrl_ptr->icon_num_page,iconlist_ctrl_ptr->top_index,iconlist_ctrl_ptr->bottom_index,iconlist_ctrl_ptr->cur_index);

		if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
		{
			if(index_ptr > iconlist_ctrl_ptr->cur_index)	//右移
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_RIGHT);
				return FALSE;
			}
			else if(index_ptr < iconlist_ctrl_ptr->cur_index)	//左移
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_LEFT);
				return FALSE;
			}

			rect_ptr = ICONLIST_GetIconRect(index_ptr,iconlist_ctrl_ptr);
			if(Atest_GetValidTPPoint(rect_ptr,iconlist_ctrl_ptr->base_ctrl.rect,rect_x,rect_y))
			{			
				return TRUE;
			}
		}
		item_ptr++;
	}
	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件Title，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持文本ID，image id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchTitleControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	uint16 i = 0;
	CTRLTITLE_OBJ_T  *title_ptr = PNULL;
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_STRING_T text_ptr = { 0 };

	title_ptr = (CTRLTITLE_OBJ_T  *)ctrl_ptr;
	if (PNULL == title_ptr)
	{
		return FALSE;
	}

	if(title_ptr->is_need_button)
	{
		for(i=0;i<GUITITLE_BUTTON_NUM;i++)
		{
			if(!title_ptr->button_state[i])
			{
				switch (id_type)
				{
					case TEXT_TYPE:
					case TEXT_ID_TYPE:
						SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
						if(GUITITLE_DATA_TEXT_ID == title_ptr->button_info[i].text_type)
						{
							MMITHEME_GetResText(title_ptr->button_info[i].text_id, title_ptr->win_handle, &text_ptr);
						}
						else if(GUITITLE_DATA_TEXT_BUFFER == title_ptr->button_info[i].text_type)
						{
							text_ptr.wstr_ptr = title_ptr->button_info[i].icon_str_ptr;
							text_ptr.wstr_len = title_ptr->button_info[i].str_len;
						}
						break;
					case IMAGE_ID_TYPE:
						user_data_id = title_ptr->button_info[i].image_id;
						break;
						default:
							return FALSE;
				}

				if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
				{
					*rect_x = (title_ptr->button_rect[i].left + title_ptr->button_rect[i].right)/2;
					*rect_y = (title_ptr->button_rect[i].bottom + title_ptr->button_rect[i].top)/2;
					return TRUE;
				}
			}
		}
	}

	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件IM，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持按键code字符查找
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchIMControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
#if defined (MMI_IM_PDA_SUPPORT)
	uint16 key_idx = 0;
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	IM_DATA_T *im_data_ptr = PNULL;
	CTRLIM_OBJ_T *im_ptr = PNULL;

	im_ptr = (CTRLIM_OBJ_T *)ctrl_ptr;
	if (PNULL == im_ptr)
	{
		return FALSE;
	}

	im_data_ptr = im_ptr->im_handle;
	if (PNULL == im_data_ptr)
	{
		return FALSE;
	}

	for (key_idx = 0; key_idx < im_data_ptr->vkb.key_cnt; key_idx++)
    {
		if(!im_data_ptr->vkb.keys[key_idx].is_hide)
		{
			switch (id_type)
			{
				case TEXT_TYPE:
				case TEXT_ID_TYPE:
					SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
					text_ptr.wstr_ptr = im_data_ptr->vkb.keys[key_idx].text;
					text_ptr.wstr_len = im_data_ptr->vkb.keys[key_idx].text_len;
					break;
				case CONTROL_ID_TYPE:
					user_data_id = im_data_ptr->vkb.keys[key_idx].code;
					break;
					default:
						return FALSE;
			}

			if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
			{
				*rect_x = (im_data_ptr->vkb.keys[key_idx].rect.left + im_data_ptr->vkb.keys[key_idx].rect.right)/2 + im_ptr->base_ctrl.rect.left;
				*rect_y = (im_data_ptr->vkb.keys[key_idx].rect.bottom + im_data_ptr->vkb.keys[key_idx].rect.top)/2 + im_ptr->base_ctrl.rect.top;
				return TRUE;
			}
		}
	}
#endif
	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件ToolBar，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持文本ID，image id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchToolBarControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
#ifdef GUIF_TOOLBAR
	uint16 index = 0;
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	GUITOOLBAR_ITEM_T* toolbar_item_ptr = PNULL;
	CTRLTOOLBAR_OBJ_T* toolbar_ptr = PNULL;
	GUITOOLBAR_ITEM_INFO_T* item_info_ptr = PNULL;

	toolbar_ptr = (CTRLTOOLBAR_OBJ_T *)ctrl_ptr;
	if (PNULL == toolbar_ptr)
	{
		return FALSE;
	}

	index = toolbar_ptr->click_index;

	item_info_ptr = toolbar_ptr->item_info_ptr;
	for(toolbar_ptr->click_index=0;toolbar_ptr->click_index<toolbar_ptr->total_num;toolbar_ptr->click_index++)
	{
		if(PNULL == item_info_ptr)
		{
			break;
		}

		toolbar_item_ptr = &(item_info_ptr->item);

		switch (id_type)
		{
			case TEXT_TYPE:
			case TEXT_ID_TYPE:
				SCI_MEMSET(&text_ptr,0,sizeof(MMI_STRING_T));
				MMITHEME_GetResText(toolbar_item_ptr->text_id, toolbar_ptr->win_handle,&text_ptr);
				break;
			case IMAGE_ID_TYPE:
				user_data_id = toolbar_item_ptr->image_id;
				break;
				default:
					return FALSE;
		}

		if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
		{
			*rect_x = (item_info_ptr->base_ctrl.rect.left + item_info_ptr->base_ctrl.rect.right)/2;
			*rect_y = (item_info_ptr->base_ctrl.rect.bottom + item_info_ptr->base_ctrl.rect.top)/2;
			return TRUE;
		}
		
		item_info_ptr = item_info_ptr + 1;
	}

	toolbar_ptr->click_index = index;
#endif
	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件Tips，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持文本,控件id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchTipsControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	TIPS_OBJ_T *tips_ptr  = PNULL;

	tips_ptr  = (TIPS_OBJ_T *)ctrl_ptr;
	if (PNULL == tips_ptr)
	{
		return FALSE;
	}

	if(tips_ptr->is_valid) //tip是否有效
	{
		switch (id_type)
		{
			case TEXT_TYPE:
			case TEXT_ID_TYPE:
				text_ptr.wstr_ptr = tips_ptr->text_info.wstr_ptr;
				text_ptr.wstr_len = tips_ptr->text_info.wstr_len;
				break;
			case CONTROL_ID_TYPE:
				user_data_id = ctrl_id;
				break;
				default:
					return FALSE;
		}

		if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
		{
			*rect_x = (tips_ptr->base_ctrl.rect.left + tips_ptr->base_ctrl.rect.right)/2;
			*rect_y = (tips_ptr->base_ctrl.rect.bottom + tips_ptr->base_ctrl.rect.top)/2;
			return TRUE;
		}
	}
	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件Statusbar，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持文本,image id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchStatusbarControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	uint16 item_total_num = 0;
	uint16 item_index = 0;
	CTRLSTATUSBAR_OBJ_T *statusbar_ptr = PNULL;
	GUISTBDATA_ITEM_DATA_T *stb_item_ptr = PNULL;
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_STRING_T text_ptr = { 0 };

	statusbar_ptr = (CTRLSTATUSBAR_OBJ_T *)ctrl_ptr;
	if (PNULL == statusbar_ptr)
	{
		 return FALSE;
	} 
	item_total_num = GUISTBDATA_GetItemTotalNum();
	if(statusbar_ptr->is_shown)
	{
		 for(item_index=0;item_index<item_total_num;item_index++)
		 {
			if(GUISTBDATA_IsItemVisible(item_index))
			{
				stb_item_ptr = GUISTBDATA_GetItemData(item_index);
				if (PNULL == stb_item_ptr)
				{
					 break;
				} 

				switch (id_type)
				{
					case TEXT_TYPE:
					case TEXT_ID_TYPE:
						text_ptr.wstr_ptr = stb_item_ptr->text_info.wstr_ptr;
						text_ptr.wstr_len = stb_item_ptr->text_info.wstr_len;
						break;
					case IMAGE_ID_TYPE:
						user_data_id = stb_item_ptr->icon_info.icon_array[stb_item_ptr->cur_frame];
						break;
						default:
							return FALSE;
				}

				if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
				{
					*rect_x = (stb_item_ptr->item_rect.left + stb_item_ptr->item_rect.right)/2;
					*rect_y = (stb_item_ptr->item_rect.bottom + stb_item_ptr->item_rect.top)/2;
					return TRUE;
				}
			}
		}
	}
	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件Owndraw，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持control id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchOwndrawControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	CTRLOWNERDRAW_OBJ_T  *owndraw_ctrl_ptr = PNULL;

    owndraw_ctrl_ptr = (CTRLOWNERDRAW_OBJ_T *)ctrl_ptr;
    if (PNULL == owndraw_ctrl_ptr)
    {
		return FALSE;
	}

	switch (id_type)
	{
		case CONTROL_ID_TYPE:
			user_data_id = ctrl_id;
			break;
			default:
				return FALSE;
	}

	if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
	{
		if(0 == owndraw_ctrl_ptr->base_ctrl.display_rect.bottom
			&& 0 == owndraw_ctrl_ptr->base_ctrl.display_rect.left
			&& 0 == owndraw_ctrl_ptr->base_ctrl.display_rect.top
			&& 0 == owndraw_ctrl_ptr->base_ctrl.display_rect.right) //未显示
		{
			if(owndraw_ctrl_ptr->base_ctrl.rect.top < ATEST_RECT_LIMIT) //需上翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_UP);
				return FALSE;
						
			}
			else if(owndraw_ctrl_ptr->base_ctrl.rect.bottom > ATEST_RECT_LIMIT) //需下翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_DOWN);
				return FALSE;
			}
		}
		
		*rect_x = (owndraw_ctrl_ptr->base_ctrl.display_rect.left+owndraw_ctrl_ptr->base_ctrl.display_rect.right)/2;
		*rect_y = (owndraw_ctrl_ptr->base_ctrl.display_rect.bottom+owndraw_ctrl_ptr->base_ctrl.display_rect.top)/2;
		return TRUE;
	}

	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件Prgbox，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持control id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchPrgboxControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	CTRLPROGRESS_OBJ_T *prgbox_ctrl_ptr = PNULL;

	prgbox_ctrl_ptr = (CTRLPROGRESS_OBJ_T *)ctrl_ptr;
	if (PNULL == prgbox_ctrl_ptr)
	{
		 return FALSE;
	}

	switch (id_type)
	{
		case CONTROL_ID_TYPE:
			user_data_id = ctrl_id;
			break;
			default:
				return FALSE;
	}

	if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
	{
		*rect_x = (prgbox_ctrl_ptr->base_ctrl.rect.left + prgbox_ctrl_ptr->base_ctrl.rect.right)/2;
		*rect_y = (prgbox_ctrl_ptr->base_ctrl.rect.bottom + prgbox_ctrl_ptr->base_ctrl.rect.top)/2;
		return TRUE;
	}

	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件Form，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持control id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchFormControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	CTRLFORM_OBJ_T  *form_ctrl_ptr = PNULL;

	form_ctrl_ptr = (CTRLFORM_OBJ_T *)ctrl_ptr;
	if (PNULL == form_ctrl_ptr)
	{
		return FALSE;
	}

	switch (id_type)
	{
		case CONTROL_ID_TYPE:
			user_data_id = ctrl_id;
			break;
			default:
				return FALSE;
	}

	if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
	{
		if(0 == form_ctrl_ptr->base_ctrl.rect.bottom
			&& 0 == form_ctrl_ptr->base_ctrl.rect.left
			&& 0 == form_ctrl_ptr->base_ctrl.rect.top
			&& 0 == form_ctrl_ptr->base_ctrl.rect.right) //未显示
		{
			if(form_ctrl_ptr->base_ctrl.rect.top < ATEST_RECT_LIMIT) //需上翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_UP);
				return FALSE;
						
			}
			else if(form_ctrl_ptr->base_ctrl.rect.bottom > ATEST_RECT_LIMIT) //需下翻
			{
				Atest_SendSignalToAppTask(receive_data_arr,strlen((char*)receive_data_arr),0,ATEST_SIGNAL_KB_DOWN);
				return FALSE;
			}
		}
		
		*rect_x = (form_ctrl_ptr->base_ctrl.display_rect.left+form_ctrl_ptr->base_ctrl.display_rect.right)/2;
		*rect_y = (form_ctrl_ptr->base_ctrl.display_rect.bottom+form_ctrl_ptr->base_ctrl.display_rect.top)/2;
		return TRUE;
	}

	return FALSE;
}

/*****************************************************************************/
//  Description:查找控件Iconfolder，返回其对应的中心坐标
//  Global resource dependence :none
//  Author: linchen
//  Note:支持control id
/*****************************************************************************/ 
LOCAL BOOLEAN Atest_SearchIconfolderControlItem(
										    IGUICTRL_T *ctrl_ptr,   	//控件指针 
										    MMI_CTRL_ID_T ctrl_id,		//控件id
										    MMI_HANDLE_T ctrl_handle,	//控件handle
										    ATEST_ID_TYPE_E id_type,	//查找类型
										    uint8 *user_data_ptr,		//查找的数据
										    uint16 *rect_x,				//out:坐标x
											uint16 *rect_y)				//out:坐标y
{
	MMI_IMAGE_ID_T user_data_id = 0;
	MMI_STRING_T text_ptr = { 0 };
	CTRLICONFOLDER_OBJ_T    *iconfolder_ctrl_ptr = PNULL;

	iconfolder_ctrl_ptr = (CTRLICONFOLDER_OBJ_T *)ctrl_ptr;
	if (PNULL == iconfolder_ctrl_ptr)
	{
		 return FALSE;
	}

	switch (id_type)
	{
		case CONTROL_ID_TYPE:
			user_data_id = ctrl_id;
			break;
			default:
				return FALSE;
	}

	if(Atest_Compare_content(id_type,ctrl_handle,text_ptr,user_data_ptr,user_data_id))
	{
		*rect_x = (iconfolder_ctrl_ptr->base_ctrl.rect.left + iconfolder_ctrl_ptr->base_ctrl.rect.right)/2;
		*rect_y = (iconfolder_ctrl_ptr->base_ctrl.rect.bottom + iconfolder_ctrl_ptr->base_ctrl.rect.top)/2;
		return TRUE;
	}

	return FALSE;
}

/*****************************************************************************/
//  Description: 设置闹钟时间
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_SetAlarmTime(uint8 *user_data_ptr)
{
	uint8 *start_ptr = user_data_ptr;
	SCI_TIME_T    time_val;
	uint32 win_id = Atest_GetTestMessageId(',',&start_ptr); 
	uint32 hour = Atest_GetTestMessageId(',',&start_ptr); 
	uint32 min = Atest_GetTestMessageId(',',&start_ptr); 
	uint32 sec = Atest_GetTestMessageId(',',&start_ptr); 
	
	if(win_id != MMK_GetFocusWinId())
	{
		return FALSE;
	}	

	time_val.sec = sec;	
	time_val.min = min;	
	time_val.hour = hour;
	
#ifdef MMI_ALARM_GESTURE_CLOCK_SUPPORT
#if (defined MMIWIDGET_SUPPORT) || (defined MMI_GRID_IDLE_SUPPORT)

	if(ATESTALM_SetAlarmTime( time_val ))
	{
		return TRUE;
	}
	
#endif
#endif
	return FALSE;	
}

/*****************************************************************************/
//  Description: 获取下个闹钟的时间
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetLatestAlarmTime(uint8 *user_data_ptr)
{
	uint8 data_len = 0;
	uint8 *data_ptr = PNULL;
	char date[50];
	uint32 second = 0;
	SCI_ALARM_T s_alarm= {0};

	data_ptr = (uint8 *)SCI_ALLOC_APP(128);
    if (PNULL == data_ptr)
    {
        return FALSE;
    }

	ATESTALM_GetLatestAlarmTime(&s_alarm);
	second = MMIAPICOM_Tm2Second( s_alarm.sec,s_alarm.min,s_alarm.hour,s_alarm.mday,s_alarm.mon,s_alarm.year );   

	data_len = sprintf((char *)date,"%d,%d,%d,%d,%d,%d,%d",second,s_alarm.year,s_alarm.mon,s_alarm.mday,s_alarm.hour,s_alarm.min,s_alarm.sec);
	data_len = sprintf((char *)data_ptr,"<AlarmTime>%s</AlarmTime><Len>%d</Len>",date,data_len);
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);

	SCI_FREE(data_ptr);
	return TRUE;
}

/*****************************************************************************/
//  Description: 获取当前手机的时间
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetCurSysTime(uint8 *user_data_ptr)
{
	uint8 data_len = 0;
	uint8 *data_ptr = PNULL;
	uint32 second = MMIAPICOM_GetCurTime();
	MMI_TM_T tm=MMIAPICOM_Second2Tm(second);
	char date[50];

	data_ptr = (uint8 *)SCI_ALLOC_APP(128);
    if (PNULL == data_ptr)
    {
        return FALSE;
    }

	data_len = sprintf((char *)date,"%d,%d,%d,%d,%d,%d,%d",second,tm.tm_year,tm.tm_mon,tm.tm_mday,tm.tm_hour,tm.tm_min,tm.tm_sec);
	data_len = sprintf((char *)data_ptr,"<SysTime>%s</SysTime><Len>%d</Len>",date,data_len);
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);

	SCI_FREE(data_ptr);
	return TRUE;
}

/*****************************************************************************/
//  Description: 进入日历上的某个日期
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_ClickCalendarDate(uint8 *user_data_ptr)
{
	uint8 cur_date = 0;
	uint8 cur_month = 0;
	uint16 cur_year = 0;
	GUI_RECT_T rect = {0};
	uint16 rect_x = 0;
	uint16 rect_y = 0;
	
	uint8 *start_ptr = user_data_ptr;
	uint32 win_id = Atest_GetTestMessageId(',',&start_ptr); 
	uint32 year = Atest_GetTestMessageId(',',&start_ptr); 
	uint32 month = Atest_GetTestMessageId(',',&start_ptr); 
	uint32 date = Atest_GetTestMessageId(',',&start_ptr); 
	
	if(win_id != MMK_GetFocusWinId())
	{
		return FALSE;
	}

	ATESTCALENDAR_GetCurDate(&cur_date,&cur_month,&cur_year);	
	if(cur_year != year && cur_month != month)
	{
		return FALSE;
	}	

	ATESTCALENDAR_GetDateRect(date,month,year,&rect);

	rect_x = (rect.left + rect.right)/2;
	rect_y = (rect.top + rect.bottom)/2;

	Atest_SendTouchMessage(MMI_TP_DOWN,rect_x,rect_y);
	Atest_SendTouchMessage(MMI_TP_UP,rect_x,rect_y);			

	return TRUE;
}

/*****************************************************************************/
//  Description: 获得当前日历的焦点日期
//  Global resource dependence :none
//  Author: linchen
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN Atest_GetCalendarCurDate(uint8 *user_data_ptr)
{
	uint8 date = 0;
	uint8 month = 0;
	uint16 year = 0;
	uint8 data_len = 0;
	uint8 *data_ptr = PNULL;
	char dateArr[50];	

	data_ptr = (uint8 *)SCI_ALLOC_APP(128);
    if (PNULL == data_ptr)
    {
        return FALSE;
    }

	ATESTCALENDAR_GetCurDate(&date,&month,&year);

	data_len = sprintf((char *)dateArr,"%d,%d,%d",date,month,year);
	data_len = sprintf((char *)data_ptr,"<CalendarCurDate>%s</CalendarCurDate><Len>%d</Len>",dateArr,data_len);
	Atest_TransmitATString(data_ptr, data_len, FALSE, FALSE);

	SCI_FREE(data_ptr);
	return TRUE;
}

#endif // ATEST_SUPPORT

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/*                                    End  of Atest  Function                                                                  */
/* Description:  Hanlde at cmd for auto test cases                                                                    */
/* Author: Shuyan.hu                                                                                                           */
/* Date: 30/12/2010                                                                                                            */ 
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/



/*****************************************************************************/
// 	Description : If the cmd is match the indication
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN IsMatchIndication(
				                uint8 *cmd,  // Point to the command infomation buffer
				                uint32 len,   // The length of command infomation buffer
                                const char* ind_ptr //the indication
				                )
{
    uint8 ind_str[MMI_MAX_INDICATE_LEN + 1] = {0};
    uint16 ind_len = 0;

    SCI_ASSERT(PNULL != cmd); /*assert verified*/
    SCI_ASSERT(PNULL != ind_ptr); /*assert verified*/

    ind_len = strlen(ind_ptr);

    strncpy((char *)ind_str, (char *)cmd, ind_len);
    if(0 == strcmp((char *)ind_str, ind_ptr))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


#define MMI_MONKEY_TEST_SETTING_STR "+MONKEYTEST_SETTING"
/***************************************************************************//*!
@brief monkey test setting
@author Lianxiang.Zhou
@param cmd_str [IN] at cmd string
@param cmd_len [IN] at cmd string len
@retval TRUE - is monkey test at cmd, and deal it
@retval FALSE - not monkey test at cmd
@return deal it?
@note 实现以下的部分功能
-# 锁屏关闭
-# USB log Open
-# Call BARING Open
-# 动态墙纸随机设定
-# 视频墙纸开启
-# idle放置widget及shortcut
-# 4个系统切换
-# LOGEL工具自动加载map
*******************************************************************************/
LOCAL BOOLEAN HandleMonkeyTest(
    const char *cmd_str,
    uint32 cmd_len
)
{
    uint32  str_len = strlen(MMI_MONKEY_TEST_SETTING_STR);

    if (cmd_len != str_len)
    {
        return FALSE;
    }

    if (0 != strncmp(cmd_str, MMI_MONKEY_TEST_SETTING_STR, str_len))
    {
        return FALSE;
    }

    //setting
    //turn on
    MMIDEFAULT_TurnOnBackLight();
#ifdef MMI_KEY_LOCK_SUPPORT
    //unlock
    MMIAPIKL_UnlockPhone();
#endif
    //backlight
    MMIDEFAULT_AllowTurnOffBackLight(FALSE);

    //锁屏关闭
    MMISET_SetAutoBoardKey(MMISET_KEYLOCK_CLOSE);

#ifdef ENG_SUPPORT
    //USB log Open
    MMIENG_SetUSBLog(TRUE);

    //Call BARING Open
    MMIAPIENG_SetCallBarring(TRUE);

    //set monkey test mode
    MMIENG_SetMonkeyTestMode(1);
#endif



    return TRUE;
}


/*****************************************************************************/
// 	Description : This function parse at cmd wich from sync tool
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN ParseSyncAtCmd(
					      uint8 *cmd,  // Point to the command infomation buffer
					      uint32 len   // The length of command infomation buffer
					      )
{
    uint8 module_type = 0;
    uint8 operation_type = 0;
    BOOLEAN recode = TRUE;

	uint8	*cmd_dec = NULL;
	uint16	dec_len = 0;

#ifndef _WIN32
    if(!s_atc_is_run)
    {
        //SCI_TRACE_LOW:"mmi_atc.c: ParseSyncAtCmd(), mmi atc is not run"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11114_112_2_18_1_59_49_84,(uint8*)"");
        return FALSE;
    }
#endif 

    //check length, must be have module type and operation type
    //sync_alarm have only module type
    if(len < 1)
    {
        return FALSE;
    }

    module_type = *(cmd++);
    len--;
    operation_type = *(cmd++);
    len--;

    //SCI_TRACE_LOW:"mmi_atc.c: ParseSyncAtCmd(), module_type = %c, operation_type = %c"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11131_112_2_18_1_59_49_85,(uint8*)"cc", module_type, operation_type);

	cmd_dec = (uint8*)SCI_ALLOC_APP(MAX(MAX_RESCMD_LEN, (len +1)));
	SCI_ASSERT(NULL != cmd_dec); /*assert verified*/
	SCI_MEMSET(cmd_dec, 0, MAX(MAX_RESCMD_LEN, (len +1)));
	
	//解压缩命令字符串
	dec_len = DecompressCmdStr(cmd, len, cmd_dec, MAX(MAX_RESCMD_LEN, (len +1)));
	//SCI_ASSERT(MAX_RESCMD_LEN > dec_len);

	//test
// 	{
// 		uint8	*cmd_m = NULL;
// 
// 		cmd_m = SCI_ALLOC_APP(MAX_RESCMD_LEN);
// 
// 		SCI_MEMSET(cmd_m, 0, MAX_RESCMD_LEN);
// 		len = CompressCmdStr(cmd_dec, dec_len, cmd_m);
// 		SCI_MEMSET(cmd_dec, 0, dec_len);
// 		dec_len = DecompressCmdStr(cmd_m, len, cmd_dec);
// 	}
	//test

    switch(module_type)
    {
    case MMI_SYNC_PB:
        switch(operation_type) 
        {
        case MMI_SYNC_GETINFO:
            recode = HandlePbGetInfo(cmd_dec, dec_len);
        	break;

        case MMI_SYNC_ADD:
            recode = HandlePbAdd(cmd_dec, dec_len);
            break;        

        case MMI_SYNC_DELETE:
            recode = HandlePbDelete(cmd_dec, dec_len);
            break;

        case MMI_SYNC_MODIFY:
            recode = HandlePbModify(cmd_dec, dec_len);
            break;

        case MMI_SYNC_GETITEM:
            recode = HandlePbReadItem(cmd_dec, dec_len);
            break;

        default:
            recode = FALSE;
        }
        break;

    case MMI_SYNC_SMS:
        switch(operation_type) 
        {
        case MMI_SYNC_DELETE:
            recode = HandleSmsDelete(cmd_dec, dec_len);
            break;

        default:
            recode = FALSE;
			break;
        }
        break;

    case MMI_SYNC_RING:
        recode = FALSE;
        break;

    case MMI_SYNC_PICTURE:
        recode = FALSE;
        break;

    case MMI_SYNC_MEMO:
        switch(operation_type) 
        {
        case MMI_SYNC_GETINFO:
            recode = HandleMemoGetInfo(cmd_dec, dec_len);
            break;

        case MMI_SYNC_ADD:
            recode = HandleMemoAdd(cmd_dec, dec_len);
            break;        

        case MMI_SYNC_DELETE:
            recode = HandleMemoDelete(cmd_dec, dec_len);
            break;

        case MMI_SYNC_MODIFY:
            recode = HandleMemoModify(cmd_dec, dec_len);
            break;

        case MMI_SYNC_GETITEM:
            recode = HandleMemoReadItem(cmd_dec, dec_len);
            break;

        default:
            recode = FALSE;
        }
        break;        

    case MMI_SYNC_PBGROUP:
        switch(operation_type) 
        {
        case MMI_SYNC_GETINFO:
            recode = HandleGroupGetInfo(cmd_dec, dec_len);
            break;

        case MMI_SYNC_ADD:
            recode = HandleGroupAdd(cmd_dec, dec_len);
            break;        

        case MMI_SYNC_DELETE:
            recode = HandleGroupDelete(cmd_dec, dec_len);
            break;

        case MMI_SYNC_MODIFY:
            recode = HandleGroupModify(cmd_dec, dec_len);
            break;

        case MMI_SYNC_GETITEM:
            recode = HandleGroupReadItem(cmd_dec, dec_len);
            break;

        default:
            recode = FALSE;
        }
        break;

    default:
        recode = FALSE;
        break;
    }

	SCI_FREE(cmd_dec);

    return recode;
}

#define MMI_AUTO_TEST_MODULE_STR "+TESTMODULE:"
/*****************************************************************************/
// 	Description : handle auto test module
//	Global resource dependence : none
//  Author:      
//	Note:James.Zhang
/*****************************************************************************/
LOCAL BOOLEAN HandleAutoTestModule(
                                   uint8 *cmd,  // Point to the command infomation buffer
                                   uint32 len   // The length of command infomation buffer
                                   )
{
    BOOLEAN result = FALSE;
    uint32  str_len = strlen( MMI_AUTO_TEST_MODULE_STR );

    if ( len > str_len
        && 0 == strncmp( (const char*)cmd, (const char*)MMI_AUTO_TEST_MODULE_STR, str_len ) )
    {
        if ( MMK_IsFocusWin( MAIN_IDLE_WIN_ID ) )
        {
            uint32 module_len = len - str_len;
            char*  module_str = SCI_ALLOC_APP( module_len + 1 );

            strncpy( module_str, (const char*)(cmd + str_len), module_len );
            module_str[module_len] = 0;

            MMIAPICOM_OtherTaskToMMI(VIRTUAL_WIN_ID, MSG_MMI_AUTO_TEST_MODULE, (DPARAM)module_str, module_len + 1);
            
            SCI_FREE(module_str);

            result = TRUE;
        }
    }

    return result;
}

/*****************************************************************************/
// 	Description : This function parse at atuo test cmd
//	Global resource dependence : none
//  Author:      
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN ParseSyncUTAtCmd(
					      uint8 *cmd,  // Point to the command infomation buffer
					      uint32 len   // The length of command infomation buffer
					      )
{
    uint8 module_type = 0;
    uint8 operation_type = 0;
    BOOLEAN recode = TRUE;
    uint8   str_buf[MMI_MAX_INDICATE_LEN] = {0};
    uint8	*cmd_dec = NULL;
    uint16	dec_len = 0;
    BOOLEAN  is_on = FALSE;
#ifndef  FLASH_SUPPORT
    MMIMAINMENU_TYPE_E mainmenu_style = MMIMAINMENU_MATRIX_E;
#endif

    if ( HandleAutoTestModule( cmd, len ) )
    {
        return TRUE;
    }
    //monkey test setting
    if (HandleMonkeyTest((char*)cmd, len))
    {
        return TRUE;
    }

    //check length, must be have module type and operation type
    //sync_alarm have only module type
    if(len < 1)
    {
        return FALSE;
    }
    if(MMI_UT_CMD_INTERVAL_FLAG != *(cmd++))
    {
        //SCI_TRACE_LOW:"ParseSyncUTAtCmd, cmd[0] 0x%x"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11299_112_2_18_1_59_49_86,(uint8*)"d", cmd[0]);
        return FALSE;
    }
    len --;
    SCI_MEMSET(str_buf, 0x00, sizeof(str_buf));
    if(!GetATCNextString(cmd, len, str_buf, MMI_MAX_INDICATE_LEN))
    {
        //SCI_TRACE_LOW:"ParseSyncUTAtCmd, get module_type error"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11306_112_2_18_1_59_49_87,(uint8*)"");
        return FALSE;
    }
    dec_len = strlen((char*)str_buf);
    module_type = atoi((char*)str_buf);
    if(dec_len + 1 >= len)
    {
        //SCI_TRACE_LOW:"ParseSyncUTAtCmd, module_type strlen %d, cmd_len %d"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11313_112_2_18_1_59_49_88,(uint8*)"dd",strlen((char*)str_buf), len);
        return FALSE;
    }
    cmd = cmd + dec_len + 1; 
    len = len - dec_len - 1;
    SCI_MEMSET(str_buf, 0x00, sizeof(str_buf));
    if(!GetATCNextString(cmd, len, str_buf, MMI_MAX_INDICATE_LEN))
    {
        //SCI_TRACE_LOW:"ParseSyncUTAtCmd, Get operation_type error"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11321_112_2_18_1_59_49_89,(uint8*)"");
        return FALSE;
    }
    operation_type = atoi((char*)str_buf);
    dec_len = strlen((char*)str_buf);
    if(dec_len + 1 > len)
    {
        //SCI_TRACE_LOW:"ParseSyncUTAtCmd, operation_type strlen %d, cmd_len %d"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11328_112_2_18_1_59_49_90,(uint8*)"dd",strlen((char*)str_buf), len);
        return FALSE;
    }
    cmd = cmd + dec_len + 1; 
    len = len - dec_len - 1;
    //SCI_TRACE_LOW:"mmi_atc.c: ParseSyncAtCmd(), module_type = %c, operation_type = %c"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11333_112_2_18_1_59_49_91,(uint8*)"cc", module_type, operation_type);

    cmd_dec = (uint8*)SCI_ALLOC_APP(MAX(MAX_RESCMD_LEN, (len +1)));
    SCI_ASSERT(NULL != cmd_dec); /*assert verified*/
    SCI_MEMSET(cmd_dec, 0, MAX(MAX_RESCMD_LEN, (len +1)));
    //解压缩命令字符串
    dec_len = DecompressCmdStr(cmd, len, cmd_dec, MAX(MAX_RESCMD_LEN, (len +1)));

    switch(module_type)
    {
        case MMI_UT_SMS://SMS
            switch(operation_type) 
            {
                case MMI_AUTO_TEST_INPUT_STRING:
                    //send message
                    recode = HandleSmsSendMsg(cmd, dec_len);
                break;
                default:
                    recode = FALSE;
                break;
            }
        break;
        case MMI_UT_MMS://MMS
            switch(operation_type) 
            {
                case MMI_AUTO_TEST_INPUT_STRING:
                    //send message
                    recode = HandleMMSSendMsg(cmd, dec_len);
                break;
                default:
                    recode = FALSE;
            }
        break;
        case MMI_UT_WAP://WAP
            switch(operation_type) 
            {
                case MMI_AUTO_TEST_INPUT_STRING:
                    //send message
                    recode = HandleWWWInputURL(cmd, dec_len);
                break;
                default:
                    recode = FALSE;
                break;
            }
        break;
        case MMI_UT_CONNECTION://connection
            switch(operation_type) 
            {
                case MMI_AUTO_TEST_INPUT_STRING:
                    //send message
                    recode = HandleConnection(cmd, dec_len);
                break;
                default:
                    recode = FALSE;
                break;
            }
        break;
        case MMI_UT_CC://call control
            switch(operation_type) 
            {
                case MMI_AUTO_TEST_ACO_OFF:
                    //close auto answer call--on
                    //SCI_TRACE_LOW:"[baokun] MMI_AUTO_TEST_ACO_OFF"
                    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11395_112_2_18_1_59_49_92,(uint8*)"");
#ifdef ENG_SUPPORT
                    MMIAPIENG_SetAutoAnswerCallSet(FALSE);
#endif
                break;
                case MMI_AUTO_TEST_ACO_ON:
                    //open auto answer call--on
                    //SCI_TRACE_LOW:"[baokun] MMI_AUTO_TEST_ACO_ON"
                    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11402_112_2_18_1_59_49_93,(uint8*)"");
#ifdef ENG_SUPPORT
                    MMIAPIENG_SetAutoAnswerCallSet(TRUE);
#endif
                break;
                case MMI_AUTO_TEST_HEADSET_MODE_OFF:
                    //close vt默认为耳机模式 
                    //SCI_TRACE_LOW:"[baokun] MMI_AUTO_TEST_HEADSET_MODE_OFF"
                    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11409_112_2_18_1_59_49_94,(uint8*)"");
#ifdef VT_SUPPORT
                    MMIAPIVT_SetIsEPDefault(FALSE);
#endif
                break;	
                case MMI_AUTO_TEST_HEADSET_MODE_ON:
                    //open vt默认为耳机模式
                    //SCI_TRACE_LOW:"[baokun] MMI_AUTO_TEST_HEADSET_MODE_ON"
                    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11416_112_2_18_1_59_49_95,(uint8*)"");
#ifdef VT_SUPPORT
                    MMIAPIVT_SetIsEPDefault(TRUE);
#endif
                break;				
                default:
                    recode = FALSE;
                break;
            }		
        break;
#ifdef ENG_SUPPORT        
        case MMI_UT_USB://USB log
            switch(operation_type) 
            {
                case MMI_AUTO_TEST_OFF:
                    //usb log --close
                    is_on = FALSE;
                    //SCI_TRACE_LOW:"[baokun] MMI_AUTO_TEST_OFF is_on %d"
                    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11433_112_2_18_1_59_49_96,(uint8*)"d", is_on);
                    MMINV_WRITE(MMINV_ENG_USBLOG,&is_on);
                break;
                case MMI_AUTO_TEST_ON:
                    //usb log --open
                    is_on = TRUE;
                    //SCI_TRACE_LOW:"[baokun] MMI_AUTO_TEST_ON is_on %d"
                    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11439_112_2_18_1_59_49_97,(uint8*)"d", is_on);
                    MMINV_WRITE(MMINV_ENG_USBLOG,&is_on);
                break;
                default:
                    recode = FALSE;
                break;
            }
        break;
        /* +CR247389 */
        case MMI_UT_AUTOTEST_ALLSETTINGS: 
            switch(operation_type) 
            {
                case MMI_AUTO_TEST_OFF:
#ifdef MMI_AUTOTEST_SUPPORT
                    MMI_SetAllAtValue(FALSE);
#endif
                break;
                case MMI_AUTO_TEST_ON:
#ifdef MMI_AUTOTEST_SUPPORT
                    MMI_SetAllAtValue(TRUE);
#endif
                break;
                default:
                    recode = FALSE;
                break;
            }
        break;
        /* -CR247389 */
#endif        
        case MMI_UT_LCD_BRIGHTNESS://Lcd brightness
        {                
            MMISET_BACKLIGHT_SET_T  backlight_info={0};

            //SCI_TRACE_LOW:" AutoTest Lcd Brightness  MMI_AUTO_TEST_OFF is_on %d"
            SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11472_112_2_18_1_59_49_98,(uint8*)"d", operation_type);
            switch(operation_type) 
            {   
                case MMI_AUTO_TEST_BACKLIGHT_FOREVER_OFF:		
                    //is off,restore to factory setting
                    backlight_info.backlight_type = MMISET_EDEFAULT_BACKLIGHT_OPEN;
                    backlight_info.backlight_time = MMISET_EDEFAULT_BACKLIGHT_TIME;
                    MMIAPISET_SetBackLightInfo(backlight_info);	
                break;
                case MMI_AUTO_TEST_BACKLIGHT_FOREVER_ON:                 
                    //is on, set backlight open forever,turn on backlight  first
                    MMIDEFAULT_TurnOnBackLight();
                    backlight_info.backlight_type = MMISET_BACKLIGHT_OPEN_FOREVER;                        
                    MMIAPISET_SetBackLightInfo(backlight_info);	
                break;
                case MMI_AUTO_TEST_BACKLIGH_ON:
                    MMIDEFAULT_TurnOnBackLight();
                break;                    
                default:
                    recode = FALSE;
                break;
            }
        }
        break;
#ifndef  FLASH_SUPPORT
        case MMI_UT_MAINMENU://set MainMenu style
            switch(operation_type) 
            {
                case MMI_AUTO_TEST_SET_ICON_MENU:
                    mainmenu_style = MMIMAINMENU_MATRIX_E;
                break;
                case MMI_AUTO_TEST_SET_TITLE_ICON_MENU:
                    mainmenu_style = MMIMAINMENU_MATRIX_TITLE_E;
                break;
#ifndef PDA_UI_SUPPORT_MANIMENU_GO
                case MMI_AUTO_TEST_SET_LIDE_PAGE_MENU:
                    mainmenu_style = MMIMAINMENU_GO_SLIDE_E;
                break;
#endif
                default:
                    mainmenu_style = MMIMAINMENU_MATRIX_E;
                break;
            }
            MMIAPISET_SetMainmenuStyle((uint32)mainmenu_style);
            MMIAPIMENU_UpdateMainMenu();
        break;	
#endif
#ifdef PUSH_EMAIL_SUPPORT
        case MMI_UT_PUSH_MAIL://Push mail
            switch(operation_type) 
            {
                case MMI_AUTO_TEST_INPUT_STRING:
                    recode = HandlePushMailSendMsg(cmd, dec_len);
                break;
                default:
                    recode = FALSE;
                break;
            }
        break;
#endif /* PUSH_EMAIL_SUPPORT */

        default:
            recode = FALSE;
        break;
    }

    SCI_FREE(cmd_dec);

    return recode;
}

/*****************************************************************************/
// 	Description : This function handle the pb getinfo command
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandlePbGetInfo(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{
    PB_HEAD_INFO_T  pb_head_info = {0};
    uint8 *res_cmd = NULL;
    uint16 res_len = 0; 
    uint16 struct_len = 0;
    uint16 dest_len = 0;
    uint8  pos = 0;
    
    res_cmd = (uint8 *)SCI_ALLOC_APP(MAX_RESCMD_LEN);
    SCI_ASSERT(NULL != res_cmd); /*assert verified*/

    if(!GetPbStorage(&pos, *cmd))
    {
        return FALSE;
    }
    
    //SCI_TRACE_LOW:"mmi_atc.c: HandlePbGetInfo(), pos = %d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11570_112_2_18_1_59_50_99,(uint8*)"d", pos);
    
    SCI_MEMSET(&pb_head_info, 0, sizeof(PB_HEAD_INFO_T));
    SCI_MEMSET(res_cmd, 0, MAX_RESCMD_LEN);
    if(MMIPB_SyncHeadInfo(&pb_head_info, pos))
    {
        //SCI_TRACE_LOW:"mmi_atc.c: HandlePbGetInfo(), max_record_num = %d, used_record_num = %d"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11577_112_2_18_1_59_50_100,(uint8*)"dd",pb_head_info.max_record_num, pb_head_info.used_record_num);

        strcpy((char *)res_cmd, (char *)MMI_SYNC_INDICATE);
        res_len += strlen((char *)MMI_SYNC_INDICATE);

        struct_len = sizeof(PB_HEAD_INFO_T);
        MMIAPICOM_BinaryToHexChar((uint8 *)&struct_len, 2, res_cmd+res_len, &dest_len);
        res_len += dest_len;

        MMIAPICOM_BinaryToHexChar((uint8 *)&pb_head_info, sizeof(PB_HEAD_INFO_T), res_cmd+res_len, &dest_len);
        res_len += dest_len;

        dest_len = strlen((char*)MMI_TO_SYNC_OK_SYMBOL);
        MMI_MEMCPY(res_cmd + res_len, MAX_RESCMD_LEN - res_len, (char *)MMI_TO_SYNC_OK_SYMBOL, dest_len, dest_len);
        res_len += dest_len;

        ReturnResponse(res_cmd, res_len);
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }

    SCI_FREE(res_cmd);

    return TRUE;
}

/*****************************************************************************/
// 	Description : This function handle the pb get one item command
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandlePbReadItem(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{
    PB_PHONEBOOK_ENTRY_T  pb_item = {0};
    uint8  *res_cmd = NULL;
    uint16 res_len = 0;    
    uint16 entry_id = 0;
    uint16 struct_len = 0;
    uint16 dest_len = 0;
    uint8  pos = 0;
    
    res_cmd = (uint8 *)SCI_ALLOC_APP(MAX_RESCMD_LEN);
    SCI_ASSERT(NULL != res_cmd); /*assert verified*/

    if(!GetPbStorage(&pos, *cmd))
    {
        return FALSE;
    }

    cmd++;    
    entry_id = GetPbEntryId(cmd, (uint16)(len-1)) ;    
    //SCI_TRACE_LOW:"mmi_atc.c: HandlePbReadItem(), pos = %d, entry_id = %d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11632_112_2_18_1_59_50_101,(uint8*)"dd", pos, entry_id);

    SCI_MEMSET(&pb_item, 0, sizeof(PB_PHONEBOOK_ENTRY_T));
    SCI_MEMSET(res_cmd, 0, MAX_RESCMD_LEN);
    pb_item.entry_id = entry_id;
    if(MMIPB_SyncRead(&pb_item, pos))
    {
        //SCI_TRACE_LOW:"mmi_atc.c: HandlePbReadItem(), entry_id = %d"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11639_112_2_18_1_59_50_102,(uint8*)"d", pb_item.entry_id);

        strcpy((char *)res_cmd, (char *)MMI_SYNC_INDICATE);
        res_len += strlen((char *)MMI_SYNC_INDICATE);

        struct_len = sizeof(PB_PHONEBOOK_ENTRY_T);
        MMIAPICOM_BinaryToHexChar((uint8 *)&struct_len, 2, res_cmd+res_len, &dest_len);
        res_len += dest_len;

        MMIAPICOM_BinaryToHexChar((uint8 *)&pb_item, sizeof(PB_PHONEBOOK_ENTRY_T), res_cmd+res_len, &dest_len);
        res_len += dest_len;

        dest_len = strlen((char*)MMI_TO_SYNC_OK_SYMBOL);
        MMI_MEMCPY(res_cmd + res_len, MAX_RESCMD_LEN - res_len, (char *)MMI_TO_SYNC_OK_SYMBOL, dest_len, dest_len);
        res_len += dest_len;

        ReturnResponse(res_cmd, res_len);
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }

    SCI_FREE(res_cmd);

    return TRUE;
}

/*****************************************************************************/
// 	Description : This function handle the pb add command
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandlePbAdd(	
                            uint8 *cmd,  // Point to the command infomation buffer
					        uint32 len   // The length of command infomation buffer
                            )
{
    PB_PHONEBOOK_ENTRY_T *pb_entry_ptr = PNULL;
    uint8  pos = 0;
    uint16 pb_entry_size = 0;
	MMIPB_ERROR_E ret_code = 0;

    SCI_ASSERT(len >= 1+ sizeof(PB_PHONEBOOK_ENTRY_T)); /*assert verified*/
    
    pb_entry_ptr = (PB_PHONEBOOK_ENTRY_T *)SCI_ALLOC_APP(sizeof(PB_PHONEBOOK_ENTRY_T));
    if(pb_entry_ptr == PNULL)
    {
        return FALSE;
    }
    SCI_MEMSET(pb_entry_ptr, 0, sizeof(PB_PHONEBOOK_ENTRY_T));

    if(!GetPbStorage(&pos, *cmd))
    {
        return FALSE;
    }

    cmd++;
    //SCI_MEMCPY(&pb_entry, cmd, sizeof(PB_PHONEBOOK_ENTRY_T));
    pb_entry_size = sizeof(PB_PHONEBOOK_ENTRY_T);
    MMIAPICOM_HexCharToBinary(cmd, len-1, (uint8*)pb_entry_ptr, &pb_entry_size);
    SCI_ASSERT(pb_entry_size == sizeof(PB_PHONEBOOK_ENTRY_T)); /*assert verified*/
    //SCI_TRACE_LOW:"mmi_atc.c: HandlePbAdd(), pos = %d, entry_id = %d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11699_112_2_18_1_59_50_103,(uint8*)"dd", pos, pb_entry_ptr->entry_id);
    ret_code = MMIPB_SyncAdd(pos, pb_entry_ptr);
    if(MMIPB_ERROR_SUCCESS == ret_code)
    {
        //return "ok\r\n" to sync tool;
        ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_OK_SYMBOL));
    }
    else
    {
		if(MMIPB_ERROR_PENDING != ret_code)
		{
			ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
		}
    }
    SCI_FREE(pb_entry_ptr);
    return TRUE;
}

/*****************************************************************************/
// 	Description : This function handle the pb delete command
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandlePbDelete(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{
    uint16 entry_id = 0;
    uint8  pos = 0;
    MMIPB_ERROR_E del_ret = 0;

    SCI_ASSERT(len >= 1+ sizeof(uint16)); /*assert verified*/
    
    if(!GetPbStorage(&pos, *cmd))
    {
        return FALSE;
    }

    cmd++;
    entry_id = GetPbEntryId(cmd, (uint16)(len-1)) ;    
    //SCI_TRACE_LOW:"mmi_atc.c: HandlePbDelete(), pos = %d, entry_id = %d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11767_112_2_18_1_59_50_105,(uint8*)"dd",pos, entry_id);
    del_ret = MMIPB_SyncDelete(pos, entry_id);
    if(del_ret == MMIPB_ERROR_SUCCESS)
    {
        //return "ok\r\n" to sync tool;
        ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_OK_SYMBOL));
    }
    else
    {
		if(MMIPB_ERROR_PENDING != del_ret)
		{
			ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
		}
    }

    return TRUE;
}

/*****************************************************************************/
// 	Description : This function handle the pb modify command
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandlePbModify(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{
    PB_PHONEBOOK_ENTRY_T pb_entry = {0};
	MMIPB_ERROR_E error_code = 0;
    uint8  pos = 0;

    uint16 pb_entry_size = 0;

    SCI_ASSERT(len >= 1 + sizeof(PB_PHONEBOOK_ENTRY_T)); /*assert verified*/

    if(!GetPbStorage(&pos, *cmd))
    {
        return FALSE;
    }
    cmd++;
//    SCI_MEMCPY(&pb_entry, cmd, sizeof(PB_PHONEBOOK_ENTRY_T));
    pb_entry_size = sizeof(PB_PHONEBOOK_ENTRY_T);
    MMIAPICOM_HexCharToBinary(cmd, len-1,(uint8*)&pb_entry, &pb_entry_size);
    SCI_ASSERT(pb_entry_size == sizeof(PB_PHONEBOOK_ENTRY_T)); /*assert verified*/

    //SCI_TRACE_LOW:"mmi_atc.c: HandlePbModify(), pos = %d, entry_id = %d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11815_112_2_18_1_59_50_106,(uint8*)"dd", pos, pb_entry.entry_id);
    error_code = MMIPB_SyncModify(pos, &pb_entry);
	if(error_code != MMIPB_ERROR_PENDING)
	{
		if(error_code == MMIPB_ERROR_SUCCESS)
		{
			//return "ok\r\n" to sync tool;
			ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_OK_SYMBOL));
		}
		else
		{
			ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
		}
	}

    return TRUE;
}

/*****************************************************************************/
// 	Description : This function handle the sms deletecommand
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:   status(1 byte) + storage(1 byte) + record id(1 byte)
/*****************************************************************************/
LOCAL BOOLEAN HandleSmsDelete(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{
    MN_SMS_RECORD_ID_T record_id = 0;
    BOOLEAN is_mt_sms = FALSE;
    uint8	pos = 0;

	uint8 record_id_str[4]= {0};

    uint8 param[SMS_DELETE_PARAM_NUM] = {0};
    int32 i = 0;

    if(len != SMS_DELETE_PARAM_NUM + 3)
    {
        //SCI_TRACE_LOW:"mmi_atc.c:HandleSmsDelete(), length error, len = %d"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11882_112_2_18_1_59_50_108,(uint8*)"d", len);
        return FALSE;
    }

    for (i=0; i<SMS_DELETE_PARAM_NUM - 1; i++)
    {         
        param[i] = *(cmd++);  
        len--;      
    }

    strncpy((char*)record_id_str,(char*)cmd,4);
    //SCI_TRACE_LOW:"mmi_atc.c:HandleSmsDelete(), record_id_str = %s"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11893_112_2_18_1_59_50_109,(uint8*)"s", record_id_str);
    record_id= atoi((char*)record_id_str);

    if(SMS_SYNC_STATUS_MT == param[0])
    {
        is_mt_sms = TRUE;
    }
    else if(SMS_SYNC_STATUS_MO == param[0])
    {
        is_mt_sms = FALSE;
    }
    else
    {
		//SCI_TRACE_LOW:"mmi_atc.c:HandleSmsDelete(), SMS status error,  %s"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11906_112_2_18_1_59_50_110,(uint8*)"s", param[0]);
        return FALSE;
    }
    
    if(SMS_SYNC_POS_ME == param[1])
    {
        pos = SMS_SYNC_POS_ME;
    }
    else if(SMS_SYNC_POS_SIM_1 == param[1])
    {
        pos = SMS_SYNC_POS_SIM_1;
    }
	else if(SMS_SYNC_POS_SIM_2 == param[1])
	{
		pos = SMS_SYNC_POS_SIM_2;
	}
    else
    {
		//SCI_TRACE_LOW:"mmi_atc.c:HandleSmsDelete(), SMS storage error,  %d"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11924_112_2_18_1_59_50_111,(uint8*)"d", param[1]);
        return FALSE;
    }

    //record_id = param[2];

    //SCI_TRACE_LOW:"mmi_atc.c: HandleSmsDelete(), record_id = %d, is_mt_sms = %d, pos = %d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_11931_112_2_18_1_59_50_112,(uint8*)"ddd",record_id, is_mt_sms, pos);

    //call the SMS function       
    if(MMIAPISMS_DelSMSByAT(is_mt_sms, pos, record_id))
    {
        //return "ok\r\n" to sync tool;
        ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_OK_SYMBOL));
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }

    return TRUE;
}


/*****************************************************************************/
// 	Description : This function handle the group getinfo command
//	Global resource dependence : none
//  Author:      liqing.peng
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleGroupGetInfo(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{
    GROUP_HEAD_INFO_T   group_head_info = {0};
    uint8               *res_cmd = NULL;
    uint16              res_len = 0; 
    uint16              struct_len = 0;
    uint16              dest_len = 0;

    res_cmd = (uint8 *)SCI_ALLOC_APP(MAX_RESCMD_LEN);
    SCI_ASSERT(NULL != res_cmd); /*assert verified*/

    SCI_MEMSET(&group_head_info, 0, sizeof(GROUP_HEAD_INFO_T));
    SCI_MEMSET(res_cmd, 0, MAX_RESCMD_LEN);
    if(MMIPBGROUP_SyncHeadInfo(&group_head_info))
    {
        strcpy((char *)res_cmd, (char *)MMI_SYNC_INDICATE);
        res_len += strlen((char *)MMI_SYNC_INDICATE);

        struct_len = sizeof(GROUP_HEAD_INFO_T);
        MMIAPICOM_BinaryToHexChar((uint8 *)&struct_len, 2, res_cmd+res_len, &dest_len);
        res_len += dest_len;

        MMIAPICOM_BinaryToHexChar((uint8 *)&group_head_info, sizeof(GROUP_HEAD_INFO_T), res_cmd+res_len, &dest_len);
        res_len += dest_len;

        dest_len = strlen((char*)MMI_TO_SYNC_OK_SYMBOL);
        MMI_MEMCPY(res_cmd + res_len, MAX_RESCMD_LEN - res_len, (char *)MMI_TO_SYNC_OK_SYMBOL, dest_len, dest_len);
        res_len += dest_len;

        ReturnResponse(res_cmd, res_len);
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }

    SCI_FREE(res_cmd);

    return TRUE;
}

/*****************************************************************************/
// 	Description : This function handle the group get one item command
//	Global resource dependence : none
//  Author:      liqing.peng
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleGroupReadItem(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{
    uint16          entry_id = 0;
    GROUP_ENTRY_T   group_item_info = {0};
    uint8           *res_cmd = NULL;
    uint16          res_len = 0; 
    uint16          struct_len = 0;
    uint16          dest_len = 0;

    SCI_ASSERT(NULL != cmd); /*assert verified*/
    SCI_ASSERT(len >= PB_ENTRY_ID_MAX_LEN); /*assert verified*/

    res_cmd = (uint8 *)SCI_ALLOC_APP(MAX_RESCMD_LEN);
    SCI_ASSERT(NULL != res_cmd); /*assert verified*/

    entry_id = GetPbEntryId(cmd, (uint16)len);

    SCI_MEMSET(&group_item_info, 0, sizeof(GROUP_ENTRY_T));
    SCI_MEMSET(res_cmd, 0, MAX_RESCMD_LEN);
    if(MMIPBGROUP_SyncRead(entry_id, &group_item_info))
    {
        strcpy((char *)res_cmd, (char *)MMI_SYNC_INDICATE);
        res_len += strlen((char *)MMI_SYNC_INDICATE);

        struct_len = sizeof(GROUP_ENTRY_T);
        MMIAPICOM_BinaryToHexChar((uint8 *)&struct_len, 2, res_cmd+res_len, &dest_len);
        res_len += dest_len;

        MMIAPICOM_BinaryToHexChar((uint8 *)&group_item_info, sizeof(GROUP_ENTRY_T), res_cmd+res_len, &dest_len);
        res_len += dest_len;

        dest_len = strlen((char*)MMI_TO_SYNC_OK_SYMBOL);
        MMI_MEMCPY(res_cmd + res_len, MAX_RESCMD_LEN - res_len, (char *)MMI_TO_SYNC_OK_SYMBOL, dest_len, dest_len);
        res_len += dest_len;

        ReturnResponse(res_cmd, res_len);
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }

    SCI_FREE(res_cmd);

    return TRUE;
}


/*****************************************************************************/
// 	Description : This function handle the group add command
//	Global resource dependence : none
//  Author:      liqing.peng
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleGroupAdd(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{
    uint16          group_entry_size = 0;
    GROUP_ENTRY_T   group_entry = {0};

    SCI_ASSERT(NULL != cmd); /*assert verified*/
    SCI_ASSERT(len >= sizeof(GROUP_ENTRY_T)*2); /*assert verified*/

    SCI_MEMSET(&group_entry, 0, sizeof(GROUP_ENTRY_T));

    group_entry_size = sizeof(GROUP_ENTRY_T);
    MMIAPICOM_HexCharToBinary(cmd, len, (uint8*)&group_entry, &group_entry_size);
    SCI_ASSERT(group_entry_size == sizeof(GROUP_ENTRY_T)); /*assert verified*/
    if(MMIPBGROUP_SyncAdd(&group_entry))
    {
        //return "ok\r\n" to sync tool;
        ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_OK_SYMBOL));
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }

    return TRUE;
}


/*****************************************************************************/
// 	Description : This function handle the group delete command
//	Global resource dependence : none
//  Author:      liqing.peng
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleGroupDelete(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{
    uint16  entry_id = 0;

    SCI_ASSERT(NULL != cmd); /*assert verified*/
    SCI_ASSERT(len >= PB_ENTRY_ID_MAX_LEN); /*assert verified*/

    entry_id = GetPbEntryId(cmd, (uint16)len);
    if(MMIPBGROUP_SyncDelete(entry_id))
    {
        //return "ok\r\n" to sync tool;
        ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_OK_SYMBOL));
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }

    return TRUE;
}


/*****************************************************************************/
// 	Description : This function handle the group modify command
//	Global resource dependence : none
//  Author:      liqing.peng
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleGroupModify(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{
    uint16          group_entry_size = 0;
    GROUP_ENTRY_T   group_entry = {0};

    SCI_ASSERT(NULL != cmd); /*assert verified*/
    SCI_ASSERT(len >= sizeof(GROUP_ENTRY_T)*2); /*assert verified*/

    SCI_MEMSET(&group_entry, 0, sizeof(GROUP_ENTRY_T));

    group_entry_size = sizeof(GROUP_ENTRY_T);
    MMIAPICOM_HexCharToBinary(cmd, len, (uint8*)&group_entry, &group_entry_size);
    SCI_ASSERT(group_entry_size == sizeof(GROUP_ENTRY_T)); /*assert verified*/
    if(MMIPBGROUP_SyncModify(group_entry.entry_id, &group_entry))
    {
        //return "ok\r\n" to sync tool;
        ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_OK_SYMBOL));
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }

    return TRUE;
}


/*****************************************************************************/
// 	Description : This function handle the group getinfo command
//	Global resource dependence : none
//  Author:      liqing.peng
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleMemoGetInfo(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{
    MEMO_HEAD_INFO_T    memo_head_info = {0};
    uint8               *res_cmd = NULL;
    uint16              res_len = 0; 
    uint16              struct_len = 0;
    uint16              dest_len = 0;

    res_cmd = (uint8 *)SCI_ALLOC_APP(MAX_RESCMD_LEN);
    SCI_ASSERT(NULL != res_cmd); /*assert verified*/

    SCI_MEMSET(&memo_head_info, 0, sizeof(MEMO_HEAD_INFO_T));
    SCI_MEMSET(res_cmd, 0, MAX_RESCMD_LEN);
    if(MMIMEMO_SyncHeadInfo(&memo_head_info))
    {
        strcpy((char *)res_cmd, (char *)MMI_SYNC_INDICATE);
        res_len += strlen((char *)MMI_SYNC_INDICATE);

        struct_len = sizeof(MEMO_HEAD_INFO_T);
        MMIAPICOM_BinaryToHexChar((uint8 *)&struct_len, 2, res_cmd+res_len, &dest_len);
        res_len += dest_len;

        MMIAPICOM_BinaryToHexChar((uint8 *)&memo_head_info, sizeof(MEMO_HEAD_INFO_T), res_cmd+res_len, &dest_len);
        res_len += dest_len;

        dest_len = strlen((char*)MMI_TO_SYNC_OK_SYMBOL);
        MMI_MEMCPY(res_cmd + res_len, MAX_RESCMD_LEN - res_len, (char *)MMI_TO_SYNC_OK_SYMBOL, dest_len, dest_len);
        res_len += dest_len;

        ReturnResponse(res_cmd, res_len);
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }

    SCI_FREE(res_cmd);

    return TRUE;
}

/*****************************************************************************/
// 	Description : This function handle the group get one item command
//	Global resource dependence : none
//  Author:      liqing.peng
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleMemoReadItem(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{
    uint16          entry_id = 0;
    MEMO_ENTRY_T    memo_item_info = {0};
    uint8           *res_cmd = NULL;
    uint16          res_len = 0; 
    uint16          struct_len = 0;
    uint16          dest_len = 0;

    SCI_ASSERT(NULL != cmd); /*assert verified*/
    SCI_ASSERT(len >= PB_ENTRY_ID_MAX_LEN); /*assert verified*/

    res_cmd = (uint8 *)SCI_ALLOC_APP(MAX_RESCMD_LEN);
    SCI_ASSERT(NULL != res_cmd); /*assert verified*/

    entry_id = GetPbEntryId(cmd, (uint16)len);

    SCI_MEMSET(&memo_item_info, 0, sizeof(MEMO_ENTRY_T));
    SCI_MEMSET(res_cmd, 0, MAX_RESCMD_LEN);
    if(MMIMEMO_SyncRead(entry_id, &memo_item_info))
    {
        strcpy((char *)res_cmd, (char *)MMI_SYNC_INDICATE);
        res_len += strlen((char *)MMI_SYNC_INDICATE);

        struct_len = sizeof(MEMO_ENTRY_T);
        MMIAPICOM_BinaryToHexChar((uint8 *)&struct_len, 2, res_cmd+res_len, &dest_len);
        res_len += dest_len;

        MMIAPICOM_BinaryToHexChar((uint8 *)&memo_item_info, sizeof(MEMO_ENTRY_T), res_cmd+res_len, &dest_len);
        res_len += dest_len;

        dest_len = strlen((char*)MMI_TO_SYNC_OK_SYMBOL);
        MMI_MEMCPY(res_cmd + res_len, MAX_RESCMD_LEN - res_len, (char *)MMI_TO_SYNC_OK_SYMBOL, dest_len, dest_len);
        res_len += dest_len;

        ReturnResponse(res_cmd, res_len);
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }

    SCI_FREE(res_cmd);

    return TRUE;
}


/*****************************************************************************/
// 	Description : This function handle the group add command
//	Global resource dependence : none
//  Author:      liqing.peng
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleMemoAdd(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{
    uint16          memo_entry_size = 0;
    MEMO_ENTRY_T    memo_entry = {0};
    uint16          index = 0;
    uint8           *res_cmd = PNULL;
    uint16          res_len = 0; 
    uint16          dest_len = 0;

    SCI_ASSERT(NULL != cmd); /*assert verified*/
    SCI_ASSERT(len >= sizeof(MEMO_ENTRY_T)*2); /*assert verified*/

    res_cmd = (uint8 *)SCI_ALLOC_APP(MAX_RESCMD_LEN);
    SCI_ASSERT(NULL != res_cmd); /*assert verified*/
    SCI_MEMSET(res_cmd, 0, MAX_RESCMD_LEN);;

    SCI_MEMSET(&memo_entry, 0, sizeof(MEMO_ENTRY_T));

    memo_entry_size = sizeof(MEMO_ENTRY_T);
    MMIAPICOM_HexCharToBinary(cmd, len, (uint8*)&memo_entry, &memo_entry_size);
    SCI_ASSERT(memo_entry_size == sizeof(MEMO_ENTRY_T)); /*assert verified*/
    if(MMIMEMO_SyncAdd(&memo_entry, &index))
    {
        strcpy((char *)res_cmd, (char *)MMI_SYNC_INDICATE);
        res_len += strlen((char *)MMI_SYNC_INDICATE);

        MMIAPICOM_BinaryToHexChar((uint8 *)&index, 2, res_cmd+res_len, &dest_len);
        res_len += dest_len;

        dest_len = strlen((char*)MMI_TO_SYNC_OK_SYMBOL);
        MMI_MEMCPY((void*)(res_cmd + res_len), MAX_RESCMD_LEN - res_len, (void *)(MMI_TO_SYNC_OK_SYMBOL), 
            dest_len, dest_len);

        res_len += dest_len;

        ReturnResponse(res_cmd, res_len);
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }

    return TRUE;
}


/*****************************************************************************/
// 	Description : This function handle the group delete command
//	Global resource dependence : none
//  Author:      liqing.peng
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleMemoDelete(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{
    uint16  entry_id = 0;

    SCI_ASSERT(NULL != cmd); /*assert verified*/
    SCI_ASSERT(len >= PB_ENTRY_ID_MAX_LEN); /*assert verified*/

    entry_id = GetPbEntryId(cmd, (uint16)len);
    if(MMIMEMO_SyncDelete(entry_id))
    {
        //return "ok\r\n" to sync tool;
        ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_OK_SYMBOL));
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }

    return TRUE;
}


/*****************************************************************************/
// 	Description : This function handle the group modify command
//	Global resource dependence : none
//  Author:      liqing.peng
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN HandleMemoModify(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{
    uint16          memo_entry_size = 0;
    MEMO_ENTRY_T    memo_entry = {0};

    SCI_ASSERT(NULL != cmd); /*assert verified*/
    SCI_ASSERT(len >= sizeof(MEMO_ENTRY_T)*2); /*assert verified*/

    SCI_MEMSET(&memo_entry, 0, sizeof(MEMO_ENTRY_T));

    memo_entry_size = sizeof(MEMO_ENTRY_T);
    MMIAPICOM_HexCharToBinary(cmd, len, (uint8*)&memo_entry, &memo_entry_size);
    SCI_ASSERT(memo_entry_size == sizeof(MEMO_ENTRY_T)); /*assert verified*/
    if(MMIMEMO_SyncModify(memo_entry.entry_id, &memo_entry))
    {
        //return "ok\r\n" to sync tool;
        ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_OK_SYMBOL));
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }

    return TRUE;
}

/*****************************************************************************/
// 	Description : This function get string finished by finish_char
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
//LOCAL BOOLEAN GetString(
//                        uint8* dest_str_ptr, 
//                        uint32 max_len, 
//                        uint8* src_str_ptr, 
//                        uint32 src_str_len,
//                        uint8 finish_char
//                        )
//{
//    uint8* ptr = src_str_ptr;
//    uint32 i=0;
//
//    for(i=0; i<src_str_len; i++)
//    {
//        if(*(ptr++) == finish_char)
//        {
//            break;
//        }
//    }
//
//    if((ptr-1 - src_str_ptr > 0) && (ptr-1 - src_str_ptr <= max_len))
//    {
////        strncpy((char *)dest_str_ptr, (char *)src_str_ptr, ptr-1 - src_str_ptr);
//        MMI_MEMCPY(dest_str_ptr, max_len, src_str_ptr, src_str_len, ptr-1 - src_str_ptr);
//    }
//    else
//    {
//        return FALSE;
//    }    
//
//    return TRUE;
//}
//

/*****************************************************************************/
// 	Description : This function return response to at
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL void ReturnResponse(
                            uint8* res_ptr,
                            uint16 len
                            )
{
	uint8	*res_cmp = NULL;
	uint16	cmp_len = 0;

	res_cmp = (uint8*)SCI_ALLOC_APP(MAX_RESCMD_LEN);
	SCI_ASSERT(NULL != res_cmp); /*assert verified*/
	SCI_MEMSET(res_cmp, 0, MAX_RESCMD_LEN);

	SCI_TRACE_LOW("mmi_atc.c ReturnResponse before CompressCmdStr %s,%d",res_ptr,len);
	//压缩命令字符串
	cmp_len = CompressCmdStr(res_ptr, len, res_cmp);
	SCI_ASSERT(MAX_RESCMD_LEN > cmp_len); /*assert verified*/
#ifndef WIN32
	ATC_WriteCmdRsp(res_cmp, cmp_len);/*lint !e718 !e746*/
#endif
    //SIO_ATC_WriteCmdRes(res_cmp, cmp_len);
    SCI_TRACE_LOW("mmi_atc.c ReturnResponse after CompressCmdStr %s,%d",res_cmp,len);
	SCI_FREE(res_cmp);
}


/*****************************************************************************/
// 	Description : This function judge pb paramter
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL BOOLEAN GetPbStorage(
                     uint8 *pos, 
                     uint8 cmd_char
                     )
{
	if(NULL == pos)
	{
		//SCI_TRACE_LOW:"[MMIATC] GetPbStorage pos 0x%x"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_12442_112_2_18_1_59_51_113,(uint8*)"d", pos);
		return FALSE;
	}

	*pos = cmd_char;
    return TRUE;
}

/*****************************************************************************/
// 	Description : This function get pb entry id from cmd string
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL uint16 GetPbEntryId(uint8* cmd, uint16 len)
{
    uint8 id_str[PB_ENTRY_ID_MAX_LEN +1] = {0};
    
    SCI_ASSERT(len >= PB_ENTRY_ID_MAX_LEN); /*assert verified*/

    strncpy((char *)id_str,(char*)cmd, PB_ENTRY_ID_MAX_LEN);
    return atoi((char*)id_str);
}


/*****************************************************************************/
// 	Description : 行程压缩法
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL uint16 CompressCmdStr(
							  uint8 *cmd_in,	//cmd str, in
							  uint16 len,		//cmd str len
							  uint8	*cmd_out	//out
							  )
{
	int32	i = 0;
	int32	j = 0;
	uint16	out_len = 0;
	uint16	zero_num = 0;
	uint8	szValue[6] = {0};

	SCI_ASSERT(NULL != cmd_in); /*assert verified*/
	SCI_ASSERT(NULL != cmd_out); /*assert verified*/

	//压缩
	while(i<len)
	{
		if(i+5 < len 
			&& '0' == cmd_in[i] && '0' == cmd_in[i+1] && '0' == cmd_in[i+2]
			&& '0' == cmd_in[i+3] && '0' == cmd_in[i+4] && '0' == cmd_in[i+5])
		{
			//遇到连续6个0的字符串
			j = 0;
			while('0' == cmd_in[i+j])
			{
				j++;
			}
			zero_num = j;

			SCI_MEMSET(szValue, 0, sizeof(szValue));
			sprintf((char*)szValue, "%04x", zero_num);
			cmd_out[out_len] = 'x';
			cmd_out[out_len+1] = 'x';
			cmd_out[out_len+2] = szValue[0];
			cmd_out[out_len+3] = szValue[1];
			cmd_out[out_len+4] = szValue[2];
			cmd_out[out_len+5] = szValue[3];

			out_len += 6;

			i += zero_num;
		}
		else
		{
			cmd_out[out_len] = cmd_in[i];
			out_len++;
			i++;
		}
	}

	return out_len;
}

/*****************************************************************************/
// 	Description : 行程压缩法
//	Global resource dependence : none
//  Author:      lin.lin
//	Note:
/*****************************************************************************/
LOCAL uint16 DecompressCmdStr(
							  uint8 *cmd_in,	//cmd str, in
							  uint16 len,		//cmd str len
							  uint8	*cmd_out,	//out
							  uint16 out_buf_max_len//IN:
							  )
{
	int32	i = 0;
	uint16	out_len = 0;
	uint16	zero_num = 0;

	SCI_ASSERT(NULL != cmd_in); /*assert verified*/
	SCI_ASSERT(NULL != cmd_out); /*assert verified*/

	//解压缩
	while(i<len)
	{
		if(i+5 < len && 'x' == cmd_in[i] && 'x' == cmd_in[i+1])
		{
			//遇到以'xx'开始的字符串,且长度等于6
			zero_num = MMIAPICOM_HexCharToByte(cmd_in[i+2]);
			zero_num = zero_num*16 + MMIAPICOM_HexCharToByte(cmd_in[i+3]);
			zero_num = zero_num*16 + MMIAPICOM_HexCharToByte(cmd_in[i+4]);
			zero_num = zero_num*16 + MMIAPICOM_HexCharToByte(cmd_in[i+5]);
            if(out_len + zero_num < out_buf_max_len)
			{
				SCI_MEMSET((cmd_out+out_len), '0', zero_num);	
				out_len += zero_num;
				
				i += 6;
			}
			else
			{
				//SCI_TRACE_LOW:"[MMIATC] DecompressCmdStr out_len %d"
				SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_12560_112_2_18_1_59_52_114,(uint8*)"d", out_len + zero_num);
				break;
			}
		}
		else
		{
			if(out_len + 1 < out_buf_max_len)
			{
				cmd_out[out_len] = cmd_in[i];
				out_len++;
				i++;
			}
			else
			{
				//SCI_TRACE_LOW:"[MMIATC] DecompressCmdStr out_len %d"
				SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_12574_112_2_18_1_59_52_115,(uint8*)"d", out_len + 1);
			}
		}
	}

	return out_len;
}

/*****************************************************************************/
// 	Description : send sms message
//	Global resource dependence : none
//  Author:     
//	Note:   codeformat(1 byte) + message string
/*****************************************************************************/
LOCAL BOOLEAN HandleSmsSendMsg(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{

    uint32  text_format = MMI_UT_UTF8;
    uint32  offset = 0;
    // int32 i = 0;
	wchar  *wstr_msg_ptr = PNULL;
	BOOLEAN result = FALSE;
	uint8   str_buf[MMI_MAX_INDICATE_LEN] = {0};

	if(len > 0)
	{
		//get string format type
		if(GetATCNextString(cmd, len, str_buf, MMI_MAX_INDICATE_LEN))
		{
			text_format = (uint32)atoi((char*)str_buf);
			offset = strlen((char*)str_buf) + 1;
		}
		if(offset < len)
		{
			len = len - offset;
			cmd = cmd + offset;
		}
		else
		{
			len = 0;
		}
	}

	if(len > 0)
	{
		wstr_msg_ptr = (wchar *)GetATCParameter(text_format, cmd, len, 0);
		if(wstr_msg_ptr != PNULL)
		{
			//call sms insert message function
			result = MMIAPISMS_InsertMessage(wstr_msg_ptr, MMIAPICOM_Wstrlen(wstr_msg_ptr));
			//SCI_TRACE_LOW:"[MMIATC] HandleSmsSendMsg wstr_msg_ptr %x  %x"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_12625_112_2_18_1_59_52_116,(uint8*)"dd",wstr_msg_ptr[0],wstr_msg_ptr[1]);
			SCI_FREE(wstr_msg_ptr);
		}
	}

    //call the SMS function       
    if(result)
    {
        //return "ok\r\n" to sync tool;
        ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_OK_SYMBOL));
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }

    return TRUE;
}
#ifdef PUSH_EMAIL_SUPPORT
/*****************************************************************************/
// 	Description : send Input string  message
//	Global resource dependence : none
//  Author: Jiaoyou.wu
//	Note:   codeformat(1 byte) + message string
/*****************************************************************************/
LOCAL BOOLEAN HandlePushMailSendMsg(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{

    uint32  text_format = MMI_UT_UTF8;
    uint32  offset = 0;
    wchar  *wstr_msg_ptr = PNULL;
    BOOLEAN result = FALSE;
    uint8   str_buf[MMI_MAX_INDICATE_LEN] = {0};

	if(len > 0)
	{
		//get string format type
		if(GetATCNextString(cmd, len, str_buf, MMI_MAX_INDICATE_LEN))
		{
			text_format = atoi((char*)str_buf);
			offset = strlen((char*)str_buf) + 1;
		}
		if(offset < len)
		{
			len = len - offset;
			cmd = cmd + offset;
		}
		else
		{
			len = 0;
		}
	}

	if(len > 0)
	{
		wstr_msg_ptr = (wchar *)GetATCParameter(text_format, cmd, len, 0);
		if(wstr_msg_ptr != PNULL)
		{
                //call pushmail insert message function
                result = MMIAPIMAIL_InsertMessage(wstr_msg_ptr, MMIAPICOM_Wstrlen(wstr_msg_ptr));
                //SCI_TRACE_LOW:"[MMIATC] HandleSmsSendMsg wstr_msg_ptr %x  %x"
                SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_12686_112_2_18_1_59_52_117,(uint8*)"dd",wstr_msg_ptr[0],wstr_msg_ptr[1]);
                SCI_FREE(wstr_msg_ptr);
		}
	}

    if(result)
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_OK_SYMBOL));
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }

    return TRUE;
}
#endif

/*****************************************************************************/
// 	Description : send sms message
//	Global resource dependence : none
//  Author:     
//	Note:   codeformat(1 byte) + message string
/*****************************************************************************/
LOCAL BOOLEAN HandleMMSSendMsg(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{

    uint32  text_format = MMI_UT_UTF8;
    uint32  offset = 0;
    // int32 i = 0;
	wchar  *wstr_msg_ptr = PNULL;
	uint8   str_buf[MMI_MAX_INDICATE_LEN] = {0};
	BOOLEAN result = FALSE;

	if(len > 0)
	{
		//get string format type
		if(GetATCNextString(cmd, len, str_buf, MMI_MAX_INDICATE_LEN))
		{
			text_format = (uint32)atoi((char*)str_buf);
			offset = strlen((char*)str_buf) + 1;
		}
		if(offset < len)
		{
			len = len - offset;
			cmd = cmd + offset;
		}
		else
		{
			len = 0;
		}
	}

	if(len > 0)
	{
		wstr_msg_ptr = (wchar *)GetATCParameter(text_format, cmd, len, 0);
		if(wstr_msg_ptr != PNULL)
		{
			//call sms insert message function
#ifdef MMS_SUPPORT			
			result = MMIAPIMMS_InsertMessage(wstr_msg_ptr, MMIAPICOM_Wstrlen(wstr_msg_ptr));
#endif			
			//SCI_TRACE_LOW:"[MMIATC] MMIAPIMMS_InsertMessage wstr_msg_ptr %x  %x"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_12749_112_2_18_1_59_52_118,(uint8*)"dd",wstr_msg_ptr[0],wstr_msg_ptr[1]);
			SCI_FREE(wstr_msg_ptr);
		}
	}

    //call the SMS function   
#ifdef MMS_SUPPORT	    
    if(result)
    {
        //return "ok\r\n" to sync tool;
        ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_OK_SYMBOL));
    }
    else
#endif
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }

    return result;
}

/*****************************************************************************/
// 	Description : send sms message
//	Global resource dependence : none
//  Author:     
//	Note:   codeformat(1 byte) + message string
/*****************************************************************************/
LOCAL BOOLEAN HandleWWWInputURL(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{
    // int32 i = 0;
#ifdef BROWSER_SUPPORT_NETFRONT
	BOOLEAN result = FALSE;
	uint32  offset = 0;
	uint8   str_buf[MMI_MAX_INDICATE_LEN] = {0};
	uint32  text_format = MMI_UT_UTF8;
	wchar  *wstr_msg_ptr = PNULL;
	if(len > 0)
	{
		//get string format type
		if(GetATCNextString(cmd, len, str_buf, MMI_MAX_INDICATE_LEN))
		{
			text_format = atoi((char*)str_buf);
			offset = strlen((char*)str_buf) + 1;
		}
		if(offset < len)
		{
			len = len - offset;
			cmd = cmd + offset;
		}
		else
		{
			len = 0;
		}
	}

	if(len > 0)
	{
		wstr_msg_ptr = (wchar *)GetATCParameter(text_format, cmd, len, 0);
		if(wstr_msg_ptr != PNULL)
		{
			//call sms insert message function
			result = MMIAPIWWW_InsertURL(wstr_msg_ptr, MMIAPICOM_Wstrlen(wstr_msg_ptr));
			//SCI_TRACE_LOW:"[MMIATC] MMIAPIWWW_InsertURL wstr_msg_ptr %x  %x"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_12812_112_2_18_1_59_52_119,(uint8*)"dd",wstr_msg_ptr[0],wstr_msg_ptr[1]);
			SCI_FREE(wstr_msg_ptr);
		}
	}

    //call the SMS function       
    if(result)
    {
        //return "ok\r\n" to sync tool;
        ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_OK_SYMBOL));
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }
#endif
    return TRUE;
}

/*****************************************************************************/
// 	Description : connection setting
//	Global resource dependence : none
//  Author:     
//	Note:   codeformat(1 byte) + message string
/*****************************************************************************/
LOCAL BOOLEAN HandleConnection(	
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 len   // The length of command infomation buffer
                                )
{

    uint32  text_format = MMI_UT_UTF8;
    uint32  offset = 0;
    // int32 i = 0;
	wchar  *wstr_msg_ptr = PNULL;
	uint8   str_buf[MMI_MAX_INDICATE_LEN] = {0};
	BOOLEAN result = FALSE;
	if(len > 0)
	{
		//get string format type
		if(GetATCNextString(cmd, len, str_buf, MMI_MAX_INDICATE_LEN))
		{
			text_format = (uint32)atoi((char*)str_buf);
			offset = strlen((char*)str_buf) + 1;
		}
		if(offset < len)
		{
			len = len - offset;
			cmd = cmd + offset;
		}
		else
		{
			len = 0;
		}
	}

	if(len > 0)
	{
		wstr_msg_ptr = (wchar *)GetATCParameter(text_format, cmd, len, 0);
		if(wstr_msg_ptr != PNULL)
		{
			//call sms insert message function
			result = MMIAPICONNECTION_InsertStr(wstr_msg_ptr, MMIAPICOM_Wstrlen(wstr_msg_ptr));
			//SCI_TRACE_LOW:"[MMIATC] MIAPICONNECTION_InsertStr wstr_msg_ptr %x  %x"
			SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_12873_112_2_18_1_59_52_120,(uint8*)"dd",wstr_msg_ptr[0],wstr_msg_ptr[1]);
			SCI_FREE(wstr_msg_ptr);
		}
	}

    //call the SMS function       
    if(result)
    {
        //return "ok\r\n" to sync tool;
        ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_OK_SYMBOL));
    }
    else
    {
        ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
    }
    return TRUE;
}


/*****************************************************************************/
// 	Description : send string or struct from cmd
//	Global resource dependence : none
//  Author:     
//	Note:   
/*****************************************************************************/
LOCAL void* GetATCParameter(uint32 text_format,
                                uint8 *cmd,  // Point to the command infomation buffer
					            uint32 cmd_len,   // The length of command infomation buffer
								uint32 struct_size//if text_format is MMI_ATC_STRUCT, this size must be input
                                )
{
	void   *paramter_ptr = PNULL;
	uint16 binary_val_len = 0;
    uint8  *binary_val_ptr = PNULL;
	if(PNULL == cmd)
	{
		//SCI_TRACE_LOW:"[MMIATC] GetATCParameter cmd == PNULL !"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_12907_112_2_18_1_59_52_121,(uint8*)"");
		return PNULL;
	}

    //SCI_TRACE_LOW:"[MMIATC] GetATCParameter cmd %x  %x  %x  %x  %x  %x  %x  %x  %x"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_12912_112_2_18_1_59_52_122,(uint8*)"ddddddddd",cmd[0],cmd[1],cmd[2],cmd[3],cmd[4],cmd[5],cmd[6],cmd[7],cmd[8]);
	binary_val_ptr = (void *)SCI_ALLOC_APP(cmd_len +1);
	if(binary_val_ptr == PNULL)
	{
		return PNULL;
	}
	SCI_MEMSET(binary_val_ptr, 0x00, (cmd_len +1 ));
   
	MMIAPICOM_HexCharToBinary(cmd, cmd_len, (uint8*)binary_val_ptr, &binary_val_len);
	
	switch(text_format)
	{
	case MMI_UT_UTF8:
		paramter_ptr = (wchar *)SCI_ALLOC_APP((binary_val_len +1 )*sizeof(wchar));
		SCI_MEMSET(paramter_ptr, 0x00, ((binary_val_len +1 )*sizeof(wchar)));
		GUI_UTF8ToWstr((wchar *)paramter_ptr, binary_val_len, (uint8 *)binary_val_ptr, binary_val_len);
		break;
	case MMI_UT_UNICODE:
        paramter_ptr = (wchar *)SCI_ALLOC_APP((binary_val_len +1 )*sizeof(wchar));
		SCI_MEMSET(paramter_ptr, 0x00, ((binary_val_len +1 )*sizeof(wchar)));
		SCI_MEMCPY(paramter_ptr, binary_val_ptr, binary_val_len);
		break;
	case MMI_UT_GB2312:
        paramter_ptr = (wchar *)SCI_ALLOC_APP((binary_val_len +1 )*sizeof(wchar));
		SCI_MEMSET(paramter_ptr, 0x00, ((binary_val_len +1 )*sizeof(wchar)));
		GUI_GBToWstr(paramter_ptr, binary_val_ptr, binary_val_len);
		break;
	case MMI_UT_STRUCT:
		if(struct_size > 0)
		{
			paramter_ptr = SCI_ALLOC_APP(struct_size);
			SCI_MEMSET(paramter_ptr, 0x00, struct_size);
			SCI_MEMCPY(paramter_ptr, binary_val_ptr, binary_val_len);
		}
		break;

    default:
        break;
	}
    SCI_FREE(binary_val_ptr);
	return paramter_ptr;
}

/*****************************************************************************/
// 	Description : send string or struct from cmd
//	Global resource dependence : none
//  Author:     
//	Note:   
/*****************************************************************************/
LOCAL BOOLEAN GetATCNextString( uint8 *cmd,  // Point to the command infomation buffer
					            uint32 cmd_len,   // The length of command infomation buffer
								uint8 *next_str_ptr,//OUT
								uint8 next_str_max_len//IN
                                )
{

    BOOLEAN result = FALSE;
    uint32  i = 0;
    uint32  min_len = 0;

    if(PNULL == cmd 
        || (PNULL == next_str_ptr) 
        || 0 == cmd_len 
        || 0 ==next_str_max_len 
    )
    {
        //parameter error
        //SCI_TRACE_LOW:"[MMIATC] GetATCNextString parameter error !"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_12977_112_2_18_1_59_52_123,(uint8*)"");
        return FALSE;
    }

    min_len = (uint32)MIN(cmd_len,next_str_max_len);

    for(i = 0; i < min_len; i++) /*lint !e737*/
    {
        if(MMI_UT_CMD_INTERVAL_FLAG == cmd[i])
        {
            result = TRUE;
            break;
        }
        else
        {
            next_str_ptr[i] = cmd[i];
        }
    }
    //SCI_TRACE_LOW:"[MMIATC] GetATCNextString string %s result %d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMI_ATC_12995_112_2_18_1_59_52_124,(uint8*)"sd", next_str_ptr, result);
    return result;

}
#endif //#ifdef MMI_SYNCTOOL_SUPPORT

#if defined(MMI_SYNCTOOL_SUPPORT) || defined(MMI_SYNCTOOL_V3)
/*****************************************************************************/
// 	Description : response to atc cmd
//	Global resource dependence : none
//  Author:     
//	Note:   
/*****************************************************************************/
PUBLIC void MMIAPIATC_Response(BOOLEAN result)
{
	if(result)
	{
		//return "ok\r\n" to sync tool;
		ReturnResponse((uint8 *)MMI_TO_SYNC_OK_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_OK_SYMBOL));
	}
	else
	{
		ReturnResponse((uint8 *)MMI_TO_SYNC_ERROR_SYMBOL, (uint16)strlen((char*)MMI_TO_SYNC_ERROR_SYMBOL));
	}
}
#endif

