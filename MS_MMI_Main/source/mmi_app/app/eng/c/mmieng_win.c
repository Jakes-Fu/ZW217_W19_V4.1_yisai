/*****************************************************************************
** File Name:      mmieng_win.c                                              *
** Author:                                                                   *
** Date:           09/2004                                                   *
** Copyright:      2003 Spreadtrum, Incorporated. All Rights Reserved.         *
** Description:    This file is used to describe call log                    *
******************************************************************************
**                         Important Edit History                            *
** --------------------------------------------------------------------------*
** DATE           NAME             DESCRIPTION                               *
** 9/2004         Allen

******************************************************************************/


#define _MMIENG_WIN_C_

/**--------------------------------------------------------------------------*
                                Include Files      
 **--------------------------------------------------------------------------*/
//this line must be at the fisrt line of include sentences now
#include "mmi_app_eng_trc.h"
#ifdef WIN32
#include "std_header.h"
//#include "mmieng_Dynamic_main.h"
#endif
#include "mmk_app.h"
#include "mmk_type.h"
#include "mmk_timer.h"
#include "mmipub.h"
#include "window_parse.h"

#include "guilabel.h"

//#include "mmieng.h"
#include "mmieng_internal.h"
#include "mmieng_win.h"
#include "mmieng_uitestwin.h"
#include "mmieng_id.h"
#include "mmieng_text.h"

#ifdef ENG_SUPPORT
#include "mmi_image.h"
#include "mmi_text.h"
#include "guilcd.h"
#include "guicommon.h"
#include "guitext.h"

#include "guifont.h"
#include "tb_dal.h"
#include "mn_api.h"
#include "mmi_common.h"
#include "mmi_nv.h"
#include "mmi_default.h"
#include "guiprgbox.h"
#ifndef WIN32
#include "adc_parameter.h"
#endif
//#include "mmiset.h"
#include "mmiset_export.h"
#include "production_test.h"
#include "guilistbox.h"
#include "mn_type.h"
//#include "efs.h"
#include "mmi_textfun.h"
#include "layer1_engineering.h"
#include "mmieng_main.h"
#include "mmi_nv.h"
#include "mmieng_menutable.h"
//#include "mmimp3_image.h"
#include "mmi_appmsg.h"
//#include "sig_code.h"
//#include "mmiset_call.h"
#include "mmiset_call_export.h"
//#include "mmiset_wintab.h"
//#include "mmiset_text.h"
#include "mmiset_func.h"
#include "mmisd_export.h"
//#include "version.h"

#include "flash.h"
#include "mmifm_export.h"
#include "mn_api.h"
#include "mmidc_export.h"
#include "mmidc_camera_text.h"
#include "mmicc_export.h"
#include "mmiudisk_export.h"

/*[START] Jerry Liang for ENG MODE powersweep 2008/08/07*/
//#include "mmiphone_export.h" //modify by mary
/*[END] Jerry Liang for ENG MODE powersweep 2008/08/07*/
#include "mmieng_nv.h"
#include "mmidc_setting.h"
#include "mmidc_export.h"
#include "dal_dcamera.h"

#ifdef VIDEO_PLAYER_SUPPORT
#include "mmivp_export.h"
#endif


#include "ref_param.h"

#include "mmifmm_export.h"
//#include "guires.h"
#include "mmimp3_export.h"
#include "mmisrvaud_api.h"
#ifdef KURO_SUPPORT
#include "mmikur.h"
#endif
#include "guiedit.h"
#include "guiim_base.h"
#ifdef PCLINK_SUPPORT
#include "app_tcp_if.h"
#endif

#ifdef BROWSER_SUPPORT
#include "mmibrowser_export.h"
#endif

#ifdef CMMB_SUPPORT
#include "mtv_api.h"
#include "mbbms_service.h"
#include "mmimtv_main.h"
#include "mtv_setting.h"
#endif
#include "tcpip_api.h"
#include "app_tcp_if.h"
#include "guistring.h"
#include "block_mem.h"
#include "sfs.h"
#include "mmieng_text.h"
#include "mmiconnection_export.h"
//#include "mmiset_display.h"

#ifdef MBBMS_SUPPORT
#include "mmimbbms_main.h"
#endif
#include "mmisms_export.h"
#ifndef _WIN32
#ifdef ENGTD_SUPPORT
#include "layer1_engineering.h"
#endif
#endif
#include "mmidm_export.h"
#ifdef JAVA_SUPPORT
#include "mmijava_export.h"
#endif

#ifdef MMI_WIFI_SUPPORT
#include "wifisupp_api.h"
#endif

#include "mmi_appmsg.h"
#include "mmidisplay_data.h"
#include "guiform.h"
#include "guictrl_api.h"

#ifdef _WIN32
#define __packed
#endif

#include "admm_III.h"
#include "prod_param.h" 

#include "mmi_modu_main.h"
//#include "nvitem.h"
#include "power.h"
#include "tp_export.h"    
#include "audio_config.h"
#include "audio_api.h"
#ifdef MMI_AUTOTEST_SUPPORT
#include "mmi_autotest.h"
#endif

#include "guisetlist.h"

#ifdef TF_LOAD_SUPPORT
#include "tf_load.h"
#include "chg_drv.h"
#include "tf_cfg.h"
#include "mmi_appmsg.h"
#include "mmiacc_id.h"
#include "version.h"
#endif

//#ifdef MMI_DUAL_BATTERY_SUPPORT
#include "dualbat_drvapi.h"
//#endif
#ifdef DSP_USB_LOG
#include "dsp_log.h"      //xuefang.jiang 20110729
#endif

#ifdef WRE_SUPPORT
#include "mmiwre_export.h"
#endif
#ifdef MMISRV_AUDIO_TEST_SUPPORT
#include "mmisrvaud_test.h"
#endif
#include "nvitem.h"

#include "mmimultim_text.h"
#ifdef MMI_RECORD_SUPPORT
#include "mmirecord_export.h"
#endif


#ifdef BLUETOOTH_SUPPORT
#ifndef WIN32
//#include "bt_ps_version.h"
#endif
#include "bt_abs.h"
#endif
#include "mmiphone_export.h"

#include "guidropdownlist.h"
#ifdef MMI_WIFI_SUPPORT
#ifndef WIN32
#include "wifi_api.h"
#endif
#endif
#if defined (PLATFORM_ANTISW3)
#ifndef WIN32
#include "ulog.h"
#endif
#endif
#ifndef WIN32
#include "lcm_cfg.h"
#endif
#include "watch_commonwin_export.h"
#include "mmicom_trace.h"
#include "guirichtext.h"
#include "mmipdp_export.h"

#ifdef DAPS_IPERF_SUPPORT
#include "daps_iperf_api.h"
#endif
#include "ual_bt.h"
#ifndef WIN32
#ifdef GOODIX_SUPPORT_GR5515
#include "production_line.h"
#include "uart_data_process.h"
#include "goodix_export.h"
#include "sensor.h"
#include "ucom_main.h"
#endif
#endif

#ifdef BBM_ROLE_SUPPORT
#include "bbm_export.h"
#endif
#include "mn_api.h"

#ifdef DATA_ROAMING_SUPPORT
#include "mmiconnection_text.h"
#endif
#include "mmipb_search.h"

#include "os_api.h"
#include "guires.h"

#include "mmieng_export.h"
#include "mmisms_set.h"
#include "mmipb_app.h"
#include "mmipb_search.h"

#include "watch_cc_view.h"
#include "ual_tele_data.h"
/**--------------------------------------------------------------------------*
                                     MACRO DEFINITION
 **--------------------------------------------------------------------------*/
#define MMIENG_WAIT_MSG         "Please wait..."
#define MMIENG_WAIT_MSG_LEN     14
#define MMIENG_THRESHOLD_LEN    10
#define MMIENG_AFC_MAX_VALUE     65535   //1023
#define MMIENG_PA_MAX_VALUE     65535

#define MMIENG_PROMPT_TIMEOUT   2000
#define ENG_WAPUA_MAX_LEN       512 

#define MMIENG_ADDR_INFO_MAX_LEN       64
#define MMIENG_RF_TIME                 1000

#define MMIENG_CMMB_CHANNEL_INFO_MAX_LEN    64

#define MMIENG_AUDIO_SET_VOLMAX  36

#define MMIENG_AUDIO_VOL_MAX 9
//add for mp3 audio gain setting
#define MMIENG_MP3_AUDIO_VOL_MAX 15
#define MMIENG_AUDIO_GAIN_LEVEL_MAX 35
// add str len
#define MMIENG_SHOW_STR_MAX_LEN   (128)

#ifdef PCLINK_SUPPORT
#define     MMIENG_PCLINK_MAX_IP_LEN            15          //ip,DNS,subnet mas,and 网关地址的最大长度
#define     MMIENG_PCLINK_PINGTEST_TIMER_OUT        5000    //pc link ping test等待超时的时间，5s
#endif

#define ADC_CALIBRATE_INFO_ITEM 32

#define MMIMTV_INPUT_PAGE_RANGE               20


#define MMIENG_IQ_DATA_SIZE  (50*1024)
#define ENG_IQ_TEST_BUF_SIZE  (50 * 1024)

#define MMIENG_USER_AGENT_MTK "MAUI WAP Browser"
#define MMIENG_USER_AGENT_09A "SonyEricssonK700c/R2AE SEMC-Browser/4.0.3 Profile/MIDP-2.0 Configuration/CLDC-1.1"
#define MMIENG_USER_AGENT_DORADO "Dorado WAP-Browser/1.0.0"
#define MMIENG_USER_AGENT_NOKIA "NokiaN95/1.0 (15.1.002) SymbianOS/9.2 Series60/3.1 Profile/MIDP-2.0 Configuration/CLDC-1.1"
#define MMIENG_USER_AGENT_NF "HS-N51/1.0 Release/10.25.2009 Browser/NF3.5 Profile/MIDP-2.0 Config/CLDC-1.1"

#define MMIENG_UA_PROFILE_NOKIA "http://nds1.nds.nokia.com/uaprof/NN95-5r100.xml"
#define MMIENG_UA_PROFILE_SONYERICSSION "http://wap.sonyericsson.com/UAprof/K700cR201.xml"

#define MMIENG_GPRS_TEST_BUTTON_HEIGHT (32)

#define BT_ROLE_MAX_ITEM (3)
#define BT_VISIBILITY_MAX_ITEM (4)
#ifdef SCREEN_SHAPE_CIRCULAR
#define MMIENG_PB_LIST_MAX_NUM (8)
#else
#define MMIENG_PB_LIST_MAX_NUM (6)
#endif
#define MMIENG_FLOWRATE_BUFFER_LENGTH (21)
#define MMIENG_FLOWRATE_TEXT_LEN      100

typedef enum
{
    MMIENG_RF_CELL_C0 = 0,
    MMIENG_RF_CELL_N0,
    MMIENG_RF_CELL_N1,
    MMIENG_RF_CELL_N2,
    MMIENG_RF_CELL_N3,
    MMIENG_RF_CELL_N4,
    MMIENG_RF_CELL_N5,
    MMIENG_RF_CELL_ALL,
    MMIENG_RF_CELL_MAX
} MMIENG_RF_CELL_E;
typedef enum
{
    MMIENG_DC_PREVIEW = 0,
    MMIENG_DC_CAPTURE,
    MMIENG_DC_REVIEW,

    MMIENG_DC_STATE_MAX
} MMIENG_DC_STATE_E;

typedef struct
{
    int32 BCH;
    int32 BRXL;
    int32 BSIC;
    int32 DSC;
    int32 TN;
    int32 TXLEV;
    int32 RLT;
    int32 TAV;
    int32 CBA;
    int32 CBQ;
    int32 C1;
    int32 C2;    
    int32 LAC;
    int32 CELID;
    int32 ALIG;
    int32 FFSET;
} MMIENG_RF_CELL_INFO_T;

typedef struct
{
    uint8  sec;  
    uint8  min;
    uint16  hour;
} MMIENG_TIME_T;

/*! \brief EditBox and IM data interface */
//typedef struct 
//{
//    GUIEDIT_CTRL_T*       editbox_ptr;
//    const uint16*               add_string;         /*!< [IN]  the string to add editbox when the type is EDITBOX_ADD_CHAR, must be 0-terminate string */
//    uint16                    add_num;            /*!< [IN]  the length of adding char availably when the type is EDITBOX_ADD_CHAR */
//  uint16                      del_num;            //[IN]  type为EDITBOX_DEL_CHAR时有效
//    uint16                    move_left_num;      /*!< [IN]  The number for move left availably when the type istype is EDITBOX_MOVE_LEFT(move continually，cursor move to end from begining ) */
//    uint16                    move_right_num;     /*!< [IN]  The number for move right availably when the type istype is EDITBOX_MOVE_LEFT */
//    uint16                    up_new_pos;         /*!< [OUT] The cursor position avalably when the type istype*/
//    uint16                    down_new_pos;       /*!< [OUT] The cursor position avalably when the type istype为EDITBOX_MOVE_DOWN */
//    uint16                    first_index;        /*!< [IN]  The shadow char begining position avalably when the type is EDITBOX_ENTER_SHADE */
//    uint16                    last_index;         /*!< [IN]  The shadow char end position avalably when the type is  EDITBOX_ENTER_SHADE */
//
//    GUI_RECT_T          rect;         //[OUT] type为EDITBOX_MODIFY_RECT时有效, 控件显示区域，不能利用控件指针直接调整区域，因为控件本身可能有多个区域需要更新
//    BOOLEAN             is_fullscreen;  //[OUT] type为EDITBOX_FULLSCREEN_MODE时有效
//    GUIEDIT_TYPE_E        cur_input_type; //[OUT] type为EDITBOX_SET_INPUTTYPE时有效
//    uint32              cur_input;      //[OUT] type为EDITBOX_SET_INPUT时有效
//    BOOLEAN             is_move_left;   //[IN]  type为EDITBOX_MOVE_DEPTH时有效
//    uint16              move_depth;     //[OUT] type为EDITBOX_MOVE_DEPTH时有效
//} EDITBOX_INPUT_INTERFACE_T;

typedef struct
{
    //double digital_gain;
    //double pga_gain;
    //double pga2_gain;
    float total_gain;
    uint32 hex_value;
    //int16  eng_value;
}MMIENG_AUDIO_MP3_GAIN_T;

#ifdef TF_LOAD_SUPPORT
typedef struct
{
    uint8   *file_addr;  
    uint32  file_len;
} MMIENG_TF_T;


typedef enum
{
    MMIENG_ALL_EXIST=0,
    MMIENG_PAC_NO_EXITS=1,
    MMIENG_FILE_NO_EXITS=2,
    MMIENG_DIR_NO_EXITS=4,
    MMIENG_PAC_ERROR=8,
    MMIENG_FILE_ERROR=16,    
    MMIENG_FILE_INFO_MAX
} MMIENG_TF_FILE_E;

typedef unsigned short WCHAR;

/*.pac file  structure*/
typedef struct _BIN_PACKET_HEADER_T
{
    WCHAR szVersion[24];        // packet struct version
    DWORD  dwSize;              // the whole packet size;
    WCHAR szPrdName[256];       // product name
    WCHAR szPrdVersion[256];   // product version
    int    	    nFileCount;          // the number of files that will be downloaded, the file may be an operation
    DWORD  dwFileOffset;        // the offset from the packet file header to the array of FILE_T struct buffer
    DWORD  dwMode;
    DWORD  dwFlashType;
    DWORD  dwNandStrategy;
    DWORD  dwIsNvBackup;
    DWORD  dwNandPageType;
    WCHAR   szPrdAlias[100];    // product alias
    DWORD  dwOmaDmProductFlag;
    DWORD  dwIsOmaDM;
    DWORD  dwIsPreload;
    DWORD  dwReserved[202];
}BIN_PACKET_HEADER_T,*PBIN_PACKET_HEADER_T;

#ifdef CHIP_ENDIAN_LITTLE
#define TF_WORDSWAP(x)					x
#define TF_DWORDSWAP(x)				x
#else
#define TF_WORDSWAP(x)    		        ((((x)<<8)&0xff00)|(((x)>>8)&0x00ff))
#define TF_DWORDSWAP(x)   	   		 	((((x)<<24)&0xff000000L)|(((x)<<8)&0x00ff0000L)|(((x)>>8)&0x0000ff00L)|(((x)>>24)&0x000000ffL))
#endif
#endif

/**--------------------------------------------------------------------------*
                                     STATIC DEFINITION
 **--------------------------------------------------------------------------*/
extern const MMI_UITEST_DISPLAY_T mmi_uitest_display;
static uint8 s_mmieng_show3result_timer_id = 0;
LOCAL int16 *s_volValue = PNULL;
uint32 g_dual_sys = 0;

LOCAL int16 s_vol_array[MMIENG_MP3_AUDIO_VOL_MAX]={0}; //代替MMIENG_AUDIO_VOL_MAX的9级，以配合正常的15级音量

//LOCAL AUDMOD_DEVMOD_T s_mode_param={0}; //for 217 ram cutdown
//LOCAL AUDIO_NV_ARM_MODE_INFO_T s_arm_audiomode_param={0}; //for 217 ram cutdown

// show net info timer
static uint8 s_mmieng_netinfo_timer_id = 0;
#define PSCELLWIN_LIST_MAX_NUM  10
LOCAL uint16 s_cell_num = 0; 
LOCAL int16 s_cell_arfcn[MN_MAX_NCELL_NUM]; // Neighbour cells measurement report 

static uint8 s_mmieng_up_down_link = 0; // 0 -- uplink  1 -- downlink
static AUDIO_DEVICE_MODE_TYPE_E s_mmieng_audio_dev_mode = AUDIO_DEVICE_MODE_HANDHOLD;/*lint !e551*/
//static int16 s_mmieng_contrast_value = 0;


static int16 s_mmieng_brightness_value = 0;
static int16 s_mmieng_save_brightness_value = 95;

static BOOLEAN s_mmieng_afc_inited = FALSE;
static BOOLEAN s_mmieng_pa_inited = FALSE;
static BOOLEAN s_mmieng_agc_inited = FALSE;
static BOOLEAN s_mmieng_errrate_inited = FALSE;

// PLMN info
//static MN_PHONE_FPLMN_LIST_T s_mmieng_fplmn = {0}; //for 217 ram cutdown

//#ifdef PCLINK_SUPPORT
//static BOOLEAN s_is_pclink_ping_start = FALSE;
//#endif

LOCAL BOOLEAN s_mtv_dsp_iq_test = FALSE;
LOCAL MMIFILE_HANDLE s_mtv_iq_fh = PNULL;
LOCAL uint32   s_iqdata_save_len = 0;

uint32*  s_mmieng_sim_select_table_ptr =PNULL;
#if defined (PLATFORM_UWS6121E)
LOCAL MN_DUAL_SYS_E g_dual_sys_eng_win = 0;
#endif

#ifndef _WIN32
#ifndef MMI_MULTI_SIM_SYS_SINGLE
#ifndef MMI_DUALMODE_ENABLE
extern void RRA_GetRraMonItem(RRA_MONITOR_ITEM_T *item_ptr);  //pizer.fan temp-modify
#endif
#endif
//extern MN_RETURN_RESULT_E MNENG_GetCellBasicInfo (MN_ENG_CELL_BASIC_INFO_T *cell_basic_info);
extern MN_RETURN_RESULT_E MNENG_GetSCellTrafInfo (MN_ENG_SCELL_TRAF_INFO_T *scell_traf_info);
//extern MN_RETURN_RESULT_E MNENG_GetSCellCtrlInfo (MN_ENG_SCELL_CTRL_INFO_T *scell_ctrl_info);
//extern MN_RETURN_RESULT_E MNENG_GetCellIdleInfo (
//                            MN_ENG_CELL_IDLE_INFO_T *cell_idle_info
//                            );
#endif                            
// #ifndef WIN32                             
// extern int32 EFS_ReadPhaseCheck(uint8 *buffer,uint16  buffer_length) ;
// #endif

//extern char   *Cms_Browser_GetVersion( void );
//extern char    *Cms_MMS_Get_Version(void);
#ifndef _WIN32
#ifdef IM_ENGINE_CSTAR
extern const char* CS_IMM_GetVersion(void);
#endif
#endif
#ifdef PCLINK_SUPPORT
extern BOOLEAN TCPIPPCLINK_ResetNetInterface( void );
extern BOOLEAN TCPIPPCLINK_SetNetInterface( void );
#endif
#if 0
extern void MMIBRW_SetUAProfile(uint8 *ua_profile_ptr, uint16 ua_profile_length);
extern void MMIBRW_SetUA(uint8 *ua_ptr, uint16 ua_length);
#endif
#ifdef CMMB_SUPPORT
LOCAL uint8 s_cmmb_timer = 0;
LOCAL CMMB_CHANNEL_INFO_T s_config_channel_info = {0};
#ifdef MBBMS_SUPPORT
LOCAL BOOLEAN s_mbbms_interface_test_enable = FALSE;
//LOCAL BOOLEAN s_mbbms_gba_test_enable = FALSE;
#ifdef DEMOD_HW_SIANO
LOCAL BOOLEAN s_mbbms_log_control_enable = FALSE;
#endif
//LOCAL BOOLEAN s_mbbms_msk_test_enable = FALSE;
LOCAL BOOLEAN s_mbbms_smd_counter_enable = FALSE;
#endif
LOCAL BOOLEAN s_mbbms_audio_enable = FALSE;
#endif

LOCAL const wchar s_saved_wstr[] = {  'S', 'a', 'v', 'e', 'd', 0 };
LOCAL const wchar s_fail_saved_wstr[] = {  'F', 'a', 'i', 'l', ' ' ,'s', 'a', 'v', 'e', 'd', 0 };
LOCAL const wchar s_fail_to_wstr[] = {  'F', 'a', 'i', 'l', ' ' ,'t', 'o', 0 };
LOCAL const wchar s_get_production_wstr[] = {  'g', 'e', 't', ' ', 'p' ,'r', 'o', 'd', 'u', 'c', 't', 'i', 'o', 'n' ,0 };
LOCAL const wchar s_set_wstr[] = {  'S', 'e', 't', 0 };
LOCAL const wchar s_audio_param_wstr[] = {  'a', 'u', 'd', 'i', 'o', ' ', 'p', 'a', 'r', 'a', 'm', 0 };
LOCAL const wchar s_success_wstr[] = {  's', 'u', 'c', 'c', 'e', 's', 's' , 0 };
LOCAL const wchar s_fail_wstr[] = {  'f', 'a', 'i', 'l', 0 };
LOCAL const wchar s_long_press_wstr[] = {  'l', 'o', 'n', 'g', ' ', 'p', 'r', 'e', 's', 's', 0 };
LOCAL const wchar s_red_key_will_wstr[] = {  'r', 'e', 'd', ' ', 'k', 'e', 'y', ' ', 'w', 'i', 'l', 'l', 0 };
LOCAL const wchar s_power_off_wstr[] = {  'p', 'o', 'w', 'e', 'r', ' ', 'o', 'f', 'f', 0 };
LOCAL const wchar s_do_nothing_wstr[] = {  'd', 'o', ' ', 'n', 'o', 't', 'h', 'i', 'n', 'g', 0 };
LOCAL const wchar s_space_wstr[] = { ' ', ' ',  0 };
LOCAL const wchar s_bch_wstr[] = { 'B', 'C', 'H', 0 };
LOCAL const wchar s_brxl_wstr[] = { 'B', 'R', 'X', 'L',  0 };
LOCAL const wchar s_c0_wstr[] = { 'C', '0', 0 };
LOCAL const wchar s_c1_wstr[] = { 'C', '1', 0 };
LOCAL const wchar s_c2_wstr[] = { 'C', '2', 0 };
LOCAL const wchar s_n0_wstr[] = { 'N', '0', 0 };
LOCAL const wchar s_n1_wstr[] = { 'N', '1', 0 };
LOCAL const wchar s_n2_wstr[] = { 'N', '2', 0 };
LOCAL const wchar s_n3_wstr[] = { 'N', '3', 0 };
LOCAL const wchar s_n4_wstr[] = { 'N', '4', 0 };
LOCAL const wchar s_n5_wstr[] = { 'N', '5', 0 };
LOCAL const wchar s_bsic_wstr[] = { 'B', 'S', 'I', 'C',  0 };
LOCAL const wchar s_dsc_wstr[] = { 'D', 'S', 'C',  0 };
LOCAL const wchar s_txlev_wstr[] = { 'T', 'X', 'L', 'E', 'V', 0 };
LOCAL const wchar s_tn_wstr[] = { 'T', 'N', 0 };
LOCAL const wchar s_rlt_wstr[] = { 'R', 'L', 'T', 0 };
LOCAL const wchar s_tav_wstr[] = { 'T', 'A', 'V', 0 };
LOCAL const wchar s_cba_wstr[] = { 'C', 'B', 'A', 0 };
LOCAL const wchar s_cbq_wstr[] = { 'C', 'B', 'Q', 0 };
LOCAL const wchar s_info_wstr[] = { 'I', 'N', 'F', 'O', 0 };
LOCAL const wchar s_celid_wstr[] = { 'C', 'E', 'L', 'I', 'D', 0 };
LOCAL const wchar s_alig_wstr[] = { 'A', 'L', 'I', 'G', 0 };
LOCAL const wchar s_lac_wstr[] = { 'L', 'A', 'C', 0 };
LOCAL const wchar s_ffset_wstr[] = { 'F', 'F', 'S', 'E', 'T', 0 };
LOCAL MMI_TEXT_ID_T s_vol_table[]={
TXT_ENG_AUDIO_VOLUME1,
TXT_ENG_AUDIO_VOLUME2,
TXT_ENG_AUDIO_VOLUME3,
TXT_ENG_AUDIO_VOLUME4,
TXT_ENG_AUDIO_VOLUME5,
TXT_ENG_AUDIO_VOLUME6,
TXT_ENG_AUDIO_VOLUME7,
TXT_ENG_AUDIO_VOLUME8,
TXT_ENG_AUDIO_VOLUME9,
TXT_ENG_AUDIO_VOLUME10,
TXT_ENG_AUDIO_VOLUME11,
TXT_ENG_AUDIO_VOLUME12,
TXT_ENG_AUDIO_VOLUME13,
TXT_ENG_AUDIO_VOLUME14,
TXT_ENG_AUDIO_VOLUME15
};
LOCAL MMIENG_AUDIO_MP3_GAIN_T *s_mp3_gain_array=PNULL;

LOCAL MMIENG_AUDIO_MP3_GAIN_T s_mp3_handsfree[MMIENG_AUDIO_GAIN_LEVEL_MAX] = 
{
{-48.14,    0x3c0001},    //1},
{-46.56,    0x3a0001},    //2},
{-45.08,    0x380001},    //3},
{-43.59,    0x360001},    //4},
{-42.12,    0x340001},    //5},
{-40.54,    0x320001},    //6},
{-39.06,    0x300001},    //7},
{-37.57,    0x2e0001},    //8},
{-36.1 ,    0x2c0001},    //9},
{-34.52,    0x2a0001},    //10},
{-33.04,    0x280001},    //11},
{-31.55,    0x260001},    //12},
{-30.08,    0x240001},    //13},
{-28.5 ,    0x220001},    //14},
{-27.02,    0x200001},    //15},
{-25.53,    0x1e0001},    //16},
{-24.06,    0x1c0001},    //17},
{-22.48,    0x1a0001},    //18},
{-21   ,    0x180001},    //19},
{-19.48,    0x1a0002},    //20},
{-18   ,    0x180002},    //21},
{-16.48,    0x1a0003},    //22},
{-15   ,    0x180003},    //23},
{-13.48,    0x1a0004},    //24},
{-12   ,    0x180004},    //25},
{-10.48,    0x1a0005},    //26},
{-9    ,    0x180005},    //27},
{-7.48 ,    0x1a0006},    //28},
{-6    ,    0x180006},    //29},
{-4.48 ,    0x1a0007},    //30},
{-3    ,    0x180007},    //31},
{-1.48 ,    0x1a0008},    //32},
{ 0    ,    0x180008},    //33},
{ 1.52 ,    0x1a0009},    //34},
{ 3    ,    0x180009}    //35}
};

LOCAL MMIENG_AUDIO_MP3_GAIN_T s_mp3_headset[MMIENG_AUDIO_GAIN_LEVEL_MAX] = 
{
{-51.14,    0x3c0004},    //1},
{-49.56,    0x3a0004},    //2},
{-48.08,    0x380004},    //3},
{-46.59,    0x360004},    //4},
{-45.12,    0x340004},    //5},
{-43.54,    0x320004},    //6},
{-42.06,    0x300004},    //7},
{-40.57,    0x2e0004},    //8},
{-39.1 ,    0x2c0004},    //9},
{-37.52,    0x2a0004},    //10},
{-36.04,    0x280004},    //11},
{-34.55,    0x260004},    //12},
{-33.08,    0x240004},    //13},
{-31.5 ,    0x220004},    //14},
{-30.02,    0x200004},    //15},
{-28.53,    0x1e0004},    //16},
{-27.06,    0x1c0004},    //17},
{-25.48,    0x1a0004},    //18},
{-24   ,    0x180004},    //19},
{-22.48,    0x1a0005},    //20},
{-21   ,    0x180005},    //21},
{-19.48,    0x1a0006},    //22},
{-18   ,    0x180006},    //23},
{-16.48,    0x1a0007},    //24},
{-15   ,    0x180007},    //25},
{-13.48,    0x1a0008},    //26},
{-12   ,    0x180008},    //27},
{-10.48,    0x1a0009},    //28},
{-9    ,    0x180009},    //29},
{ -7.48,    0x1a000a},    //30},
{ -6   ,    0x18000a},    //31},
{ -4.48,    0x1a000b},    //32},
{ -3   ,    0x18000b},    //33},
{ -1.48,    0x1a000c},    //34},
{  0   ,    0x18000c}    //35}
};

LOCAL MMIENG_AUDIO_MP3_GAIN_T s_mp3_headfree[MMIENG_AUDIO_GAIN_LEVEL_MAX] = 
//Total gain,    Hex Value,    Value in Engineering mode
{
{-48.14,    0x3c0041},    //1},
{-46.56,    0x3a0041},    //2},
{-45.08,    0x380041},    //3},
{-43.59,    0x360041},    //4},
{-42.12,    0x340041},    //5},
{-40.54,    0x320041},    //6},
{-39.06,    0x300041},    //7},
{-37.57,    0x2e0041},    //8},
{-36.1 ,    0x2c0041},    //9},
{-34.52,    0x2a0041},    //10},
{-33.04,    0x280041},    //11},
{-31.55,    0x260041},    //12},
{-30.08,    0x240041},    //13},
{-28.5 ,    0x220041},    //14},
{-27.02,    0x200041},    //15},
{-25.53,    0x1e0041},    //16},
{-24.06,    0x1c0041},    //17},
{-22.48,    0x1a0041},    //18},
{-21   ,    0x180041},    //19},
{-19.48,    0x1a0052},    //20},
{-18   ,    0x180052},    //21},
{-16.48,    0x1a0063},    //22},
{-15   ,    0x180063},    //23},
{-13.48,    0x1a0074},    //24},
{-12   ,    0x180074},    //25},
{-10.48,    0x1a0085},    //26},
{-9    ,    0x180085},    //27},
{-7.48 ,    0x1a0096},    //28},
{-6    ,    0x180096},    //29},
{-4.48 ,    0x1a00a7},    //30},
{-3    ,    0x1800a7},    //31},
{-1.48 ,    0x1a00b8},    //32},
{ 0    ,    0x1800b8},    //33},
{ 1.52 ,    0x1a00c9},    //34},
{ 3    ,    0x1800c9}    //35}
};

#ifdef TF_LOAD_SUPPORT
MMIENG_TF_T s_tf_load;
extern const char*  const s_version_info[];

#define TF_UPGRADING_VBAT_MIN  3700  //about 3.7v
wchar g_device_sdcard[2][2]   = {{ 'E', 0 }, { 'F', 0 }};
wchar *g_valid_sdcard = NULL;
//#define MMIFILE_DEVICE_SDCARD               (g_device_sdcard)//"\x00\x45\x00\x00"
#define MMIFILE_DEVICE_SDCARD_LEN           1 //unicode number
#define MMIFILE_PARSE_SIZE                  4096
BOOLEAN slot_exist[2] = {FALSE, FALSE};
#endif
#define OTA_UPGRADING_VBAT_MIN  3700  //about 3.7v

/**--------------------------------------------------------------------------*
                                     TYPE AND CONSTANT
 **--------------------------------------------------------------------------*/
static MMI_STRING_T s_mmieng_show3result_text1 = {0};
static MMI_STRING_T s_mmieng_show3result_text2 = {0};
static MMI_STRING_T s_mmieng_show3result_text3 = {0};
#ifdef WIN32
typedef enum{
  ULOG_AP,
  ULOG_MODEM,
  ULOG_WCN,
}ULOG_LOG_E;
#endif

#ifdef  PLATFORM_ANTISW3
LOCAL ULOG_LOG_E s_log_option = ULOG_AP;
#endif
LOCAL const MMI_TEXT_ID_T s_mmieng_sel_band_txt_tab[] = 
{
    TXT_ENG_BAND_PCS,
    TXT_ENG_BAND_GSM,
    TXT_ENG_BAND_DCS,
    TXT_ENG_BAND_DUL,
    TXT_ENG_BAND_QUAD
};

#if 0//def WIN32
#ifndef ENGTD_SUPPORT
#define MAX_TD_NCELL_REPORT_NUM 32

typedef struct
{
    uint16  arfcn;
    uint8   cell_id;
    int8    rscp;
}LAYER1_TD_NCELL_T;

typedef struct
{
   LAYER1_TD_NCELL_T td_ncell[MAX_TD_NCELL_REPORT_NUM];
}LAYER1_TD_NCELL_ARR_T;

#endif
#endif
#define MMIENG_FM_TEST_PARAM_MAX_LEN           8

/**--------------------------------------------------------------------------*
                                     LOCAL FUNCTION DECLARE
 **--------------------------------------------------------------------------*/
#if defined (WIN32) || defined (PLATFORM_UWS6121E)
typedef struct
{ 
uint8 item_name[255];
uint32 arr_count;
uint32 arr_value[50];
uint32 min_value;
uint32 max_value;
}ITEM_T;

void ble_test_mode_set_cur_state(uint32 cur_state)
{}
uint32 ble_test_mode_get_cur_state(void)
{return 0;}
void ble_test_mode_start(void)
{}
void em_get_2g_serv_cell_info(int32 a,ITEM_T *b, uint32 c )
{}
uint32 em_get_2g_serv_cell_info_count(void)
{return 0;}
void em_get_3g_cqi_tb_size_info(int32 a,ITEM_T *b, uint32 c )
{}
uint32 em_get_3g_cqi_tb_size_count(void)
{return 0;}
void em_get_4g_cqi_tb_size_info(int32 a,ITEM_T *b, uint32 c )
{}
uint32 em_get_4g_cqi_tb_size_count(void)
{return 0;}
void em_get_4g_serv_cell_info(int32 card_id, ITEM_T *item_ptr, uint32 index)
{}
uint32 em_get_4g_serv_cell_info_count(void)
{return 0;}
BOOLEAN em_get_amr_wb_from_network(void)
{return FALSE;}
void em_get_aoc_nv_param(uint8 *aoc_enable)
{}
void em_get_armlog_dynamic_saveinUdisk(int32 card_id, ITEM_T *item_ptr, uint32 index)
{}
uint32 em_get_armlog_dynamic_saveinUdisk_count(void)
{return 0;}
void em_get_cell_handover_stat(int32 card_id, ITEM_T *item_ptr, uint32 index)
{}
uint32 em_get_cell_handover_stat_count(void)
{return 0;}
void em_get_cell_resel_num(int32 multi_sys, ITEM_T *item_ptr, uint32 index)
{}
uint32 em_get_cell_resel_stat_count(void)
{return 0;}
void em_get_cell_resel_stat(int32 multi_sys, ITEM_T *item_ptr, uint32 index)
{}
uint32 em_get_cell_search_stat_count(void)
{return 0;}
void em_get_drop_network_stat(int32 card_id, ITEM_T *item_ptr, uint32 index)
{}
uint32 em_get_drop_network_stat_count(void)
{return 0;}
void em_get_edge_enable(int32 card_id, ITEM_T *item_ptr, uint32 index)
{}
uint32 em_get_edge_enable_count(void)
{return 0;}
BOOLEAN em_get_fdd_rf_band(uint band, uint8 *status)
{return FALSE;}
uint32 em_get_generic_nv_count(void)
{return 0;}
void em_get_generic_nv_info(int32 card_id, ITEM_T *item_ptr, uint32 index)
{}
void em_get_gmm_rej_info(int32 card_id, ITEM_T *item_ptr, uint32 index)
{}
uint32 em_get_gmm_rej_info_count(void)
{return 0;}
void em_get_gsm_monitor_item(int32 card_id, ITEM_T *item_ptr, uint32 index)
{}
uint32 em_get_gsm_monitor_item_count(void)
{return 0;}
void em_get_hsdpa_hsupa_enable(int32 card_id, ITEM_T *item_ptr, uint32 index)
{}
void em_get_4g_inter_neig_cell_info(int32 card_id, ITEM_T *item_ptr, uint32 index)
{}
uint32 em_get_4g_inter_neig_cell_info_count(void)
{return 0;}
void em_get_2g_intra_3g_neig_cell_info(int32 card_id, ITEM_T *item_ptr, uint32 index)
{}
void em_get_2g_inter_neig_cell_info(int32 card_id, ITEM_T *item_ptr, uint32 index)
{}
void em_get_sys_capa_support_info(int32 card_id, ITEM_T *item_ptr, uint32 index)
{}
void em_get_4g_intra_3g_neig_cell_info(int32 card_id, ITEM_T *item_ptr, uint32 index)
{}
void em_get_4g_intra_2g_neig_cell_info(int32 card_id, ITEM_T *item_ptr, uint32 index)
{}
void em_get_3g_intra_4g_neig_cell_info(int32 card_id, ITEM_T *item_ptr, uint32 index)
{}
void em_get_3g_intra_2g_neig_cell_info(int32 card_id, ITEM_T *item_ptr, uint32 index)
{}
void em_get_2g_intra_4g_neig_cell_info(int32 card_id, ITEM_T *item_ptr, uint32 index)
{}
uint32 em_get_2g_intra_4g_neig_cell_info_count(void)
{return 0;}
uint32 em_get_2g_intra_3g_neig_cell_info_count(void)
{return 0;}
void em_get_2g_3g_4g_time(int32 card_id, ITEM_T *item_ptr, uint32 index)
{}
void RRENG_Delay_CSFB_Enable(uint8 type)
{}
void RRENG_Delay_CSFB_Disable(uint8 type)
{}
MN_GMMREG_RAT_E MNPHONE_GetCurrentRATEx(MN_DUAL_SYS_E dual_sys)
{return 0;}
#endif
/********************************************************************************
 NAME:          EngCardLogWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        bin.ji
 DATE:          
********************************************************************************/
LOCAL MMI_RESULT_E EngCardLogWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngAutoAnswerCallWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL MMI_RESULT_E EngProductSNWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngShow3ResultWinHandleMsgNoAutoClose(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL MMI_RESULT_E EngShow3ResultWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL MMI_RESULT_E EngShowHelpWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL int GetSCNetInfoStr(uint8* net_buf, uint16 buf_len);

LOCAL int GetNCNetInfoStr(uint8* net_buf, uint16 buf_len);

LOCAL int32 EngGetNetInfo(char *buf, int32 buf_length);

LOCAL MMI_RESULT_E EngShowNetWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngPSCellWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngPSCellOptionMenuWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL int GetPhoneInfoStr(uint8* phone_buf, uint32 buf_len);

LOCAL MMI_RESULT_E EngShowPhoneWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL MMI_RESULT_E EngAssertTargetWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL uint32 AppendForbidPLMNItem(MMI_CTRL_ID_T list_id);

//LOCAL MMI_RESULT_E HandlePLMNPromptWindow(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL MMI_RESULT_E EngForbidPLMNWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL MMI_RESULT_E EngNetLostWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL int GetTCVInfoStr(uint8* tcv_buf, uint8 buf_len);

LOCAL MMI_RESULT_E EngTCVWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
#if 0
LOCAL MMI_RESULT_E HandleAFCWaitWindow(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL MMI_RESULT_E EngAFCWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL MMI_RESULT_E HandlePAWaitWindow(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL MMI_RESULT_E EngPAWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL MMI_RESULT_E HandleAGCWaitWindow(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL int GetAGCInfoStr(uint8* agc_buf, uint8 buf_len);

LOCAL MMI_RESULT_E EngAGCWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
#endif
LOCAL MMI_RESULT_E HandleErrRateWaitWindow(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL int GetErrRateInfoStr(uint8* rate_buf, uint8 buf_len);

LOCAL MMI_RESULT_E EngErrRateWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngUSBLOGWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngCAPOUTPUTWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
// LOCAL MMI_RESULT_E EngContrastWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL MMI_RESULT_E EngBrightnessWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL void ShowSetAudioParamResult(BOOLEAN result);

LOCAL MMI_RESULT_E EngSidetoneWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL MMI_RESULT_E EngVoiceParamWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL int32 GetProductionInfoStr(char* pd_buf, int32 buf_len);

LOCAL int32 GetProductionSNStr(uint8* pd_buf, uint8 buf_len,  const PRODUCTION_TEST_INFO_T *s_mmieng_product);


LOCAL MMI_RESULT_E EngProductWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL void ShowSetPowerKeyResult(BOOLEAN result);

LOCAL void AppendPowerKeyItem(MMI_CTRL_ID_T list_id);

LOCAL void AppendListItem(
                            MMI_CTRL_ID_T list_id,
                            MMI_TEXT_ID_T *text_id_tab,
                            int32 tab_len
                            );

LOCAL MMI_RESULT_E EngPowerKeyWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

#ifdef DSP_USB_LOG
LOCAL MMI_RESULT_E EngDspCardLogEnableWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);//xuefangjiang 20110729
#endif

LOCAL MMI_RESULT_E EngSensorModeWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);//@songbin.zeng

LOCAL void AppendBandSelectItem(MMI_CTRL_ID_T list_id);

LOCAL MMI_RESULT_E EngBandSelectWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL MMI_RESULT_E EngShowLayer1MonitorWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

/*[START] Jerry Liang for ENG MODE powersweep 2008/07/30*/
//LOCAL MMI_RESULT_E EngShowPowersweepInfoWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
/*[END] Jerry Liang for ENG MODE powersweep 2008/07/30*/

LOCAL MMI_RESULT_E EngShowRFWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL BOOLEAN GetRFCellInfo(MMIENG_RF_CELL_INFO_T *info, MMIENG_RF_CELL_E cell);

LOCAL void DrawRFWin(MMIENG_RF_CELL_E cell );

LOCAL int16 EngDVCovFrameFre2ListItemPos(MMIENG_DV_FRAME_FRE_E dv_frame_frequency);

LOCAL MMIENG_DV_FRAME_FRE_E EngDVCovListItemPos2FrameFre(int16 item_pos);

LOCAL MMI_RESULT_E EngDVFrameFreWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
#if 0
LOCAL MMI_RESULT_E EngWapUAWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL MMI_RESULT_E EngWapUAProfileWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL MMI_RESULT_E EngWapMmsSasTestModeWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL BOOLEAN SetWapMmsSasTestMode(BOOLEAN is_on);
#endif
LOCAL MMI_RESULT_E BtAddressInfoWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);


#ifdef BLUETOOTH_SUPPORT

LOCAL MMI_RESULT_E BTBQBModeWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngBTNoSignalTestWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E BtVerInfoWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E BTSSPDebugModeWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngBTNoSignalBLERxWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngBTNoSignalBLETxWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngBTNoSignalRxWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngBTNoSignalTxWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngBTBleRXInforWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngBTRXInforWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL void ShowRXDataInfo(BOOLEAN need_update );
LOCAL int GetRXDataInfoStr(uint8* phone_buf, uint32 buf_len);

LOCAL void MMIBT_GetRXDataCallback( BT_NONSIG_DATA* data);
LOCAL void MMIBTInitRXData(void);
#endif
LOCAL void BT_GetRXParam(void);
LOCAL BT_ADDRESS StringToADDR(uint8 input[12]);
LOCAL void BT_GetTXParam(void);
LOCAL void ENGBT_GetBLETXParam(void);
LOCAL void ENGBT_GetBLERXParam(void);

#ifdef FM_SUPPORT
//ENG FM START
LOCAL MMI_RESULT_E EngFmDataCaptureWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngFmRegModeWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngShowFmStateWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngFMSetChannelTestWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngShowFMRdsBler_WINMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngFMNoiseScanWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngFMNoiseScanShowWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngFMTuneModeWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngFMAudioModeWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

//ENG FM END
#endif

//HardWare

LOCAL MMI_RESULT_E EngHardWareVibTestWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngHardWareCamLcdInfoWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngHardWareCamPowTestWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
//Debug and log
LOCAL MMI_RESULT_E EngDebugGprsAttachSerWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngDebugThermalSwitchWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngDebugAPRWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngDebugAPRServerWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngDebugAPRGroupWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngDebugAPRViewLogWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngDebugAPRDetectTimeWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL MMI_RESULT_E HandleChipTestMenuWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

#ifdef CMMB_SUPPORT
LOCAL MMI_RESULT_E HandleCMMBTestMainMenuWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E HandleCMMBTestWaitWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E HandleCMMBRDTestMenuWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E HandleCMMBFactoryTestMenuWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E HandleCMMBTestOKSignalMenuWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E HandleCMMBTestNoSignalMenuWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E HandleCMMBSerialNumberWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL MMI_RESULT_E HandleCMMBDisplayWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL void DisplayChannelStatusInfo(MTV_CHANNEL_STATUS_T* channel_info_ptr);
LOCAL MMI_RESULT_E EngMtvLOGSwitchWinHandleMsg(MMI_WIN_ID_T      win_id,
                                               MMI_MESSAGE_ID_E  msg_id,
                                               DPARAM            param);
LOCAL MMI_RESULT_E EngMtvLOGToBBSwitchWinHandleMsg(MMI_WIN_ID_T      win_id,
                                                   MMI_MESSAGE_ID_E  msg_id,
                                                   DPARAM            param);
LOCAL MMI_RESULT_E EngMtvLOGStorageWinHandleMsg(MMI_WIN_ID_T      win_id,
                                                MMI_MESSAGE_ID_E  msg_id,
                                                DPARAM            param);
#ifdef MBBMS_SUPPORT
#ifdef DEMOD_HW_SIANO
LOCAL MMI_RESULT_E HandleLOGControlEnableWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
#endif

LOCAL MMI_RESULT_E HandleInterfaceTestEnableWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E HandleSMDCounterEnableWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
#endif
LOCAL MMI_RESULT_E HandleAudioServiceEnableWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
#endif

LOCAL MMI_RESULT_E HandleChipTestPlayMp3MP4WinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL MMI_RESULT_E HandleChipTestDCWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL MMI_RESULT_E HandleChipTestLoopBackWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL MMI_RESULT_E HandleChipTestSettingWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngIQModeWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngIQModeOnOffWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E HandleIQDataWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngIQDataModeSelectWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngIQDataPowerOnStartWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E HandleIQDataModeSettingWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E HandleIQDataModeSettingFormatWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E HandleIQDataModeSettingTimeLimitWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E HandleIQDataModeSettingFrameLengthWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E HandleIQDataModeSettingBlockCountWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

/*[START] Jerry Liang for IQ MODE 2008/07/31*/        
LOCAL MMI_RESULT_E HandleIQDataModeSettingARFCNWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
/*[END] Jerry Liang for IQ MODE 2008/07/31*/        

LOCAL MMI_RESULT_E HandleIQDataModeSettingChannelWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E HandleIQDataQueryWin(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL MMI_RESULT_E EngShow3rdPartyVersionWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL void Show3rdPartyVersionInfo(BOOLEAN   need_update);

LOCAL int32 GetAdcCalibrateInfoStr(uint8* adc_info_buf, uint16 buf_len);
LOCAL MMI_RESULT_E EngShowAdcCalibrateWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

#ifdef PCLINK_SUPPORT
LOCAL MMI_RESULT_E HandlePClinkEnableWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E HandlePClinkInputIPAddrWinMsg(MMI_WIN_ID_T   win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E HandlePClinkInputSNMaskWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E HandlePClinkInputDefGWWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E HandlePClinkInputDNSWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);  

LOCAL MMI_RESULT_E HandlePCLinkInputTestAdfressWinMsg(MMI_WIN_ID_T  win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E HandlePCLinkPingTestWaitWinMsg(MMI_WIN_ID_T  win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);                                  
#endif

#ifdef CAMERA_SUPPORT
LOCAL MMI_RESULT_E HandleDCParamScreenSizeWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E HandleDCParamScreenSwitchWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E HandleDCParamScreenPrevSetWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);  
LOCAL MMI_RESULT_E HandleDCParamSensorAngleWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E HandleDCParamSensorIDWinMsg(MMI_WIN_ID_T win_id,
                                                          MMI_MESSAGE_ID_E msg_id,
                                                          DPARAM param
                                                          );

LOCAL BOOLEAN CheckIfDCScreenSwitchPrevSetSupported(
                                                CAMERA_ENG_VISUAL_MODE_E switch_mode,
                                                CAMERA_ENG_PREVIEW_MODE_E prev_mode);
#endif
LOCAL MMI_RESULT_E EngAudioSetWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL MMI_RESULT_E EngAudioVolWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL void MMIENG_AppendListItemByTextId(                                   
                                                MMI_TEXT_ID_T        text_id,
                                                MMI_TEXT_ID_T        left_softkey_id,
                                                MMI_TEXT_ID_T        middle_softkey_id,
                                                MMI_TEXT_ID_T        right_softkey_id,
                                                MMI_CTRL_ID_T        ctrl_id,
                                                GUIITEM_STYLE_E      item_style,
                                                uint8 * data_buf
                                                );
LOCAL double MMIENG_Log(double m,double base);   
LOCAL double MMIENG_Ln(double x);
LOCAL double MMIENG_Sqrt(double b);
LOCAL double MMIENG_Horner(double x);
LOCAL double MMIENG_Coef(int n);   
LOCAL double MMIENG_Exp(double x);    
LOCAL double MMIENG_Pow(double m,double n);    
LOCAL int16 MMIENG_DextoInt(uint8 * buf);
LOCAL MMI_RESULT_E EngAudioMp3WinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL uint32 EngAudioRead(uint32 menu_id , int16 * vol_array);
LOCAL uint32 EngAudioWrite(uint32 menu_id , int16 * vol_array);
LOCAL void AudioMp3AppendListItem(uint16 index);

#ifdef WIN32
PUBLIC uint32 PROD_ReadAudioParam(  
             NV_AUDIO_E   audio_mode,
             void*        mode_param_ptr
             );

PUBLIC uint32 PROD_WriteAudioParam(
    //const uint8* pucModeName, 
    NV_AUDIO_E   audio_mode, 
    void*        mode_param_ptr,
    BOOLEAN      is_flush
    );
#endif

LOCAL uint32 GetRunningNVCountingInfo(char *buffer, uint32 buffer_lengh) ;
LOCAL MMI_RESULT_E HandleRunningNVCountingWinMsg(
                                                 MMI_WIN_ID_T    win_id,    // 窗口的ID
                                                 MMI_MESSAGE_ID_E   msg_id,     // 窗口的内部消息ID
                                                 DPARAM             param       // 相应消息的参数
                                                 );

//MS00216980 cheney
LOCAL MMI_RESULT_E EngCMCCTestWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL void MMI_CalculateStandbyTime2File(void);
#ifdef MMI_SMS_RETRY_SUPPORT
LOCAL MMI_RESULT_E EngSMSRetryWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
#endif
LOCAL MMI_RESULT_E EngCallBarringWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);//MS00186848
LOCAL MMI_RESULT_E EngUpdateIMEIWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngUpdateIMEIEditWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngGetFlashInfoWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
#ifdef WRE_SUPPORT
LOCAL MMI_RESULT_E EngShowWREVersionWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
#endif

LOCAL MMI_RESULT_E EngMemPressTestEnterWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngMemPressTestWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

#ifdef TOUCH_PANEL_SUPPORT
LOCAL MMI_RESULT_E EngListPressTestHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngListNeedHightBarHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngListSupportLeftSlideHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
#endif
/*****************************************************************************/
//  Description : handle set lcd logic angle window msg
//  Global resource dependence : 
//  Author: Jassmine
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E EngSetAngleWinHandleMsg(
                                           MMI_WIN_ID_T         win_id,
                                           MMI_MESSAGE_ID_E     msg_id,
                                           DPARAM               param
                                           );

#ifdef ENGTD_SUPPORT
LOCAL int GetTDNCNetInfoStr(uint8* net_buf, uint16 buf_len);
#endif


PUBLIC void MMIENG_Int2Str(int16 value, uint8* buf, uint16 buf_len);
/*****************************************************************************/
//  Description : HandleUaAgentWinMsg
//  Global resource dependence : 
//  Author: li.li
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleUaAgentWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

/*****************************************************************************/
//  Description : HandleUaAgentWinMsg
//  Global resource dependence : 
//  Author: fen.xie
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleUaAgentSetWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

/*****************************************************************************/
//  Description : HandleUaProfileWinMsg
//  Global resource dependence : 
//  Author: li.li
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleUaProfileWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

/*****************************************************************************/
//  Description : HandleUaProfileSetWinMsg
//  Global resource dependence : 
//  Author: fen.xie
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleUaProfileSetWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

/*****************************************************************************/
//  Description : HandleUaAgentListWinMsg
//  Global resource dependence : 
//  Author: li.li
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleUaAgentListWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

/*****************************************************************************/
//  Description : HandleUaProfileListWinMsg
//  Global resource dependence : 
//  Author: li.li
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleUaProfileListWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
/*****************************************************************************/
//  Description : HandleUaAgentShowWinMsg
//  Global resource dependence : 
//  Author: fen.xie
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleUaAgentShowWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

/*****************************************************************************/
//  Description : HandleUaProfileShowWinMsg
//  Global resource dependence : 
//  Author: fen.xie
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleUaProfileShowWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

/*****************************************************************************/
//  Description : HandleUaAgentEditWinMsg
//  Global resource dependence : 
//  Author: fen.xie
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleUaAgentEditWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

/*****************************************************************************/
//  Description : HandleUaProfileEditWinMsg
//  Global resource dependence : 
//  Author: fen.xie
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleUaProfileEditWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

/*****************************************************************************/
//  Description : HandleBrowserLogWinMsg
//  Global resource dependence : 
//  Author: sally.he
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleBrowserLogWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

/*****************************************************************************/
//  Description : change url win
//  Global resource dependence : 
//  Author: 
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleBrowserChangeURLWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

/*****************************************************************************/
//  Description : HandleScreenLogWinMsg
//  Global resource dependence : 
//  Author: James.Zhang
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleScreenLogWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL MMI_RESULT_E  HandleChiptestTpWinMsg (MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E BTLocalNameSetWinHandleMsg(MMI_WIN_ID_T win_id,
                                                    MMI_MESSAGE_ID_E msg_id,
                                                    DPARAM param);

#ifdef MMI_AUTOTEST_SUPPORT
/*****************************************************************************/
//  Description : HandleAutoTestSetWinMsg
//  Global resource dependence : 
//  Author: 
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleAutoTestSetWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
#endif

#ifdef MMI_WIFI_SUPPORT
LOCAL MMI_RESULT_E HandleWlanPerformanceModeWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E HandleWifiIperfWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E HandleWlanRfSetWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL MMI_RESULT_E EngWifiRegWRHandleWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngWifiTXHandleWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngWifiRXHandleWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngPacketCheckItemHandleWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

#ifndef WIN32
extern void iperf_test_start(char* param);
#endif

#ifndef _WIN32
extern char* WIFI_GetVersion(void);
#endif
#endif

//for SUPPORT_STANDBY_RECORD
LOCAL MMI_RESULT_E StandbyTimeInfoWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
//end for SUPPORT_STANDBY_RECORD

#ifdef TF_LOAD_SUPPORT
LOCAL MMI_RESULT_E HandleTFLoadWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
PUBLIC void GPIO_SetLcdBackLight (BOOLEAN b_on);

#endif
/*****************************************************************************/
//  Description : OTA window
//  Global resource dependence :
//  Author: xiuyun.wang
//  Note:
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleOTAWinMsg(
                                       MMI_WIN_ID_T     win_id,
                                       MMI_MESSAGE_ID_E    msg_id,
                                       DPARAM              param
                                       );


#ifdef MMISRV_AUDIO_TEST_SUPPORT
/*****************************************************************************/
// 	Description : Audio self test, play audio.
//	Global resource dependence : none
//  Author: Yintang.Ren
//	Note:
/*****************************************************************************/
LOCAL MMI_RESULT_E EngAudioSelfTestPlayHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

/*****************************************************************************/
// 	Description : Audio self test, display audio info.
//	Global resource dependence : none
//  Author: Yintang.Ren
//	Note:
/*****************************************************************************/
LOCAL MMI_RESULT_E EngAudioSelfTestDisplayInfoHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

/*****************************************************************************/
// 	Description : Audio self test.
//	Global resource dependence : none
//  Author: Yintang.Ren
//	Note:
/*****************************************************************************/
LOCAL MMI_RESULT_E EngAudioSelfTestHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
#endif

/********************************************************************************
 NAME:          BandSelectCallBack
 DESCRIPTION:
 PARAM IN:      is_ok
 PARAM OUT:     None
 AUTHOR:        fangfang.yao
********************************************************************************/
LOCAL void BandSelectCallBack(MN_DUAL_SYS_E dual_sys,BOOLEAN is_ok);

LOCAL MMI_RESULT_E  EngTeleBANDSelectWinHandleMsg(MMI_WIN_ID_T win_id,MMI_MESSAGE_ID_E msg_id,DPARAM param);
LOCAL MMI_RESULT_E  EngTeleBANDTDDWinHandleMsg(MMI_WIN_ID_T win_id,MMI_MESSAGE_ID_E msg_id,DPARAM param);
LOCAL MMI_RESULT_E  EngTeleBANDFDDWinHandleMsg(MMI_WIN_ID_T win_id,MMI_MESSAGE_ID_E msg_id,DPARAM param);
LOCAL MMI_RESULT_E  EngTeleBANDGSMWinHandleMsg(MMI_WIN_ID_T win_id,MMI_MESSAGE_ID_E msg_id,DPARAM param);
LOCAL MMI_RESULT_E  EngTeleBANDWCDMAWinHandleMsg(MMI_WIN_ID_T win_id,MMI_MESSAGE_ID_E msg_id,DPARAM param);
LOCAL MMI_RESULT_E  EngTeleSIMTraceWinHandleMsg(MMI_WIN_ID_T win_id,MMI_MESSAGE_ID_E msg_id,DPARAM param);
LOCAL MMI_RESULT_E  EngTeleNetWorkModeWinHandleMsg(MMI_WIN_ID_T win_id,MMI_MESSAGE_ID_E msg_id,DPARAM param);
LOCAL MMI_RESULT_E  ENGNetinfoShowWinHandleMsg(MMI_WIN_ID_T win_id,MMI_MESSAGE_ID_E msg_id,DPARAM param);
LOCAL MMI_RESULT_E  ENGNWCAPShowWinHandleMsg(MMI_WIN_ID_T win_id,MMI_MESSAGE_ID_E msg_id,DPARAM param);
LOCAL MMI_RESULT_E  ENGNetinfoStatisticsWinHandleMsg(MMI_WIN_ID_T win_id,MMI_MESSAGE_ID_E msg_id,DPARAM param);

#if defined(PLATFORM_UWS6121E)
LOCAL MMI_RESULT_E ENG_Netinfo_Statistics_WinHandleMsg(MMI_WIN_ID_T win_id,MMI_MESSAGE_ID_E msg_id,DPARAM param);
#else
LOCAL MMI_RESULT_E  ENGNetinfoStatisticsDetailInfoWinHandleMsg(MMI_WIN_ID_T win_id,MMI_MESSAGE_ID_E msg_id,DPARAM param);
#endif
LOCAL MMI_RESULT_E  Eng_IMS_NV_PARAM_ID_WinHandleMsg(MMI_WIN_ID_T win_id,MMI_MESSAGE_ID_E msg_id,DPARAM param);
LOCAL MMI_RESULT_E  EngTeleVoltePLMNWhiteListWinHandleMsg(MMI_WIN_ID_T win_id,MMI_MESSAGE_ID_E msg_id,DPARAM param);
#ifdef MMI_VOLTE_SUPPORT
LOCAL MMI_RESULT_E EngTeleVolteOnOffWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E EngTeleImsPdnWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
#endif
LOCAL MMI_RESULT_E  EngTeleVoltePLMNWhiteListRelWinHandleMsg(MMI_WIN_ID_T win_id,MMI_MESSAGE_ID_E msg_id,DPARAM param);
LOCAL MMI_RESULT_E  EngTeleCSFBToGSmWinHandleMsg(MMI_WIN_ID_T win_id,MMI_MESSAGE_ID_E msg_id,DPARAM param);
LOCAL MMI_RESULT_E  EngFactoryResetWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E  EngResetFactoryInputPwdHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E  EngSetSMSSCHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL void MMISMS_SMSCenterNumber(void);
LOCAL MMI_RESULT_E  EngFastDormancyHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
LOCAL MMI_RESULT_E  EngQosSwitchWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

LOCAL MMI_RESULT_E  EngAddContactHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
#ifdef MP3_SUPPORT
LOCAL MMI_RESULT_E EngMp3PlayWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
#endif
LOCAL MMI_RESULT_E EngLightSleepWinHandleMsg( MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param );
LOCAL MMI_RESULT_E EngBetweenCelllWinHandleMsg( MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param );
LOCAL MMI_RESULT_E ENGBetweenCellShowWinHandleMsg( MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param );

LOCAL void EngPopupPromptMsg(MMI_TEXT_ID_T txt_id);
LOCAL MMI_RESULT_E  EngGprsPowerSaveModeWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
// 2022-04-28 新增函数
LOCAL MMI_RESULT_E EngShowCsonWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

#ifdef DATA_ROAMING_SUPPORT  
LOCAL MMI_RESULT_E EngDataRoamingWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
#endif

/*****************************************************************************/
//  Description : EngShowFlowrateWinHandleMsg
//  Global resource dependence :
//  Author:shuting.ma
//  Note:
/*****************************************************************************/
LOCAL MMI_RESULT_E EngShowFlowrateWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);

/**--------------------------------------------------------------------------*
                                     GLOBAL DEFINITION
 **--------------------------------------------------------------------------*/
#ifdef PCLINK_SUPPORT
MN_GPRS_PCLINK_CFG_T    s_pclink_config_info = {0};
#endif

WINDOW_TABLE(MMIENG_SHOW3RESULT_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngShow3ResultWinHandleMsg),
    WIN_ID(MMIENG_SHOW3RESULT_WIN_ID),
    WIN_TITLE(TXT_ENG_RESULT),
    WIN_SOFTKEY(TXT_NULL, TXT_NULL, STXT_RETURN),
    CREATE_LABEL_CTRL(GUILABEL_ALIGN_MIDDLE, MMIENG_LABEL1_CTRL_ID),
    CREATE_LABEL_CTRL(GUILABEL_ALIGN_MIDDLE, MMIENG_LABEL2_CTRL_ID),
    CREATE_LABEL_CTRL(GUILABEL_ALIGN_MIDDLE, MMIENG_LABEL3_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_SHOW3RESULT_NOAUTOCLOSE_WIN_TAB) = 
{
    //CLEAR_LCD,
    //WIN_PRIO( WIN_ONE_LEVEL ),
    WIN_FUNC((uint32)EngShow3ResultWinHandleMsgNoAutoClose),
    WIN_ID(MMIENG_SHOW3RESULT_WIN_ID),
    WIN_TITLE(TXT_ENG_RESULT),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LABEL_CTRL(GUILABEL_ALIGN_MIDDLE, MMIENG_LABEL1_CTRL_ID),
    CREATE_LABEL_CTRL(GUILABEL_ALIGN_MIDDLE, MMIENG_LABEL2_CTRL_ID),
    CREATE_LABEL_CTRL(GUILABEL_ALIGN_MIDDLE, MMIENG_LABEL3_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_SHOWHELP_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngShowHelpWinHandleMsg),
    WIN_ID(MMIENG_SHOWHELP_WIN_ID),
    WIN_TITLE(TXT_ENG_HELP_INFO),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_TEXT_CTRL(MMIENG_TEXTBOX1_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_SHOW_3RDPARTY_VERSION_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngShow3rdPartyVersionWinHandleMsg),
    WIN_ID(MMIENG_SHOW_3RDPARTY_VERSION_WIN_ID),
    WIN_TITLE(TXT_ENG_3RDPARTY_VERSION_INFO),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    
    CREATE_TEXT_CTRL(MMIENG_3RDPARTY_VERSION_CTRL_ID),
                
    END_WIN
};

WINDOW_TABLE(MMIENG_SHOWNET_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngShowNetWinHandleMsg),
    WIN_ID(MMIENG_SHOWNET_WIN_ID),
    WIN_TITLE(TXT_ENG_NET_INFO),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_TEXT_CTRL(MMIENG_TEXTBOX1_CTRL_ID),  
    END_WIN
};

LOCAL MMI_RESULT_E EngGprsTestWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param);
WINDOW_TABLE(MMIENG_GPRS_TEST_WIN_TAB) = 
{
    WIN_FUNC((uint32)EngGprsTestWinHandleMsg),
    WIN_ID(MMIENG_GPRS_TEST_WIN_ID),
    WIN_TITLE(TXT_ENG_GPRS_TEST),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_TEXT_CTRL(MMIENG_GPRS_TEST_CTRL_ID),
    CREATE_BUTTON_CTRL(PNULL, MMIENG_GPRS_TEST_OK_BUTTON),
    CREATE_BUTTON_CTRL(PNULL, MMIENG_GPRS_TEST_BACK_BUTTON),
    END_WIN
};
WINDOW_TABLE(MMIENG_PSCELL_OPTION_MENU_WIN_TAB) = 
{   
    WIN_FUNC( (uint32)EngPSCellOptionMenuWinHandleMsg),
    WIN_ID(MMIENG_PSCELL_OPTION_MENU_WIN_ID),
    WIN_STYLE( WS_HAS_TRANSPARENT),
    WIN_SOFTKEY(TXT_COMMON_OK,TXT_NULL,STXT_RETURN),
    CREATE_POPMENU_CTRL(MENU_PSCELL_OPTION, MMIENG_OPTION_MENU_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_PSCELL_WIN_TAB) = 
{
    WIN_FUNC((uint32)EngPSCellWinHandleMsg),
    WIN_ID(MMIENG_PSCELL_WIN_ID),
    WIN_TITLE(TXT_ENG_PSCELL_INFO),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_CHECKLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_SHOWPHONE_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngShowPhoneWinHandleMsg),
    WIN_ID(MMIENG_SHOWPHONE_WIN_ID),
    WIN_TITLE(TXT_ENG_PHONE_INFO),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_TEXT_CTRL(MMIENG_TEXTBOX1_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_SHOW_ADC_CALIBRATE_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngShowAdcCalibrateWinHandleMsg),
    WIN_ID(MMIENG_SHOW_ADC_CALIBRATE_WIN_ID),
    WIN_TITLE(TXT_ENG_ADC_CALIBRATE_INFO),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
#if !defined (PLATFORM_ANTISW3)      
    CREATE_TEXT_CTRL( MMIENG_TEXTBOX1_CTRL_ID),
#else    
    CREATE_RICHTEXT_CTRL(MMIENG_TEXTBOX1_CTRL_ID),
#endif    
    END_WIN
};

WINDOW_TABLE(MMIENG_ASSERTTARGET_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngAssertTargetWinHandleMsg),
    WIN_ID(MMIENG_ASSERTTARGET_WIN_ID),
    WIN_TITLE(TXT_ENG_ASSERTTARGET),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_EDIT_PHONENUM_CTRL(ENG_TARGET_MAX_LEN, MMIENG_EDITBOX1_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_FORBIDPLMN_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngForbidPLMNWinHandleMsg),
    WIN_ID(MMIENG_FORBIDPLMN_WIN_ID),
    WIN_TITLE(TXT_ENG_FORBIDPLMN),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_CARDLOG_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngCardLogWinHandleMsg),
    WIN_ID(MMIENG_CARDLOG_WIN_ID),
    WIN_TITLE(TXT_ENG_CARDLOG),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_AUTO_ANSWER_CALL_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngAutoAnswerCallWinHandleMsg),
    WIN_ID(MMIENG_AUTO_ANSWER_CALL_WIN_ID),
    WIN_TITLE(TXT_ENG_AUTO_ANSWER_CALL),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};

#ifdef MMI_SMS_RETRY_SUPPORT
WINDOW_TABLE(MMIENG_SMS_RETRY_WIN_TAB) = 
{
    //CLEAR_LCD,
    //WIN_PRIO( WIN_ONE_LEVEL ),
    WIN_FUNC((uint32)EngSMSRetryWinHandleMsg),
    WIN_ID(MMIENG_SMS_RETRY_WIN_ID),
    WIN_TITLE(TXT_SMS_RETRY_SET),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};
#endif

WINDOW_TABLE(MMIENG_NETLOST_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngNetLostWinHandleMsg),
    WIN_ID(MMIENG_NETLOST_WIN_ID),
    WIN_TITLE(TXT_ENG_NETLOST),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    //CREATE_LABEL_CTRL(GUILABEL_ALIGN_LEFT, MMIENG_LABEL1_CTRL_ID),
    CREATE_TEXT_CTRL(MMIENG_TEXTBOX1_CTRL_ID),
    //CREATE_LABEL_CTRL(GUILABEL_ALIGN_LEFT, MMIENG_LABEL2_CTRL_ID),
    //CREATE_TEXT_CTRL( MMIENG_TEXTBOX2_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_TCV_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngTCVWinHandleMsg),
    WIN_ID(MMIENG_TCV_WIN_ID),
    WIN_TITLE(TXT_ENG_TCV),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_TEXT_CTRL(MMIENG_TEXTBOX1_CTRL_ID),
    END_WIN
};
#if 0
WINDOW_TABLE(MMIENG_AFC_WIN_TAB) = 
{
    //CLEAR_LCD,
    //WIN_PRIO( WIN_ONE_LEVEL ),
    WIN_FUNC((uint32)EngAFCWinHandleMsg),
    WIN_ID(MMIENG_AFC_WIN_ID),
    WIN_TITLE(TXT_ENG_AFC),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_TEXT_CTRL( MMIENG_TEXTBOX1_CTRL_ID),
//    CREATE_PRGBOX_CTRL(GUIPRGBOX_STYLE_HORIZONTAL_PROCESS, MMIENG_PRGBOX_CTRL_ID),
    END_WIN
};
#endif
#if 0
WINDOW_TABLE(MMIENG_PA_WIN_TAB) = 
{
    //CLEAR_LCD,
    //WIN_PRIO( WIN_ONE_LEVEL ),
    WIN_FUNC((uint32)EngPAWinHandleMsg),
    WIN_ID(MMIENG_PA_WIN_ID),
    WIN_TITLE(TXT_ENG_PA),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
//    CREATE_LABEL_CTRL(GUILABEL_ALIGN_MIDDLE, MMIENG_LABEL1_CTRL_ID),
//    CREATE_PRGBOX_CTRL(GUIPRGBOX_STYLE_HORIZONTAL_PROCESS, MMIENG_PRGBOX_CTRL_ID),
    CREATE_TEXT_CTRL( MMIENG_TEXTBOX1_CTRL_ID),
    END_WIN
};
#endif

WINDOW_TABLE(MMIENG_AUDIOMP3_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngAudioMp3WinHandleMsg),
    WIN_ID(MMIENG_AudioMP3_WIN_ID),
    WIN_TITLE(TXT_ENG_AUDIO_SETTING),
#ifdef MMI_PDA_SUPPORT
    WIN_STYLE(WS_HAS_BUTTON_SOFTKEY),
#endif
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),

    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_MP3_LISTBOX_CTRL_ID),
    /*                      
    CREATE_EDIT_DIGITAL_CTRL(ENG_CLIENT_LEFT,ENG_CLIENT_TOP+MMI_EDITNOX_IM_ICON_RECT_HEIGHT,
                            ENG_CLIENT_RIGHT,MMI_INPUT_EDITBOX_BOTTOM,  
                            4, MMIENG_WAPUAPROFILE_CTRL_ID),
    */
    END_WIN
};


WINDOW_TABLE(MMIENG_AUDIOVOL_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngAudioVolWinHandleMsg),
    WIN_ID(MMIENG_AudioVol_WIN_ID),
    WIN_TITLE(TXT_ENG_AUDIO_SETTING),
#ifdef MMI_PDA_SUPPORT
    WIN_STYLE(WS_HAS_BUTTON_SOFTKEY),
#endif
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LABEL_CTRL(GUILABEL_ALIGN_MIDDLE, MMIENG_LABEL1_CTRL_ID),
    CREATE_PRGBOX_CTRL(GUIPRGBOX_STYLE_HORIZONTAL_PROCESS, MMIENG_PRGBOX_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_AUDIOSET_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngAudioSetWinHandleMsg),
    WIN_ID(MMIENG_AUDIOSET_WIN_ID),
    WIN_TITLE(TXT_ENG_AUDIO_SETTING),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};
#if 0
WINDOW_TABLE(MMIENG_AGC_WIN_TAB) = 
{
    //CLEAR_LCD,
    //WIN_PRIO( WIN_ONE_LEVEL ),
    WIN_FUNC((uint32)EngAGCWinHandleMsg),
    WIN_ID(MMIENG_AGC_WIN_ID),
    WIN_TITLE(TXT_ENG_AGC),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_TEXT_CTRL(MMIENG_TEXTBOX1_CTRL_ID),
    END_WIN
};
#endif
WINDOW_TABLE(MMIENG_ERRRATE_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngErrRateWinHandleMsg),
    WIN_ID(MMIENG_ERRRATE_WIN_ID),
    WIN_TITLE(TXT_ENG_ERRRATE),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_TEXT_CTRL(MMIENG_TEXTBOX1_CTRL_ID),
    END_WIN
};
WINDOW_TABLE(MMIENG_USBLOG_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngUSBLOGWinHandleMsg),
    WIN_ID(MMIENG_USBLOG_WIN_ID),
    WIN_TITLE(TXT_COMM_USB_LOG),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};
WINDOW_TABLE(MMIENG_CAPOUPUT_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngCAPOUTPUTWinHandleMsg),
    WIN_ID(MMIENG_CAPOUPUT_WIN_ID),
    WIN_TITLE(TXT_CAP_OUTPUT),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};
//WINDOW_TABLE(MMIENG_CONTRAST_TAB) = 
//{
//  //CLEAR_LCD,
//  //WIN_PRIO( WIN_ONE_LEVEL ),
//  WIN_FUNC((uint32)EngContrastWinHandleMsg),
//  WIN_ID(MMIENG_CONTRAST_WIN_ID),
//  WIN_TITLE(TXT_ENG_CONTRAST),
//    WIN_SOFTKEY(STXT_OK, TXT_NULL, STXT_RETURN),
//  CREATE_LABEL_CTRL(GUILABEL_ALIGN_MIDDLE, MMIENG_LABEL1_CTRL_ID),
//  CREATE_PRGBOX_CTRL(GUIPRGBOX_STYLE_HORIZONTAL_PROCESS, MMIENG_PRGBOX_CTRL_ID),
//  END_WIN
// };

WINDOW_TABLE(MMIENG_BRIGHTNESS_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngBrightnessWinHandleMsg),
    WIN_ID(MMIENG_BRIGHTNESS_WIN_ID),
    WIN_TITLE(TXT_ENG_BRIGHTNESS),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LABEL_CTRL(GUILABEL_ALIGN_MIDDLE, MMIENG_LABEL1_CTRL_ID),
    CREATE_PRGBOX_CTRL(GUIPRGBOX_STYLE_HORIZONTAL_PROCESS, MMIENG_PRGBOX_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_SIDETONE_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngSidetoneWinHandleMsg),
    WIN_ID(MMIENG_SIDETONE_WIN_ID),
    WIN_TITLE(TXT_ENG_HDSTSDTONE),
#ifdef MMI_PDA_SUPPORT
    CREATE_FORM_CTRL(GUIFORM_LAYOUT_ORDER,MMIENG_SIDETONE_FORM_CTRL_ID), 
    CHILD_EDIT_DIGITAL_CTRL(TRUE, 5, MMIENG_EDITBOX1_CTRL_ID, MMIENG_SIDETONE_FORM_CTRL_ID),
    CHILD_SOFTKEY_CTRL(TXT_ENG_OK, TXT_NULL, TXT_ENG_RETURN,MMIENG_SIDETONE_SOFTKEY_CTRL_ID,MMIENG_SIDETONE_FORM_CTRL_ID),
#else
    WIN_SOFTKEY(TXT_NULL, TXT_NULL, STXT_RETURN),
    CREATE_EDIT_DIGITAL_CTRL(5, MMIENG_EDITBOX1_CTRL_ID),
#endif
    END_WIN
};

WINDOW_TABLE(MMIENG_VOICEPARAM_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngVoiceParamWinHandleMsg),
    WIN_ID(MMIENG_VOICEPARAM_WIN_ID),
    WIN_TITLE(TXT_ENG_VOICE_PARAM),
    
   
    CREATE_FORM_CTRL(GUIFORM_LAYOUT_ORDER,MMIENG_FORM_CTRL_ID), 
        CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_FORM1_CTRL_ID,MMIENG_FORM_CTRL_ID),
            CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_LABEL1_CTRL_ID, MMIENG_FORM1_CTRL_ID),
            CHILD_EDIT_DIGITAL_CTRL(TRUE, 5,MMIENG_EDITBOX1_CTRL_ID, MMIENG_FORM1_CTRL_ID),  

        CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_FORM2_CTRL_ID,MMIENG_FORM_CTRL_ID),
            CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_LABEL2_CTRL_ID, MMIENG_FORM2_CTRL_ID),
            CHILD_EDIT_DIGITAL_CTRL(TRUE, 5,MMIENG_EDITBOX2_CTRL_ID, MMIENG_FORM2_CTRL_ID),  
#ifdef MMI_PDA_SUPPORT

       CHILD_SOFTKEY_CTRL(TXT_COMMON_OK, TXT_NULL, STXT_RETURN,MMIENG_VOICE_PARAM_SOFTKEY_CTRL_ID,MMIENG_FORM_CTRL_ID),
#else
       WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
#endif

    END_WIN
};

WINDOW_TABLE(MMIENG_PRODUCT_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngProductWinHandleMsg),
    WIN_ID(MMIENG_PRODUCT_WIN_ID),
    WIN_TITLE(TXT_ENG_PRODUCT),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_TEXT_CTRL(MMIENG_TEXTBOX1_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_PRODUCT_SN_WIN_TAB) = 
{

    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngProductSNWinHandleMsg),
    WIN_ID(MMIENG_PRODUCT_WIN_ID),
    WIN_TITLE(TXT_ENG_PRODUCT),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_TEXT_CTRL(MMIENG_TEXTBOX1_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_POWERKEY_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngPowerKeyWinHandleMsg),
    WIN_ID(MMIENG_POWERKEY_WIN_ID),
    WIN_TITLE(TXT_ENG_POWER_KEY),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};
#ifdef DSP_USB_LOG
/*xuefangjiang 20110729*/
WINDOW_TABLE(MMIENG_DSPCARD_LOG_ENABLE_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngDspCardLogEnableWinHandleMsg),
    WIN_ID(MMIENG_DSPCARD_LOG_ENABLE_WIN_ID),
    WIN_TITLE(TXT_ENG_DSPCARD_LOG_ENABLE),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};
#endif
WINDOW_TABLE(MMIENG_SENSOR_MODE_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngSensorModeWinHandleMsg),
    WIN_ID(MMIENG_SENSOR_MODE_WIN_ID),
    WIN_TITLE(TXT_ENG_SENSOR_MODE),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};

 //MS00216980 cheney
WINDOW_TABLE(MMIENG_CMCC_TEST_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
	WIN_FUNC((uint32)EngCMCCTestWinHandleMsg),
	WIN_ID(MMIENG_CMCC_TEST_WIN_ID),
	WIN_TITLE(TXT_ENG_CMCC_TEST_CONFIG),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
	CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
	END_WIN
};

WINDOW_TABLE(MMIENG_GET_FLASH_INFO_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
	WIN_FUNC((uint32)EngGetFlashInfoWinHandleMsg),
	WIN_ID(MMIENG_GET_FLASH_INFO_WIN_ID),
	WIN_TITLE(TXT_ENG_GET_FLASH_INFO),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_TEXT_CTRL(MMIENG_TEXTBOX1_CTRL_ID),
	END_WIN
};

WINDOW_TABLE(MMIENG_UPDATE_IMEI_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
	WIN_FUNC((uint32)EngUpdateIMEIWinHandleMsg),
	WIN_ID(MMIENG_UPDATE_IMEI_WIN_ID),
	WIN_TITLE(TXT_ENG_UPDATE_IMEI),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_TEXTLIST_E, MMIENG_LISTBOX_CTRL_ID),
	END_WIN
};

WINDOW_TABLE(MMIENG_UPDATE_IMEI_EDIT_WIN_TAB) = 
{
	//CLEAR_LCD,
	//WIN_PRIO( WIN_ONE_LEVEL ),
#ifdef MMI_PDA_SUPPORT
    WIN_STYLE(WS_HAS_BUTTON_SOFTKEY),
#endif
	WIN_FUNC((uint32)EngUpdateIMEIEditWinHandleMsg),
	WIN_ID(MMIENG_UPDATE_IMEI_EIDT_WIN_ID),
	WIN_TITLE(TXT_ENG_UPDATE_IMEI),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_EDIT_TEXT_CTRL(MN_MAX_IMEI_LENGTH*2 , MMIENG_EDITBOX1_CTRL_ID),
	END_WIN
};


WINDOW_TABLE(MMIENG_DV_FRAME_FRE_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngDVFrameFreWinHandleMsg),
    WIN_ID(MMIENG_DV_FRAME_FRE_WIN_ID),
    WIN_TITLE(TXT_ENG_DV_FRAME_FRE),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_BANDSELECT_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngBandSelectWinHandleMsg),
    WIN_ID(MMIENG_BANDSELECT_WIN_ID),
    WIN_TITLE(TXT_ENG_BAND),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_LAYER1MONITOR_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngShowLayer1MonitorWinHandleMsg),
    WIN_ID(MMIENG_LAYER1MONITOR_WIN_ID),
    WIN_TITLE(TXT_ENG_LAYER1_MONITOR),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_TEXT_CTRL(MMIENG_TEXTBOX1_CTRL_ID),

    END_WIN
};

/*[START] Jerry Liang for ENG MODE powersweep 2008/07/30*/
/*WINDOW_TABLE(MMIENG_POWERSWEEPINFO_WIN_TAB) = 
{
    //CLEAR_LCD,
    //WIN_PRIO( WIN_ONE_LEVEL ),
    WIN_FUNC((uint32)EngShowPowersweepInfoWinHandleMsg),
    WIN_ID(MMIENG_POWERSWEEPINFO_WIN_ID),
    WIN_TITLE(TXT_ENG_POWERSWEEP_INFO),
    WIN_SOFTKEY(STXT_OK, TXT_NULL, STXT_RETURN),
    CREATE_TEXT_CTRL(MMIENG_TEXTBOX1_CTRL_ID),

    END_WIN
};*/// modify by mary
/*[END] Jerry Liang for ENG MODE powersweep 2008/07/30*/


WINDOW_TABLE(MMIENG_SHOW_RF_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngShowRFWinHandleMsg),
    WIN_ID(MMIENG_SHOW_RF_WIN_ID),
        WIN_TITLE(TXT_ENG_RF_PARAM),
        WIN_SOFTKEY(TXT_NULL, TXT_NULL, STXT_RETURN),
        CREATE_TEXT_CTRL(MMIENG_TEXTBOX1_CTRL_ID),
    END_WIN
};

#if 0
WINDOW_TABLE(MMIENG_WAPUA_WIN_TAB) = 
{
    WIN_FUNC((uint32)EngWapUAWinHandleMsg),
    WIN_ID(MMIENG_WAPUA_WIN_ID),
    WIN_TITLE(TXT_ENG_UA),
    CREATE_EDIT_TEXT_CTRL(ENG_WAPUA_MAX_LEN,MMIENG_WAPUA_CTRL_ID),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    END_WIN
};

WINDOW_TABLE(MMIENG_WAPUAPROFILE_WIN_TAB) = 
{
    WIN_FUNC((uint32)EngWapUAProfileWinHandleMsg),
    WIN_ID(MMIENG_WAPUAPROFILE_WIN_ID),
    WIN_TITLE(TXT_ENG_UA_PROFILE),
    CREATE_EDIT_TEXT_CTRL(ENG_WAPUA_MAX_LEN,MMIENG_WAPUAPROFILE_CTRL_ID),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    END_WIN
};

WINDOW_TABLE(MMIENG_WAPMMS_SAS_TEST_MODE_WIN_TAB) = 
{
    //CLEAR_LCD,
    //WIN_PRIO( WIN_ONE_LEVEL ),
    WIN_FUNC((uint32)EngWapMmsSasTestModeWinHandleMsg),
    WIN_ID(MMIENG_WAPMMS_SAS_TEST_MODE_WIN_ID),
    WIN_TITLE(TXT_ENG_SAS_TEST_MODE),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};
#endif
#ifdef BLUETOOTH_SUPPORT
WINDOW_TABLE(MMIENG_BT_SSP_DEBUG_TAB) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)BTSSPDebugModeWinHandleMsg),
	WIN_ID(MMIENG_BT_SSP_DEBUG_WIN_ID),
	WIN_TITLE(TXT_ENG_BT_SSP_DEBUG),
	WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
	CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
	END_WIN
};
#endif
WINDOW_TABLE(MMIENG_BT_ADDRESS_INFO_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)BtAddressInfoWinHandleMsg),
    WIN_ID(MMIENG_BT_ADDRESS_INFO_WIN_ID),
    WIN_TITLE(TXT_EMG_BT_ADDR_INFO),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_TEXT_CTRL( MMIENG_BTADDRESS_CTRL_ID),
    END_WIN
};
#ifdef ADULT_WATCH_SUPPORT
WINDOW_TABLE(MMIENG_BT_LOCAL_NAME_SET_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)BTLocalNameSetWinHandleMsg),
    WIN_ID(MMIENG_BT_LOCAL_NAME_SET_WIN_ID),
    WIN_TITLE(TXT_ENG_BT_LOCAL_NAME_SET),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_EDIT_TEXT_CTRL(UAL_BT_DEV_NAME_MAX_LEN, MMIENG_EDITBOX1_CTRL_ID),
    END_WIN
};
#endif

#ifdef BLUETOOTH_SUPPORT
WINDOW_TABLE(MMIENG_BT_VER_INFO_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)BtVerInfoWinHandleMsg),
    WIN_ID(MMIENG_BT_VER_INFO_WIN_ID),
    WIN_TITLE(TXT_ENG_VERSION_INFO),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_TEXT_CTRL( MMIENG_BTADDRESS_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_BT_NOSIGNAL_TEST_TAB) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngBTNoSignalTestWinHandleMsg),
	WIN_ID(MMIENG_BT_NOSIGNAL_TEST_WIN_ID),
	WIN_TITLE(TXT_BT_NOSIGNAL_TITLE),
	WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
	CREATE_LISTBOX_CTRL(GUILIST_TEXTLIST_E, MMIENG_BT_NOSIGNAL_TESTCTRL_ID),
	END_WIN
};
WINDOW_TABLE(MMIENG_BT_NOSIGNAL_RX_INFO_TAB) = 
{
    WIN_HIDE_STATUS,
	WIN_FUNC((uint32)EngBTRXInforWinHandleMsg),
	WIN_ID(MMIENG_BT_NOSIGNAL_RX_INFO_WIN_ID),
	WIN_TITLE(TXT_BT_NOSIGNAL_INFO),

	WIN_SOFTKEY(TXT_BT_NOSIGNAL_UPDATE, TXT_NULL, STXT_RETURN),
	//    CREATE_LISTBOX_CTRL(GUILIST_TYPE_NONE, MMIENG_BT_NOSIGNAL_INFO_CTRL_ID),
	CREATE_TEXT_CTRL(MMIENG_BT_NOSIGNAL_INFO_CTRL_ID),
	END_WIN
};
WINDOW_TABLE(MMIENG_BT_NOSIGNAL_TX_TAB) = 
{
    WIN_HIDE_STATUS,
	WIN_FUNC((uint32)EngBTNoSignalTxWinHandleMsg),
	WIN_ID(MMIENG_BT_NOSIGNAL_TX_WIN_ID),
	WIN_TITLE(TXT_ENG_ENTER_BT_NOSIGNAL_TX),

	CREATE_FORM_CTRL(GUIFORM_LAYOUT_ORDER,MMIENG_FORM_CTRL_ID), 
	//first ctrl  tx pattern
	CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_BT_NOSIGNAL_CTRL1_ID,MMIENG_FORM_CTRL_ID),
	CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_BT_NOSIGNAL_LABEL_CTRL1_ID, MMIENG_BT_NOSIGNAL_CTRL1_ID),
	CHILD_SETLIST_CTRL(TRUE, MMIENG_BT_NOSIGNAL_EDIT_CTRL1_ID, MMIENG_BT_NOSIGNAL_CTRL1_ID),

	//second ctrl tx channel
	CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_BT_NOSIGNAL_CTRL2_ID,MMIENG_FORM_CTRL_ID),
	CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_BT_NOSIGNAL_LABEL_CTRL2_ID, MMIENG_BT_NOSIGNAL_CTRL2_ID),
	CHILD_EDIT_DIGITAL_CTRL(TRUE, 5,MMIENG_BT_NOSIGNAL_EDIT_CTRL2_ID, MMIENG_BT_NOSIGNAL_CTRL2_ID),  
	//third ctrl tx pac type
	CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_BT_NOSIGNAL_CTRL3_ID,MMIENG_FORM_CTRL_ID),
	CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_BT_NOSIGNAL_LABEL_CTRL3_ID, MMIENG_BT_NOSIGNAL_CTRL3_ID),
	CHILD_SETLIST_CTRL(TRUE, MMIENG_BT_NOSIGNAL_EDIT_CTRL3_ID, MMIENG_BT_NOSIGNAL_CTRL3_ID),
	//forth tx pac len which need pac type

	//fifth ctrl tx power type 0 or 1
	CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_BT_NOSIGNAL_CTRL4_ID,MMIENG_FORM_CTRL_ID),
	CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_BT_NOSIGNAL_LABEL_CTRL4_ID, MMIENG_BT_NOSIGNAL_CTRL4_ID),
	CHILD_SETLIST_CTRL(TRUE, MMIENG_BT_NOSIGNAL_EDIT_CTRL4_ID, MMIENG_BT_NOSIGNAL_CTRL4_ID),
	//tx power value 0-33
	CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_BT_NOSIGNAL_CTRL5_ID,MMIENG_FORM_CTRL_ID),
	CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_BT_NOSIGNAL_LABEL_CTRL5_ID, MMIENG_BT_NOSIGNAL_CTRL5_ID),
	CHILD_EDIT_DIGITAL_CTRL(TRUE, 5,MMIENG_BT_NOSIGNAL_EDIT_CTRL5_ID, MMIENG_BT_NOSIGNAL_CTRL5_ID),  
	//tx pac Cnt 0-65536
	CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_BT_NOSIGNAL_CTRL6_ID,MMIENG_FORM_CTRL_ID),
	CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_BT_NOSIGNAL_LABEL_CTRL6_ID, MMIENG_BT_NOSIGNAL_CTRL6_ID),
	CHILD_EDIT_DIGITAL_CTRL(TRUE, 5,MMIENG_BT_NOSIGNAL_EDIT_CTRL6_ID, MMIENG_BT_NOSIGNAL_CTRL6_ID),  

	WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
	END_WIN
};
WINDOW_TABLE(MMIENG_BT_NOSIGNAL_RX_TAB) = 
{
    WIN_HIDE_STATUS,
	WIN_FUNC((uint32)EngBTNoSignalRxWinHandleMsg),
	WIN_ID(MMIENG_BT_NOSIGNAL_RX_WIN_ID),
	WIN_TITLE(TXT_ENG_ENTER_BT_NOSIGNAL_RX),

	CREATE_FORM_CTRL(GUIFORM_LAYOUT_ORDER,MMIENG_FORM_CTRL_ID), 
	//Rx channel
	CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_BT_NOSIGNAL_CTRL7_ID,MMIENG_FORM_CTRL_ID),
	CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_BT_NOSIGNAL_LABEL_CTRL7_ID, MMIENG_BT_NOSIGNAL_CTRL7_ID),
	CHILD_EDIT_DIGITAL_CTRL(TRUE, 5,MMIENG_BT_NOSIGNAL_EDIT_CTRL7_ID, MMIENG_BT_NOSIGNAL_CTRL7_ID),  
	// ctrl tx pac type
	CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_BT_NOSIGNAL_CTRL8_ID,MMIENG_FORM_CTRL_ID),
	CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_BT_NOSIGNAL_LABEL_CTRL8_ID, MMIENG_BT_NOSIGNAL_CTRL8_ID),
	CHILD_SETLIST_CTRL(TRUE, MMIENG_BT_NOSIGNAL_EDIT_CTRL8_ID, MMIENG_BT_NOSIGNAL_CTRL8_ID),

	//RX Gain value 0-32
	CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_BT_NOSIGNAL_CTRL9_ID,MMIENG_FORM_CTRL_ID),
	CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_BT_NOSIGNAL_LABEL_CTRL9_ID, MMIENG_BT_NOSIGNAL_CTRL9_ID),
	CHILD_EDIT_DIGITAL_CTRL(TRUE, 5,MMIENG_BT_NOSIGNAL_EDIT_CTRL9_ID, MMIENG_BT_NOSIGNAL_CTRL9_ID),  
	//Rx Addr input 12 bit addr
	CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_BT_NOSIGNAL_CTRL10_ID,MMIENG_FORM_CTRL_ID),
	CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_BT_NOSIGNAL_LABEL_CTRL10_ID, MMIENG_BT_NOSIGNAL_CTRL10_ID),
//	CHILD_EDIT_DIGITAL_CTRL(TRUE, 12,MMIENG_BT_NOSIGNAL_EDIT_CTRL10_ID, MMIENG_BT_NOSIGNAL_CTRL10_ID),  
	 CHILD_EDIT_TEXT_CTRL(TRUE,12,MMIENG_BT_NOSIGNAL_EDIT_CTRL10_ID,MMIENG_BT_NOSIGNAL_CTRL10_ID),
//	  CHILD_EDIT_LIST_CTRL(TRUE,1,5,MMIENG_BT_NOSIGNAL_EDIT_CTRL10_ID,MMIENG_BT_NOSIGNAL_CTRL10_ID),

	WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
	END_WIN
};

WINDOW_TABLE(MMIENG_BT_NOSIGNAL_BLE_TX_TAB) = 
{
    WIN_HIDE_STATUS,
	WIN_FUNC((uint32)EngBTNoSignalBLETxWinHandleMsg),
	WIN_ID(MMIENG_BT_NOSIGNAL_BLE_TX_WIN_ID),
	WIN_TITLE(TXT_ENG_ENTER_BT_NOSIGNAL_BLE_TX),

	CREATE_FORM_CTRL(GUIFORM_LAYOUT_ORDER,MMIENG_FORM_CTRL_ID), 
	//tx LE_PHY
	CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_BT_NOSIGNAL_CTRL8_ID,MMIENG_FORM_CTRL_ID),
	CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_BT_NOSIGNAL_LABEL_CTRL8_ID, MMIENG_BT_NOSIGNAL_CTRL8_ID),
	CHILD_SETLIST_CTRL(TRUE, MMIENG_BT_NOSIGNAL_EDIT_CTRL8_ID, MMIENG_BT_NOSIGNAL_CTRL8_ID),
	//tx Pac Payload
	CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_BT_NOSIGNAL_CTRL9_ID,MMIENG_FORM_CTRL_ID),
	CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_BT_NOSIGNAL_LABEL_CTRL9_ID, MMIENG_BT_NOSIGNAL_CTRL9_ID),
	CHILD_SETLIST_CTRL(TRUE, MMIENG_BT_NOSIGNAL_EDIT_CTRL9_ID, MMIENG_BT_NOSIGNAL_CTRL9_ID),
	//first ctrl  tx pattern
	CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_BT_NOSIGNAL_CTRL1_ID,MMIENG_FORM_CTRL_ID),
	CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_BT_NOSIGNAL_LABEL_CTRL1_ID, MMIENG_BT_NOSIGNAL_CTRL1_ID),
	CHILD_SETLIST_CTRL(TRUE, MMIENG_BT_NOSIGNAL_EDIT_CTRL1_ID, MMIENG_BT_NOSIGNAL_CTRL1_ID),
	//second ctrl tx channel
	CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_BT_NOSIGNAL_CTRL2_ID,MMIENG_FORM_CTRL_ID),
	CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_BT_NOSIGNAL_LABEL_CTRL2_ID, MMIENG_BT_NOSIGNAL_CTRL2_ID),
	CHILD_EDIT_DIGITAL_CTRL(TRUE, 5,MMIENG_BT_NOSIGNAL_EDIT_CTRL2_ID, MMIENG_BT_NOSIGNAL_CTRL2_ID),  
	//second ctrl tx data length
	CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_BT_NOSIGNAL_CTRL10_ID,MMIENG_FORM_CTRL_ID),
	CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_BT_NOSIGNAL_LABEL_CTRL10_ID, MMIENG_BT_NOSIGNAL_CTRL10_ID),
	CHILD_EDIT_DIGITAL_CTRL(TRUE, 5,MMIENG_BT_NOSIGNAL_EDIT_CTRL10_ID, MMIENG_BT_NOSIGNAL_CTRL10_ID), 
	//third ctrl tx pac type
	CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_BT_NOSIGNAL_CTRL3_ID,MMIENG_FORM_CTRL_ID),
	CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_BT_NOSIGNAL_LABEL_CTRL3_ID, MMIENG_BT_NOSIGNAL_CTRL3_ID),
	CHILD_SETLIST_CTRL(TRUE, MMIENG_BT_NOSIGNAL_EDIT_CTRL3_ID, MMIENG_BT_NOSIGNAL_CTRL3_ID),
	//forth tx pac len which need pac type
	CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_BT_NOSIGNAL_CTRL7_ID,MMIENG_FORM_CTRL_ID),
	CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_BT_NOSIGNAL_LABEL_CTRL7_ID, MMIENG_BT_NOSIGNAL_CTRL7_ID),
	CHILD_EDIT_DIGITAL_CTRL(TRUE, 5,MMIENG_BT_NOSIGNAL_EDIT_CTRL7_ID, MMIENG_BT_NOSIGNAL_CTRL7_ID),  
	//fifth ctrl tx power type 0 or 1
	CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_BT_NOSIGNAL_CTRL4_ID,MMIENG_FORM_CTRL_ID),
	CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_BT_NOSIGNAL_LABEL_CTRL4_ID, MMIENG_BT_NOSIGNAL_CTRL4_ID),
	CHILD_SETLIST_CTRL(TRUE, MMIENG_BT_NOSIGNAL_EDIT_CTRL4_ID, MMIENG_BT_NOSIGNAL_CTRL4_ID),
	//tx power value 0-33
	CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_BT_NOSIGNAL_CTRL5_ID,MMIENG_FORM_CTRL_ID),
	CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_BT_NOSIGNAL_LABEL_CTRL5_ID, MMIENG_BT_NOSIGNAL_CTRL5_ID),
	CHILD_EDIT_DIGITAL_CTRL(TRUE, 5,MMIENG_BT_NOSIGNAL_EDIT_CTRL5_ID, MMIENG_BT_NOSIGNAL_CTRL5_ID),  
	//tx pac Cnt 0-65536
	CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_BT_NOSIGNAL_CTRL6_ID,MMIENG_FORM_CTRL_ID),
	CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_BT_NOSIGNAL_LABEL_CTRL6_ID, MMIENG_BT_NOSIGNAL_CTRL6_ID),
	CHILD_EDIT_DIGITAL_CTRL(TRUE, 5,MMIENG_BT_NOSIGNAL_EDIT_CTRL6_ID, MMIENG_BT_NOSIGNAL_CTRL6_ID),  

	WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
	END_WIN
};

WINDOW_TABLE(MMIENG_BT_NOSIGNAL_BLE_RX_INFO_TAB) = 
{
    WIN_HIDE_STATUS,
	WIN_FUNC((uint32)EngBTBleRXInforWinHandleMsg),
	WIN_ID(MMIENG_BT_NOSIGNAL_RX_INFO_WIN_ID),
	WIN_TITLE(TXT_ENG_ENTER_BT_NOSIGNAL_BLE_RX),

	WIN_SOFTKEY(TXT_BT_NOSIGNAL_UPDATE, TXT_NULL, STXT_RETURN),
	//    CREATE_LISTBOX_CTRL(GUILIST_TYPE_NONE, MMIENG_BT_NOSIGNAL_INFO_CTRL_ID),
	CREATE_TEXT_CTRL(MMIENG_BT_NOSIGNAL_INFO_CTRL_ID),
	END_WIN
};

WINDOW_TABLE(MMIENG_BT_NOSIGNAL_BLE_RX_TAB) = 
{
    WIN_HIDE_STATUS,
	WIN_FUNC((uint32)EngBTNoSignalBLERxWinHandleMsg),
	WIN_ID(MMIENG_BT_NOSIGNAL_BLE_RX_WIN_ID),
	WIN_TITLE(TXT_ENG_ENTER_BT_NOSIGNAL_BLE_RX),

	CREATE_FORM_CTRL(GUIFORM_LAYOUT_ORDER,MMIENG_FORM_CTRL_ID), 

	//Rx Mod_Index
	CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_BT_NOSIGNAL_CTRL1_ID,MMIENG_FORM_CTRL_ID),
	CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_BT_NOSIGNAL_LABEL_CTRL1_ID, MMIENG_BT_NOSIGNAL_CTRL1_ID),
	CHILD_SETLIST_CTRL(TRUE, MMIENG_BT_NOSIGNAL_EDIT_CTRL1_ID, MMIENG_BT_NOSIGNAL_CTRL1_ID),

	//Rx LE_PHY
	CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_BT_NOSIGNAL_CTRL2_ID,MMIENG_FORM_CTRL_ID),
	CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_BT_NOSIGNAL_LABEL_CTRL2_ID, MMIENG_BT_NOSIGNAL_CTRL2_ID),
	CHILD_SETLIST_CTRL(TRUE, MMIENG_BT_NOSIGNAL_EDIT_CTRL2_ID, MMIENG_BT_NOSIGNAL_CTRL2_ID),

	//Rx channel
	CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_BT_NOSIGNAL_CTRL7_ID,MMIENG_FORM_CTRL_ID),
	CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_BT_NOSIGNAL_LABEL_CTRL7_ID, MMIENG_BT_NOSIGNAL_CTRL7_ID),
	CHILD_EDIT_DIGITAL_CTRL(TRUE, 5,MMIENG_BT_NOSIGNAL_EDIT_CTRL7_ID, MMIENG_BT_NOSIGNAL_CTRL7_ID),  
	//Rx pac type
	CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_BT_NOSIGNAL_CTRL8_ID,MMIENG_FORM_CTRL_ID),
	CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_BT_NOSIGNAL_LABEL_CTRL8_ID, MMIENG_BT_NOSIGNAL_CTRL8_ID),
	CHILD_SETLIST_CTRL(TRUE, MMIENG_BT_NOSIGNAL_EDIT_CTRL8_ID, MMIENG_BT_NOSIGNAL_CTRL8_ID),

	//RX Gain value 0-5
	CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_BT_NOSIGNAL_CTRL9_ID,MMIENG_FORM_CTRL_ID),
	CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_BT_NOSIGNAL_LABEL_CTRL9_ID, MMIENG_BT_NOSIGNAL_CTRL9_ID),
	CHILD_EDIT_DIGITAL_CTRL(TRUE, 5,MMIENG_BT_NOSIGNAL_EDIT_CTRL9_ID, MMIENG_BT_NOSIGNAL_CTRL9_ID),  
	//Rx Addr input 12 bit addr
	CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_BT_NOSIGNAL_CTRL10_ID,MMIENG_FORM_CTRL_ID),
	CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_BT_NOSIGNAL_LABEL_CTRL10_ID, MMIENG_BT_NOSIGNAL_CTRL10_ID),
	CHILD_EDIT_TEXT_CTRL(TRUE,12,MMIENG_BT_NOSIGNAL_EDIT_CTRL10_ID,MMIENG_BT_NOSIGNAL_CTRL10_ID),

	WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
	END_WIN
};
WINDOW_TABLE(MMIENG_BT_BQB_MODE_TAB) =
{
    WIN_HIDE_STATUS,
	WIN_FUNC((uint32)BTBQBModeWinHandleMsg),
	WIN_ID(MMIENG_BT_VER_INFO_WIN_ID),
	WIN_TITLE(TXT_ENG_BT_BQB_MODE),
	WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
	CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
	END_WIN
};
#endif

#ifdef FM_SUPPORT
//ENG_FM_START
WINDOW_TABLE(MMIENG_SHOW_FM_STATE_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngShowFmStateWinHandleMsg),
    WIN_ID(MMIENG_SHOW_FM_STATE_WIN_ID),
    WIN_TITLE(TXT_ENG_FM_OBSERVE_STATE),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_TEXT_CTRL(MMIENG_TEXTBOX1_CTRL_ID),
    END_WIN
};
WINDOW_TABLE(MMIENG_FM_REG_MODE_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngFmRegModeWinHandleMsg),
    WIN_ID(MMIENG_FM_REG_MODE_WIN_ID),
    WIN_TITLE(TXT_ENG_FM_REG_MODE),
    WIN_SOFTKEY(TXT_ENG_FM_WRITE, TXT_ENG_FM_READ, STXT_RETURN),
    CREATE_FORM_CTRL(GUIFORM_LAYOUT_ORDER, MMIENG_FM_REG_MODE_FORM_CTRL_ID),
    CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_FM_REG_MODE_LABEL_1_CTRL_ID, MMIENG_FM_REG_MODE_FORM_CTRL_ID),
    CHILD_EDIT_TEXT_CTRL(TRUE,MMIENG_FM_TEST_PARAM_MAX_LEN,MMIENG_FM_REG_MODE_PARAM_1_EDIT_CTRL_ID,MMIENG_FM_REG_MODE_FORM_CTRL_ID),
    CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_FM_REG_MODE_LABEL_2_CTRL_ID, MMIENG_FM_REG_MODE_FORM_CTRL_ID),
    CHILD_EDIT_TEXT_CTRL(TRUE,MMIENG_FM_TEST_PARAM_MAX_LEN,MMIENG_FM_REG_MODE_PARAM_2_EDIT_CTRL_ID, MMIENG_FM_REG_MODE_FORM_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_FM_DATA_CAPTURE_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngFmDataCaptureWinHandleMsg),
    WIN_ID(MMIENG_FM_DATA_CAPTURE_WIN_ID),
    WIN_TITLE(TXT_ENG_FM_DATA_CAPTURE),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_FORM_CTRL(GUIFORM_LAYOUT_ORDER, MMIENG_FM_DATA_CAPTURE_FORM_CTRL_ID),
    CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_FM_DATA_CAPTURE_LABEL_1_CTRL_ID, MMIENG_FM_DATA_CAPTURE_FORM_CTRL_ID),
    CHILD_EDIT_TEXT_CTRL(TRUE,MMIENG_FM_TEST_PARAM_MAX_LEN,MMIENG_FM_DATA_CAPTURE_PARAM_1_EDIT_CTRL_ID,MMIENG_FM_DATA_CAPTURE_FORM_CTRL_ID),
    CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_FM_DATA_CAPTURE_LABEL_2_CTRL_ID, MMIENG_FM_DATA_CAPTURE_FORM_CTRL_ID),
    CHILD_EDIT_TEXT_CTRL(TRUE,MMIENG_FM_TEST_PARAM_MAX_LEN,MMIENG_FM_DATA_CAPTURE_PARAM_2_EDIT_CTRL_ID, MMIENG_FM_DATA_CAPTURE_FORM_CTRL_ID),
    END_WIN
};


WINDOW_TABLE(MMIENG_FM_CHANNEL_SET_TAB) = 
{
    WIN_HIDE_STATUS,
	WIN_FUNC((uint32)EngFMSetChannelTestWinHandleMsg),
	WIN_ID(MMIENG_FM_CHANNEL_SET_WIN_ID),
	WIN_TITLE(TXT_ENG_FM_CHANNEL_SET),

	CREATE_FORM_CTRL(GUIFORM_LAYOUT_ORDER,MMIENG_FORM_CTRL_ID), 

	//FM channel and Earphone or Extroverted 
	CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_COMMON_CTRL1_ID,MMIENG_FORM_CTRL_ID),
	CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL1_ID, MMIENG_COMMON_CTRL1_ID),
	CHILD_EDIT_TEXT_CTRL(TRUE,12,MMIENG_COMMON_EDIT_CTRL1_ID,MMIENG_COMMON_CTRL1_ID),

	//CHILD_LIST_CTRL(TRUE, GUILIST_TEXTLIST_E, MMIENG_TEXTBOX1_CTRL_ID, MMIENG_FORM_CTRL_ID),

	//Switch
	CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_COMMON_CTRL2_ID,MMIENG_FORM_CTRL_ID),
	CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL2_ID, MMIENG_COMMON_CTRL2_ID),
	CHILD_EDIT_DIGITAL_CTRL(TRUE, 5,MMIENG_COMMON_EDIT_CTRL2_ID, MMIENG_COMMON_CTRL2_ID),  

	//FM RDS BLER
	//CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_COMMON_CTRL3_ID,MMIENG_FORM_CTRL_ID),
	CHILD_LIST_CTRL(TRUE, GUILIST_TEXTLIST_E, MMIENG_COMMON_EDIT_CTRL3_ID, MMIENG_FORM_CTRL_ID),
	
	WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
	END_WIN
};

WINDOW_TABLE(MMIENG_SHOW_FM_RDS_BLER_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngShowFMRdsBler_WINMsg),
    WIN_ID(MMIENG_FM_BLER_SHOW_WIN_ID),
    WIN_TITLE(TXT_ENG_FM_RDS_BLER_SET),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    
    CREATE_TEXT_CTRL(MMIENG_3RDPARTY_VERSION_CTRL_ID),
                
    END_WIN
};


WINDOW_TABLE(MMIENG_SHOW_FM_NOISE_SCAN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngFMNoiseScanWinHandleMsg),
    WIN_ID(MMIENG_FM_NOISE_SCAN_WIN_ID),
    WIN_TITLE(TXT_ENG_FM_NOISE_SCAN),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),

    CREATE_FORM_CTRL(GUIFORM_LAYOUT_ORDER,MMIENG_FORM_CTRL_ID), 

     //Start freqency
    CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_COMMON_CTRL4_ID,MMIENG_FORM_CTRL_ID),
    CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL4_ID, MMIENG_COMMON_CTRL4_ID),
    CHILD_EDIT_TEXT_CTRL(TRUE, 5,MMIENG_COMMON_EDIT_CTRL4_ID, MMIENG_COMMON_CTRL4_ID),  

    //End freqency
    CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_COMMON_CTRL5_ID,MMIENG_FORM_CTRL_ID),
    CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL5_ID, MMIENG_COMMON_CTRL5_ID),
    CHILD_EDIT_TEXT_CTRL(TRUE, 5,MMIENG_COMMON_EDIT_CTRL5_ID, MMIENG_COMMON_CTRL5_ID),  

    //Time
    CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_COMMON_CTRL6_ID,MMIENG_FORM_CTRL_ID),
    CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL6_ID, MMIENG_COMMON_CTRL6_ID),
    CHILD_EDIT_DIGITAL_CTRL(TRUE, 5,MMIENG_COMMON_EDIT_CTRL6_ID, MMIENG_COMMON_CTRL6_ID), 
    
    END_WIN
};


WINDOW_TABLE(MMIENG_SHOW_FM_NOISE_SCAN_SHOW_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngFMNoiseScanShowWinHandleMsg),
    WIN_ID(MMIENG_FM_NOISE_SCAN_SHOW_WIN_ID),
    WIN_TITLE(TXT_ENG_FM_NOISE_SCAN),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),

    CREATE_LISTBOX_CTRL(GUILIST_TEXTLIST_E, MMIENG_BT_NOSIGNAL_TESTCTRL_ID),
	
    END_WIN
};


WINDOW_TABLE(MMIENG_SHOW_FM_TUNE_MODE_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngFMTuneModeWinHandleMsg),
    WIN_ID(MMIENG_FM_TUNE_MODE_WIN_ID),
    WIN_TITLE(TXT_ENG_FM_TUNE_MODE),
    WIN_SOFTKEY(TXT_ENG_COMMON_SET, TXT_ENG_COMMON_GET, STXT_RETURN),
    
     CREATE_FORM_CTRL(GUIFORM_LAYOUT_ORDER,MMIENG_FORM_CTRL_ID), 
     //rssi threshold
    CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_COMMON_CTRL7_ID,MMIENG_FORM_CTRL_ID),
    CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL7_ID, MMIENG_COMMON_CTRL7_ID),
    CHILD_EDIT_DIGITAL_CTRL(TRUE, 5,MMIENG_COMMON_EDIT_CTRL7_ID, MMIENG_COMMON_CTRL7_ID),  

     //snr threshold
    CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_COMMON_CTRL8_ID,MMIENG_FORM_CTRL_ID),
    CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL8_ID, MMIENG_COMMON_CTRL8_ID),
    CHILD_EDIT_DIGITAL_CTRL(TRUE, 5,MMIENG_COMMON_EDIT_CTRL8_ID, MMIENG_COMMON_CTRL8_ID),  

     //freq offset threshold 
    CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_COMMON_CTRL9_ID,MMIENG_FORM_CTRL_ID),
    CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL9_ID, MMIENG_COMMON_CTRL9_ID),
    CHILD_EDIT_TEXT_CTRL(TRUE,12,MMIENG_COMMON_EDIT_CTRL9_ID,MMIENG_COMMON_CTRL9_ID),

    //pilot power  threshold
    CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_COMMON_CTRL10_ID,MMIENG_FORM_CTRL_ID),
    CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL10_ID, MMIENG_COMMON_CTRL10_ID),
    CHILD_EDIT_TEXT_CTRL(TRUE,12,MMIENG_COMMON_EDIT_CTRL10_ID,MMIENG_COMMON_CTRL10_ID),

    //noise power threshold
    CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_COMMON_CTRL11_ID,MMIENG_FORM_CTRL_ID),
    CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL11_ID, MMIENG_COMMON_CTRL11_ID),
    CHILD_EDIT_TEXT_CTRL(TRUE,12,MMIENG_COMMON_EDIT_CTRL11_ID,MMIENG_COMMON_CTRL11_ID),
                
    END_WIN
};


WINDOW_TABLE(MMIENG_SHOW_FM_AUDIO_MODE_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngFMAudioModeWinHandleMsg),
    WIN_ID(MMIENG_FM_AUDIO_MODE_WIN_ID),
    WIN_TITLE(TXT_ENG_FM_AUDIO_MODE),
    WIN_SOFTKEY(TXT_ENG_COMMON_SET, TXT_ENG_COMMON_GET, STXT_RETURN),

    CREATE_FORM_CTRL(GUIFORM_LAYOUT_ORDER,MMIENG_FORM_CTRL_ID), 
    //sofemute hbound 
    CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_COMMON_CTRL7_ID,MMIENG_FORM_CTRL_ID),
    CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL7_ID, MMIENG_COMMON_CTRL7_ID),
    CHILD_EDIT_DIGITAL_CTRL(TRUE, 5,MMIENG_COMMON_EDIT_CTRL7_ID, MMIENG_COMMON_CTRL7_ID),  
    
    //softmute lbbound
    CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_COMMON_CTRL8_ID,MMIENG_FORM_CTRL_ID),
    CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL8_ID, MMIENG_COMMON_CTRL8_ID),
    CHILD_EDIT_DIGITAL_CTRL(TRUE, 5,MMIENG_COMMON_EDIT_CTRL8_ID, MMIENG_COMMON_CTRL8_ID),  
    
    //power threshold
    CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_COMMON_CTRL9_ID,MMIENG_FORM_CTRL_ID),
    CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL9_ID, MMIENG_COMMON_CTRL9_ID),
    CHILD_EDIT_DIGITAL_CTRL(TRUE, 5,MMIENG_COMMON_EDIT_CTRL9_ID, MMIENG_COMMON_CTRL9_ID),  
    
    //Retardation coefficient 
    CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_COMMON_CTRL10_ID,MMIENG_FORM_CTRL_ID),
    CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL10_ID, MMIENG_COMMON_CTRL10_ID),
    CHILD_EDIT_DIGITAL_CTRL(TRUE, 5,MMIENG_COMMON_EDIT_CTRL10_ID, MMIENG_COMMON_CTRL10_ID),  
    
    //snr threshold
    CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_COMMON_CTRL11_ID,MMIENG_FORM_CTRL_ID),
    CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL11_ID, MMIENG_COMMON_CTRL11_ID),
    CHILD_EDIT_DIGITAL_CTRL(TRUE, 5,MMIENG_COMMON_EDIT_CTRL11_ID, MMIENG_COMMON_CTRL11_ID),  
               
    END_WIN
};

//ENG_FM_END
#endif
//HardWare 

WINDOW_TABLE(MMIENG_HARDWARE_VIBRATE_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
	WIN_FUNC((uint32)EngHardWareVibTestWinHandleMsg),
	WIN_ID(MMIENG_WAITING_WIN_ID),
	WIN_TITLE(TXT_ENG_HARD_VIBTEST_TITLE),//TXT_ENG_UIVIBRATE_TITLE
	CREATE_TEXT_CTRL( MMIENG_UITEST_TEXT_CTRL_ID),
	WIN_SOFTKEY(TXT_ENG_OK , TXT_NULL, STXT_RETURN),
	END_WIN
};

WINDOW_TABLE(MMIENG_HARDWARE_CAM_LCD_INFO_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
	WIN_FUNC((uint32)EngHardWareCamLcdInfoWinHandleMsg),
	WIN_ID(MMIENG_WAITING_WIN_ID),
	WIN_TITLE(TXT_ENG_CAMERA_LCD_INFO_TITLE),//TXT_ENG_UIVIBRATE_TITLE
	WIN_SOFTKEY(TXT_ENG_OK , TXT_NULL, STXT_RETURN),
      CREATE_TEXT_CTRL(MMIENG_SHOW_VERSION_CTRL_ID),
	END_WIN
};

WINDOW_TABLE( MMIENG_HARDWARE_CAM_POW_TEST_MODE_WIN_TAB ) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC( (uint32)EngHardWareCamPowTestWinHandleMsg ),
    WIN_ID( MMIENG_WAITING_WIN_ID ),
    WIN_TITLE(TXT_ENG_CAM_POW_TEST_MODE_TITLE),
    WIN_SOFTKEY(NULL, TXT_ENG_OK, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_COMMON_CTRL1_ID),
    END_WIN
};
//Debug & Log
WINDOW_TABLE( MMIENG_DEBUG_GPRS_ATTACH_SER_WIN_TAB ) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC( (uint32)EngDebugGprsAttachSerWinHandleMsg ),
    WIN_ID( MMIENG_WAITING_WIN_ID ),
    WIN_TITLE(TXT_ENG_DEB_GPRS_ATTACH_SERVICE),
    WIN_SOFTKEY(NULL, TXT_ENG_OK, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_COMMON_CTRL1_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_DEBUG_THERMAL_SWITCH_WIN_TAB ) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC( (uint32)EngDebugThermalSwitchWinHandleMsg ),
    WIN_ID( MMIENG_WAITING_WIN_ID ),
    WIN_TITLE(TXT_ENG_DEB_THERMAL_SWITCH),
    WIN_SOFTKEY(NULL, TXT_ENG_OK, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_COMMON_CTRL1_ID),
    END_WIN
 };

//APR Start
WINDOW_TABLE( MMIENG_DEBUG_APR_WIN_TAB ) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC( (uint32)EngDebugAPRWinHandleMsg ),
    WIN_ID( MMIENG_DEBUG_APR_WIN_ID ),
    WIN_TITLE(TXT_ENG_DEB_APR_SET),
    WIN_SOFTKEY(NULL, TXT_ENG_OK, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_CHECKLIST_E, MMIENG_COMMON_CTRL1_ID),
    END_WIN
};

WINDOW_TABLE( MMIENG_DEBUG_APR_SERVER_WIN_TAB ) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC( (uint32)EngDebugAPRServerWinHandleMsg ),
    WIN_ID( MMIENG_DEBUG_APR_SER_WIN_ID ),
    WIN_TITLE(TXT_ENG_DEB_APR_SERVER),
    WIN_SOFTKEY(NULL, TXT_ENG_OK, STXT_RETURN),
    CREATE_FORM_CTRL(GUIFORM_LAYOUT_ORDER,MMIENG_COMMON_CTRL1_ID),
    
	 CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_COMMON_CTRL2_ID,MMIENG_COMMON_CTRL1_ID),
	       CHILD_SOFTKEY_CTRL(NULL, TXT_ENG_OK, STXT_RETURN, MMICOMMON_SOFTKEY_CTRL_ID, MMIENG_COMMON_CTRL2_ID),
		CHILD_LIST_CTRL(TRUE, GUILIST_CHECKLIST_E, MMIENG_COMMON_EDIT_CTRL2_ID, MMIENG_COMMON_CTRL2_ID),
	 CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_COMMON_CTRL3_ID,MMIENG_COMMON_CTRL1_ID),
		CHILD_LIST_CTRL(TRUE, GUILIST_CHECKLIST_E, MMIENG_COMMON_EDIT_CTRL3_ID, MMIENG_COMMON_CTRL3_ID),
	
    END_WIN
};

WINDOW_TABLE(MMIENG_DEBUG_APR_GROUP_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
	WIN_FUNC((uint32)EngDebugAPRGroupWinHandleMsg),
	WIN_ID(MMIENG_DEBUG_APR_GROUP_WIN_ID),
	WIN_TITLE(TXT_ENG_DEB_APR_GROUP),

	CREATE_FORM_CTRL(GUIFORM_LAYOUT_ORDER,MMIENG_FORM_CTRL_ID), 

	// Select CSSLAB CSFLAB CSFT Beta
	CHILD_LIST_CTRL(TRUE, GUILIST_TEXTLIST_E, MMIENG_COMMON_EDIT_CTRL5_ID, MMIENG_FORM_CTRL_ID),

	//Input group manually
	CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_COMMON_CTRL4_ID,MMIENG_FORM_CTRL_ID),
	CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL4_ID, MMIENG_COMMON_CTRL4_ID),
	CHILD_EDIT_TEXT_CTRL(TRUE,12,MMIENG_COMMON_EDIT_CTRL4_ID,MMIENG_COMMON_CTRL4_ID),

	WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
	END_WIN
};

//view log 
WINDOW_TABLE(MMIENG_DEBUG_APR_VIEW_LOG_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
	WIN_FUNC((uint32)EngDebugAPRViewLogWinHandleMsg),
	WIN_ID(MMIENG_DEBUG_APR_VIEW_LOG_WIN_ID),
	WIN_TITLE(TXT_ENG_DEB_APR_VIEW_LOG),

	WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
	CREATE_TEXT_CTRL(MMIENG_COMMON_EDIT_CTRL6_ID),
	END_WIN
};


//Detect time
WINDOW_TABLE( MMIENG_DEBUG_APR_DETECT_TIME_WIN_TAB ) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC( (uint32)EngDebugAPRDetectTimeWinHandleMsg ),    
    WIN_ID( MMIENG_DEBUG_APR_DETECT_TIME_WIN_ID ),
    WIN_TITLE( TXT_ENG_DEB_APR_DETECT_TIME ), //cr227782 maryxiao
    CREATE_EDIT_DIGITAL_CTRL(5,MMIENG_COMMON_EDIT_CTRL4_ID),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    END_WIN
};

//APR End

WINDOW_TABLE(MMIENG_CHIP_TEST_WIN_TAB) = 
{
    //CLEAR_LCD,
    //WIN_PRIO( WIN_ONE_LEVEL ),
    WIN_FUNC( (uint32)HandleChipTestMenuWinMsg ),    
    WIN_ID( MMIENG_CHIP_TEST_MENU_WIN_ID ),
    WIN_TITLE(TXT_ENG_CHIP_TEST),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_MENU_CTRL(MENU_CHIP_TEST, MMIENG_CHIP_TEST_MENU_CTRL_ID),
    END_WIN
};


#ifdef CMMB_SUPPORT

//工厂测试、研发调试
WINDOW_TABLE(MMIENG_CMMB_TEST_MAIN_WIN_TAB) = 
{
    //CLEAR_LCD,
    //WIN_PRIO( WIN_ONE_LEVEL ),
    WIN_FUNC( (uint32)HandleCMMBTestMainMenuWinMsg ),    
        WIN_ID( MMIENG_CMMB_TEST_MENU_WIN_ID ),
        WIN_TITLE(TXT_ENG_CMMB_TEST),
        WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
        CREATE_MENU_CTRL(MENU_CMMB_MAIN, MMIENG_CMMB_TEST_MENU_CTRL_ID),
        END_WIN
};

//研发调试：IQ数据、Display
WINDOW_TABLE(MMIENG_CMMB_RD_TEST_WIN_TAB) = 
{
    //CLEAR_LCD,
    //WIN_PRIO( WIN_ONE_LEVEL ),
    WIN_FUNC( (uint32)HandleCMMBRDTestMenuWinMsg ),    
        WIN_ID( MMIENG_CMMB_RD_TEST_MENU_WIN_ID ),
        WIN_TITLE(TXT_ENG_CMMB_RD_TEST),
        WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
        CREATE_MENU_CTRL(MENU_CMMB_RD_TEST, MMIENG_CMMB_RD_TEST_MENU_CTRL_ID),
        END_WIN
};

//工厂测试：有信号测试、无信号测试
WINDOW_TABLE(MMIENG_CMMB_FACTORY_TEST_WIN_TAB) = 
{
    //CLEAR_LCD,
    //WIN_PRIO( WIN_ONE_LEVEL ),
    WIN_FUNC( (uint32)HandleCMMBFactoryTestMenuWinMsg ),    
        WIN_ID( MMIENG_CMMB_FACTORY_TEST_MENU_WIN_ID ),
        WIN_TITLE(TXT_ENG_CMMB_FACTORY_TEST),
        WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
        CREATE_MENU_CTRL(MENU_CMMB_FACTORY_TEST, MMIENG_CMMB_FACTORY_TEST_MENU_CTRL_ID),
        END_WIN
};

//有信号测试
WINDOW_TABLE(MMIENG_CMMB_OK_SIGNAL_WIN_TAB) = 
{
    //CLEAR_LCD,
    //WIN_PRIO( WIN_ONE_LEVEL ),
    WIN_FUNC( (uint32)HandleCMMBTestOKSignalMenuWinMsg ),    
        WIN_ID( MMIENG_CMMB_HAVE_SIGNAL_MENU_WIN_ID ),
        WIN_TITLE(TXT_ENG_CMMB_FACTORY_HAVE_SIGNAL),
        WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
        CREATE_MENU_CTRL(MENU_CMMB_OK_SIGNAL, MMIENG_CMMB_FACTORY_HAVE_SIGNAL_MENU_CTRL_ID),
        END_WIN
};

//无信号测试: RF测试、解码测试
WINDOW_TABLE(MMIENG_CMMB_NO_SIGNAL_WIN_TAB) = 
{
    //CLEAR_LCD,
    //WIN_PRIO( WIN_ONE_LEVEL ),
    WIN_FUNC( (uint32)HandleCMMBTestNoSignalMenuWinMsg ),    
        WIN_ID( MMIENG_CMMB_NO_SIGNAL_MENU_WIN_ID ),
        WIN_TITLE(TXT_ENG_CMMB_FACTORY_NO_SIGNAL),
        WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
        CREATE_MENU_CTRL(MENU_CMMB_NO_SIGNAL, MMIENG_CMMB_FACTORY_NO_SIGNAL_MENU_CTRL_ID),
        END_WIN
};

WINDOW_TABLE(MMIENG_CMMB_SN_WIN_TAB) = 
{
    //CLEAR_LCD,
    //WIN_PRIO( WIN_ONE_LEVEL ),
    WIN_FUNC( (uint32)HandleCMMBSerialNumberWinMsg ),    
    WIN_ID( MMIENG_CMMB_SN_WIN_ID ),
    WIN_TITLE(TXT_ENG_CMMB_SN_NO),
    WIN_SOFTKEY(TXT_NULL, TXT_NULL, STXT_RETURN),
    CREATE_TEXT_CTRL(MMIENG_CMMB_SN_TEXT_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_CMMB_DISPLAY_WIN_TAB) = 
{
    //CLEAR_LCD,
    //WIN_PRIO( WIN_ONE_LEVEL ),
    WIN_FUNC( (uint32)HandleCMMBDisplayWinMsg ),    
    WIN_ID( MMIENG_CMMB_DISPLAY_WIN_ID ),
    WIN_TITLE(TXT_ENG_CMMB_DISPLAY),
    WIN_SOFTKEY(TXT_NULL, TXT_NULL, STXT_RETURN),
    CREATE_TEXT_CTRL(MMIENG_CMMB_TEXT_CTRL_ID),
    END_WIN
};

#ifdef MBBMS_SUPPORT

#ifdef DEMOD_HW_SIANO
WINDOW_TABLE(MMIENG_LOG_CONTROL_ENABLE_WIN_TAB) = 
{
    //CLEAR_LCD,
    //WIN_PRIO( WIN_ONE_LEVEL ),
    WIN_FUNC((uint32)HandleLOGControlEnableWinMsg),
    WIN_ID(MMIENG_SIANO_LOG_CONTROL_WIN_ID),
    WIN_TITLE(TXT_ENG_MBBMS_MSK),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LOG_ENABLE_CONTROL_CTRL_ID),
    END_WIN
};
#endif
WINDOW_TABLE(MMIENG_INTERFACE_TEST_ENABLE_WIN_TAB) = 
{
    //CLEAR_LCD,
    //WIN_PRIO( WIN_ONE_LEVEL ),
    WIN_FUNC((uint32)HandleInterfaceTestEnableWinMsg),
    WIN_ID(MMIENG_GBA_AND_MSK_ENABLE_WIN_ID),
    WIN_TITLE(TXT_ENG_MBBMS_INTERFACE_TEST),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_GBA_AND_MSK_TEST_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_SMD_COUNTER_ENABLE_WIN_TAB) = 
{
    //CLEAR_LCD,
    //WIN_PRIO( WIN_ONE_LEVEL ),
    WIN_FUNC((uint32)HandleSMDCounterEnableWinMsg),
    WIN_ID(MMIENG_SMD_COUNTER_ENABLE_WIN_ID),
    WIN_TITLE(TXT_ENG_MBBMS_SMD_COUNTER),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_SMD_COUNTER_ENABLE_CTRL_ID),
    END_WIN
};
#endif
WINDOW_TABLE(MMIENG_AUDIO_SERVICE_ENABLE_WIN_TAB) = 
{
    //CLEAR_LCD,
    //WIN_PRIO( WIN_ONE_LEVEL ),
    WIN_FUNC((uint32)HandleAudioServiceEnableWinMsg),
    WIN_ID(MMIENG_AUDIO_SERVICE_ENABLE_WIN_ID),
    WIN_TITLE(TXT_ENG_MBBMS_AUDIO_SERVICE),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_AUDIO_SERVICE_ENABLE_CTRL_ID),
    END_WIN
};
WINDOW_TABLE(MMIENG_MTV_LOG_SWITCH_WIN_TAB) = 
{
    WIN_FUNC((uint32)EngMtvLOGSwitchWinHandleMsg),
    WIN_ID(MMIENG_MTV_LOG_SWITCH_WIN_ID),
    WIN_TITLE(TXT_ENG_MTV_LOG_SWITCH),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};
WINDOW_TABLE(MMIENG_MTV_LOG_TO_BB_SWITCH_WIN_TAB) = 
{
    WIN_FUNC((uint32)EngMtvLOGToBBSwitchWinHandleMsg),
    WIN_ID(MMIENG_MTV_LOG_TO_BB_SWITCH_WIN_ID),
    WIN_TITLE(TXT_ENG_MTV_LOG_TO_BB_SWITCH),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};
WINDOW_TABLE(MMIENG_MTV_LOG_STORAGE_WIN_TAB) = 
{
    WIN_FUNC((uint32)EngMtvLOGStorageWinHandleMsg),
    WIN_ID(MMIENG_MTV_LOG_STORAGE_WIN_ID),
    WIN_TITLE(TXT_ENG_MTV_LOG_STORAGE_SELECT),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};

#endif

#ifdef TF_LOAD_SUPPORT
WINDOW_TABLE(MMIENG_TFLOAD_WIN_TAB) = 
{
    //CLEAR_LCD,
       //WIN_PRIO( WIN_ONE_LEVEL ),
    WIN_FUNC( (uint32)HandleTFLoadWinMsg),
    WIN_ID( MMIENG_TFLOAD_WIN_ID ),
#ifdef MMI_PDA_SUPPORT
    WIN_STYLE(WS_HAS_BUTTON_SOFTKEY),
#endif
    WIN_TITLE(TXT_ENG_TF_UPDATE),
    CREATE_TEXT_CTRL(MMIENG_TEXTBOX1_CTRL_ID),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    END_WIN
};
#endif

WINDOW_TABLE(MMIENG_OTA_WIN_TAB) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC( (uint32)HandleOTAWinMsg),
    WIN_ID( MMIENG_OTA_WIN_ID ),
    WIN_TITLE(TXT_ENG_OTA),
    CREATE_TEXT_CTRL(MMIENG_TEXTBOX1_CTRL_ID),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    END_WIN
};

WINDOW_TABLE(MMIENG_CHIP_TEST_SETTING_WIN_TAB) =
{
    //CLEAR_LCD,
    //WIN_PRIO( WIN_ONE_LEVEL ),
    WIN_FUNC( (uint32)HandleChipTestSettingWinMsg ), 
    WIN_ID( MMIENG_CHIP_TEST_SETTING_WIN_ID ),
    WIN_TITLE(TXT_ENG_POWERON_RUN),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_CHIP_TEST_SETTING_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_CHIP_TEST_PLAYMP3MP4_WIN_TAB) = 
{
    //CLEAR_LCD,
    //WIN_PRIO( WIN_ONE_LEVEL ),
    WIN_FUNC( (uint32)HandleChipTestPlayMp3MP4WinMsg),    
    WIN_ID( MMIENG_CHIP_TEST_PLAYMP3MP4_WIN_ID ),
    WIN_TITLE(TXT_ENG_CHIP_TEST),
    //WIN_SOFTKEY(STXT_OK, TXT_NULL, STXT_RETURN),
    END_WIN
};

WINDOW_TABLE(MMIENG_CHIP_TEST_DC_WIN_TAB) = 
{
    //CLEAR_LCD,
    //WIN_PRIO( WIN_ONE_LEVEL ),
    WIN_FUNC( (uint32)HandleChipTestDCWinMsg),    
    WIN_ID( MMIENG_CHIP_TEST_DCPREVIEW_WIN_ID ),
    WIN_TITLE(TXT_ENG_CHIP_TEST),
    //WIN_SOFTKEY(STXT_OK, TXT_NULL, STXT_RETURN),
    END_WIN
};

WINDOW_TABLE(MMIENG_CHIP_TEST_LOOPBACK_WIN_TAB) = 
{
    //CLEAR_LCD,
    //WIN_PRIO( WIN_ONE_LEVEL ),
    WIN_FUNC((uint32)HandleChipTestLoopBackWinMsg),
    WIN_ID(MMIENG_UITESTLOOPBACK_WIN_ID),
    WIN_TITLE(TXT_ENG_UILOOPBACK_TITLE),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LABEL_CTRL(GUILABEL_ALIGN_MIDDLE, MMIENG_UITEST_LABEL_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_IQ_MODE_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngIQModeWinHandleMsg),
    WIN_ID(MMIENG_IQ_MODE_WIN_ID),
    WIN_TITLE(TXT_ENG_IQ_MODE),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_MENU_CTRL(MENU_IQ_MODE, MMIENG_IQ_MODE_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_IQ_MODE_ONOFF_WIN_TAB) = //开关
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngIQModeOnOffWinHandleMsg),
    WIN_ID(MMIENG_IQ_MODE_ONOFF_WIN_ID),
    WIN_TITLE(TXT_ENG_IQ_MODE_ONOFF),//TXT_ENG_IQ_MODE_ONOFF
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_IQ_DATA_ENABLE_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)HandleIQDataWinMsg),    
    WIN_ID(MMIENG_IQ_DATA_WIN_ID),
    WIN_TITLE(TXT_ENG_IQ_DATA),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_MENU_CTRL(MENU_IQ_DATA_ENABLE, MMIENG_IQ_DATA_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_IQ_DATA_DISABLE_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)HandleIQDataWinMsg),    
    WIN_ID(MMIENG_IQ_DATA_WIN_ID),
    WIN_TITLE(TXT_ENG_IQ_DATA),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_MENU_CTRL(MENU_IQ_DATA_DISABLE, MMIENG_IQ_DATA_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_IQ_DATA_MODE_SELECT_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngIQDataModeSelectWinHandleMsg),
    WIN_ID(MMIENG_IQ_DATA_MODE_SELECT_WIN_ID),
    WIN_TITLE(TXT_ENG_IQ_DATA_MODE_SETTINGS),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_IQ_DATA_MODE_SELECT_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_IQ_DATA_POWER_ON_START_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngIQDataPowerOnStartWinHandleMsg),
    WIN_ID(MMIENG_IQ_DATA_POWER_ON_START_WIN_ID),
    WIN_TITLE(TXT_ENG_IQ_DATA_POWER_ON_START),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_IQ_DATA_MODE_SETTING_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)HandleIQDataModeSettingWinMsg),    
    WIN_ID(MMIENG_IQ_DATA_MODE_SETTING_WIN_ID),
    WIN_TITLE(TXT_ENG_IQ_DATA_MODE_SETTINGS),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_MENU_CTRL(MENU_IQ_DATA_MODE_SETTING, MMIENG_IQ_DATA_MODE_SETTING_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_IQ_DATA_MODE_SETTING_FORMAT_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)HandleIQDataModeSettingFormatWinMsg),    
    WIN_ID( MMIENG_IQ_DATA_MODE_SETTING_FORMAT_WIN_ID),
    WIN_TITLE(TXT_ENG_IQ_DATA_FORMAT_SETTING),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_EDIT_DIGITAL_CTRL(2, MMIENG_IQ_DATA_MODE_SETTING_FORMAT_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_IQ_DATA_MODE_SETTING_TIME_LIMIT_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)HandleIQDataModeSettingTimeLimitWinMsg),    
    WIN_ID( MMIENG_IQ_DATA_MODE_SETTING_TIME_LIMIT_WIN_ID),
    WIN_TITLE(TXT_ENG_IQ_DATA_TIME_LIMIT),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_EDIT_DIGITAL_CTRL(4, MMIENG_IQ_DATA_MODE_SETTING_TIME_LIMIT_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_IQ_DATA_MODE_SETTING_FRAME_LENGTH_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)HandleIQDataModeSettingFrameLengthWinMsg),    
    WIN_ID( MMIENG_IQ_DATA_MODE_SETTING_FRAME_LENGTH_WIN_ID),
    WIN_TITLE(TXT_ENG_IQ_DATA_FRAME_LENGTH),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_EDIT_DIGITAL_CTRL(4, MMIENG_IQ_DATA_MODE_SETTING_FRAME_LENGTH_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_IQ_DATA_MODE_SETTING_BLOCK_COUNT_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)HandleIQDataModeSettingBlockCountWinMsg),    
    WIN_ID( MMIENG_IQ_DATA_MODE_SETTING_BLOCK_COUNT_WIN_ID),
    WIN_TITLE(TXT_ENG_IQ_DATA_BLOCK_COUNT),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_EDIT_DIGITAL_CTRL(2, MMIENG_IQ_DATA_MODE_SETTING_BLOCK_COUNT_CTRL_ID),
    END_WIN
};

/*[START] Jerry Liang for IQ MODE 2008/07/31*/        
WINDOW_TABLE(MMIENG_IQ_DATA_MODE_SETTING_ARFCN_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)HandleIQDataModeSettingARFCNWinMsg),    
    WIN_ID( MMIENG_IQ_DATA_MODE_SETTING_ARFCN_WIN_ID),
    WIN_TITLE(TXT_ENG_IQ_DATA_ARFCN),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_EDIT_DIGITAL_CTRL(4, MMIENG_IQ_DATA_MODE_SETTING_ARFCN_CTRL_ID),
    END_WIN
};
/*[END] Jerry Liang for IQ MODE 2008/07/31*/        

WINDOW_TABLE(MMIENG_IQ_DATA_MODE_SETTING_CHANNEL_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)HandleIQDataModeSettingChannelWinMsg),
    WIN_ID(MMIENG_IQ_DATA_MODE_SETTING_CHANNEL_WIN_ID),
    WIN_TITLE(TXT_ENG_IQ_DATA_CHANNEL_SETTING),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_IQ_DATA_MODE_SETTING_CHANNEL_CTRL_ID),
    END_WIN
};

//the window for handle query
WINDOW_TABLE(MMIENG_HANDLE_QUERY_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)HandleIQDataQueryWin),    
    WIN_TITLE(TXT_NULL),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    WIN_ID(MMIENG_IQ_DATA_HANDLE_QUERY_WIN_ID),
    END_WIN
};

#ifdef  CAMERA_SUPPORT
WINDOW_TABLE(MMIENG_DC_PARAM_SCREEN_SIZE_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)HandleDCParamScreenSizeWinMsg),
    WIN_ID(MMIENG_DCPARAM_SCREENSIZE_WIN_ID),
    WIN_TITLE(TXT_ENG_DC_PARAM_SCREEN_SIZE),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_DC_PARAM_SCREEN_SWITCH_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)HandleDCParamScreenSwitchWinMsg),
    WIN_ID(MMIENG_DCPARAM_SCREENSWITCH_WIN_ID),
    WIN_TITLE(TXT_ENG_DC_PARAM_SCREEN_SWITCH),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_DC_PARAM_PREV_SET_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)HandleDCParamScreenPrevSetWinMsg),
    WIN_ID(MMIENG_DCPARAM_PREVSET_WIN_ID),
    WIN_TITLE(TXT_ENG_DC_PARAM_PREV_SET),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_DC_PARAM_SENSOR_ANGLE_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)HandleDCParamSensorAngleWinMsg),
    WIN_ID(MMIENG_DCPARAM_SENSOR_ANGLE_WIN_ID),
    WIN_TITLE(TXT_ENG_DC_PARAM_SENSOR_ANGLE),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_DC_PARAM_SENSOR_ID_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)HandleDCParamSensorIDWinMsg),
    WIN_ID(MMIENG_DCPARAM_SENSOR_ID_WIN_ID),
    WIN_TITLE(TXT_SWITCH_SENSOR),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};
#endif

WINDOW_TABLE(MMIENG_UA_AGENT_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)HandleUaAgentWinMsg),
    WIN_ID(MMIENG_UA_AGENT_WIN_ID),
    WIN_TITLE(TXT_ENG_UA_AGENT),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_MENU_CTRL(MENU_UA_SUB, MMIENG_UA_SUB_MENU_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_UA_AGENT_SET_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)HandleUaAgentSetWinMsg),
    WIN_ID(MMIENG_UA_AGENT_SET_WIN_ID),
    WIN_TITLE(TXT_ENG_UA_AGENT),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_UA_SELECT_LISTBOX_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_UA_AGENT_EDIT_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)HandleUaAgentEditWinMsg),
    WIN_ID(MMIENG_UA_AGENT_EDIT_WIN_ID),
    WIN_TITLE(TXT_ENG_UA_AGENT),
#ifdef MMI_PDA_SUPPORT
    WIN_STYLE(WS_HAS_BUTTON_SOFTKEY),
#endif
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_EDIT_TEXT_CTRL(MMIENG_MAX_URL_LEN, MMIENG_UAAGENT_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_UA_AGENT_LIST_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)HandleUaAgentListWinMsg),
    WIN_ID(MMIENG_UA_AGENT_LIST_WIN_ID),
    WIN_TITLE(TXT_ENG_UA_AGENT),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_UA_SELECT_LIST_NUM_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_UA_AGENT_SHOW_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)HandleUaAgentShowWinMsg),
    WIN_ID(MMIENG_UA_AGENT_SHOW_WIN_ID),
    WIN_TITLE(TXT_ENG_UA_AGENT),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_TEXT_CTRL(MMIENG_TEXTBOX1_CTRL_ID),  
    END_WIN
};

WINDOW_TABLE(MMIENG_UA_PROFILE_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)HandleUaProfileWinMsg),
    WIN_ID(MMIENG_UA_PROFILE_WIN_ID),
    WIN_TITLE(TXT_ENG_UA_PROFILE),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_MENU_CTRL(MENU_UA_SUB, MMIENG_UA_SUB_MENU_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_UA_PROFILE_SET_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)HandleUaProfileSetWinMsg),
    WIN_ID(MMIENG_UA_PROFILE_SET_WIN_ID),
    WIN_TITLE(TXT_ENG_UA_PROFILE),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_PROFILE_SELECT_LISTBOX_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_UA_PROFILE_LIST_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)HandleUaProfileListWinMsg),
    WIN_ID(MMIENG_UA_PROFILE_LIST_WIN_ID),
    WIN_TITLE(TXT_ENG_UA_PROFILE),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_PROFILE_SELECT_LIST_NUM_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_UA_PROFILE_SHOW_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)HandleUaProfileShowWinMsg),
    WIN_ID(MMIENG_UA_PROFILE_SHOW_WIN_ID),
    WIN_TITLE(TXT_ENG_UA_PROFILE),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_TEXT_CTRL(MMIENG_TEXTBOX1_CTRL_ID),  
    END_WIN
};


WINDOW_TABLE(MMIENG_UA_PROFILE_EDIT_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)HandleUaProfileEditWinMsg),
    WIN_ID(MMIENG_UA_PROFILE_EDIT_WIN_ID),
    WIN_TITLE(TXT_ENG_UA_PROFILE),
#ifdef MMI_PDA_SUPPORT
    WIN_STYLE(WS_HAS_BUTTON_SOFTKEY),
#endif
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_EDIT_TEXT_CTRL(MMIENG_MAX_URL_LEN, MMIENG_UAPROFILE_CTRL_ID),
    END_WIN
};

#ifdef PCLINK_SUPPORT
WINDOW_TABLE(MMIENG_PCLINK_ENABLE_WIN_TAB) = 
{
    //CLEAR_LCD,
    //WIN_PRIO( WIN_ONE_LEVEL ),
    WIN_FUNC((uint32)HandlePClinkEnableWinMsg),
    WIN_ID(MMIENG_PCLINK_ENABLE_WIN_ID),
    WIN_TITLE(TXT_ENG_PCLINK_ENABLE),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_PCLINK_ENABLE_CTRL_ID),
    END_WIN
};

//the window for input gateway
WINDOW_TABLE(MMIENG_PCLINK_INPUT_IPADDR_WIN_TAB) = 
{
    WIN_FUNC((uint32)HandlePClinkInputIPAddrWinMsg),    
    WIN_ID(MMIENG_PCLINK_INPUT_IPADDR_WIN_ID),
    WIN_TITLE(TXT_ENG_PCLINK_IP),
#ifdef MMI_PDA_SUPPORT
    WIN_STYLE(WS_HAS_BUTTON_SOFTKEY),
#endif
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    //参数为测试用
    CREATE_EDIT_IP_CTRL(MMIENG_PCLINK_INPUT_IPADDR_CTRL_ID),
    END_WIN
};

//the window for input gateway
WINDOW_TABLE(MMIENG_PCLINK_INPUT_SNMASK_WIN_TAB) = 
{
    WIN_FUNC((uint32)HandlePClinkInputSNMaskWinMsg),    
    WIN_ID(MMIENG_PCLINK_INPUT_SNMASK_WIN_ID),
    WIN_TITLE(TXT_ENG_PCLINK_SNMASK),
#ifdef MMI_PDA_SUPPORT
    WIN_STYLE(WS_HAS_BUTTON_SOFTKEY),
#endif
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    //参数为测试用
    CREATE_EDIT_IP_CTRL(MMIENG_PCLINK_INPUT_SNMASK_CTRL_ID),
    END_WIN
};

//the window for input gateway
WINDOW_TABLE(MMIENG_PCLINK_INPUT_DEFGW_WIN_TAB) = 
{
    WIN_FUNC((uint32)HandlePClinkInputDefGWWinMsg),    
    WIN_ID(MMIENG_PCLINK_INPUT_DEFGW_WIN_ID),
    WIN_TITLE(TXT_ENG_PCLINK_DEFGW),
#ifdef MMI_PDA_SUPPORT
    WIN_STYLE(WS_HAS_BUTTON_SOFTKEY),
#endif
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    //参数为测试用
    CREATE_EDIT_IP_CTRL(MMIENG_PCLINK_INPUT_DEFGW_CTRL_ID),
    END_WIN
};

//the window for input gateway
WINDOW_TABLE(MMIENG_PCLINK_INPUT_DNS_WIN_TAB) = 
{
    WIN_FUNC((uint32)HandlePClinkInputDNSWinMsg),    
    WIN_ID(MMIENG_PCLINK_INPUT_DNS_WIN_ID),
    WIN_TITLE(TXT_ENG_PCLINK_DNS),
#ifdef MMI_PDA_SUPPORT
    WIN_STYLE(WS_HAS_BUTTON_SOFTKEY),
#endif
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    //参数为测试用
    CREATE_EDIT_IP_CTRL(MMIENG_PCLINK_INPUT_DNS_CTRL_ID),
    END_WIN
};

//the window for input test address
WINDOW_TABLE(MMIENG_PCLINK_INPUT_TEST_ADDRESS_WIN_TAB) = 
{
    WIN_FUNC((uint32)HandlePCLinkInputTestAdfressWinMsg),    
    WIN_ID(MMIENG_PCLINK_INPUTUSERNAME_WIN_ID),
    WIN_TITLE(TXT_ENG_PCLINK_TEST_ADDR),
#ifdef MMI_PDA_SUPPORT
    WIN_STYLE(WS_HAS_BUTTON_SOFTKEY),
#endif
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    //参数为测试用
    CREATE_EDIT_IP_CTRL(MMIENG_PCLINK_INPUT_TEST_ADDRESS_CTRL_ID),
    END_WIN
};
#endif

//MS00186848
WINDOW_TABLE(MMIENG_CALL_BARRING_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngCallBarringWinHandleMsg),
    WIN_ID(MMIENG_CALL_BARRING_WIN_ID),
    WIN_TITLE(TXT_ENG_CALL_BARRING),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_SET_ANGLE_WIN_TAB) = 
{
    WIN_FUNC((uint32)EngSetAngleWinHandleMsg),
    WIN_ID(MMIENG_SET_ANGLE_WIN_ID),
    WIN_TITLE(TXT_ENG_SET_ANGLE),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E,MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_NV_COUNTING_WIN_TAB) = 
{
        WIN_HIDE_STATUS,
        WIN_FUNC((uint32)HandleRunningNVCountingWinMsg),    
        WIN_ID(MMIENG_NV_COUNTING_WIN_ID),
              WIN_TITLE(TXT_ENG_NVCOUNT),
        WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),      
        CREATE_TEXT_CTRL( MMIENG_NV_COUNTING_TEXTBOX_CTRL_ID), 
        END_WIN
};

WINDOW_TABLE(MMIENG_BROWSER_LOG_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)HandleBrowserLogWinMsg),
    WIN_ID(MMIENG_BROWSER_LOG_WIN_ID),
    WIN_TITLE(TXT_ENG_BROWSER_LOG),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};


WINDOW_TABLE(MMIENG_BROWSER_CHANGE_URL_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)HandleBrowserChangeURLWinMsg),
        WIN_ID(MMIENG_BROWSER_LOG_WIN_ID),
        WIN_TITLE(TXT_ENG_BROWSER_LOG),
        WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
        CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
        END_WIN
};

WINDOW_TABLE(MMIENG_SCREEN_LOG_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)HandleScreenLogWinMsg),
    WIN_ID(MMIENG_SCREEN_LOG_WIN_ID),
    WIN_TITLE(TXT_ENG_SCREEN_LOG),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};


WINDOW_TABLE(MMIENG_CHIPTEST_TP_WIN_TAB) = 
{
    //CLEAR_LCD,
    //WIN_PRIO( WIN_ONE_LEVEL ),
    WIN_FUNC((uint32)HandleChiptestTpWinMsg),
    WIN_ID(MMIENG_CHIPTEST_TP_WIN_ID),    
    END_WIN
};

#ifdef MMI_AUTOTEST_SUPPORT
WINDOW_TABLE(MMIENG_AUTOTEST_SET_WIN_TAB) = 
{
    //CLEAR_LCD,
    //WIN_PRIO( WIN_ONE_LEVEL ),
    WIN_FUNC((uint32)HandleAutoTestSetWinMsg),
    WIN_ID(MMIENG_AUTO_TEST_SET_WIN_ID),
    WIN_TITLE(TXT_ENG_AUTO_TEST_SET),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};
#endif

#ifdef MMI_WIFI_SUPPORT
WINDOW_TABLE(MMIENG_WLAN_PERFORMANCE_MODE_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)HandleWlanPerformanceModeWinMsg),
    WIN_ID(MMIENG_WLAN_PERFORMANCE_MODE_WIN_ID),
    WIN_TITLE(TXT_ENG_WLAN_PERFORMANCE_MODE),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};
WINDOW_TABLE(MMIENG_WIFI_IPERF_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)HandleWifiIperfWinMsg),
    WIN_ID(MMIENG_WIFI_IPERF_WIN_ID),
    WIN_TITLE(TXT_ENG_WLAN_IPERF),
    CREATE_FORM_CTRL(GUIFORM_LAYOUT_ORDER,MMIENG_FORM_CTRL_ID),
      //GPRS/WIFI
      CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_SBS,MMIENG_FORM1_CTRL_ID,MMIENG_FORM_CTRL_ID),
          CHILD_LABEL_CTRL( GUILABEL_ALIGN_MIDDLE, FALSE, MMIENG_COMMON_LABEL_CTRL7_ID, MMIENG_FORM1_CTRL_ID ),
          CHILD_DROPDOWNLIST_CTRL(TRUE, MMIENG_COMMON_EDIT_CTRL7_ID, MMIENG_FORM1_CTRL_ID ),
      //TCP/UDP
      CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_SBS,MMIENG_WIFI_IPERF_TYPE_FORM_CTRL_ID,MMIENG_FORM_CTRL_ID),
          CHILD_LABEL_CTRL( GUILABEL_ALIGN_MIDDLE, FALSE, MMIENG_COMMON_LABEL_CTRL1_ID, MMIENG_WIFI_IPERF_TYPE_FORM_CTRL_ID ),
          CHILD_DROPDOWNLIST_CTRL(TRUE, MMIENG_COMMON_EDIT_CTRL1_ID, MMIENG_WIFI_IPERF_TYPE_FORM_CTRL_ID ),
      //UP/DOWN
      CHILD_FORM_CTRL( TRUE, GUIFORM_LAYOUT_SBS, MMIENG_WIFI_IPERF_UP_FORM_CTRL_ID, MMIENG_FORM_CTRL_ID ),
          CHILD_LABEL_CTRL( GUILABEL_ALIGN_MIDDLE, FALSE, MMIENG_COMMON_LABEL_CTRL2_ID, MMIENG_WIFI_IPERF_UP_FORM_CTRL_ID ),
          CHILD_DROPDOWNLIST_CTRL(TRUE, MMIENG_COMMON_EDIT_CTRL2_ID, MMIENG_WIFI_IPERF_UP_FORM_CTRL_ID ),
      //IP
      CHILD_FORM_CTRL( TRUE, GUIFORM_LAYOUT_SBS, MMIENG_WIFI_IPERF_IP_FORM_CTRL_ID,MMIENG_FORM_CTRL_ID ),
          CHILD_LABEL_CTRL(GUILABEL_ALIGN_MIDDLE, FALSE, MMIENG_COMMON_LABEL_CTRL3_ID, MMIENG_WIFI_IPERF_IP_FORM_CTRL_ID ),
          CHILD_EDIT_TEXT_CTRL(TRUE, 20,MMIENG_COMMON_EDIT_CTRL3_ID, MMIENG_WIFI_IPERF_IP_FORM_CTRL_ID ),
      //PORT
      CHILD_FORM_CTRL( TRUE, GUIFORM_LAYOUT_SBS, MMIENG_WIFI_IPERF_PORT_FORM_CTRL_ID,MMIENG_FORM_CTRL_ID ),
          CHILD_LABEL_CTRL(GUILABEL_ALIGN_MIDDLE,FALSE, MMIENG_COMMON_LABEL_CTRL4_ID, MMIENG_WIFI_IPERF_PORT_FORM_CTRL_ID ),
          CHILD_EDIT_DIGITAL_CTRL(TRUE, 10, MMIENG_COMMON_EDIT_CTRL4_ID, MMIENG_WIFI_IPERF_PORT_FORM_CTRL_ID ),
      //TIME
      CHILD_FORM_CTRL( TRUE, GUIFORM_LAYOUT_SBS, MMIENG_WIFI_IPERF_TIME_FORM_CTRL_ID,MMIENG_FORM_CTRL_ID ),
          CHILD_LABEL_CTRL( GUILABEL_ALIGN_MIDDLE, FALSE, MMIENG_COMMON_LABEL_CTRL5_ID, MMIENG_WIFI_IPERF_TIME_FORM_CTRL_ID ),
          CHILD_EDIT_DIGITAL_CTRL(TRUE, 10, MMIENG_COMMON_EDIT_CTRL5_ID, MMIENG_WIFI_IPERF_TIME_FORM_CTRL_ID ),
      //RESULT
      CHILD_FORM_CTRL( TRUE, GUIFORM_LAYOUT_SBS, MMIENG_WIFI_IPERF_RESULT_FORM_CTRL_ID,MMIENG_FORM_CTRL_ID ),
          CHILD_LABEL_CTRL( GUILABEL_ALIGN_MIDDLE, FALSE, MMIENG_COMMON_LABEL_CTRL6_ID, MMIENG_WIFI_IPERF_RESULT_FORM_CTRL_ID ),
          CHILD_TEXT_CTRL(TRUE, MMIENG_COMMON_EDIT_CTRL6_ID, MMIENG_WIFI_IPERF_RESULT_FORM_CTRL_ID ),
#ifdef MMI_PDA_SUPPORT
    CHILD_SOFTKEY_CTRL(TXT_COMMON_OK, TXT_NULL, STXT_RETURN,MMICOMMON_SOFTKEY_CTRL_ID, MMIENG_FORM_CTRL_ID),  
#else
    WIN_SOFTKEY(TXT_START_GPS_SHORT, TXT_NULL, TXT_STOP_GPS_SHORT),
#endif
    END_WIN
};

WINDOW_TABLE(MMIENG_WLAN_RADIO_FREQUENCY_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)HandleWlanRfSetWinMsg),    
    WIN_ID(MMIENG_WLAN_RADIO_FREQUENCY_WIN_ID),
    WIN_TITLE(TXT_ENG_WLAN_RADIO_FREQUENCY),
    WIN_SOFTKEY(STXT_SELECT, TXT_NULL, STXT_FINISH),
    CREATE_FORM_CTRL(GUIFORM_LAYOUT_ORDER,MMIENG_RADIO_FREQUENCY_FORM_CTRL_ID),
    
    CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_WLAN_POWER_SAVE_FORM_CTRL_ID,MMIENG_RADIO_FREQUENCY_FORM_CTRL_ID),
        CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_WLAN_POWER_SAVE_LABEL_CTRL_ID, MMIENG_WLAN_POWER_SAVE_FORM_CTRL_ID),//主菜单风格
        CHILD_SETLIST_CTRL(TRUE, MMIENG_WLAN_POWER_SAVE_SETLIST_CTRL_ID, MMIENG_WLAN_POWER_SAVE_FORM_CTRL_ID),

    CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_WLAN_ROAMING_FORM_CTRL_ID,MMIENG_RADIO_FREQUENCY_FORM_CTRL_ID),
        CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT,FALSE,MMIENG_WLAN_ROAMING_LABEL_CTRL_ID,MMIENG_WLAN_ROAMING_FORM_CTRL_ID),//待机风格
        CHILD_SETLIST_CTRL(TRUE, MMIENG_WLAN_ROAMING_SETLIST_CTRL_ID, MMIENG_WLAN_ROAMING_FORM_CTRL_ID),

    END_WIN
};

//TX
WINDOW_TABLE(MMIENG_WIFI_TX_WIN_TAB) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngWifiTXHandleWinMsg),
    WIN_ID(MMIENG_WIFI_TX_WIN_ID),
    WIN_TITLE(TXT_ENG_WIFI_TX),
    CREATE_FORM_CTRL(GUIFORM_LAYOUT_ORDER,MMIENG_FORM_CTRL_ID),
    //pkt length
    CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_SBS,MMIENG_WIFI_LEN_FORM_CTRL_ID,MMIENG_FORM_CTRL_ID),
        CHILD_LABEL_CTRL( GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL1_ID, MMIENG_WIFI_LEN_FORM_CTRL_ID ),
        CHILD_EDIT_DIGITAL_CTRL(TRUE,3, MMIENG_COMMON_EDIT_CTRL1_ID, MMIENG_WIFI_LEN_FORM_CTRL_ID ),
    //pkt cnt
    CHILD_FORM_CTRL( TRUE, GUIFORM_LAYOUT_SBS, MMIENG_WIFI_CNT_FORM_CTRL_ID, MMIENG_FORM_CTRL_ID ),
        CHILD_LABEL_CTRL( GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL2_ID, MMIENG_WIFI_CNT_FORM_CTRL_ID ),
        CHILD_EDIT_DIGITAL_CTRL(TRUE,3, MMIENG_COMMON_EDIT_CTRL2_ID, MMIENG_WIFI_CNT_FORM_CTRL_ID ),
    //power level
    CHILD_FORM_CTRL( TRUE, GUIFORM_LAYOUT_SBS, MMIENG_WIFI_LEVEL_FORM_CTRL_ID,MMIENG_FORM_CTRL_ID ),
        CHILD_TEXT_CTRL( FALSE, MMIENG_COMMON_LABEL_CTRL3_ID, MMIENG_WIFI_LEVEL_FORM_CTRL_ID ),
        CHILD_EDIT_DIGITAL_CTRL(TRUE,3, MMIENG_COMMON_EDIT_CTRL3_ID, MMIENG_WIFI_LEVEL_FORM_CTRL_ID ),
    //RF standard
    CHILD_FORM_CTRL( TRUE, GUIFORM_LAYOUT_SBS, MMIENG_WIFI_STANDARD_FORM_CTRL_ID,MMIENG_FORM_CTRL_ID ),
        CHILD_TEXT_CTRL(FALSE, MMIENG_COMMON_LABEL_CTRL4_ID, MMIENG_WIFI_STANDARD_FORM_CTRL_ID ),
        CHILD_DROPDOWNLIST_CTRL(TRUE, MMIENG_WIFI_STANDARD_DROP_CTRL_ID, MMIENG_WIFI_STANDARD_FORM_CTRL_ID ),
    //Channel
    CHILD_FORM_CTRL( TRUE, GUIFORM_LAYOUT_SBS, MMIENG_WIFI_CHANNEL_FROM_CTRL_ID,MMIENG_FORM_CTRL_ID ),
        CHILD_LABEL_CTRL( GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL5_ID, MMIENG_WIFI_CHANNEL_FROM_CTRL_ID ),
        CHILD_DROPDOWNLIST_CTRL(TRUE, MMIENG_WIFI_CHANNEL_DROP_CTRL_ID, MMIENG_WIFI_CHANNEL_FROM_CTRL_ID ),
    //RATE
    CHILD_FORM_CTRL( TRUE, GUIFORM_LAYOUT_SBS, MMIENG_WIFI_RATE_FROM_CTRL_ID,MMIENG_FORM_CTRL_ID ),
        CHILD_LABEL_CTRL( GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL6_ID, MMIENG_WIFI_RATE_FROM_CTRL_ID ),
        CHILD_DROPDOWNLIST_CTRL(TRUE, MMIENG_WIFI_RATE_DROP_CTRL_ID, MMIENG_WIFI_RATE_FROM_CTRL_ID ),
    //PREAMBLE
    CHILD_FORM_CTRL( TRUE, GUIFORM_LAYOUT_SBS, MMIENG_WIFI_PREAM_FROM_CTRL_ID,MMIENG_FORM_CTRL_ID ),
        CHILD_LABEL_CTRL( GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL7_ID, MMIENG_WIFI_PREAM_FROM_CTRL_ID ),
        CHILD_DROPDOWNLIST_CTRL(TRUE, MMIENG_WIFI_PREAM_DROP_CTRL_ID, MMIENG_WIFI_PREAM_FROM_CTRL_ID ),
    //MODE
    CHILD_FORM_CTRL( TRUE, GUIFORM_LAYOUT_SBS, MMIENG_WIFI_MODE_FROM_CTRL_ID,MMIENG_FORM_CTRL_ID ),
        CHILD_LABEL_CTRL( GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL8_ID, MMIENG_WIFI_MODE_FROM_CTRL_ID ),
        CHILD_DROPDOWNLIST_CTRL(TRUE, MMIENG_WIFI_MODE_DROP_CTRL_ID, MMIENG_WIFI_MODE_FROM_CTRL_ID ),
    //GUARD INTERVAL
    CHILD_FORM_CTRL( TRUE, GUIFORM_LAYOUT_SBS, MMIENG_WIFI_GUARD_FROM_CTRL_ID,MMIENG_FORM_CTRL_ID ),
        CHILD_TEXT_CTRL( FALSE, MMIENG_COMMON_LABEL_CTRL9_ID, MMIENG_WIFI_GUARD_FROM_CTRL_ID ),
        CHILD_DROPDOWNLIST_CTRL(TRUE, MMIENG_WIFI_GUARD_DROP_CTRL_ID, MMIENG_WIFI_GUARD_FROM_CTRL_ID ),
    WIN_SOFTKEY(TXT_COMMON_START, TXT_NULL, STXT_STOP),
    END_WIN
};

//RX
WINDOW_TABLE(MMIENG_WIFI_RX_WIN_TAB) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngWifiRXHandleWinMsg),
    WIN_ID(MMIENG_WIFI_RX_WIN_ID),
    WIN_TITLE(TXT_ENG_WIFI_RX),
    CREATE_FORM_CTRL(GUIFORM_LAYOUT_ORDER,MMIENG_FORM_CTRL_ID),
    //RX Num
    CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_SBS,MMIENG_WIFI_NUM_FORM_CTRL_ID,MMIENG_FORM_CTRL_ID),
        CHILD_LABEL_CTRL( GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL1_ID, MMIENG_WIFI_NUM_FORM_CTRL_ID ),
        CHILD_EDIT_DIGITAL_CTRL(TRUE,6, MMIENG_COMMON_EDIT_CTRL1_ID, MMIENG_WIFI_NUM_FORM_CTRL_ID ),
    //RF standard
    CHILD_FORM_CTRL( TRUE, GUIFORM_LAYOUT_SBS, MMIENG_WIFI_STANDARD_FORM_CTRL_ID, MMIENG_FORM_CTRL_ID ),
        CHILD_TEXT_CTRL(FALSE, MMIENG_COMMON_LABEL_CTRL2_ID, MMIENG_WIFI_STANDARD_FORM_CTRL_ID ),
        CHILD_DROPDOWNLIST_CTRL(TRUE, MMIENG_WIFI_STANDARD_DROP_CTRL_ID, MMIENG_WIFI_STANDARD_FORM_CTRL_ID ),
    //Channel
    CHILD_FORM_CTRL( TRUE, GUIFORM_LAYOUT_SBS, MMIENG_WIFI_CHANNEL_FORM_CTRL_ID,MMIENG_FORM_CTRL_ID ),
        CHILD_LABEL_CTRL( GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL3_ID, MMIENG_WIFI_CHANNEL_FORM_CTRL_ID ),
        CHILD_DROPDOWNLIST_CTRL(TRUE, MMIENG_WIFI_CHANNEL_DROP_CTRL_ID, MMIENG_WIFI_CHANNEL_FORM_CTRL_ID ),
    //RX Ok
    CHILD_FORM_CTRL( TRUE, GUIFORM_LAYOUT_SBS, MMIENG_WIFI_RXOK_FORM_CTRL_ID,MMIENG_FORM_CTRL_ID ),
        CHILD_LABEL_CTRL( GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL4_ID, MMIENG_WIFI_RXOK_FORM_CTRL_ID ),
        CHILD_LABEL_CTRL( GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL5_ID, MMIENG_WIFI_RXOK_FORM_CTRL_ID ),
    //PER
    CHILD_FORM_CTRL( TRUE, GUIFORM_LAYOUT_SBS, MMIENG_WIFI_PER_FORM_CTRL_ID,MMIENG_FORM_CTRL_ID ),
        CHILD_LABEL_CTRL( GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL6_ID, MMIENG_WIFI_PER_FORM_CTRL_ID ),
        CHILD_LABEL_CTRL( GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL7_ID, MMIENG_WIFI_PER_FORM_CTRL_ID ),
    WIN_SOFTKEY(TXT_COMMON_START, TXT_NULL, STXT_STOP),
    END_WIN
};

//REG WR
WINDOW_TABLE(MMIENG_WIFI_REG_WR_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngWifiRegWRHandleWinMsg),    
    WIN_ID(MMIENG_WIFI_REG_WR_WIN_ID),
    WIN_TITLE(TXT_ENG_WIFI_REGWR),
    CREATE_FORM_CTRL(GUIFORM_LAYOUT_ORDER,MMIENG_FORM_CTRL_ID),
    //type

    //address
    CHILD_FORM_CTRL( TRUE, GUIFORM_LAYOUT_SBS, MMIENG_WIFI_ADDR_FORM_CTRL_ID, MMIENG_FORM_CTRL_ID ),
        CHILD_LABEL_CTRL( GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL2_ID, MMIENG_WIFI_ADDR_FORM_CTRL_ID ),
        CHILD_EDIT_DIGITAL_CTRL(TRUE, 20,MMIENG_COMMON_EDIT_CTRL2_ID, MMIENG_WIFI_ADDR_FORM_CTRL_ID ),
    //length
    CHILD_FORM_CTRL( TRUE, GUIFORM_LAYOUT_SBS, MMIENG_WIFI_LEN_FORM_CTRL_ID,MMIENG_FORM_CTRL_ID ),
        CHILD_LABEL_CTRL( GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL3_ID, MMIENG_WIFI_LEN_FORM_CTRL_ID ),
        CHILD_EDIT_DIGITAL_CTRL(TRUE,20, MMIENG_COMMON_EDIT_CTRL3_ID, MMIENG_WIFI_LEN_FORM_CTRL_ID ),
    //value
    CHILD_FORM_CTRL( TRUE, GUIFORM_LAYOUT_SBS, MMIENG_WIFI_VALUE_FORM_CTRL_ID,MMIENG_FORM_CTRL_ID ),
        CHILD_LABEL_CTRL( GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL4_ID, MMIENG_WIFI_VALUE_FORM_CTRL_ID ),
        CHILD_EDIT_DIGITAL_CTRL(TRUE, 20,MMIENG_COMMON_EDIT_CTRL4_ID, MMIENG_WIFI_VALUE_FORM_CTRL_ID ),
    //type
    CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_SBS,MMIENG_WIFI_TYPE_FORM_CTRL_ID,MMIENG_FORM_CTRL_ID),
        CHILD_LABEL_CTRL( GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL1_ID, MMIENG_WIFI_TYPE_FORM_CTRL_ID ),
        CHILD_DROPDOWNLIST_CTRL(TRUE, MMIENG_COMMON_LIST_CTRL1_ID, MMIENG_WIFI_TYPE_FORM_CTRL_ID ),
    WIN_SOFTKEY(TXT_ENG_FM_READ, TXT_NULL, TXT_ENG_FM_WRITE),
    END_WIN
};
#endif

#ifdef MMI_WIFI_SUPPORT
//packet check
WINDOW_TABLE(MMIENG_WIFI_PK_WIN_TAB) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngPacketCheckItemHandleWinMsg),
    WIN_ID(MMIENG_WIFI_TX_WIN_ID),
    WIN_TITLE(TXT_ENG_WIFI_PACKET_ITEM),
    CREATE_FORM_CTRL(GUIFORM_LAYOUT_SBS,MMIENG_FORM_CTRL_ID),
        CHILD_LABEL_CTRL( GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL1_ID, MMIENG_FORM_CTRL_ID ),
        CHILD_EDIT_DIGITAL_CTRL(TRUE,4, MMIENG_COMMON_EDIT_CTRL1_ID, MMIENG_FORM_CTRL_ID ),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    END_WIN
};
#endif
// for SUPPORT_STANDBY_RECORD
WINDOW_TABLE(MMIENG_STANDBY_TIME_INFO_TAB) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)StandbyTimeInfoWinHandleMsg),
    WIN_ID(MMIENG_STANDBY_TIME_INFO_WIN_ID),
    WIN_TITLE(TXT_ENG_SHOW_STANDBY_TIME),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_TEXT_CTRL(MMIENG_TEXTBOX1_CTRL_ID),
    END_WIN
};

#ifdef WRE_SUPPORT
WINDOW_TABLE(MMIENG_SHOW_WREVERSION_WIN_TAB) = 
{
    WIN_FUNC((uint32)EngShowWREVersionWinHandleMsg),
    WIN_ID(MMIENG_SHOW_WRE_VERSION_WIN_ID),
        WIN_TITLE(TXT_ENG_WRE_VERSION_INFO),
#if defined MMI_PDA_SUPPORT
    WIN_STYLE(WS_HAS_BUTTON_SOFTKEY),
#endif	
        WIN_SOFTKEY(TXT_ENG_OK, TXT_NULL, TXT_ENG_RETURN),
        CREATE_TEXT_CTRL(MMIENG_SHOW_WRE_VERSION_CTRL_ID),
    END_WIN
};
#endif
//end for SUPPORT_STANDBY_RECORD

#if MMISRV_AUDIO_TEST_SUPPORT
WINDOW_TABLE(MMIENG_AUDIO_SELF_TEST_TAB) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngAudioSelfTestHandleMsg),
    WIN_ID(MMIENG_AUDIO_SELF_TEST),
    WIN_TITLE(TXT_ENG_AUDIO_SELF_TEST),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};
WINDOW_TABLE(MMIENG_AUDIO_SELF_TEST_PLAY_TAB) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngAudioSelfTestPlayHandleMsg),
    WIN_ID(MMIENG_AUDIO_SELF_TEST_PLAY),
    //WIN_TITLE(TXT_ENG_AUDIO_PLAY),
    //WIN_SOFTKEY(STXT_OK, TXT_NULL, STXT_RETURN),
    END_WIN
};         
#ifdef PRINTSCREEN_SUPPORT
WINDOW_TABLE(MMIENG_AUDIO_SELF_TEST_DISPLAY_INFO_TAB) =
{
    WIN_FUNC((uint32)EngAudioSelfTestDisplayInfoHandleMsg),
    WIN_ID(MMIENG_AUDIO_SELF_TEST_DISPLAY_INFO),
    WIN_TITLE(TXT_ENG_AUDIO_DISPLAY_INFO),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_TEXT_CTRL(MMIENG_TEXTBOX1_CTRL_ID),
    END_WIN
};         
#endif
#endif
/*telephony begin*/
WINDOW_TABLE( MMIENG_TELE_SIM_TRACE_WIN_TAB ) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC( (uint32)EngTeleSIMTraceWinHandleMsg ),
    WIN_ID( MMIENG_SIM_TRACE_WIN_ID ),
    WIN_TITLE(TXT_ENG_TEL_SIM_TRACE_TITLE),
    WIN_SOFTKEY(NULL, TXT_ENG_OK, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_COMMON_CTRL1_ID),
    END_WIN
};
WINDOW_TABLE( MMIENG_TELE_BAND_SELECT_WIN_TAB ) =
{
    WIN_HIDE_STATUS,
	WIN_FUNC( (uint32)EngTeleBANDSelectWinHandleMsg),
	WIN_ID( MMIENG_TELE_BAND_SELECT_WIN_ID),
	WIN_TITLE(TXT_ENG_BAND_SELECT ),
	CREATE_LISTBOX_CTRL(GUILIST_TEXTLIST_E, MMIENG_COMMON_EDIT_CTRL2_ID),
	WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_CANCEL),
	END_WIN
};

WINDOW_TABLE( MMIENG_TELE_BAND_TDD_WIN_TAB ) =
{
    WIN_HIDE_STATUS,
	WIN_FUNC( (uint32)EngTeleBANDTDDWinHandleMsg), 
	WIN_ID( MMIENG_TELE_BAND_TDD_WIN_ID ),
	WIN_TITLE( TXT_ENG_TEL_BAND_TDD ),
	CREATE_LISTBOX_CTRL(GUILIST_CHECKLIST_E, MMIENG_COMMON_EDIT_CTRL2_ID),
	WIN_SOFTKEY(TXT_COMMON_OK, TXT_EDIT, STXT_CANCEL),
	END_WIN
};

WINDOW_TABLE( MMIENG_TELE_BAND_FDD_WIN_TAB ) =
{
    WIN_HIDE_STATUS,
	WIN_FUNC( (uint32)EngTeleBANDFDDWinHandleMsg),    
	WIN_ID( MMIENG_TELE_BAND_FDD_WIN_ID ),
	WIN_TITLE( TXT_ENG_TEL_BAND_FDD ),
	CREATE_LISTBOX_CTRL(GUILIST_CHECKLIST_E, MMIENG_COMMON_EDIT_CTRL2_ID),
	WIN_SOFTKEY(TXT_COMMON_OK, TXT_EDIT, STXT_CANCEL),
	END_WIN
};

WINDOW_TABLE( MMIENG_TELE_BAND_GSM_WIN_TAB ) =
{
    WIN_HIDE_STATUS,
	WIN_FUNC( (uint32)EngTeleBANDGSMWinHandleMsg),
	WIN_ID( MMIENG_TELE_BAND_GSM_WIN_ID ),
	WIN_TITLE( TXT_ENG_TEL_BAND_GSM ),
	CREATE_LISTBOX_CTRL(GUILIST_CHECKLIST_E, MMIENG_COMMON_EDIT_CTRL2_ID),
	WIN_SOFTKEY(TXT_COMMON_OK, TXT_EDIT, STXT_CANCEL),
	END_WIN
};

WINDOW_TABLE( MMIENG_TELE_BAND_WCDMA_WIN_TAB ) =
{
    WIN_HIDE_STATUS,
	WIN_FUNC( (uint32)EngTeleBANDWCDMAWinHandleMsg),
	WIN_ID( MMIENG_TELE_BAND_WCDMA_WIN_ID ),
	WIN_TITLE( TXT_ENG_TEL_BAND_WCDMA ),
	CREATE_LISTBOX_CTRL(GUILIST_CHECKLIST_E, MMIENG_COMMON_EDIT_CTRL2_ID),
	WIN_SOFTKEY(TXT_COMMON_OK, TXT_EDIT, STXT_CANCEL),
	END_WIN
};
//network mode
WINDOW_TABLE( MMIENG_TELE_NETWORK_MODE_WIN_TAB ) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC( (uint32)EngTeleNetWorkModeWinHandleMsg),
    WIN_ID( MMIENG_TELE_NETWORK_MODE_WIN_ID ),
    WIN_TITLE(TXT_ENG_TEL_NETWORK_MODE_TITLE),
    WIN_SOFTKEY(NULL, TXT_ENG_OK, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_COMMON_CTRL1_ID),
    END_WIN
};

/*netinfo begin*/
WINDOW_TABLE(MMIENG_BETWEEN_CELL_SHOW_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)ENGBetweenCellShowWinHandleMsg),
    WIN_ID(MMIENG_TELE_BETWEEN_RAT_WIN_ID),
    WIN_TITLE(TXT_ENG_BETWEEN_ADJACENT_CELL),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_TEXT_CTRL(MMIENG_TEXTBOX2_CTRL_ID),
    END_WIN
};

WINDOW_TABLE( MMIENG_NET_INFO_BETWEEN_CELL_WIN_TAB ) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC( (uint32)EngBetweenCelllWinHandleMsg ),
    WIN_ID( MMIENG_TELE_BETWEEN_WIN_ID ),
    WIN_TITLE(TXT_ENG_BETWEEN_ADJACENT_CELL),
    WIN_SOFTKEY(NULL, TXT_ENG_OK, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_TEXTLIST_E, MMIENG_COMMON_EDIT_CTRL4_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_NET_INFO_SHOW_WIN_TAB) =
{
    WIN_HIDE_STATUS,
	WIN_FUNC((uint32)ENGNetinfoShowWinHandleMsg),
	WIN_ID(MMIENG_NET_INFO_SHOW_WIN_ID),
	WIN_TITLE(TXT_ENG_NET_INFO),
	WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
	CREATE_MENU_CTRL(MENU_NW_CAP_ENG, MMIENG_NET_INFO_SHOW_CTRL_ID),
	END_WIN
};

WINDOW_TABLE(MMIENG_NW_CAP_SHOW_WIN_TAB) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)ENGNWCAPShowWinHandleMsg),
    WIN_ID(MMIENG_NW_CAP_SHOW_WIN_ID),
    WIN_TITLE(TXT_ENG_NW_CAP),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_TEXT_CTRL(MMIENG_TEXTBOX1_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_NETINFO_STATISTICS_WIN_TAB) =
{
    WIN_HIDE_STATUS,
	WIN_FUNC((uint32)ENGNetinfoStatisticsWinHandleMsg),
	WIN_ID(MMIENG_NETINFO_STATISTICS_WIN_ID),
	WIN_TITLE(TXT_ENG_NETINFO_STATISTICS),
	WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
	CREATE_MENU_CTRL(MENU_NETINFO_STATISTICS_ENG, MMIENG_NETINFO_STATISTICS_CTRL_ID),
	END_WIN
};

WINDOW_TABLE(MMIENG_NETINFO_STATISTICS_HANDLE_WIN_TAB) =
{
    WIN_HIDE_STATUS,
#if defined(PLATFORM_UWS6121E)
    WIN_FUNC((uint32)ENG_Netinfo_Statistics_WinHandleMsg),
#else
    WIN_FUNC((uint32)ENGNetinfoStatisticsDetailInfoWinHandleMsg),
#endif    
    WIN_ID(MMIENG_NETINFO_STATISTICS_HANDLE_WIN_ID),
    WIN_TITLE(TXT_ENG_NETINFO_STATISTICS),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_TEXT_CTRL(MMIENG_TEXTBOX1_CTRL_ID),
    END_WIN
};
/*netinfo end*/

WINDOW_TABLE( MMIENG_IMS_NV_PARAM_ID_WIN_TAB ) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC( ( uint32 )Eng_IMS_NV_PARAM_ID_WinHandleMsg ),
    WIN_ID( MMIENG_TELE_VOLTE_SET_WIN_ID ),
    WIN_TITLE( TXT_ENG_TEL_VOLTE_IMS_MENU ),
    CREATE_FORM_CTRL( GUIFORM_LAYOUT_ORDER, MMIENG_FORM_CTRL_ID ),
    //ID
    CHILD_FORM_CTRL( TRUE, GUIFORM_LAYOUT_ORDER, MMIENG_COMMON_CTRL1_ID, MMIENG_FORM_CTRL_ID ),
    CHILD_LABEL_CTRL( GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL1_ID, MMIENG_COMMON_CTRL1_ID ),
    CHILD_EDIT_DIGITAL_CTRL( TRUE, 4, MMIENG_COMMON_EDIT_CTRL1_ID, MMIENG_COMMON_CTRL1_ID ),
    //value
    CHILD_FORM_CTRL( TRUE, GUIFORM_LAYOUT_ORDER, MMIENG_COMMON_CTRL2_ID, MMIENG_FORM_CTRL_ID ),
    CHILD_LABEL_CTRL( GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL2_ID, MMIENG_COMMON_CTRL2_ID ),
    CHILD_EDIT_TEXT_CTRL( TRUE, 255, MMIENG_COMMON_EDIT_CTRL2_ID, MMIENG_COMMON_CTRL2_ID ),
    WIN_SOFTKEY( TXT_ENG_FM_WRITE, TXT_ENG_FM_READ, STXT_RETURN ),
    END_WIN
};

WINDOW_TABLE( MMIENG_TELE_VOLTE_PLMN_WHITE_WIN_TAB ) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC( (uint32)EngTeleVoltePLMNWhiteListWinHandleMsg ),
    WIN_ID( MMIENG_TELE_VOLTE_PLMN_WHITE_WIN_ID ),
    WIN_TITLE(TXT_ENG_TEL_VOLTE_PLMN_WHITE_LIST_TITLE),
    WIN_SOFTKEY(NULL, TXT_ENG_OK, STXT_RETURN),

    CREATE_FORM_CTRL(GUIFORM_LAYOUT_ORDER,MMIENG_FORM_CTRL_ID), 

    //Test PLMN1
    CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_COMMON_CTRL2_ID,MMIENG_FORM_CTRL_ID),
    CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL2_ID, MMIENG_COMMON_CTRL2_ID),
    CHILD_EDIT_DIGITAL_CTRL(TRUE, 6,MMIENG_COMMON_EDIT_CTRL2_ID, MMIENG_COMMON_CTRL2_ID),
    //Test PLMN2
    CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_COMMON_CTRL3_ID,MMIENG_FORM_CTRL_ID),
    CHILD_LABEL_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL3_ID, MMIENG_COMMON_CTRL3_ID),
    CHILD_EDIT_DIGITAL_CTRL(TRUE, 6,MMIENG_COMMON_EDIT_CTRL3_ID, MMIENG_COMMON_CTRL3_ID), 

    //Released White List  //fix bug 1631017,1647066
    CHILD_FORM_CTRL(TRUE,GUIFORM_LAYOUT_ORDER,MMIENG_COMMON_CTRL4_ID,MMIENG_FORM_CTRL_ID),
    CHILD_BUTTON_CTRL(GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_EDIT_CTRL4_ID, MMIENG_COMMON_CTRL4_ID),
    END_WIN
};

#ifdef MMI_VOLTE_SUPPORT
WINDOW_TABLE( MMIENG_TELE_VOLTE_ONOFF_WIN_TAB ) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC( (uint32)EngTeleVolteOnOffWinHandleMsg ),
    WIN_ID( MMIENG_TELE_VOLTE_ONOFF_WIN_ID ),
    WIN_TITLE(TXT_ENG_TEL_VOLTE_ONOFF),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_VOLTE_LISTBOX_CTRL_ID),
    WIN_SOFTKEY(NULL, TXT_ENG_OK, STXT_RETURN),
    END_WIN
};
WINDOW_TABLE( MMIENG_TELE_IMS_PDN_WIN_TAB ) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC( (uint32)EngTeleImsPdnWinHandleMsg ),
    WIN_ID( MMIENG_TELE_IMS_PDN_WIN_ID ),
    WIN_TITLE(TXT_ENG_TEL_VOLTE_IMS_PDN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_VOLTE_LISTBOX_CTRL_ID),
    WIN_SOFTKEY(NULL, TXT_ENG_OK, STXT_RETURN),
    END_WIN
};

#endif

WINDOW_TABLE( MMIENG_TELE_VOLTE_PLMN_WHITE_REL_WIN_TAB ) =
{
    WIN_HIDE_STATUS,
	WIN_FUNC( (uint32)EngTeleVoltePLMNWhiteListRelWinHandleMsg ),
	WIN_ID( MMIENG_TELE_VOLTE_PLMN_WHITE_REL_WIN_ID ),
	WIN_TITLE( TXT_ENG_TEL_VOLTE_PLMN_WHITE_LIST_RELEASED_TITLE ),
	CREATE_LISTBOX_CTRL(GUILIST_TEXTLIST_E, MMIENG_COMMON_EDIT_CTRL5_ID),
	WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_CANCEL),
	END_WIN
};

WINDOW_TABLE( MMIENG_TELE_CSFB_GSM_WIN_TAB ) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC( (uint32)EngTeleCSFBToGSmWinHandleMsg ),
    WIN_ID( MMIENG_TELE_CSFB_GSM_WIN_ID),
    WIN_TITLE( TXT_ENG_TEL_CSFB_GSM ),
    CREATE_LISTBOX_CTRL(GUILIST_CHECKLIST_E, MMIENG_COMMON_EDIT_CTRL2_ID),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_CANCEL),
    END_WIN
};

WINDOW_TABLE( MMIENG_FACTORY_RESET_WIN_TAB ) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC( (uint32)EngFactoryResetWinHandleMsg ),
    WIN_ID( MMIENG_FACTORY_RESET_WIN_ID),
    WIN_TITLE( TXT_ENG_FACTORY_RESET ),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_COMMON_EDIT_CTRL2_ID),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_CANCEL),
    END_WIN
};
WINDOW_TABLE( MMIENG_GPRS_POWER_SAVE_MODE_WIN_TAB ) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC( (uint32)EngGprsPowerSaveModeWinHandleMsg ),
    WIN_ID( MMIENG_GPRS_POWER_SAVE_MODE_WIN_ID),
    WIN_TITLE( TXT_ENG_GPRS_POWER_SAVE_MODE_TITLE ),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_COMMON_EDIT_CTRL2_ID),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_CANCEL),
    END_WIN
};

//factory reset
WINDOW_TABLE( MMIENG_FACTORY_RESET_INPUT_PWD_WIN_TAB ) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC( (uint32)EngResetFactoryInputPwdHandleMsg),   
    WIN_ID( MMIENG_FACTORY_RESET_INPUT_PWD_WIN_ID ),
    WIN_TITLE( TXT_NULL ),
    CREATE_FORM_CTRL( GUIFORM_LAYOUT_ORDER, MMIENG_FORM_CTRL_ID ),
    //pwd
    CHILD_FORM_CTRL( TRUE, GUIFORM_LAYOUT_ORDER, MMIENG_COMMON_CTRL1_ID, MMIENG_FORM_CTRL_ID ),
    CHILD_LABEL_CTRL( GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL1_ID, MMIENG_COMMON_CTRL1_ID ),
    CHILD_EDIT_PASSWORD_CTRL( TRUE, 4, MMIENG_COMMON_EDIT_CTRL1_ID, MMIENG_COMMON_CTRL1_ID ),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_CANCEL),
    END_WIN
};
//Set sms center number
WINDOW_TABLE(MMIENG_SMS_SETSC_WIN_TAB ) =
{
    WIN_HIDE_STATUS,
    WIN_TITLE(TXT_NULL ),
    WIN_FUNC((uint32) EngSetSMSSCHandleMsg ),
    WIN_ID( MMIENG_SMS_SETSC_WIN_ID ),
    CREATE_FORM_CTRL( GUIFORM_LAYOUT_ORDER, MMIENG_FORM_CTRL_ID ),
    //sms center number
    CHILD_FORM_CTRL( TRUE, GUIFORM_LAYOUT_ORDER, MMIENG_COMMON_CTRL1_ID, MMIENG_FORM_CTRL_ID ),
    CHILD_LABEL_CTRL( GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL1_ID, MMIENG_COMMON_CTRL1_ID ),
    CHILD_EDIT_PHONENUM_CTRL(TRUE,MMISMS_MAX_SC_NUMBER_LEN,MMIENG_COMMON_EDIT_CTRL1_ID,MMIENG_COMMON_CTRL1_ID),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_CANCEL ),
    END_WIN
};
//Set fast dormancy
WINDOW_TABLE(MMIENG_FAST_NORMANCY_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_TITLE(TXT_ENG_INPUT_TIMES_DORMANCY),
    WIN_FUNC((uint32) EngFastDormancyHandleMsg),
    WIN_ID( MMIENG_FAST_DORMANCY_WIN_ID),
    CREATE_FORM_CTRL( GUIFORM_LAYOUT_ORDER, MMIENG_FORM_CTRL_ID ),
    //open
    CHILD_FORM_CTRL( TRUE, GUIFORM_LAYOUT_ORDER, MMIENG_COMMON_CTRL1_ID, MMIENG_FORM_CTRL_ID ),
    CHILD_LIST_CTRL(TRUE, GUILIST_CHECKLIST_E, MMIENG_COMMON_LIST_CTRL1_ID, MMIENG_COMMON_CTRL1_ID ),

    //input fast domancy times
    CHILD_FORM_CTRL( TRUE, GUIFORM_LAYOUT_ORDER, MMIENG_COMMON_CTRL2_ID, MMIENG_FORM_CTRL_ID ),
    CHILD_LABEL_CTRL( GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL2_ID, MMIENG_COMMON_CTRL2_ID ),
    CHILD_EDIT_PHONENUM_CTRL(TRUE,5,MMIENG_COMMON_EDIT_CTRL2_ID,MMIENG_COMMON_CTRL2_ID),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_CANCEL),
    END_WIN
};
//QOS switch
WINDOW_TABLE( MMIENG_QOS_SWTICH_WIN_TAB ) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC( (uint32)EngQosSwitchWinHandleMsg ),
    WIN_ID( MMIENG_QOS_SWTICH_WIN_ID),
    WIN_TITLE(TXT_ENG_QOS_SWTICH),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_COMMON_EDIT_CTRL2_ID),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_CANCEL),
    END_WIN
};

//Add Contact for test 
WINDOW_TABLE(MMIENG_ADD_CONTACT_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    //WIN_TITLE(TXT_ENG_ADD_CONTACT), //Bug 2156126
    WIN_FUNC((uint32) EngAddContactHandleMsg),
    WIN_ID( MMIENG_ADD_CONTACT_WIN_ID),
    CREATE_FORM_CTRL( GUIFORM_LAYOUT_ORDER, MMIENG_FORM_CTRL_ID ),
    //name
    CHILD_FORM_CTRL( TRUE, GUIFORM_LAYOUT_SBS, MMIENG_FORM_NAME_ID, MMIENG_FORM_CTRL_ID ),
        CHILD_LABEL_CTRL( GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL1_ID, MMIENG_FORM_NAME_ID ),
        CHILD_DROPDOWNLIST_CTRL(TRUE, MMIENG_COMMON_LIST_CTRL1_ID, MMIENG_FORM_NAME_ID ),
    //head icon
    CHILD_FORM_CTRL( TRUE, GUIFORM_LAYOUT_SBS, MMIENG_FORM_ICON_ID,MMIENG_FORM_CTRL_ID ),
        CHILD_LABEL_CTRL( GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL2_ID, MMIENG_FORM_ICON_ID ),
        CHILD_DROPDOWNLIST_CTRL(TRUE, MMIENG_DROP_LIST_ICON_ID, MMIENG_FORM_ICON_ID ),
    //phone number
    CHILD_FORM_CTRL( TRUE, GUIFORM_LAYOUT_SBS, MMIENG_FORM_PHONENUM_ID,MMIENG_FORM_CTRL_ID ),
        CHILD_LABEL_CTRL( GUILABEL_ALIGN_LEFT, FALSE, MMIENG_COMMON_LABEL_CTRL3_ID, MMIENG_FORM_PHONENUM_ID ),
        CHILD_EDIT_PHONENUM_CTRL(TRUE, 20,MMIENG_COMMON_EDIT_CTRL3_ID, MMIENG_FORM_PHONENUM_ID ),

    WIN_SOFTKEY(STXT_SAVE, TXT_NULL, STXT_CANCEL),
    END_WIN
};
/*telephony end*/

//Memory Press Test Enter
WINDOW_TABLE(MMIENG_MEM_PRESS_TEST_ENTER_WIN_TAB) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngMemPressTestEnterWinHandleMsg),

    WIN_ID(MMIENG_MEM_PRESS_TEST_ENTER_WIN_ID),
    WIN_TITLE(TXT_ENG_MEM_PRESS_INFO),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_TEXTLIST_E, MMIENG_COMMON_CTRL1_ID),

    END_WIN
};

WINDOW_TABLE(MMIENG_MEM_PRESS_TEST_WIN_TAB) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngMemPressTestWinHandleMsg),

    WIN_ID(MMIENG_MEM_PRESS_TEST_WIN_ID),
    WIN_TITLE(TXT_NULL),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_TEXT_CTRL(MMIENG_TEXTBOX1_CTRL_ID),

    END_WIN
};

#ifdef MP3_SUPPORT
WINDOW_TABLE(MMIENG_MP3PLAY_TEST_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngMp3PlayWinHandleMsg),
    WIN_ID(MMIENG_MP3PLAY_TEST_WIN_ID),

    WIN_TITLE(TXT_ENG_MP3_PLAY_TEST),
    CREATE_LABEL_CTRL(GUILABEL_ALIGN_MIDDLE, MMIENG_LABEL1_CTRL_ID),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    END_WIN
};
#endif

#ifdef TOUCH_PANEL_SUPPORT
//List Press Test Enter
WINDOW_TABLE(MMIENG_LIST_PRESS_TEST_ENTER_WIN_TAB) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngListPressTestHandleMsg),
    WIN_ID(MMIENG_LIST_PRESS_TEST_WIN_ID),
    WIN_TITLE(TXT_LIST_PRESS_TEST),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_TEXTLIST_E, MMIENG_COMMON_CTRL1_ID),

    END_WIN
};

WINDOW_TABLE(MMIENG_LIST_NEED_HIGHBAR_WIN_TAB) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngListNeedHightBarHandleMsg),
    WIN_ID(MMIENG_LIST_NEED_HIGHBAR_WIN_ID),
    WIN_TITLE(TXT_LIST_NEED_HIGHBAR_IF_CLICK),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_TEXTLIST_E, MMIENG_COMMON_CTRL2_ID),

    END_WIN
};

WINDOW_TABLE(MMIENG_LIST_SUPPORT_LEFT_SLIDE_WIN_TAB) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngListSupportLeftSlideHandleMsg),
    WIN_ID(MMIENG_LIST_SUPPORT_LEFT_SLIDE_WIN_ID),
    WIN_TITLE(TXT_LIST_SUPPORT_LEFT_SLIDE),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_TEXTLIST_E, MMIENG_COMMON_CTRL2_ID),

    END_WIN
};
#endif

// rat 连接显示状态
WINDOW_TABLE(MMIENG_SHOWCSCON_WIN_TAB) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngShowCsonWinHandleMsg),
    WIN_ID(MMIENG_SHOWCSCON_WIN_ID),
    WIN_TITLE(TXT_ENG_CSCON_STATUS),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_TEXT_CTRL(MMIENG_TEXTBOX1_CTRL_ID),
    END_WIN
};

#ifdef DATA_ROAMING_SUPPORT  
WINDOW_TABLE(MMIENG_DATA_ROAMING_WIN_TAB) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngDataRoamingWinHandleMsg),
    WIN_ID(MMIENG_DATA_ROAMING_WIN_ID),
    WIN_TITLE(TXT_CONNECTION_DATA_ROAMING),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};
#endif

//Statistical flowrate
WINDOW_TABLE(MMIENG_SHOW_FLOWRATE_WIN_TAB) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngShowFlowrateWinHandleMsg),
    WIN_ID(MMIENG_SHOW_FLOWRATE_WIN_ID),
    WIN_TITLE(TXT_ENG_FLOWRATE_INFO),
    CREATE_TEXT_CTRL(MMIENG_FLOWRATE_TEXT_CTRL_ID),
    END_WIN
};

/**--------------------------------------------------------------------------*
                                     EXTERNAL DECLARE
 **--------------------------------------------------------------------------*/
extern BOOLEAN g_mmieng_showversion_from_ui ;
extern const MMI_ENG_DISPLAY_T mmi_eng_display;

extern MMI_VOICEPARAM_E g_mmieng_voice_param;

//extern LCD_ID_E g_mmieng_lcd;

//extern uint32 g_mmieng_afc_value;               // AFC
//extern uint32 g_mmieng_pa_value[4];                // PA
//extern uint32 g_mmieng_agc_value;               // AGC

extern uint32 g_mmieng_total_pch_number;
extern uint32 g_mmieng_lost_pch_number;

extern void LCD_SetBackLightBrightness( uint32  brightless );

/*===============================================================================
                                IMPLEMENTATION
===============================================================================*/


/********************************************************************************
 NAME:          MMIEng_SetResultWinText
 DESCRIPTION:   
 PARAM IN:      txt1 - 
                txt2 - 
                txt3 - 
 PARAM OUT:     None
 AUTHOR:        allen
 DATE:          2004.09.10
********************************************************************************/
PUBLIC void MMIEng_SetResultWinText(MMI_STRING_T txt1, MMI_STRING_T txt2, MMI_STRING_T txt3)
{
    if (txt1.wstr_ptr != PNULL && txt1.wstr_len > 0)
    {
        //s_mmieng_show3result_text1.is_ucs2 = txt1.is_ucs2;
        s_mmieng_show3result_text1.wstr_len = txt1.wstr_len;
        s_mmieng_show3result_text1.wstr_ptr = txt1.wstr_ptr;
    }
    else
    {
        //s_mmieng_show3result_text1.is_ucs2 = FALSE;
        s_mmieng_show3result_text1.wstr_len = 0;
        s_mmieng_show3result_text1.wstr_ptr = PNULL;
    }
    if (txt2.wstr_ptr != PNULL && txt2.wstr_len > 0)
    {
        //s_mmieng_show3result_text2.is_ucs2 = txt2.is_ucs2;
        s_mmieng_show3result_text2.wstr_len = txt2.wstr_len;
        s_mmieng_show3result_text2.wstr_ptr = txt2.wstr_ptr;
    }
    else
    {
        //s_mmieng_show3result_text2.is_ucs2 = FALSE;
        s_mmieng_show3result_text2.wstr_len = 0;
        s_mmieng_show3result_text2.wstr_ptr = PNULL;
    }
    if (txt3.wstr_ptr != PNULL && txt3.wstr_len > 0)
    {
        //s_mmieng_show3result_text3.is_ucs2 = txt3.is_ucs2;
        s_mmieng_show3result_text3.wstr_len = txt3.wstr_len;
        s_mmieng_show3result_text3.wstr_ptr = txt3.wstr_ptr;
    }
    else
    {
        //s_mmieng_show3result_text3.is_ucs2 = FALSE;
        s_mmieng_show3result_text3.wstr_len = 0;
        s_mmieng_show3result_text3.wstr_ptr = PNULL;
    }
}


/********************************************************************************
 NAME:          EngShow3ResultWinHandleMsgNoAutoClose
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        allen
 DATE:          2004.09.10
********************************************************************************/
LOCAL MMI_RESULT_E EngShow3ResultWinHandleMsgNoAutoClose(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;    
     GUI_LCD_DEV_INFO lcd_dev_info = {GUI_MAIN_LCD_ID,GUI_BLOCK_MAIN};
    GUI_RECT_T          client_rect = MMITHEME_GetClientRect();
    GUI_RECT_T          lab_rect ={0};
#ifdef MMI_PDA_SUPPORT
    GUI_BOTH_RECT_T     client_both_rect =  MMITHEME_GetWinClientBothRect(win_id);
    client_rect.top = client_both_rect.v_rect.top;
#endif
    lab_rect = client_rect;
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:      
        lab_rect.bottom = lab_rect.top + 40;
        GUILABEL_SetRect(MMIENG_LABEL1_CTRL_ID, &lab_rect, FALSE);
        lab_rect.top =  lab_rect.bottom + 1;
        lab_rect.bottom = lab_rect.top + 40 ;
        GUILABEL_SetRect(MMIENG_LABEL2_CTRL_ID, &lab_rect, FALSE);
        lab_rect.top =  lab_rect.bottom + 1;
        lab_rect.bottom = client_rect.bottom ;
        GUILABEL_SetRect(MMIENG_LABEL3_CTRL_ID, &lab_rect, FALSE);
        // start timer: if user do not press key in time, window 'll be closed when over time
        GUILABEL_SetBackgroundColor(MMIENG_LABEL1_CTRL_ID, mmi_eng_display.bkgd_color);
        GUILABEL_SetBackgroundColor(MMIENG_LABEL2_CTRL_ID, mmi_eng_display.bkgd_color);
        GUILABEL_SetBackgroundColor(MMIENG_LABEL3_CTRL_ID, mmi_eng_display.bkgd_color);
        GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &s_mmieng_show3result_text1, FALSE);
        GUILABEL_SetText(MMIENG_LABEL2_CTRL_ID, &s_mmieng_show3result_text2, FALSE);
        GUILABEL_SetText(MMIENG_LABEL3_CTRL_ID, &s_mmieng_show3result_text3, FALSE);
        break;
    
    case MSG_LCD_SWITCH:        
         lab_rect.bottom = lab_rect.top + 40;
        GUILABEL_SetRect(MMIENG_LABEL1_CTRL_ID, &lab_rect, FALSE);
        lab_rect.top =  lab_rect.bottom + 1;
        lab_rect.bottom = lab_rect.top + 40 ;
        GUILABEL_SetRect(MMIENG_LABEL2_CTRL_ID, &lab_rect, FALSE);
        lab_rect.top =  lab_rect.bottom + 1;
        lab_rect.bottom = client_rect.bottom ;
        GUILABEL_SetRect(MMIENG_LABEL3_CTRL_ID, &lab_rect, FALSE);
        break;
        
       
    case MSG_FULL_PAINT:
        LCD_FillRect(&lcd_dev_info, client_rect, mmi_eng_display.bkgd_color);
        GUIWIN_SetSoftkeyTextId(MMIENG_SHOW3RESULT_WIN_ID,  (MMI_TEXT_ID_T)TXT_ENG_OK, (MMI_TEXT_ID_T)TXT_NULL, (MMI_TEXT_ID_T)TXT_ENG_RETURN, FALSE);
        break;
        
    case MSG_APP_WEB:       
    case MSG_KEYDOWN_OK:
    case MSG_KEYDOWN_CANCEL:
        MMK_CloseWin(MMIENG_SHOW3RESULT_WIN_ID);
        break;

    case MSG_TIMER:
        if (*(uint8*)param == s_mmieng_show3result_timer_id) 
        {
            MMK_CloseWin(MMIENG_SHOW3RESULT_WIN_ID);
        }
        else
            result = MMI_RESULT_FALSE;      // need additional process
        break;
        
    case MSG_CLOSE_WINDOW:          
        //s_mmieng_show3result_text1.is_ucs2 = FALSE;
        s_mmieng_show3result_text1.wstr_len = 0;
        s_mmieng_show3result_text1.wstr_ptr = PNULL;
        //s_mmieng_show3result_text2.is_ucs2 = FALSE;
        s_mmieng_show3result_text2.wstr_len = 0;
        s_mmieng_show3result_text2.wstr_ptr = PNULL;
        //s_mmieng_show3result_text3.is_ucs2 = FALSE;
        s_mmieng_show3result_text3.wstr_len = 0;
        s_mmieng_show3result_text3.wstr_ptr = PNULL;
        break;
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

/********************************************************************************
 NAME:          EngShow3ResultWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        allen
 DATE:          2004.09.10
********************************************************************************/
LOCAL MMI_RESULT_E EngShow3ResultWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E        result = MMI_RESULT_TRUE;
    GUI_LCD_DEV_INFO    lcd_dev_info = {GUI_MAIN_LCD_ID,GUI_BLOCK_MAIN};
    GUI_RECT_T          client_rect = {0}; 
    GUI_RECT_T          lab_rect={0};
    GUI_BOTH_RECT_T     client_both_rect =  MMITHEME_GetWinClientBothRect(win_id);
    int16               lab_height = 0;

    if(MMK_IsWindowLandscape(win_id))
    {
        client_rect = client_both_rect.h_rect;
    }
    else
    {
        client_rect = client_both_rect.v_rect;
    }

    lab_rect = client_rect;
    lab_height = (client_rect.bottom - client_rect.top)/3;  
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:       
        lab_rect.bottom = lab_rect.top + lab_height;
        GUILABEL_SetRect(MMIENG_LABEL1_CTRL_ID, &lab_rect, FALSE);
        lab_rect.top =  lab_rect.bottom;
        lab_rect.bottom = lab_rect.top + lab_height ;
        GUILABEL_SetRect(MMIENG_LABEL2_CTRL_ID, &lab_rect, FALSE);
        lab_rect.top =  lab_rect.bottom;
        lab_rect.bottom = client_rect.bottom ;
        GUILABEL_SetRect(MMIENG_LABEL3_CTRL_ID, &lab_rect, FALSE);        
            
        // start timer: if user do not press key in time, window 'll be closed when over time
        if (s_mmieng_show3result_timer_id != 0)
        {
            MMK_StopTimer(s_mmieng_show3result_timer_id);
            s_mmieng_show3result_timer_id = 0;
        }
        s_mmieng_show3result_timer_id = MMK_CreateWinTimer(MMIENG_SHOW3RESULT_WIN_ID, 
                                                        ENG_SHOWRESULT_TIMER_DELAY,
                                                        FALSE
                                                        );      
        GUILABEL_SetBackgroundColor(MMIENG_LABEL1_CTRL_ID, mmi_eng_display.bkgd_color);
        GUILABEL_SetBackgroundColor(MMIENG_LABEL2_CTRL_ID, mmi_eng_display.bkgd_color);
        GUILABEL_SetBackgroundColor(MMIENG_LABEL3_CTRL_ID, mmi_eng_display.bkgd_color);
        GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &s_mmieng_show3result_text1, FALSE);
        GUILABEL_SetText(MMIENG_LABEL2_CTRL_ID, &s_mmieng_show3result_text2, FALSE);
        GUILABEL_SetText(MMIENG_LABEL3_CTRL_ID, &s_mmieng_show3result_text3, FALSE);
        break;

    case MSG_LCD_SWITCH:
        lab_rect.bottom = lab_rect.top + lab_height;
        GUILABEL_SetRect(MMIENG_LABEL1_CTRL_ID, &lab_rect, FALSE);
        lab_rect.top =  lab_rect.bottom;
        lab_rect.bottom = lab_rect.top + lab_height ;
        GUILABEL_SetRect(MMIENG_LABEL2_CTRL_ID, &lab_rect, FALSE);
        lab_rect.top =  lab_rect.bottom;
        lab_rect.bottom = client_rect.bottom ;
        GUILABEL_SetRect(MMIENG_LABEL3_CTRL_ID, &lab_rect, FALSE);    
        break;
        
    case MSG_FULL_PAINT:       
        LCD_FillRect(&lcd_dev_info, client_rect, mmi_eng_display.bkgd_color);
        GUIWIN_SetSoftkeyTextId(MMIENG_SHOW3RESULT_WIN_ID,  (MMI_TEXT_ID_T)TXT_NULL, (MMI_TEXT_ID_T)TXT_NULL, (MMI_TEXT_ID_T)TXT_ENG_RETURN, FALSE);
        break;

    case MSG_APP_WEB:       
    case MSG_KEYDOWN_OK:
    case MSG_KEYDOWN_CANCEL:
        MMK_CloseWin(MMIENG_SHOW3RESULT_WIN_ID);
        break;

    case MSG_TIMER:
        if (*(uint8*)param == s_mmieng_show3result_timer_id) 
        {
            MMK_CloseWin(MMIENG_SHOW3RESULT_WIN_ID);
        }
        else
            result = MMI_RESULT_FALSE;      // need additional process
        break;
        
    case MSG_CLOSE_WINDOW:
        if (s_mmieng_show3result_timer_id != 0)
        {
            MMK_StopTimer(s_mmieng_show3result_timer_id);
            s_mmieng_show3result_timer_id = 0;
        }
        //s_mmieng_show3result_text1.is_ucs2 = FALSE;
        s_mmieng_show3result_text1.wstr_len = 0;
        s_mmieng_show3result_text1.wstr_ptr = PNULL;
        //s_mmieng_show3result_text2.is_ucs2 = FALSE;
        s_mmieng_show3result_text2.wstr_len = 0;
        s_mmieng_show3result_text2.wstr_ptr = PNULL;
        //s_mmieng_show3result_text3.is_ucs2 = FALSE;
        s_mmieng_show3result_text3.wstr_len = 0;
        s_mmieng_show3result_text3.wstr_ptr = PNULL;
        break;
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

/********************************************************************************
 NAME:          EngShowHelpWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        allen
 DATE:          2004.09.13
********************************************************************************/
LOCAL MMI_RESULT_E EngShowHelpWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_STRING_T text = {0};
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    wchar wstr[80] = {0};
    char* str = "Use the left soft key to enter a menu; use the right soft key to leave a menu.";
    uint16 len = strlen( str );
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        text.wstr_ptr = wstr;//"Use the left soft key to enter a menu; use the right soft key to leave a menu.";
        text.wstr_len = len;

        MMI_STRNTOWSTR( wstr, 80, (uint8*)str, len, len );

        GUITEXT_SetString(MMIENG_TEXTBOX1_CTRL_ID, text.wstr_ptr, text.wstr_len, FALSE);
        MMK_SetAtvCtrl(MMIENG_SHOWHELP_WIN_ID, MMIENG_TEXTBOX1_CTRL_ID);
        break;
        
    case MSG_CTL_OK:        
    case MSG_CTL_MIDSK:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(MMIENG_SHOWHELP_WIN_ID);
        break;
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

/********************************************************************************
 NAME:          EngShow3rdPartyVersionWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        zhaohui
 DATE:          2008.09.19
********************************************************************************/
LOCAL MMI_RESULT_E EngShow3rdPartyVersionWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E            result = MMI_RESULT_TRUE;
    GUI_RECT_T                rect = MMITHEME_GetFullScreenRect();
    GUI_LCD_DEV_INFO    lcd_dev_info = {GUI_MAIN_LCD_ID, GUI_BLOCK_MAIN};
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        MMK_SetAtvCtrl(win_id, MMIENG_3RDPARTY_VERSION_CTRL_ID);
        Show3rdPartyVersionInfo(FALSE);
        break;
        
    case MSG_FULL_PAINT:
        lcd_dev_info.lcd_id = GUI_MAIN_LCD_ID;
        lcd_dev_info.block_id = GUI_BLOCK_MAIN;
        LCD_FillRect(&lcd_dev_info, rect, mmi_eng_display.bkgd_color);
        break;
        
    case MSG_CTL_OK:        
    case MSG_CTL_CANCEL:
    case MSG_CTL_MIDSK:
        MMK_CloseWin(win_id);
        break;
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

/*****************************************************************************/
//  Description : 显示第三方软件版本信息
//  Global resource dependence : 
//  Author: zhaohui
//  Note:
/*****************************************************************************/
LOCAL void Show3rdPartyVersionInfo(
                            BOOLEAN   need_update
                            )
{
    wchar        unicode_cr = 0x0d;
    MMI_STRING_T    cr_s = {0};
    MMI_STRING_T    text_s = {0};
    uint16           uint16_str[MMIENG_3RDPARTYVER_TEXT_LEN + 1] = {0};
    uint16          uint16_str_len = 0;
    char*          temp_ptr = PNULL;
    uint16          temp_len = 0;
    
    cr_s.wstr_ptr = &unicode_cr;
    cr_s.wstr_len = 1;

    //set im
    temp_ptr = "Im Version:";
    temp_len = 11;
    MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行     
#ifndef _WIN32
#ifdef IM_ENGINE_CSTAR
    temp_ptr = CS_IMM_GetVersion();     /*lint !e605*/
#else
    temp_ptr = "IM_R1.0.5003.C0.2";
#endif

#else
    temp_ptr = "IM_R1.0.5003.C0.2"; // this is a example for simulator
#endif  
    temp_len = SCI_STRLEN((char*)temp_ptr);
    MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行

#if (defined(DM_SUPPORT) || defined(DM_ONLY_SELFREG_SUPPORT))
    MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行
    //set dm
    temp_ptr = "Dm Version: ";
    temp_len =(uint16)SCI_STRLEN((char*)temp_ptr); 
    MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行     
    temp_ptr = MMIAPIDM_GetVersion();   // this is a example for simulator
    if (PNULL == temp_ptr)
    {
        temp_ptr = "NONE";
    }
    temp_len = SCI_STRLEN((char*)temp_ptr);
    MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行
    
#endif  
#ifdef JAVA_SUPPORT    
    MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行
    //set java
    temp_ptr = "Java Version: ";
    temp_len =(uint16)SCI_STRLEN((char*)temp_ptr); 
    MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)temp_ptr, temp_len );/*lint !e605*/
    MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行     
    temp_ptr = MMIAPIJAVA_GetVersion();/*lint !e605*/
    temp_len = SCI_STRLEN((char*)temp_ptr);
    MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行
#endif

/* BEGIN: Added by George.Liu 01526, 2010/8/23   MS:00196383 */
#ifdef MMI_WIFI_SUPPORT
    temp_ptr = "WiFi Version:";
    temp_len = 13;
    MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)temp_ptr, temp_len);
    MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行
#if 0  // for suport MARLIN2 
//#ifndef _WIN32
    temp_ptr = WIFI_GetVersion();
    temp_len = SCI_STRLEN((char*)temp_ptr);
//#else
#endif
    temp_ptr = "WIFI_CSR_1.0";  // this is a example for simulator
    temp_len = 12;
//#endif
    MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)temp_ptr, temp_len);
    MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行
#endif
/* END:   Added by George.Liu 01526, 2010/8/23   MS:00196383 */

#ifdef BROWSER_SUPPORT_DORADO 
    if (PNULL != MMIAPIBROWSER_GetVersion(MMIBROWSER_TYPE_DORADO))
    {
        MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行
        //set Browser
        temp_ptr = "Browser Version(DORADO): ";
        temp_len =(uint16)SCI_STRLEN((char*)temp_ptr); 
        MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)temp_ptr, temp_len );
        MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行
        temp_ptr = MMIAPIBROWSER_GetVersion(MMIBROWSER_TYPE_DORADO);
        temp_len = SCI_STRLEN((char*)temp_ptr);
        MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)temp_ptr, temp_len );
        MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行
    }
#endif    
#ifdef BROWSER_SUPPORT_NETFRONT
    if (PNULL != MMIAPIBROWSER_GetVersion(MMIBROWSER_TYPE_NF))
    {
        MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行
        //set Browser
        temp_ptr = "Browser Version(NF): ";
        temp_len =(uint16)SCI_STRLEN((char*)temp_ptr); 
        MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)temp_ptr, temp_len );
        MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行
        temp_ptr = MMIAPIBROWSER_GetVersion(MMIBROWSER_TYPE_NF);
        temp_len = SCI_STRLEN((char*)temp_ptr);
        MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)temp_ptr, temp_len );
        MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行
    }
#endif    
#ifdef OPERA_MINI_SUPPORT
    if (PNULL != MMIAPIBROWSER_GetVersion(MMIBROWSER_TYPE_OPERA_MINI))
    {
        MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行
        //set Browser
        temp_ptr = "Browser Version(Opera Mini): ";
        temp_len =(uint16)SCI_STRLEN((char*)temp_ptr); 
        MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)temp_ptr, temp_len );
        MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行
        temp_ptr = MMIAPIBROWSER_GetVersion(MMIBROWSER_TYPE_OPERA_MINI);
        temp_len = SCI_STRLEN((char*)temp_ptr);
        MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)temp_ptr, temp_len );
        MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行
    }

#endif    

    text_s.wstr_ptr = uint16_str;
    text_s.wstr_len = uint16_str_len;

    GUITEXT_SetString(MMIENG_3RDPARTY_VERSION_CTRL_ID, text_s.wstr_ptr, text_s.wstr_len, need_update);
}

/********************************************************************************
 NAME:          EngShowLayer1MonitorWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        gang.tong
 DATE:          2006.01.09
********************************************************************************/
LOCAL MMI_RESULT_E EngShowLayer1MonitorWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_STRING_T text = {0};
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    LAYER1_MONITOR_ITEM_T monitor_item = {0};
#ifndef MMI_DUALMODE_ENABLE
    RRA_MONITOR_ITEM_T item_ptr = {0};  //pizer.fan temp-modify
#endif

#ifndef MMI_DUALMODE_ENABLE
    uint8 showbuf[1224] = {0};
#else
    uint8 showbuf[1024] = {0};
#endif
    uint8 item_show_buf[64] = {0};
    
#ifndef _WIN32
    LAYER1_GetLayer1MonItem(&monitor_item); 

#ifndef MMI_MULTI_SIM_SYS_SINGLE
#ifndef MMI_DUALMODE_ENABLE
    RRA_GetRraMonItem(&item_ptr);//pizer.fan temp-modify
#endif //endif MMI_DUALMODE_ENABLE
#endif

#else
    SCI_MEMSET(&monitor_item,0,sizeof(LAYER1_MONITOR_ITEM_T));
#ifndef MMI_DUALMODE_ENABLE
    SCI_MEMSET(&item_ptr,0,sizeof(RRA_MONITOR_ITEM_T)); //pizer.fan temp-modify
#endif //endif MMI_DUALMODE_ENABLE

#endif
    //@yongwei.he fix cr97274 begin
    sprintf((char*)item_show_buf, "%s = %lu\n", "bsic_search_total", monitor_item.bsic_search_total);
    strcat((char*)showbuf, (char*)item_show_buf);
    sprintf((char*)item_show_buf, "%s = %lu\n", "bsic_search_succ", monitor_item.bsic_search_succ);
    strcat((char*)showbuf, (char*)item_show_buf);
    sprintf((char*)item_show_buf, "%s = %lu\n", "bsic_confirm_total", monitor_item.bsic_confirm_total);
    strcat((char*)showbuf, (char*)item_show_buf);
    sprintf((char*)item_show_buf, "%s = %lu\n", "bsic_confirm_succ", monitor_item.bsic_confirm_succ);
    strcat((char*)showbuf, (char*)item_show_buf);
    sprintf((char*)item_show_buf, "%s = %lu\n", "scell_bcch_total", monitor_item.scell_bcch_total);
    strcat((char*)showbuf, (char*)item_show_buf);
    sprintf((char*)item_show_buf, "%s = %lu\n", "scell_bad_bcch", monitor_item.scell_bad_bcch);
    strcat((char*)showbuf, (char*)item_show_buf);
    sprintf((char*)item_show_buf, "%s = %lu\n", "ncell_bcch_total", monitor_item.ncell_bcch_total);
    strcat((char*)showbuf, (char*)item_show_buf);
    sprintf((char*)item_show_buf, "%s = %lu\n", "ncell_bad_bcch", monitor_item.ncell_bad_bcch);
    strcat((char*)showbuf, (char*)item_show_buf);
    sprintf((char*)item_show_buf, "%s = %lu\n", "rxlev_total", monitor_item.rxlev_total);
    strcat((char*)showbuf, (char*)item_show_buf);
    sprintf((char*)item_show_buf, "%s = %lu\n", "rxlev_bad", monitor_item.rxlev_bad);
    strcat((char*)showbuf, (char*)item_show_buf);
    
    sprintf((char*)item_show_buf, "%s = %lu\n", "pch_block_total", monitor_item.pch_block_total);
    strcat((char*)showbuf, (char*)item_show_buf);
    sprintf((char*)item_show_buf, "%s = %lu\n", "bad_pch_num", monitor_item.bad_pch_num);
    strcat((char*)showbuf, (char*)item_show_buf);
    sprintf((char*)item_show_buf, "%s = %lu\n", "rla_sort_total", monitor_item.rla_sort_total);
    strcat((char*)showbuf, (char*)item_show_buf);
    
    sprintf((char*)item_show_buf, "%s = %lu\n", "tx_rach_num", monitor_item.send_rach_num);
    strcat((char*)showbuf, (char*)item_show_buf);
    sprintf((char*)item_show_buf, "%s = %lu\n", "rx_agch_num", monitor_item.rx_agch_num);
    strcat((char*)showbuf, (char*)item_show_buf);
    sprintf((char*)item_show_buf, "%s = %lu\n", "tx_prach_num",monitor_item.send_prach_num);
    strcat((char*)showbuf, (char*)item_show_buf);
    sprintf((char*)item_show_buf, "%s = %lu\n", "rx_pagch_num", monitor_item.rx_pagch_num);
    strcat((char*)showbuf, (char*)item_show_buf);
//pizer.fan temp-modify

    sprintf((char*)item_show_buf, "%s = %lu\n", "dummy_pch_cnt", monitor_item.dummy_pch_cnt);
    strcat((char*)showbuf, (char*)item_show_buf);
    sprintf((char*)item_show_buf, "%s = %lu\n", "detected_dummy_pch_cnt", monitor_item.detected_dummy_pch_cnt);
    strcat((char*)showbuf, (char*)item_show_buf);
    sprintf((char*)item_show_buf, "%s = %lu\n", "burst_pch_cnt1",monitor_item.burst_pch_cnt1);
    strcat((char*)showbuf, (char*)item_show_buf);
    sprintf((char*)item_show_buf, "%s = %lu\n", "burst_pch_cnt2", monitor_item.burst_pch_cnt2);
    strcat((char*)showbuf, (char*)item_show_buf);   
    sprintf((char*)item_show_buf, "%s = %lu\n", "burst_pch_cnt3",monitor_item.burst_pch_cnt3);
    strcat((char*)showbuf, (char*)item_show_buf);
    sprintf((char*)item_show_buf, "%s = %lu\n", "burst_pch_cnt4", monitor_item.burst_pch_cnt4);
    strcat((char*)showbuf, (char*)item_show_buf);

    
#ifndef MMI_DUALMODE_ENABLE
    sprintf((char*)item_show_buf, "%s = %lu\n", "bcch_camp_num", monitor_item.bcch_camp_num);
    strcat((char*)showbuf, (char*)item_show_buf);
    sprintf((char*)item_show_buf, "%s = %lu\n", "pwrswp_num", monitor_item.pwrswp_num);
    strcat((char*)showbuf, (char*)item_show_buf);
    sprintf((char*)item_show_buf, "%s = %lu\n", "handover_total", monitor_item.handover_total);
    strcat((char*)showbuf, (char*)item_show_buf);
    sprintf((char*)item_show_buf, "%s = %lu\n", "handover_fail", monitor_item.handover_fail);
    strcat((char*)showbuf, (char*)item_show_buf);   

//pizer.fan temp-modify
#if 0    
    sprintf((char*)item_show_buf, "%s = %lu\x0d", "powersweep_req_1", item_ptr.powersweep_req_1);
    strcat((char*)showbuf, (char*)item_show_buf);   
    sprintf((char*)item_show_buf, "%s = %lu\x0d", "powersweep_to_layer1_0", item_ptr.powersweep_to_layer1_0);
    strcat((char*)showbuf, (char*)item_show_buf);   
    sprintf((char*)item_show_buf, "%s = %lu\x0d", "powersweep_to_layer1_1", item_ptr.powersweep_to_layer1_1);
    strcat((char*)showbuf, (char*)item_show_buf);   
    sprintf((char*)item_show_buf, "%s = %lu\x0d", "fab_powersweep_cnf_num", item_ptr.fab_powersweep_cnf_num);
    strcat((char*)showbuf, (char*)item_show_buf);   
    sprintf((char*)item_show_buf, "%s = %lu\x0d", "rach_exp_num", item_ptr.rach_exp_num);
    strcat((char*)showbuf, (char*)item_show_buf);   
    sprintf((char*)item_show_buf, "%s = %lu\x0d", "rach_delay_exp_num",item_ptr.rach_delay_exp_num);
    strcat((char*)showbuf, (char*)item_show_buf);   
    sprintf((char*)item_show_buf, "%s = %lu\x0d", "fab_scell_meas_num",item_ptr.fab_scell_meas_num);
    strcat((char*)showbuf, (char*)item_show_buf);
#endif
    
#endif
    text.wstr_len = strlen((char*)showbuf);
    //SCI_TRACE_LOW:"EngShowLayer1MonitorWinHandleMsg text.wstr_len is %d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_3108_112_2_18_2_17_47_126,(uint8*)"d",text.wstr_len);
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        {
            wchar* wstr = (wchar*)SCI_ALLOC_APP(1225 * sizeof(wchar));

            text.wstr_ptr = wstr;

            MMI_STRNTOWSTR( wstr, 1224, showbuf, text.wstr_len, text.wstr_len );

            GUITEXT_SetString(MMIENG_TEXTBOX1_CTRL_ID, text.wstr_ptr, text.wstr_len, FALSE);
            MMK_SetAtvCtrl(win_id, MMIENG_TEXTBOX1_CTRL_ID);

            SCI_FREE( wstr );
        }
        break;
        
    case MSG_FULL_PAINT:
        // the softkey is different between UI-TEST mode and Engineer mode
        if (g_mmieng_showversion_from_ui)
            GUIWIN_SetSoftkeyTextId(win_id,  0, STXT_UP, 0, FALSE);
        else
            GUIWIN_SetSoftkeyTextId(win_id,  TXT_ENG_OK, TXT_NULL, TXT_ENG_RETURN, FALSE);
        break;
        
    case MSG_KEYDOWN_UP:
        // only in UI-TEST mode, UP key will do the next action; otherwise will do nothing
        if (g_mmieng_showversion_from_ui)                    
        {
            MMIAPIENG_RunUITestNextStep();
            MMK_CloseWin(win_id);
        }    
        break;

    case MSG_CTL_MIDSK:     
    case MSG_CTL_OK:
    case MSG_CTL_CANCEL:
        // only in Engineer mode, OK / CANCEL key will close this window; otherwise will do nothing
        if (!g_mmieng_showversion_from_ui)
            MMK_CloseWin(win_id);
        break;

#ifdef FLIP_PHONE_SUPPORT        
    case MSG_KEYDOWN_FLIP:      // close flip
        // in UI-TEST mode, close FLIP will do nothing
        if (!g_mmieng_showversion_from_ui)
            result = MMI_RESULT_FALSE;
        break;
#endif
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}


/********************************************************************************
 NAME:          EngShowPowersweepInfoWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        Jerry Liang
 DATE:          2008.07.30
********************************************************************************/
// LOCAL MMI_RESULT_E EngShowPowersweepInfoWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
// {
//     MMI_RESULT_E result = MMI_RESULT_TRUE;
//     
//     switch (msg_id) 
//     {
//     case MSG_OPEN_WINDOW:
//         {
//             wchar* wstr = (wchar*)SCI_ALLOC_APP(4097 * sizeof(wchar));
//             MMI_STRING_T text = {0};
//             MN_ENG_POWER_SWEEP_INFO_T sweep_info = {0}; 
//             uint8 item_show_buf[64] = {0};
//         #ifdef _WIN32 
//             int i;  
//         #endif  
//             int j;
// 
//             uint8 *no_sim = "NO SIM CARD!! \n"; /*lint !e64*/
// 
//             uint8 *showbuf = PNULL;
//             
//             //该数组不做宏控制: wast some memory(about 60 Bytes) but keep code clearly!!!
//             uint8 sim_str[][30] = {"SIM CARD 1 \n","SIM CARD 2 \n","SIM CARD 3 \n","SIM CARD 4 \n"}; 
//             
//             MN_DUAL_SYS_E dual_sys = MN_DUAL_SYS_1;
// 
//             showbuf = (uint8 *)SCI_ALLOCA((MMI_DUAL_SYS_MAX * 2048));
// 
//             if (PNULL == showbuf)
//             {
//                 MMK_CloseWin(win_id);
//                 break;
//             }
// 
//             SCI_MEMSET(showbuf, 0x00, (MMI_DUAL_SYS_MAX * 2048));
// 
//             if(0 == MMIAPIPHONE_GetSimExistedNum(PNULL,1))
//             {        
//                 strcat((char*)showbuf, (char*)no_sim);
//             }
//             else
//             {
//                 for(dual_sys = MN_DUAL_SYS_1; dual_sys < MMI_DUAL_SYS_MAX; dual_sys++)
//                 {
//                     //BOOLEAN is_sim_exist = 
//                     if(MMIAPIPHONE_GetSimExistedStatus(dual_sys))
//                     {
//                     #ifndef _WIN32    
//                         MNENG_GetPowerSweepInfoEx( dual_sys,&sweep_info );
//                     #else
//                         sweep_info.num = 40;
//                         for( i=0;i<40;i++)
//                         {
//                              sweep_info.pwr_result_list[i].arfcn = i+1;
//                              sweep_info.pwr_result_list[i].rssi = (i+1)*100;
//                         }
//                     #endif
//                         
//                         strcat((char*)showbuf, (char*)sim_str[dual_sys]);
//                         
//                         for( j=0;j<sweep_info.num;j++)
//                         {
//                             sprintf((char*)item_show_buf, "%d  arfcn=%d  rssi=%d \x0d", j+1, sweep_info.pwr_result_list[j].arfcn, sweep_info.pwr_result_list[j].rssi);
//                             strcat((char*)showbuf, (char*)item_show_buf);
//                             SCI_MEMSET(item_show_buf,0,(sizeof(uint8)*64));
//                         }                
//                     }
//                 }
//             }
//             
//             text.wstr_len = MIN(strlen((char*)showbuf), 4096);/*lint !e666*/
//             
//             text.wstr_ptr = wstr;
//             
//             MMI_STRNTOWSTR( wstr, 4096,  showbuf, text.wstr_len, text.wstr_len );
//             GUITEXT_SetString(MMIENG_TEXTBOX1_CTRL_ID, text.wstr_ptr,text.wstr_len,FALSE);
//             MMK_SetAtvCtrl(win_id, MMIENG_TEXTBOX1_CTRL_ID);
//             
//             SCI_FREE( wstr );
//             SCI_FREE( showbuf );
//         }
//         break;
//         
//     case MSG_FULL_PAINT:
//         // the softkey is different between UI-TEST mode and Engineer mode
//         if (g_mmieng_showversion_from_ui)
//             GUIWIN_SetSoftkeyTextId(win_id,  0, STXT_UP, 0, FALSE);
//         else
//             GUIWIN_SetSoftkeyTextId(win_id,  TXT_ENG_OK, TXT_NULL, TXT_ENG_RETURN, FALSE);
//         break;
//         
//     case MSG_KEYDOWN_UP:
//         // only in UI-TEST mode, UP key will do the next action; otherwise will do nothing
//         if (g_mmieng_showversion_from_ui)                    
//         {
//             MMIAPIENG_RunUITestNextStep();
//             MMK_CloseWin(win_id);
//         }    
//         break;
// 
//     case MSG_CTL_MIDSK:     
//     case MSG_CTL_OK:
//     case MSG_CTL_CANCEL:
//         // only in Engineer mode, OK / CANCEL key will close this window; otherwise will do nothing
//         if (!g_mmieng_showversion_from_ui)
//             MMK_CloseWin(win_id);
//         break;
// 
// #ifdef FLIP_PHONE_SUPPORT        
//     case MSG_KEYDOWN_FLIP:      // close flip
//         // in UI-TEST mode, close FLIP will do nothing
//         if (!g_mmieng_showversion_from_ui)
//             result = MMI_RESULT_FALSE;
//         break;
// #endif
//     
//     default:
//         result = MMI_RESULT_FALSE;
//         break;
//     }
//     return (result);
// }

/********************************************************************************
 NAME:          GetSCNetInfoStr
 DESCRIPTION:   
 PARAM IN:      net_buf - 
                buf_len - 
 PARAM OUT:     net info string len
 AUTHOR:        allen
 DATE:          2004.09.08
********************************************************************************/
LOCAL int GetSCNetInfoStr(uint8* net_buf, uint16 buf_len)
{
    MN_PHONE_SCELL_MEAS_T scell = {0};
    uint8 digit_buf1[19] = {0};
    uint8 digit_buf2[19] = {0};
    int len1 = 0, len2 = 0;
    int offset = 0;
    
    if(PNULL == net_buf)
    {
        //SCI_TRACE_LOW:"mmieng_win.c GetSCNetInfoStr net_buf == null"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_3317_112_2_18_2_17_47_127,(uint8*)"");
        return -1;
    }
    
    //SCI_TRACE_LOW:"mmieng_win.c GetSCNetInfoStr buf_len is %d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_3321_112_2_18_2_17_47_128,(uint8*)"d",buf_len);
    if(2 > buf_len)
    {
        return -2;
    }

    
    #ifndef _WIN32
#ifdef MMI_DUALMODE_ENABLE
    scell = em_GetRSSIEx(MMIAPISET_GetActiveSim());
#else
    scell = MNPHONE_GetRSSIEx(MMIAPISET_GetActiveSim());
#endif
    #else
    scell.arfcn = 123;
    scell.rxlev =67;// 567;
    #endif
    MMIAPICOM_Int2Str(scell.arfcn, digit_buf1, 18); // absolute RF channel number
    MMIAPICOM_Int2Str((uint32)scell.rxlev, digit_buf2, 18); // Radio Signal Strength Indicator
    len1 = SCI_STRLEN((char*)digit_buf1);
    MMI_MEMCPY(net_buf + offset, buf_len - offset, digit_buf1, 18, len1);
    offset += len1;
    len2 = SCI_STRLEN((char*)digit_buf2);
    if (len1 + len2 + 1 <= ENG_WIN_MAX_CHAR)
    {
        MMI_MEMCPY(net_buf + offset, buf_len - offset, ",", 1, 1);
        offset += 1;
        MMI_MEMCPY(net_buf + offset, buf_len - offset, digit_buf2, 18, len2);
        offset += len2;
    }
    return (offset);
}

/********************************************************************************
 NAME:          GetNCNetInfoStr
 DESCRIPTION:   
 PARAM IN:      net_buf - 
                buf_len - 
 PARAM OUT:     net info string len
 AUTHOR:        allen
 DATE:          2004.09.08
********************************************************************************/
#ifdef MMI_DUALMODE_ENABLE
extern   ERR_MNPHONE_CODE_E em_GetMeasReportEx(
                MN_DUAL_SYS_E dual_sys,
                APP_MN_NCELL_RSSI_CNF_T *ncell_meas_ptr,
                MN_PHONE_CELL_MEAS_T    *scell_meas_ptr
                );      /*lint !e762*/
#endif
LOCAL int GetNCNetInfoStr(uint8* net_buf, uint16 buf_len)
{
    APP_MN_NCELL_RSSI_CNF_T ncell = {PNULL};
//     MN_PHONE_CELL_MEAS_T     scell={PNULL};
    uint8 digit_buf1[19] = {0};
    uint8 digit_buf2[19] = {0};
    int i = 0;
//@yongwei.he fix cr98371 begin    
       int index_present[MN_MAX_NCELL_NUM] = {0};
       int num_present = 0;
//@yongwei.he fix cr98371 end      
    int len1 = 0, len2 = 0;
    int offset = 0;
    
    if(PNULL == net_buf)
    {
        //SCI_TRACE_LOW:"mmieng_win.c GetNCNetInfoStr net_buf == null"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_3385_112_2_18_2_17_48_129,(uint8*)"");
        return -1;
    }
    
    //SCI_TRACE_LOW:"mmieng_win.c GetNCNetInfoStr buf_len is %d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_3389_112_2_18_2_17_48_130,(uint8*)"d",buf_len);
    if(2 > buf_len)
    {
        return -2;
    }
    
#ifndef _WIN32
#ifdef MMI_DUALMODE_ENABLE
#ifdef _8800D_OLD_API
#ifdef TIANLONG_MOCOR
    if (em_GetMeasReport(&ncell,PNULL) == MN_RETURN_SUCCESS)
#else
    if (em_GetMeasReport(&ncell)==MN_RETURN_SUCCESS)
#endif
#else
    if (em_GetMeasReportEx(MMIAPISET_GetActiveSim(), &ncell, PNULL)==MN_RETURN_SUCCESS)//(MNPHONE_GetMeasReportEx(MMIAPISET_GetActiveSim(), &ncell,&scell) == MN_RETURN_SUCCESS)
#endif
#else
#ifdef _8800D_OLD_API
#ifdef TIANLONG_MOCOR
    if (MNPHONE_GetMeasReport(&ncell,PNULL) == MN_RETURN_SUCCESS)
#else
    if (MNPHONE_GetMeasReport(&ncell)==MN_RETURN_SUCCESS)
#endif
#else
    if (MNPHONE_GetMeasReportEx(MMIAPISET_GetActiveSim(), &ncell, PNULL)==MN_RETURN_SUCCESS)//(MNPHONE_GetMeasReportEx(MMIAPISET_GetActiveSim(), &ncell,&scell) == MN_RETURN_SUCCESS)
#endif
#endif
#else 
    for (i = 0; i < MN_MAX_NCELL_NUM; i++)      // this is for example for simulator
    {
        ncell.ncell_power[i].cell_present = TRUE;
        ncell.ncell_power[i].arfcn = i * 10;
        ncell.ncell_power[i].rxlev = i * 50;
    }
//  if (TRUE)
#endif
    {
//@yongwei.he fix cr98371 begin
                for (i = 0; i < MN_MAX_NCELL_NUM; i++)      // this is for example for simulator
                {
                         if (ncell.ncell_power[i].cell_present) // this channel is served
                        {
                            index_present[num_present++] = i;
                        }
                }
        
                for (i = 0; i < num_present; i++)
          {
                   // order
                MMIAPICOM_Int2Str((uint32)i + 1, digit_buf1, 18);       //( i + 1)   is the No. of NCELL
                len1 = SCI_STRLEN((char*)digit_buf1);
                MMI_MEMCPY(net_buf + offset, buf_len - offset, digit_buf1, 18, len1);
                offset += len1;
                MMI_MEMCPY(net_buf + offset, buf_len - offset, ". ", 2, 2);
                offset += 2;
                     MMIAPICOM_Int2Str(ncell.ncell_power[index_present[i]].arfcn, digit_buf1, 18);
                     MMIAPICOM_Int2Str((uint32)(ncell.ncell_power[index_present[i]].rxlev), digit_buf2, 18);
                     len1 = SCI_STRLEN((char*)digit_buf1);
                     MMI_MEMCPY(net_buf + offset, buf_len - offset, digit_buf1, 18, len1);
                     offset += len1;
                     len2 = SCI_STRLEN((char*)digit_buf2);
                     if (len1 + len2 + 1 <= ENG_WIN_MAX_CHAR)
                     {
                         MMI_MEMCPY(net_buf + offset, buf_len - offset,  ",", 1, 1);
                         offset += 1;
                         MMI_MEMCPY(net_buf + offset, buf_len - offset, digit_buf2, 18, len2);
                         offset += len2;
                     }
                     net_buf[offset] = CR_CHAR;
                     offset += 1;
          }
                for (i = num_present; i < MN_MAX_NCELL_NUM; i++)
                {
                    // order
                    MMIAPICOM_Int2Str(i + 1, digit_buf1, 18);       //( i + 1)   is the No. of NCELL
                    len1 = SCI_STRLEN((char*)digit_buf1);
                    MMI_MEMCPY(net_buf + offset, buf_len - offset, digit_buf1, 18, len1);
                    offset += len1;
                    MMI_MEMCPY(net_buf + offset, buf_len - offset, ". ", 2, 2);
                    offset += 2;
                    MMI_MEMCPY(net_buf + offset, buf_len - offset, "---", 3, 3);
                    offset += 3;
                    net_buf[offset] = CR_CHAR;
                    offset += 1;
                }
//@yongwei.he fix cr98371 end                
    }
    return (offset);
}

/********************************************************************************
 NAME:          EngShowNetWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        ying.xu
 DATE:          2010.7.27
********************************************************************************/
LOCAL int32 EngGetNetInfo(char *buf, int32 buf_length)
{

    char temp_str[1024] = {0} ;   
    int32 offset= 0;
    int32 length = 0;
    char* str = PNULL;
    
    ////////////////
    // served CELL
    ////////////////
    str = "SCELL(arfcn,rxlev)";
    length = SCI_STRLEN(str);       
    if(buf_length - offset <  length)
    {
        return offset;
    }          
    SCI_MEMCPY(buf  + offset , str,length)
        offset += length;
    
    if(buf_length - offset <  1)
    {
        return offset;
    }   
    buf[offset] = CR_CHAR;
    offset += 1;
    
    length = GetSCNetInfoStr((uint8*)temp_str, 1023);
    if(buf_length - offset <  length)
    {
        return offset;
    } 
    SCI_MEMCPY(buf  + offset ,temp_str,(uint32)length)
        offset += length;
    
    if(buf_length - offset <  1)
    {
        return offset;
    } 
    buf[offset] = CR_CHAR;
    offset += 1;
    
    //////////////////
    // neighbor CELL
    //////////////////
    str = "NCELL(arfcn,rxlev)";
    length = SCI_STRLEN(str);     
    if(buf_length - offset <  length)
    {
        return offset;
    } 
    SCI_MEMCPY(buf  + offset , str,(uint32)length)
        offset += length;
    
    if(buf_length - offset <  1)
    {
        return offset;
    } 
    buf[offset] = CR_CHAR;
    offset += 1;
    
    length =  GetNCNetInfoStr((uint8*)temp_str, 1023);
    if(buf_length - offset <  length)
    {
        return offset;
    } 
    SCI_MEMCPY(buf  + offset , temp_str,length)
        offset += length;      
#ifdef ENGTD_SUPPORT
    
    if(buf_length - offset <  1)
    {
        return offset;
    } 
    buf[offset] = CR_CHAR;
    offset += 1;
    
    str = "TDNCELL(arfcn,rxlev)";
    length = SCI_STRLEN(str);        
    if(buf_length - offset <  length)
    {
        return offset;
    } 
    SCI_MEMCPY(buf  + offset , str,length)
        offset += length;
    
    if(buf_length - offset <  1)
    {
        return offset;
    } 
    buf[offset] = CR_CHAR;
    offset += 1;
    
    length =    GetTDNCNetInfoStr((uint8*)temp_str, 1023);
    if(buf_length - offset <  length)
    {
        return offset;
    } 
    SCI_MEMCPY(buf  + offset , temp_str,length)
        offset += length;  
    
    if(buf_length - offset <  1)
    {
        return offset;
    } 
    buf[offset] = CR_CHAR;
    offset += 1;
#endif 
    return offset; 
}
/********************************************************************************
 NAME:          EngShowNetWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        allen
 DATE:          2004.09.08
********************************************************************************/
LOCAL MMI_RESULT_E EngShowNetWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    char buf[1024] = {0};
    wchar wstr[1024] = {0};
    int length = 0; 
    
    MMI_RESULT_E result = MMI_RESULT_TRUE;  
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:       
        length = EngGetNetInfo(buf, 1023);
        MMI_STRNTOWSTR( wstr, 1023, (uint8*)buf, length, length);
        GUITEXT_SetString(MMIENG_TEXTBOX1_CTRL_ID, wstr, length, FALSE);           

        if (s_mmieng_netinfo_timer_id != 0)
        {
            MMK_StopTimer(s_mmieng_netinfo_timer_id);
            s_mmieng_netinfo_timer_id = 0;
        }
        s_mmieng_netinfo_timer_id = MMK_CreateWinTimer(win_id, 2000, FALSE);
        MMK_SetAtvCtrl(win_id,MMIENG_TEXTBOX1_CTRL_ID);
        break;
        
    case MSG_CTL_MIDSK:     
    case MSG_CTL_OK:
    case MSG_CTL_CANCEL:    
    case MSG_KEYDOWN_OK:        
    case MSG_KEYDOWN_CANCEL:
    case MSG_APP_WEB:
        MMK_CloseWin(win_id);
        break;
    case MSG_KEYUP_UP:    
    case MSG_KEYUP_DOWN:
        if (s_mmieng_netinfo_timer_id != 0)
        {
            MMK_StopTimer(s_mmieng_netinfo_timer_id);
            s_mmieng_netinfo_timer_id = 0;
        }
        s_mmieng_netinfo_timer_id = MMK_CreateWinTimer(win_id, 2000, FALSE);
        break;
    case MSG_TIMER:
        if (*(uint8*)param == s_mmieng_netinfo_timer_id) 
        {        
            length = EngGetNetInfo(buf, 1023);
            MMI_STRNTOWSTR( wstr, 1023, (uint8*)buf, length, (uint32)length);
            GUITEXT_SetString(MMIENG_TEXTBOX1_CTRL_ID, wstr, length, TRUE);  
            s_mmieng_netinfo_timer_id = MMK_CreateWinTimer(win_id, 2000, FALSE);
        }
        else
            result = MMI_RESULT_FALSE;      // need additional process
        break;
            
    case MSG_LOSE_FOCUS:
        MMK_PauseTimer(s_mmieng_netinfo_timer_id);
        break;
        
    case MSG_GET_FOCUS: 
        MMK_ResumeTimer(s_mmieng_netinfo_timer_id);
        break;
        
    case MSG_CLOSE_WINDOW:
        if (s_mmieng_netinfo_timer_id != 0)
        {
            MMK_StopTimer(s_mmieng_netinfo_timer_id);
            s_mmieng_netinfo_timer_id = 0;
        }
        break;
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

#define ENGGPRSBUFSIZE 1024
#define GPRS_START_LINE "Press leftkey to test\nPress rightkey to return\n"
LOCAL MMI_RESULT_E EngGprsTestWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{

    static char buf[ENGGPRSBUFSIZE] = {""};
    static wchar wstr[ENGGPRSBUFSIZE] = {0};
    int length = 0;

    MMI_RESULT_E result = MMI_RESULT_TRUE;

    SCI_TRACE_LOW("EngGprsTestWinHandleMsg: msg_id = 0x%x.", msg_id);
    switch (msg_id)
    {

    case MSG_OPEN_WINDOW:
    {
        uint16 lcdWidth = 0;
        uint16 lcdHeight = 0;
        GUI_BG_T btnBg = {0};
        GUI_RECT_T okBtnRect = {0};
        GUI_RECT_T backBtnRect = {0};
        GUI_BOTH_RECT_T  textRect = MMITHEME_GetWinClientBothRect(win_id);

        memset(buf, 0, sizeof(char)*ENGGPRSBUFSIZE);
        memset(wstr, 0, sizeof(wchar)*ENGGPRSBUFSIZE);
        strcat(buf, GPRS_START_LINE);
        length = strlen(buf);
        MMI_STRNTOWSTR( wstr, ENGGPRSBUFSIZE, (uint8*)buf, length, length);
        GUITEXT_SetRect(MMIENG_GPRS_TEST_CTRL_ID, &textRect);
        GUITEXT_SetString(MMIENG_GPRS_TEST_CTRL_ID, wstr, length, FALSE);
#if 0//bug 1915599
        // set button info
        btnBg.bg_type = GUI_BG_COLOR;
        btnBg.color = MMI_BACKGROUND_COLOR;
        GUIBUTTON_SetBg(MMIENG_GPRS_TEST_OK_BUTTON, &btnBg);
        okBtnRect.left = 0;
        okBtnRect.right = lcdWidth / 2 - 1;
        okBtnRect.top = lcdHeight - MMIENG_GPRS_TEST_BUTTON_HEIGHT;
        okBtnRect.bottom = lcdHeight - 1;
        GUIBUTTON_SetRect(MMIENG_GPRS_TEST_OK_BUTTON, &okBtnRect);
        GUIBUTTON_SetTextId(MMIENG_GPRS_TEST_OK_BUTTON, TXT_COMMON_OK);

        GUIBUTTON_SetBg(MMIENG_GPRS_TEST_BACK_BUTTON, &btnBg);
        backBtnRect.left = lcdWidth / 2;
        backBtnRect.right = lcdWidth - 1;
        backBtnRect.top = lcdHeight - MMIENG_GPRS_TEST_BUTTON_HEIGHT;
        backBtnRect.bottom = lcdHeight - 1;
        GUIBUTTON_SetRect(MMIENG_GPRS_TEST_BACK_BUTTON, &backBtnRect);
        GUIBUTTON_SetTextId(MMIENG_GPRS_TEST_BACK_BUTTON, STXT_RETURN);
#endif
        MMK_SetAtvCtrl(win_id,MMIENG_GPRS_TEST_CTRL_ID);
        GprsTest_SetUsedSim(0);
        break;
    }

    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    {
        memset(buf, 0, sizeof(char)*ENGGPRSBUFSIZE);
        memset(wstr, 0, sizeof(wchar)*ENGGPRSBUFSIZE);

        strcat(buf, GPRS_START_LINE);
        strcat(buf, "Begin Test. Please wait...\n");
        MMK_PostMsg(win_id, MSG_FULL_PAINT, NULL, NULL);
        GprsTest_RunPdpActive();
    }
    break;
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
    {
        MMK_CloseWin(win_id);
    }
    break;

    case MSG_ASYN_SOCKET_ACCEPT_IND:
    {
        char *recvData = (char *)param;

        if (param != NULL)
        {
            if (strlen(recvData) > 0)
            {
                SCI_TRACE_LOW("MSG_ASYN_SOCKET_ACCEPT_IND. data =%s.", recvData);
                strcat(buf, recvData);

                MMK_PostMsg(win_id, MSG_FULL_PAINT, NULL, NULL);
            }
        }

        break;
    }

    case MSG_FULL_PAINT:
    {
        //show
        length = strlen(buf);
        if (length <= 0)
            return MMI_RESULT_TRUE;
        MMI_STRNTOWSTR( wstr, ENGGPRSBUFSIZE, (uint8*)buf, length, length);
        GUITEXT_SetString(MMIENG_GPRS_TEST_CTRL_ID, wstr, length, FALSE);

        break;
    }

    case MSG_CLOSE_WINDOW:
        GprsTest_RunPdpDeActive();
        MMK_CloseWin(win_id);
        break;

#ifdef TOUCH_PANEL_SUPPORT
    case MSG_CTL_PENOK:
    {
        if (PNULL == param)
        {
            SCI_TRACE_LOW("EngGprsTestWinHandleMsg: param is PNULL!");
            break;
        }
        if(MMIENG_GPRS_TEST_OK_BUTTON == ((MMI_NOTIFY_T*)param)->src_id)//
        {
            memset(buf, 0, sizeof(char)*ENGGPRSBUFSIZE);
            memset(wstr, 0, sizeof(wchar)*ENGGPRSBUFSIZE);

            strcat(buf, GPRS_START_LINE);
            strcat(buf, "Begin Test. Please wait...\n");
            MMK_PostMsg(win_id, MSG_FULL_PAINT, NULL, NULL);
            GprsTest_RunPdpActive();
            SCI_TRACE_LOW("MMIENG_GPRS_TEST_OK_BUTTON: MSG_CTL_PENOK.");
        }
        else if(MMIENG_GPRS_TEST_BACK_BUTTON == ((MMI_NOTIFY_T*)param)->src_id)//
        {
            SCI_TRACE_LOW("MMIENG_GPRS_TEST_BACK_BUTTON: MSG_CTL_PENOK.");
            MMK_CloseWin(win_id);
        }
        else
        {
            SCI_TRACE_LOW("No need to response: MSG_CTL_PENOK.");
        }
        break;
    }

#endif //TOUCH_PANEL_SUPPORT

    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}
LOCAL int32 IsForcedCell(int16  arfcn)
{
    int32 i = 0;
    for(i = 0; i < s_cell_num; i++)
    {
        if(arfcn == s_cell_arfcn[i])
        {
            return 1;
        }        
    }
    return 0;
}

LOCAL int32 ClearAllCellListData()
{
    //SCI_MEMSET(s_cell_arfcn, -1, sizeof(s_cell_arfcn));
	uint32 i = 0;
	for(i = 0; i < MN_MAX_NCELL_NUM; i++)
	{
		s_cell_arfcn[i] = -1;
	}
    s_cell_num = 0;
    return 0;
}

LOCAL int32 AddCellListData(int16 arfcn)
{
    if(s_cell_num >= MN_MAX_NCELL_NUM)
    {
        return -1;
    }
    s_cell_arfcn[s_cell_num] = arfcn;
    s_cell_num++;
    return 0;
}

LOCAL int32 DelCellListData(int16 arfcn)
{
    int16 i = 0;
    if(s_cell_num == 0)
    {
        return -1;
    }
    for(i = 0; i < s_cell_num; i++ )
    {
        if(s_cell_arfcn[i] == arfcn)
        {
            break;
        }
    }
    if(i == s_cell_num)
    {
        return -2;
    }
    
    for(i; i < s_cell_num - 1; i++)/*lint !e520*/
    {
        s_cell_arfcn[i] = s_cell_arfcn[i + 1];
    }
    s_cell_arfcn[s_cell_num - 1] = -1;
    s_cell_num--;
    return s_cell_num;
}

LOCAL void UpdatePSCellListItem(   
                            MMI_WIN_ID_T     win_id,
                            MMI_CTRL_ID_T    ctrl_id,
                            MN_DUAL_SYS_E    dual_sys,
                            BOOLEAN          is_update
                            )
{
    int32 index = 0;
    APP_MN_NCELL_RSSI_CNF_T ncell = {PNULL};
    MN_PHONE_CELL_MEAS_T    scell  = {0};
    ERR_MNPHONE_CODE_E ps_error = 0;    
    wchar wbuffer[GUILIST_STRING_MAX_NUM + 1] = {0};
    char buffer[GUILIST_STRING_MAX_NUM + 1] = {0};
    uint16 length = 0;
    GUILIST_ITEM_T          item_t    = {0}; /*lint !e64*/
    GUILIST_ITEM_DATA_T     item_data = {0}; /*lint !e64*/
#ifdef WIN32
    static int32 timer = 0;
#endif
    item_t.item_data_ptr = &item_data;
    item_t.item_style    = GUIITEM_STYLE_ONE_LINE_TEXT_ICON;   
    item_t.item_state    = GUIITEM_STATE_SELFADAPT_RECT|GUIITEM_STATE_CONTENT_CHECK;
    item_data.item_content[1].item_data_type     = GUIITEM_DATA_IMAGE_ID;
    item_data.item_content[1].item_data.image_id = IMAGE_CHECK_UNSELECTED_ICON;    
    item_data.item_content[0].item_data_type    = GUIITEM_DATA_TEXT_BUFFER;
    
#ifdef WIN32
    timer++;
    scell.arfcn = 123;
    scell.rxlev = 456;  
    scell.cell_present = TRUE;
    for (index = 0; index < MN_MAX_NCELL_NUM; index ++)      // this is for example for simulator
    {
        ncell.ncell_power[index].cell_present = TRUE;
        ncell.ncell_power[index].arfcn = (index + timer) % 6 ;
        ncell.ncell_power[index].rxlev = index ;
    }
#else
    ps_error = MNPHONE_GetMeasReportEx(dual_sys, &ncell, &scell);
#endif    
    if(scell.cell_present)
    {
        length = sprintf(buffer, "%03d,    %03d,    SCELL", scell.arfcn, scell.rxlev );  
        item_t.user_data    = scell.arfcn;
        MMI_STRNTOWSTR(wbuffer , GUILIST_STRING_MAX_NUM , (const uint8 *)buffer , GUILIST_STRING_MAX_NUM, length);
        item_data.item_content[0].item_data.text_buffer.wstr_len = length;                 
        item_data.item_content[0].item_data.text_buffer.wstr_ptr = wbuffer;

        if(1 == IsForcedCell(scell.arfcn))
        {
            item_data.item_content[1].item_data.image_id = IMAGE_CHECK_SELECTED_ICON;
        }
        else
        {
            item_data.item_content[1].item_data.image_id = IMAGE_CHECK_UNSELECTED_ICON;
        }
     
        if( is_update )
        {
            GUILIST_ReplaceItem( ctrl_id, &item_t, 0 );
        }
        else
        {
            GUILIST_AppendItem( ctrl_id, &item_t );
        }
    }
    for(index = 0; index < MN_MAX_NCELL_NUM; index++)
    {
        if(ncell.ncell_power[index].cell_present)
        {
            SCI_MEMSET(buffer, 0, GUILIST_STRING_MAX_NUM);
            SCI_MEMSET(wbuffer, 0, GUILIST_STRING_MAX_NUM*2);
            length = sprintf(buffer, "%03d,    %03d,    NCELL", 
                ncell.ncell_power[index].arfcn,
                ncell.ncell_power[index].rxlev );    
            item_t.user_data    = ncell.ncell_power[index].arfcn;
            MMI_STRNTOWSTR(wbuffer , GUILIST_STRING_MAX_NUM , (const uint8 *)buffer , GUILIST_STRING_MAX_NUM, length);
            item_data.item_content[0].item_data.text_buffer.wstr_len = length;                 
            item_data.item_content[0].item_data.text_buffer.wstr_ptr = wbuffer;
            if(1 == IsForcedCell(ncell.ncell_power[index].arfcn))
            {
                item_data.item_content[1].item_data.image_id = IMAGE_CHECK_SELECTED_ICON;
            }
            else
            {
                item_data.item_content[1].item_data.image_id = IMAGE_CHECK_UNSELECTED_ICON;
            }

            if( is_update )
            {
                GUILIST_ReplaceItem( ctrl_id, &item_t, index + 1 );
            }
            else
            {
                GUILIST_AppendItem( ctrl_id, &item_t );
            }
         }
    }    
}

LOCAL MMI_RESULT_E EngPSCellOptionMenuWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E    result = MMI_RESULT_TRUE;
    MMI_MENU_GROUP_ID_T group_id = 0;
    MMI_MENU_ID_T   menu_id = 0;

    switch (msg_id)
    {
    case MSG_OPEN_WINDOW:
        MMK_SetAtvCtrl(win_id, MMIENG_OPTION_MENU_CTRL_ID);
        break;

#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_MIDSK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
    case MSG_APP_OK:
        GUIMENU_GetId(MMIENG_OPTION_MENU_CTRL_ID, (MMI_MENU_GROUP_ID_T *)(&group_id),(MMI_MENU_ID_T *) (&menu_id));
        switch ( menu_id )
        {
        case ID_ENG_FROCE_CELL:    
#ifndef PRODUCT_DM
            if(1 <= s_cell_num && s_cell_num <= MN_MAX_NCELL_NUM)
            {
                extern void PS_ForceCampon(uint16 sim_no,uint16 arfcn_count,  ///1 -- 6
                                                            uint16 *arfcn_list);
                uint16   sim_num = (int32)MMK_GetWinAddDataPtr( win_id); 
                PS_ForceCampon( sim_num, s_cell_num, s_cell_arfcn);  /*lint !e64*/
            }                 
#endif      
            break;
        case ID_ENG_CANCEL_FORCE_CELL:
#ifndef PRODUCT_DM
            {
            extern void PS_CancelForceCampon( void  );
            PS_CancelForceCampon(); /*lint !e718 !e746 !e628*/
            }
#endif
           
            ClearAllCellListData();           
            break;            
        default:
            break;
        }
        MMK_CloseWin(win_id);
        break;

    case MSG_APP_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
        
    case MSG_CLOSE_WINDOW:
        break;

    default:
        result = MMI_RESULT_FALSE;
        break;
    }

    return (result);
}

LOCAL MMI_RESULT_E EngPSCellWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    //int length = 0; 
    MN_DUAL_SYS_E sim_num = (int32)MMK_GetWinAddDataPtr( win_id);
    
    MMI_RESULT_E result = MMI_RESULT_TRUE; 
    MMI_CTRL_ID_T   ctrl_id = MMIENG_LISTBOX_CTRL_ID;
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:      
        GUILIST_SetMaxItem(ctrl_id, PSCELLWIN_LIST_MAX_NUM, FALSE);
        UpdatePSCellListItem(win_id, ctrl_id, sim_num, FALSE);
        if (s_mmieng_netinfo_timer_id != 0)
        {
            MMK_StopTimer(s_mmieng_netinfo_timer_id);
            s_mmieng_netinfo_timer_id = 0;
        }
        s_mmieng_netinfo_timer_id = MMK_CreateWinTimer(win_id, 1000, FALSE);
        MMK_SetAtvCtrl(win_id,ctrl_id);
        ClearAllCellListData();
        break;
        
    case MSG_CTL_MIDSK:     
    case MSG_CTL_OK:    
    case MSG_KEYDOWN_OK:        
    case MSG_APP_WEB:        
    case MSG_APP_MENU:        
        MMK_CreateWin((uint32 *) MMIENG_PSCELL_OPTION_MENU_WIN_TAB, (ADD_DATA)sim_num);    
        break;
    
    case MSG_CTL_CANCEL:    
    case MSG_KEYDOWN_CANCEL:
        MMK_CloseWin(win_id);
        break;
        

    case MSG_CTL_LIST_CHECK_CONTENT:   
        {
            uint16 sel_item_index = GUILIST_GetCurItemIndex(ctrl_id);
            uint32 arfcn = 0;
            GUILIST_GetItemData( ctrl_id, sel_item_index , &arfcn );
            if(0 == IsForcedCell(arfcn))
            {
                AddCellListData(arfcn);
            }
            else   
            {
                DelCellListData(arfcn);
            }
            UpdatePSCellListItem(win_id, ctrl_id, sim_num, TRUE);
            MMK_SendMsg(win_id, MSG_FULL_PAINT, 0);
        }        
        break;


    case MSG_TIMER:    
        if((*(uint8*)param) != s_mmieng_netinfo_timer_id)
        {
            break;
        }
        UpdatePSCellListItem(win_id, ctrl_id, sim_num, TRUE);
        MMK_SendMsg(win_id, MSG_FULL_PAINT, 0);
        s_mmieng_netinfo_timer_id = MMK_CreateWinTimer(win_id, 1000, FALSE);
        break;

    case MSG_LOSE_FOCUS:
        if (s_mmieng_netinfo_timer_id != 0)
        {
            MMK_StopTimer(s_mmieng_netinfo_timer_id);
            s_mmieng_netinfo_timer_id = 0;
        }
        break;
        
    case MSG_GET_FOCUS: 
        UpdatePSCellListItem(win_id, ctrl_id, sim_num, TRUE);
        if (s_mmieng_netinfo_timer_id != 0)
        {
            MMK_StopTimer(s_mmieng_netinfo_timer_id);
            s_mmieng_netinfo_timer_id = 0;
        }
        s_mmieng_netinfo_timer_id = MMK_CreateWinTimer(win_id, 1000, FALSE);
        break;
        
    case MSG_CLOSE_WINDOW:
        if (s_mmieng_netinfo_timer_id != 0)
        {
            MMK_StopTimer(s_mmieng_netinfo_timer_id);
            s_mmieng_netinfo_timer_id = 0;
        }        
        ClearAllCellListData();
        break;
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

/********************************************************************************
 NAME:          GetPhoneInfoStr
 DESCRIPTION:   
 PARAM IN:      phone_buf - 
                buf_len - 
 PARAM OUT:     phone info string len
 AUTHOR:        allen
 DATE:          2004.09.25
********************************************************************************/
LOCAL int GetPhoneInfoStr(uint8* phone_buf, uint32 buf_len)
{
    SCI_DATE_T cur_date = {31, 12, 2004, 6};
    SCI_TIME_T cur_time = {59, 59, 23};
       
       SCI_DATE_T  last_date={0,0,0,0};
       SCI_TIME_T   last_time={0,0,0};
    MN_IMEI_T imei = {0};
    char tmp_buf1[20] = {0};
    char tmp_buf2[20] = {0};
       MN_RETURN_RESULT_E return_value = MN_RETURN_FAILURE;
    uint32 offset = 0;
    uint32 freespace = 0;
    uint32 totalspace = 0;
    uint32 voltage = 0;
    uint len = 0;
    uint i = 0;
    int32 j = 0;
    MMIENG_TIME_T s_time_from_turnon = {0};
    uint32  s_sec = 0;

    char*          temp_ptr = PNULL;
    uint16          temp_len = 0;
#ifndef _WIN32    
    CHGMNG_STATE_INFO_T* p_chgmng_info = CHGMNG_GetModuleState();
#endif
#ifdef MMI_DUAL_BATTERY_SUPPORT
    DBAT_STATE_INFO_T* dbat_info=DBAT_GetState();
#endif
    if(PNULL == phone_buf)
    {
        //SCI_TRACE_LOW:"mmieng_win.c GetPhoneInfoStr phone_buf == null"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_4039_112_2_18_2_17_49_131,(uint8*)"");
        return -1;
    }
    
    //SCI_TRACE_LOW:"mmieng_win.c GetPhoneInfoStr buf_len is %d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_4043_112_2_18_2_17_49_132,(uint8*)"d",buf_len);
    if(2 > buf_len)
    {
        return -2;
    }
    
    //手机开机到现在的时间，不过1193小时后会溢出
    s_sec = SCI_GetTickCount()/1000;
    s_time_from_turnon.hour = s_sec/3600;
    s_time_from_turnon.min = (s_sec/60)%60;
    s_time_from_turnon.sec = s_sec%60;  

    //////////////
    // Date Time
    //////////////
    MMI_MEMCPY(phone_buf, buf_len, "<Date Time>", 11, 11);
    offset = 11;
    phone_buf[offset] = CR_CHAR;
    offset += 1;
    if (ERR_TM_NONE == TM_GetSysDate(&cur_date))
    {
        MMIAPISET_FormatDateStrByDateStyle(cur_date.year, cur_date.mon, cur_date.mday,'-',(uint8*)tmp_buf1,20);
        MMI_MEMCPY(phone_buf + offset, buf_len - offset, tmp_buf1, 19, 10);
        offset += 10;
    }
    phone_buf[offset] = CR_CHAR;
    offset += 1;
    if (ERR_TM_NONE == TM_GetSysTime(&cur_time))
    {
        MMIAPISET_FormatTimeStrByTime(cur_time.hour, cur_time.min,(uint8*)tmp_buf1,20);
        MMI_MEMCPY(phone_buf + offset, buf_len - offset, tmp_buf1, 19, 5);
        offset += 5;
    }
    phone_buf[offset] = CR_CHAR;
    offset += 1;
    //////////////
    // Time From Turn on,
    //////////////
    MMI_MEMCPY(phone_buf + offset, buf_len - offset, "<Time from Turn on>", 19, 19);
    offset += 19;
    phone_buf[offset] = CR_CHAR;
    offset += 1;    
    MMI_MEMCPY(phone_buf + offset, buf_len - offset, "hour:", 5, 5);
    offset += 5;
    sprintf(tmp_buf1, "%d", s_time_from_turnon.hour);
    MMI_MEMCPY(phone_buf + offset, buf_len - offset, tmp_buf1, 19, SCI_STRLEN(tmp_buf1));/*lint !e666*/
    offset += SCI_STRLEN(tmp_buf1);
    phone_buf[offset] = CR_CHAR;
    offset += 1;
    MMI_MEMCPY(phone_buf + offset, buf_len - offset, "min:", 4, 4);
    offset += 4;
    sprintf(tmp_buf1, "%d", s_time_from_turnon.min);
    MMI_MEMCPY(phone_buf + offset, buf_len - offset, tmp_buf1, 19, SCI_STRLEN(tmp_buf1));/*lint !e666*/
    offset += SCI_STRLEN(tmp_buf1);
    phone_buf[offset] = CR_CHAR;
    offset += 1;
    //////////////
    // EFS Status
    //////////////
    MMI_MEMCPY(phone_buf + offset, buf_len - offset, "<EFS Status>", 12, 12);/*lint !e666*/
    offset += 12;
    phone_buf[offset] = CR_CHAR;
    offset += 1;
    MMI_MEMCPY(phone_buf + offset, buf_len - offset, "total:", 6, 6);/*lint !e666*/
    offset += 6;
    #ifndef _WIN32
    freespace = EFS_GetFreeSpace();
    totalspace = freespace + EFS_GetUsedSpace();
    #endif
    sprintf(tmp_buf1, "%ld", totalspace);
    MMI_MEMCPY(phone_buf + offset, buf_len - offset, tmp_buf1, 19, SCI_STRLEN(tmp_buf1));/*lint !e666*/
    offset += SCI_STRLEN(tmp_buf1);
    phone_buf[offset] = CR_CHAR;
    offset += 1;
    MMI_MEMCPY(phone_buf + offset, buf_len - offset, "free:", 5, 5);
    offset += 5;
    sprintf(tmp_buf1, "%ld", freespace);
    MMI_MEMCPY(phone_buf + offset, buf_len - offset, tmp_buf1, 19, SCI_STRLEN(tmp_buf1));/*lint !e666*/
    offset += SCI_STRLEN(tmp_buf1);
    phone_buf[offset] = CR_CHAR;
    offset += 1;
    //////////////
    // Battery
    //////////////
    MMI_MEMCPY(phone_buf + offset, buf_len - offset, "<Battery>", 9, 9);
    offset += 9;
    phone_buf[offset] = CR_CHAR;
    offset += 1;
    MMI_MEMCPY(phone_buf + offset, buf_len - offset, "voltage:", 8, 8);
    offset += 8;
#ifndef _WIN32
    #ifdef MMI_DUAL_BATTERY_SUPPORT
    voltage=dbat_info->chgmng_info.bat_statistic_vol;
    #else
    voltage = p_chgmng_info->bat_statistic_vol;
    #endif
#endif

    sprintf(tmp_buf1, "%6.2f", (double)voltage / 1000);
    len = SCI_STRLEN(tmp_buf1);
    MMI_MEMCPY(phone_buf + offset, buf_len - offset, tmp_buf1, 19, len);
    offset += len;
    phone_buf[offset] = CR_CHAR;
    offset += 1;
    MMI_MEMCPY(phone_buf + offset, buf_len - offset, "cur voltage:", 12, 12);
    offset += 12;
#ifndef _WIN32
    #ifdef MMI_DUAL_BATTERY_SUPPORT
    voltage=dbat_info->chgmng_info.bat_cur_vol;
    #else
    voltage = p_chgmng_info->bat_cur_vol;
    #endif
#endif
    sprintf(tmp_buf1, "%6.2f", (double)voltage / 1000);
    len = SCI_STRLEN(tmp_buf1);
    MMI_MEMCPY(phone_buf + offset, buf_len - offset, tmp_buf1, 19, len);
    offset += len;
    phone_buf[offset] = CR_CHAR;
    offset += 1;

    MMI_MEMCPY(phone_buf + offset, buf_len - offset, "charging voltage:", 17, 17);
    offset += 17;
#ifndef _WIN32
    #ifdef MMI_DUAL_BATTERY_SUPPORT
    voltage=dbat_info->chgmng_info.chg_vol ;
    #else
    voltage = p_chgmng_info->chg_vol;
    #endif
#endif
    sprintf(tmp_buf1, "%6.2f", (double)voltage / 1000);
    len = SCI_STRLEN(tmp_buf1);
    MMI_MEMCPY(phone_buf + offset, buf_len - offset, tmp_buf1, 19, len);
    offset += len;
    phone_buf[offset] = CR_CHAR;
    offset += 1;
    
    MMI_MEMCPY(phone_buf + offset, buf_len - offset, "charging cvalue:", 16, 16);
    offset += 16;
#ifndef _WIN32
    #ifdef MMI_DUAL_BATTERY_SUPPORT
    voltage=dbat_info->chgmng_info.charging_current  ;
    #else
    voltage = p_chgmng_info->charging_current ;
    #endif
#endif
    sprintf(tmp_buf1, "%6.2f", (double)voltage / 1000);
    len = SCI_STRLEN(tmp_buf1);
    MMI_MEMCPY(phone_buf + offset, buf_len - offset, tmp_buf1, 19, len);
    offset += len;
    phone_buf[offset] = CR_CHAR;
    offset += 1;
    
    //////////////
    // IMEI
    //////////////
    MMI_MEMCPY(phone_buf + offset, buf_len - offset, "<IMEI>", 6, 6);
    offset += 6;
    phone_buf[offset] = CR_CHAR;
    offset += 1;
    for(j=0;j < MMI_DUAL_SYS_MAX; j++)
    {
         if(!MNNV_GetIMEIEx(MN_DUAL_SYS_1 + j, imei))
         {
            SCI_MEMSET(imei, 0, sizeof(MN_IMEI_T));
         }
        
        SCI_MEMSET(tmp_buf1, 0, 18);
        for (i = 0; i < 8; i++) 
        {
            tmp_buf1[2 * i] = (imei[i]) & 0x0F;
            tmp_buf1[2 * i + 1] = imei[i] >> 4;
        }
        sprintf(    tmp_buf2,
                "%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x",
                tmp_buf1[1], tmp_buf1[2], tmp_buf1[3],
                tmp_buf1[4], tmp_buf1[5], tmp_buf1[6], tmp_buf1[7],
                tmp_buf1[8], tmp_buf1[9], tmp_buf1[10], tmp_buf1[11],
                tmp_buf1[12], tmp_buf1[13], tmp_buf1[14], tmp_buf1[15]
            );
        MMI_MEMCPY(phone_buf + offset, buf_len - offset, tmp_buf2, 19, 15);
        offset += 15;
        phone_buf[offset] = CR_CHAR;
        offset += 1;
    }
    //////////////
    // CHIP ID
    //////////////
    MMI_MEMCPY(phone_buf + offset, buf_len - offset, "<CHIP TYPE>", 11, 11);
    offset += 11;
    phone_buf[offset] = CR_CHAR;
    offset += 1;
#ifndef _WIN32
    temp_ptr = CHIP_GetChipInfo();      /*lint !e605*/
#else
    temp_ptr = "SC6600R1";  
#endif
    temp_len = SCI_STRLEN((char*)temp_ptr);
    MMI_MEMCPY(phone_buf + offset, buf_len - offset, temp_ptr, temp_len, temp_len);
    offset += temp_len;
    phone_buf[offset] = CR_CHAR;
    offset += 1;
    MMI_MEMCPY(phone_buf + offset, buf_len - offset, "<LAST POWEROFF TIME>", 20, 20);
    offset += 20;
    phone_buf[offset] = CR_CHAR;
    offset += 1;

    MMINV_READ(MMIENG_NV_LAST_DATA_ID, &last_date,return_value);   

    MMIAPISET_FormatDateStrByDateStyle(last_date.year, last_date.mon, last_date.mday,'-',(uint8*)tmp_buf1,20);
    MMI_MEMCPY(phone_buf + offset, buf_len - offset, tmp_buf1, 19, 10);
    offset += 10;
    phone_buf[offset] = CR_CHAR;
    offset += 1;
    MMINV_READ(MMIENG_NV_LAST_TIME_ID, &last_time,return_value);    

    MMIAPISET_FormatTimeStrByTime(last_time.hour, last_time.min,(uint8*)tmp_buf1,20);
    MMI_MEMCPY(phone_buf + offset, buf_len - offset, tmp_buf1, 19, 5);
    offset += 5;
    phone_buf[offset] = CR_CHAR;
    offset += 1;

    return (offset);
}

/********************************************************************************
 NAME:          EngShowPhoneWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        allen
 DATE:          2004.09.08
********************************************************************************/
LOCAL MMI_RESULT_E EngShowPhoneWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    uint8 buf[521] = {0};
      wchar wstr[521] = {0};
      char* str = PNULL;
    MMI_STRING_T text = {0};
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:

        str = (char*)buf;
        text.wstr_len = GetPhoneInfoStr(buf, 520);
        text.wstr_ptr = wstr;
        MMI_STRNTOWSTR( wstr, 520, (uint8*)str, text.wstr_len, text.wstr_len );
        GUITEXT_SetString(MMIENG_TEXTBOX1_CTRL_ID, text.wstr_ptr,text.wstr_len, FALSE);
        MMK_SetAtvCtrl(MMIENG_SHOWPHONE_WIN_ID, MMIENG_TEXTBOX1_CTRL_ID);
        break;
        
    case MSG_CTL_MIDSK:     
    case MSG_CTL_OK:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(MMIENG_SHOWPHONE_WIN_ID);
        break;
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

static char **eng_cft_item_name = NULL;
static uint8 *eng_cft_item_type = NULL;
static char *eng_item_name_3G_W[32] = { "BAND1 ", "BAND2 ",
                                    "BAND5 ", "BAND8 ",
                                    "BAND19 ", "BAND6 ", "BAND4 ", "Reserved ",
                                    "Reserved ", "Reserved ",
                                    "Reserved ", "Reserved ", "Final Test ", "Reserved ",
                                    "Reserved ", "Reserved ", "Reserved ",
                                    "reserved ", "Reserved ", "Reserved ",
                                    "Reserved ", "Reserved ", "Reserved ", "Reserved ",
                                    "Reserved ", "Reserved ", "Reserved ",
                                    "Reserved ",
                                    "Reserved ", "Reserved ", "Reserved ", "Reserved "
                                  };
static uint8 eng_item_type_3G_W[32] = { 1, 1, 1, 1,
                                    1, 1, 1, 0,
                                    0, 0,
                                    0, 0, 2, 0,
                                    0, 0, 0, 0, 0, 0,
                                    0, 0, 0, 0, 0, 0, 0,
                                    0,
                                    0, 0, 0, 0
                                  };
static char *eng_item_name_4G_TDD[32] = { "TDD LTE AFC ", "TDD LTE AGC ",
                                      "TDD LTE APC ", "FDD LTE AFC ",
                                      "FDD LTE AGC ", "FDD LTE APC ",
                                      "Reserved ", "Reserved ",
                                      "Reserved ", "Reserved ",
                                      "Reserved ", "Reserved ",
                                      "TDD Lte Final Test ", "Reserved ",
                                      "FDD Lte Final Test ", "Reserved ", "Reserved ",
                                      "reserved ", "Reserved ", "Reserved ",
                                      "Reserved ", "Reserved ", "Reserved ", "Reserved ",
                                      "Reserved ", "Reserved ", "Reserved ",
                                      "Reserved ",
                                      "Reserved ", "Reserved ", "Reserved ", "Reserved "
                                    };
static uint8 eng_item_type_4G_TDD[32] = {     1, 1, 1, 1,
                                    1, 1, 0, 0,
                                    0, 0, 0, 0,
                                    2, 0, 2, 0,
                                    0, 0, 0, 0,
                                    0, 0, 0, 0,
                                    0, 0, 0, 0,
                                    0, 0, 0, 0
                                    };
/********************************************************************************
 NAME:          MMI_Init_Cali_RF_MMI_Test
 DESCRIPTION:
 PARAM IN:      rate_type


 PARAM OUT:
 AUTHOR:        li.liu1
 DATE:          2020.6.8
********************************************************************************/

uint32 MMI_Init_Cali_RF_MMI_Test(uint32  rat_type )
{
    uint32 reserved_info = 0;
#if defined (PLATFORM_ANTISW3)
    if(NETWORK_TYPE_WCDMA == rat_type)
    {
        eng_cft_item_name = eng_item_name_3G_W;
        eng_cft_item_type = eng_item_type_3G_W;
    }
    else if(NETWORK_TYPE_LTE == rat_type)
    {
        eng_cft_item_name = eng_item_name_4G_TDD;
        eng_cft_item_type = eng_item_type_4G_TDD;
    }
    #ifdef WIN32
    reserved_info = 0xc3fe0155;
    #else
    reserved_info = REFPARAM_GetCaliMarkerValueEx(rat_type);
    SCI_TraceLow("MMI_Init_Cali_RF_MMI_Test reserved_info = %d,rat_type = %d",reserved_info,rat_type);
    #endif
#endif
    return reserved_info;
}
/********************************************************************************
 NAME:          MMIENG_GetCalibrateInfo
 DESCRIPTION:
 PARAM IN:      info_buf
                buf_len
                rat_type
 PARAM OUT:
 AUTHOR:        li.liu1
 DATE:          2020.6.8
********************************************************************************/
LOCAL BOOLEAN MMIENG_GetCalibrateInfo(uint8 *info_buf, uint16 buf_len, uint32  rat_type)
{
    uint8 tmp_buf[20] = {0};
    int32 length = 0 ;
    int32 result = 0;
    int32 offset = 0;
    uint32 reserved_info = 0;
    int32 i =0 ;
    const char *if_passed[] = {"Not Pass" , "Pass"};
#if defined (PLATFORM_ANTISW3)

    if(PNULL == info_buf || 20 > buf_len)
    {
        return FALSE;
    }
    reserved_info = MMI_Init_Cali_RF_MMI_Test( rat_type);
    SCI_MEMSET(info_buf, 0, buf_len);
    switch(rat_type)
    {
        case NETWORK_TYPE_WCDMA:
            offset += sprintf((char *)info_buf, "<WCDMA Calibration Info>");
        break;
        case NETWORK_TYPE_LTE:
            offset += sprintf((char *)info_buf, "\n<LTE Calibration Info>");
        break;
    }
    for(i = 0; i<32; i++)
    {
        if(1 != eng_cft_item_type[i] && 2 != eng_cft_item_type[i])
        {
            continue;
        }
        SCI_MEMSET(tmp_buf, 0, 20);
        length = sprintf((char *)tmp_buf,"\r\nBIT%d:",i);
        if(offset + length >= buf_len)
        {
            return TRUE ;
        }
        SCI_MEMCPY(info_buf + offset, tmp_buf, length);
        offset += length;
        length = strlen(eng_cft_item_name[i]);
        if(offset + length >= buf_len)
        {
            return TRUE;
        }
        SCI_MEMCPY(info_buf + offset, eng_cft_item_name[i], length) ;
        offset += length;
        switch(eng_cft_item_type[i])
        {
        case 1:
            result = (reserved_info>>i) & 0x1;
            length = strlen(if_passed[result]);
            if(offset + length >= buf_len)
            {
                return TRUE;
            }
            SCI_MEMCPY(info_buf + offset, if_passed[result], length) ;
            offset += length;
            break;
        case 2:
            result = (reserved_info>>i) & 0x1;
            length = strlen(if_passed[result]);
            if(offset + length >= buf_len)
            {
                return TRUE;
            }
            SCI_MEMCPY(info_buf + offset, if_passed[result], length) ;
            offset += length;
            break;
        default:
            break;
        }
    }
#endif
    return TRUE;
}

/********************************************************************************
 NAME:          GetCalibrateInfoStrToDisplay
 DESCRIPTION:
 PARAM IN:      ctrl_id -
 PARAM OUT:
 AUTHOR:        longwei.qiao
 DATE:          2020.07.14
********************************************************************************/
LOCAL void GetCalibrateInfoStrToDisplay(MMI_CTRL_ID_T ctrl_id)
{
#if defined (PLATFORM_ANTISW3)
    char    index_str[16]     = {0};
    uint16  index_str_len     = 0;
    wchar   wstr_item_str[50] = {0};
    uint16  wstr_item_str_len = 0;
    GUIRICHTEXT_ITEM_T  item_data          = {0};
    GUI_FONT_T          test_result_color  = MMI_BLACK_COLOR;
    uint16              index              = 0;
    int32               length             = 0 ;
    int32               result             = 0;

    uint32 adc_reserved_info , reserved_info= 0;
    int32 i , rat_type =0 ;
#ifdef PLATFORM_SC7702
    uint32 w_adc_reserved_info = 0;
	uint32 temp_info = 0;
	uint32 w_cali_bit = 0x0003c000;
#endif
    const char *item[] = { "PCS AGC ",  "PCS APC ",  "DCS AGC ", "DCS APC ",
                    "EGSM AGC ", "EGSM APC ", "850AGC ",  "850APC ",
                    "AFC ", "ADC ",
                    "PCS Final test ", "DCS Final test ", "GSM Final test ", "GSM850 Final test ",
#ifdef PRODUCT_DM
#ifdef PLATFORM_SC7702
                    "W BAND 1 ", "W BAND 2 ", "W BAND 5 ",
                    "W BAND 8 ", "ANT Test ", "W Final Test ",
#else
                    "TD_AFC ", "TD APC ", "TD AGC ",
                    "TD Final Test ", "ANT Test ", "CMMB Test ",
#endif
#else
                    "reserved ", "reserved ", "reserved ",
                    "reserved ", "reserved ", "reserved ",
#endif
                    "reserved ", "reserved ", "reserved ", "reserved ",
                    "reserved ", "reserved ", "reserved ",
                    "MMI Test ",
                    "Custom1 ", "Custom2 ", "Custom3 ", "Custom4 ",
                    };
    const int32 item_type[32] = {1,1,1,1,
                                1, 1,1,1,
                                1,1,
                                2, 2, 2, 2,      //2, 2, 2, 2,
#ifdef PRODUCT_DM
#ifdef PLATFORM_SC7702
                                1, 1, 1,
                                1, 2, 2,
#else
                                0, 0, 0,
                                0, 2, 2,
#endif
#else
                                0, 0, 0, 0, 0, 0,
#endif
                                0, 0, 0, 0, 0, 0, 0,
                                2,
                                3, 3, 3, 3
                                };
    // 0:reserved 1:adc calibrate 2:test 3:custom
    const char  *if_calibrated[] = {"uncalibrated", "passed"} ;
    const char *if_passed[] = {"failed" , "passed"} ;

    //从NV中读取adc_reserved[7]的信息
#ifdef WIN32
    adc_reserved_info = 0xc3fe0155;/*lint !e64*/
#else
    adc_reserved_info = REFPARAM_GetCaliMarkerValue();
#ifdef PLATFORM_SC7702
    w_adc_reserved_info = REFPARAM_GetCaliMarkerValueEx(NETWORK_TYPE_WCDMA);
	temp_info = w_adc_reserved_info & (0x00000001 << 12);//保存w 第12位信息

	w_adc_reserved_info = w_adc_reserved_info << 14;
	w_adc_reserved_info = w_adc_reserved_info & w_cali_bit;//w信息保存14-17位

    //将接口REFPARAM_GetCaliMarkerValueEx提供的WBAND 信息赋给原信息对应位置
	adc_reserved_info = adc_reserved_info & 0xfffc3fff;	
	adc_reserved_info = adc_reserved_info | w_adc_reserved_info;

    //将接口REFPARAM_GetCaliMarkerValueEx提供的W Final Test 信息赋给原信息对应位置
	adc_reserved_info = adc_reserved_info & 0xfff7ffff;
	temp_info = temp_info << 7;
	adc_reserved_info = adc_reserved_info | temp_info;

    //SCI_TRACE_LOW:"GetAdcCalibrateInfoStr %x"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_4357_112_2_18_2_17_50_135,(uint8*)"d",adc_reserved_info);
#endif
#endif
    if(ARR_SIZE(item) != ARR_SIZE(item_type))       /*lint !e506 !e774*/
    {
        //SCI_TRACE_LOW:"mmieng_win.c GetAdcCalibrateInfoStr array definition error"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_4371_112_2_18_2_17_50_136,(uint8*)"");
        return;
    }
    //append <adc calibrate info>
    index_str_len = SCI_STRLEN("<Adc Calibrate Info>\n");
    SCI_MEMCPY(index_str,  "<Adc Calibrate Info>\n",  index_str_len);
    MMI_STRNTOWSTR(wstr_item_str,50,index_str,50,index_str_len);
    item_data.text_type = GUIRICHTEXT_TEXT_BUF;
    item_data.text_set_font_color = TRUE;
    item_data.setting_font_color= test_result_color;
    item_data.text_set_font = TRUE;
    item_data.setting_font = SONG_FONT_22;
    item_data.text_data.buf.str_ptr = wstr_item_str;
    item_data.text_data.buf.len = MMIAPICOM_Wstrlen(wstr_item_str);
    GUIRICHTEXT_AddItem(ctrl_id, &item_data, &index);
    for(i = 0; i<32; i++)
    {
        //dont display type 0 and 3
        if(0 == item_type[i] || 3 == item_type[i])
        {
            continue;
        }
        //serial num
        SCI_MEMSET(wstr_item_str, 0x00, sizeof(wstr_item_str));
        SCI_MEMSET(index_str, 0x00, sizeof(index_str));
        wstr_item_str_len = 0;
        length            = 0;
        length            = sprintf(index_str, "BIT%d:", i);
        MMIAPICOM_StrcatFromStrToUCS2(wstr_item_str, &wstr_item_str_len, index_str, length);
        //item
        length =  SCI_STRLEN(item[i]); 
        MMIAPICOM_StrcatFromStrToUCS2(wstr_item_str, &wstr_item_str_len, item[i], length);
        //result
        result = (adc_reserved_info>>i) & 0x00000001 ;/*lint !e774*/
        switch (item_type[i])
        {
            case 0:
                break;
            case 1:
                length =  SCI_STRLEN ( if_calibrated[result] );
                MMIAPICOM_StrcatFromStrToUCS2(wstr_item_str, &wstr_item_str_len, if_calibrated[result], length);
                if(result)
                {
                    test_result_color = MMIENG_TEST_PASS_COLOR;
                }
                else
                {
                    test_result_color = MMI_BLACK_COLOR;
                }
                break;
            case 2:
                length =  SCI_STRLEN ( if_passed[result] );
                MMIAPICOM_StrcatFromStrToUCS2(wstr_item_str, &wstr_item_str_len, if_passed[result], length);
                if(result)
                {
                    test_result_color = MMIENG_TEST_PASS_COLOR;
                }
                else
                {
                    test_result_color = MMIENG_TEST_FAIL_COLOR;
                }
                break;
            case 3:
                break;
            default:
                break;
         }
        SCI_MEMSET(&item_data,0,sizeof(GUIRICHTEXT_ITEM_T));
        item_data.text_type = GUIRICHTEXT_TEXT_BUF;
        item_data.text_set_font_color = TRUE;
        item_data.setting_font_color= test_result_color;
        item_data.text_set_font = TRUE;
        item_data.setting_font = SONG_FONT_16;
        item_data.text_data.buf.str_ptr = wstr_item_str;
        item_data.text_data.buf.len = MMIAPICOM_Wstrlen(wstr_item_str);
        GUIRICHTEXT_AddItem(ctrl_id, &item_data, &index);
    }
    /*append WCDMA & LTE calibrate info*/
    for(rat_type = NETWORK_TYPE_GSMTD; rat_type < 4; rat_type++)
    {
            if((NETWORK_TYPE_GSMTD == rat_type)||(NETWORK_TYPE_CDMA2000 == rat_type))
            {
                //MMIENG_CALI_GSMTD 和MMIENG_CALI_GSMTD_CDMA2000不显示
                continue;
            }
            reserved_info = MMI_Init_Cali_RF_MMI_Test( rat_type);
            test_result_color  = MMI_BLACK_COLOR;
            SCI_MEMSET(wstr_item_str, 0x00, sizeof(wstr_item_str));
            SCI_MEMSET(index_str, 0x00, sizeof(index_str));
            wstr_item_str_len = 0;
            index_str_len = 0;
            switch(rat_type)
            {
                case NETWORK_TYPE_WCDMA:
                {
                    //append <WCDMA DELIMITER>
                    index_str_len = SCI_STRLEN("<WCDMA Calibration Info>\n");
                    SCI_MEMCPY(index_str,  "<WCDMA Calibration Info>\n",  index_str_len);
                    MMI_STRNTOWSTR(wstr_item_str,50,index_str,50,index_str_len);
                    item_data.text_type = GUIRICHTEXT_TEXT_BUF;
                    item_data.text_set_font_color = TRUE;
                    item_data.setting_font_color= test_result_color;
                    item_data.text_set_font = TRUE;
                    item_data.setting_font = SONG_FONT_22;
                    item_data.text_data.buf.str_ptr = wstr_item_str;
                    item_data.text_data.buf.len = MMIAPICOM_Wstrlen(wstr_item_str);
                    GUIRICHTEXT_AddItem(MMIENG_TEXTBOX1_CTRL_ID, &item_data, &index);
                }
                break;
                case NETWORK_TYPE_LTE:
                {
                    //append <LTE DELIMITER>
                    index_str_len = SCI_STRLEN("<LTE Calibration Info>\n");
                    SCI_MEMCPY(index_str,  "<LTE Calibration Info>\n",  index_str_len);
                    MMI_STRNTOWSTR(wstr_item_str, 50, index_str, 50, index_str_len);
                    item_data.text_type = GUIRICHTEXT_TEXT_BUF;
                    item_data.text_set_font_color = TRUE;
                    item_data.setting_font_color= test_result_color;
                    item_data.text_set_font = TRUE;
                    item_data.setting_font = SONG_FONT_22;
                    item_data.text_data.buf.str_ptr = wstr_item_str;
                    item_data.text_data.buf.len = MMIAPICOM_Wstrlen(wstr_item_str);
                    GUIRICHTEXT_AddItem(ctrl_id, &item_data, &index);
                }
                break;
                default:
                    break;
            }
            //append <calibrate info>
            for(i = 0; i<32; i++)
            {
                if(1 != eng_cft_item_type[i] && 2 != eng_cft_item_type[i])
                {
                    continue;
                }
                SCI_MEMSET(wstr_item_str, 0x00, sizeof(wstr_item_str));
                SCI_MEMSET(index_str, 0x00, sizeof(index_str));
                wstr_item_str_len = 0;
                index_str_len = 0;
                length = sprintf(index_str, "BIT%d:", i);
                MMIAPICOM_StrcatFromStrToUCS2(wstr_item_str, &wstr_item_str_len, index_str, length);

                length = strlen(eng_cft_item_name[i]);
                MMIAPICOM_StrcatFromStrToUCS2(wstr_item_str, &wstr_item_str_len, eng_cft_item_name[i], length);
                switch(eng_cft_item_type[i])
                {
                case 1:
                    result = (reserved_info>>i) & 0x1;
                    length = strlen(if_passed[result]);
                    MMIAPICOM_StrcatFromStrToUCS2(wstr_item_str, &wstr_item_str_len, if_passed[result], length);
                    if(result)
                    {
                        test_result_color = MMIENG_TEST_PASS_COLOR;
                    }
                    else
                    {
                        test_result_color = MMIENG_TEST_FAIL_COLOR;
                    }
                    break;
                case 2:
                    result = (reserved_info>>i) & 0x1;
                    length = strlen(if_passed[result]);
                    MMIAPICOM_StrcatFromStrToUCS2(wstr_item_str, &wstr_item_str_len, if_passed[result], length);
                    if(result)
                    {
                        test_result_color = MMIENG_TEST_PASS_COLOR;
                    }
                    else
                    {
                        test_result_color = MMIENG_TEST_FAIL_COLOR;
                    }
                    break;
                default:
                    break;
                }
                SCI_MEMSET(&item_data,0,sizeof(GUIRICHTEXT_ITEM_T));
                item_data.text_type = GUIRICHTEXT_TEXT_BUF;
                item_data.text_set_font_color = TRUE;
                item_data.setting_font_color= test_result_color;
                item_data.text_set_font = TRUE;
                item_data.setting_font = SONG_FONT_16;
                item_data.text_data.buf.str_ptr = wstr_item_str;
                item_data.text_data.buf.len = MMIAPICOM_Wstrlen(wstr_item_str);
                GUIRICHTEXT_AddItem(ctrl_id, &item_data, &index);
            }
    }
#endif
}

/********************************************************************************
 NAME:          GetAdcCalibrateInfoStr
 DESCRIPTION:   
 PARAM IN:      adc_info_buf - 
                buf_len - 
 PARAM OUT:     adc info string len
 AUTHOR:        zhaohui
 DATE:          2008.10.24
********************************************************************************/
LOCAL int32 GetAdcCalibrateInfoStr(uint8* adc_info_buf, uint16 buf_len)
{
//     SCI_DATE_T calibrate_date = {0};
//     SCI_TIME_T calibrate_time = {0};
    char tmp_buf1[20] = {0};
//     const int32 temp_buf_length = 20;
    int32 length = 0 ;
    int32 result = 0;
    int32 offset = 0;
    
    uint32 adc_reserved_info = 0;
	uint32 adc_reserved_info_temp=0;
    int32 i =0 ;
#ifdef PLATFORM_SC7702 
    uint32 w_adc_reserved_info = 0;
	uint32 temp_info = 0;
	uint32 w_cali_bit = 0x0003c000;
#endif
    const char *item[] = {
                    "GSM_calib_afc -bit0 ",  "GSM850_calib_agc -bit1 ",  "GSM850_calib_apc -bit2 ", "GSM900_calib_agc -bit3 ",
                    "GSM900_calib_apc -bit4", "DCS1800_calib_agc -bit5", "DCS1800_calib_apc -bit6",  "PCS1900_calib_agc -bit7",
                    "PCS1900_calib_apc -bit8", "GSM_FT_flag -bit9",

                    "LTE_calib_afc -bit0", "LTE_TDD_calib_agc -bit1", "LTE_TDD_calib_apc -bit2", "LTE_TX_calib_pdt -bit3",
#ifdef PRODUCT_DM
#ifdef PLATFORM_SC7702
                    "W BAND 1 ", "W BAND 2 ", "W BAND 5 ", 
                    "W BAND 8 ", "ANT Test ", "W Final Test ",
#else
                    "TD_AFC ", "TD APC ", "TD AGC ", 
                    "TD Final Test ", "ANT Test ", "CMMB Test ",
#endif                   
#else
                    "LTE_FDD_calib_agc -bit4","LTE_FDD_calib_apc -bit5", "LTE_TX_calib_dc -bit6", 
                    "LTE_TX_calib_droop -bit7", "LTE_FT_flag -bit8", "LTE_ANT_TEST -bit9 ", 
#endif
                    "LTE_XTAL_THERM -bit10", "LTE_FT_flag2 -bit11", "LTE_RX_IRR -bit12", "reserved ", 
                    "reserved ", "reserved ", "reserved ", 
                    "MMI Test -bit27 ",
                    "Custom1 ", "Custom2 ", "Custom3 ", "Custom4 ", 
                    };
    const int32 item_type[ADC_CALIBRATE_INFO_ITEM] = {
#ifndef PLATFORM_UWS6121E
                                1,1,1,1,
                                1, 1,1,1,
                                1,1,
#else
                                0,0,0,0,
                                0, 0,0,0,
                                0,0,
#endif
                                1, 1, 1,1,      //2, 2, 2, 2,
#ifdef PRODUCT_DM
#ifdef PLATFORM_SC7702
                                1, 1, 1,
                                1, 2, 2,  
#else
                                1, 1, 1,
                                2, 2, 2,  
#endif                                
#else                            
                                1, 1, 1,
                                1, 1, 1,
#endif
                                0, 1, 1, 0, 0, 0, 0,
                                2,
                                3, 3, 3, 3
                                };
    // 0:reserved 1:adc calibrate 2:test 3:custom

    const char  *if_calibrated[] = {" <N>", " <Y>"} ;
    int32 calibrated_length[2]  = { 0 };
    const char *if_passed[] = {"failed" , "passed"} ;
    int32 passed_length[2]  = {0};

    calibrated_length[0] =  SCI_STRLEN(if_calibrated[0]);
    calibrated_length[1] =  SCI_STRLEN(if_calibrated[1]);

    passed_length[0]  = SCI_STRLEN(if_passed[0]);
    passed_length[1]  = SCI_STRLEN(if_passed[1]);
    
    if(PNULL == adc_info_buf)
    {
        //SCI_TRACE_LOW:"mmieng_win.c GetAdcCalibrateInfoStr adc_info_buf == null"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_4342_112_2_18_2_17_49_133,(uint8*)"");
        return -1;
    }
    
    //SCI_TRACE_LOW:"mmieng_win.c GetAdcCalibrateInfoStr buf_len is %d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_4346_112_2_18_2_17_49_134,(uint8*)"d",buf_len);
    if(2 > buf_len)
    {
        return -2;
    }
    
    //?NV???adc_reserved[7]???
#ifdef WIN32    
    adc_reserved_info = 0xc3fe0155;/*lint !e64*/ 
#else
adc_reserved_info=MNPHONE_GetLteCalibInfo();
adc_reserved_info=adc_reserved_info<<10;
#ifndef PLATFORM_UWS6121E
adc_reserved_info_temp=MNPHONE_GetGsmCalibInfo();
adc_reserved_info=adc_reserved_info|(adc_reserved_info_temp&0x3ff);
#endif
adc_reserved_info_temp = 0;
adc_reserved_info_temp = REFPARAM_GetCaliMarkerValue();
adc_reserved_info=adc_reserved_info|(adc_reserved_info_temp&0x8000000);

//adc_reserved_info=0x3200f;
	SCI_TraceLow("GetAdcCalibrateInfoStr@mmieng_win.c : adc_reserved_info=0x%x",adc_reserved_info);
#ifdef PLATFORM_SC7702 
    w_adc_reserved_info = REFPARAM_GetCaliMarkerValueEx(NETWORK_TYPE_WCDMA);
	temp_info = w_adc_reserved_info & (0x00000001 << 12);//??w ?12???
	
	w_adc_reserved_info = w_adc_reserved_info << 14;
	w_adc_reserved_info = w_adc_reserved_info & w_cali_bit;//w????14-17?

    //???REFPARAM_GetCaliMarkerValueEx???WBAND ???????????
	adc_reserved_info = adc_reserved_info & 0xfffc3fff;	
	adc_reserved_info = adc_reserved_info | w_adc_reserved_info;
	
    //???REFPARAM_GetCaliMarkerValueEx???W Final Test ???????????
	adc_reserved_info = adc_reserved_info & 0xfff7ffff;
	temp_info = temp_info << 7;
	adc_reserved_info = adc_reserved_info | temp_info;
    
    //SCI_TRACE_LOW:"GetAdcCalibrateInfoStr %x"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_4357_112_2_18_2_17_50_135,(uint8*)"d",adc_reserved_info);
#endif
#endif

     if ( offset + 21 >= buf_len)
     {
         return offset ;
     }     
     MMI_MEMCPY(adc_info_buf + offset, buf_len - offset, "<Adc Calibrate Info>", 20, 20);
     offset += 20;
     adc_info_buf[offset] = CR_CHAR;
     offset += 1;
    
    if(ARR_SIZE(item) != ARR_SIZE(item_type))       /*lint !e506 !e774*/
    {
        //SCI_TRACE_LOW:"mmieng_win.c GetAdcCalibrateInfoStr array definition error"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_4371_112_2_18_2_17_50_136,(uint8*)"");
        return -1;        
    }
    
    for(i = 0; i<ADC_CALIBRATE_INFO_ITEM; i++)
    {      
        //dont display type 0 and 3
        if(0 == item_type[i] || 3 == item_type[i])  
        {
            continue;
        } 

        //serial num                   
        SCI_MEMSET(tmp_buf1, 0, 20);
		sprintf(tmp_buf1," ");
        length = strlen(tmp_buf1);
		
        if ( offset + length >= buf_len )
        {
           return offset ;
        }
        SCI_MEMCPY(adc_info_buf + offset,  tmp_buf1, length);        
        offset += length;    

        //item 
        length =  SCI_STRLEN(item[i]) ; 
        if ( offset + length >= buf_len )
        {
           return offset ;
        }      
         SCI_MEMCPY(adc_info_buf + offset, item[i], length) ;
         offset += length;
         
         //result
         result = (adc_reserved_info>>i) & 0x00000001 ;/*lint !e774*/
         switch (item_type[i])
         {
            case 0:             
                break;
            case 1:
                length =  SCI_STRLEN ( if_calibrated[result] );
                if ( offset + length >= buf_len ) 
                {
                    return offset ;
                }
                SCI_MEMCPY(adc_info_buf + offset, if_calibrated[result], length) ;
                offset += length;
                break;
            case 2:
                length =  SCI_STRLEN ( if_passed[result] );
                if ( offset + length >= buf_len ) 
                {
                    return offset ;
                }
                SCI_MEMCPY(adc_info_buf + offset, if_passed[result], length) ;
                offset += length;
                break;
            case 3:
                break;
            default:
                break;
         }   
         
         //enter key
          if ( offset + 1 >= buf_len)
          {
              return offset ;
          }   
          adc_info_buf[offset] = CR_CHAR;
          offset += 1;
    }   
    
    return (offset);

}

#ifdef _SW_ZDT_PRODUCT_
LOCAL BOOLEAN WriteIMEINum(MN_DUAL_SYS_E dual_sys, uint8 *pbuf, uint32 buffer_length);
LOCAL BOOLEAN ConvertNum2IMEICode_Y(uint8 *dst,  uint32 dst_length, char *src, uint32 src_length)
{
    int32 i = 0;
    uint8 tmp_buf1[MN_MAX_IMEI_LENGTH*2 + 1] = {0};
    uint8 moveIndex = 1;
    
    for (i = 0; i < src_length; i++) /*lint !e574 !e737*/
    {
        //tmp_buf1[1 + i] = atoi(&src[i]);
        tmp_buf1[i] = src[i] - '0';
    }
    for (i = 0; i < MN_MAX_IMEI_LENGTH; i++) 
    {
        //dst[i] = (tmp_buf1[2 * i] & 0x0f) | ((tmp_buf1[2 * i + 1] << 4) & 0Xf0);
        //SCI_TRACE_LOW("MMIENG_UpdateNewImei = %x", dst[i]);
        if(i == 0 )
        {
            dst[i] =  ((tmp_buf1[2 * i] << 4) & 0Xf0);
        }
        else
        {
            dst[i] = (tmp_buf1[2 * i-1] & 0x0f) | ((tmp_buf1[2 * i] << 4) & 0Xf0);
        }
    }
    return TRUE;
}


PUBLIC BOOLEAN MMIENG_UpdateNewImei(uint8 *imeiStr)
{
    BOOLEAN ret = FALSE;
    uint8 imei_buffer[MN_MAX_IMEI_LENGTH + 1] = {0};
    char num_buffer[2*MN_MAX_IMEI_LENGTH + 1] = {0}; 
    SCI_TRACE_LOW("MMIENG_UpdateNewImei = %s", imeiStr);
    if(imeiStr == NULL || strlen(imeiStr) != 15)
    
{
        SCI_TRACE_LOW("MMIENG_UpdateNewImei error");
        return ret;
    }
    
    SCI_MEMCPY(num_buffer, imeiStr, 15);//have bug
    //SCI_MEMCPY(num_buffer+1, imeiStr, 15);
    ConvertNum2IMEICode_Y(imei_buffer,  MN_MAX_IMEI_LENGTH, num_buffer, strlen(imeiStr));
    if(WriteIMEINum(0 , imei_buffer,  MN_MAX_IMEI_LENGTH))
    {
        ret = TRUE;
    }
    
    SCI_TRACE_LOW("MMIENG_UpdateNewImei ret = %d", ret);
    return ret;

}

BOOLEAN ZDT_CheckChipCalibrationed(uint32* cali_info)
{
    int32 result = 0;
    uint32 adc_reserved_info = 0;
    uint32 adc_reserved_info_temp=0;
    int32 i =0 ;
    const char *item[] = { "GSM_calib_afc -bit0 ",  "GSM850_calib_agc -bit1 ",  "GSM850_calib_apc -bit2 ", "GSM900_calib_agc -bit3 ", 
                    "GSM900_calib_apc -bit4", "DCS1800_calib_agc -bit5", "DCS1800_calib_apc -bit6",  "PCS1900_calib_agc -bit7", 
                    "PCS1900_calib_apc -bit8", "GSM_FT_flag -bit9",
                    "LTE_calib_afc -bit0", "LTE_TDD_calib_agc -bit1", "LTE_TDD_calib_apc -bit2", "reserved",
                    "LTE_FDD_calib_agc -bit4","LTE_FDD_calib_apc -bit5", "reserved ", 
                    "reserved", "LTE_FT_flag -bit8 ", "reserved ", 
                    "reserved ", "reserved ", "reserved ", "reserved ",
                    "reserved ", "reserved ", "reserved ", 
                    "MMI Test ",
                    "Custom1 ", "Custom2 ", "Custom3 ", "Custom4 ", 
                    };
    const int32 item_type[32] = {0,0,0,0,
                                0, 0,0,0,
                                0,0,
                                1, 1, 1,0,      //2, 2, 2, 2, 
                                1, 1, 0,
                                0, 0, 0,
                                0, 0, 0, 0, 0, 0, 0,
                                0,
                                3, 3, 3, 3
                                };
#ifndef WIN32        
    adc_reserved_info=MNPHONE_GetLteCalibInfo();
    adc_reserved_info=adc_reserved_info<<10;
    adc_reserved_info_temp=0;
    adc_reserved_info=adc_reserved_info|(adc_reserved_info_temp&0x3ff);
    if(cali_info != PNULL)
    {
        *cali_info = adc_reserved_info;
    }
    
    if(ARR_SIZE(item) != ARR_SIZE(item_type))       /*lint !e506 !e774*/
    {
        return FALSE;        
    }
    
    for(i = 0; i<32; i++)
    {      
        //dont display type 0 and 3
        if(0 == item_type[i] || 3 == item_type[i])  
        {
            continue;
        } 
         
         //result
         result = (adc_reserved_info>>i) & 0x00000001 ;/*lint !e774*/
         if(result == 0)
         {
            return FALSE;
         }   
    }   
    #endif
    return TRUE;

}
#endif

/********************************************************************************
 NAME:          EngShowAdcCalibrateWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id -
                msg_id -
                param -
 PARAM OUT:
 AUTHOR:        zhaohui
 DATE:          2008.10.24
********************************************************************************/
LOCAL MMI_RESULT_E EngShowAdcCalibrateWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E  result  = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_TEXTBOX1_CTRL_ID;
    uint8 buf[1024] = {0};
    MMI_STRING_T text = {0};
    wchar w_buf[1024] = {0};
	
    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
#if defined (PLATFORM_ANTISW3)
             GUIRICHTEXT_SetBgColor(ctrl_id,MMI_WHITE_COLOR); //set bg color
             GetCalibrateInfoStrToDisplay(ctrl_id);
#else 
	        text.wstr_len = GetAdcCalibrateInfoStr(buf, 1024);
	        MMI_STRNTOWSTR(w_buf,1024, (const uint8 *)buf,text.wstr_len,text.wstr_len);    
	        text.wstr_ptr = w_buf;
	        GUITEXT_SetString(MMIENG_TEXTBOX1_CTRL_ID, text.wstr_ptr,text.wstr_len,FALSE);
#endif
             MMK_SetAtvCtrl(win_id, ctrl_id);
             break;
        case MSG_CTL_MIDSK:
        case MSG_CTL_OK:
        case MSG_CTL_CANCEL:
            MMK_CloseWin(win_id);
            break;
        case MSG_CLOSE_WINDOW:
            break;

        default:
            result = MMI_RESULT_FALSE;
            break;
    }
    return (result);
}

/********************************************************************************
 NAME:          EngAssertTargetWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        allen
 DATE:          2004.09.26
********************************************************************************/
LOCAL MMI_RESULT_E EngAssertTargetWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MN_SMS_ASSERT_DEST_ADDR_ARR_T target = {0};
    MMI_PARTY_NUMBER_T party_num = {MN_NUM_TYPE_UNKNOW, 0, PNULL};  
    MMI_STRING_T target_buf = {PNULL, 0};
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    uint16 i = 0;
  //  GUI_LCD_DEV_INFO  lcd_dev_info = {GUI_MAIN_LCD_ID, GUI_BLOCK_MAIN};
        
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        //GUIEDIT_SetRect(MMK_ConvertIdToHandle(MMIENG_EDITBOX1_CTRL_ID), &rect);
        {
            GUI_BOTH_RECT_T both_client_rect  = MMITHEME_GetWinClientBothRect(MMK_ConvertIdToHandle(win_id));
            GUIAPICTRL_SetBothRect (MMK_ConvertIdToHandle(MMIENG_EDITBOX1_CTRL_ID), &both_client_rect);
        }
        GUIEDIT_SetStyle(MMIENG_EDITBOX1_CTRL_ID, GUIEDIT_STYLE_SINGLE);
        //LCD_FillRect(&lcd_dev_info, rect, mmi_eng_display.bkgd_color);
        MMK_SetAtvCtrl(MMIENG_ASSERTTARGET_WIN_ID, MMIENG_EDITBOX1_CTRL_ID);
        break;
/*
    case MSG_LCD_SWITCH:
        GUIEDIT_SetRect(MMK_ConvertIdToHandle(MMIENG_EDITBOX1_CTRL_ID), &rect);
            break;
    case MSG_FULL_PAINT:
         LCD_FillRect(&lcd_dev_info, rect, mmi_eng_display.bkgd_color);
        break;
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_KEYDOWN_OK:
        break;
*/  
  
    case MSG_CTL_CANCEL:
        MMK_CloseWin(MMIENG_ASSERTTARGET_WIN_ID);
        break;
    

    case MSG_CTL_OK:
    case MSG_APP_WEB:
        GUIEDIT_GetPhoneNumString(MMIENG_EDITBOX1_CTRL_ID, &target_buf);
        if (target_buf.wstr_len > 0)
        {
            uint8 temp_str[ENG_TARGET_MAX_LEN + 1] = {0};

            MMI_WSTRNTOSTR( temp_str, ENG_TARGET_MAX_LEN, target_buf.wstr_ptr, target_buf.wstr_len, target_buf.wstr_len );

            // need to convert the target phone number to BCD
            if (MMIAPICOM_GenPartyNumber( temp_str, target_buf.wstr_len, &party_num))
            {
#ifndef _WIN32
                 MN_DUAL_SYS_E dual_sys = MN_DUAL_SYS_1;
#endif
                target[0] = (uint8)party_num.num_len;
                for (i = 0; i < party_num.num_len; i++)
                {
                    target[i + 1] = party_num.bcd_num[i];
                }
                if (party_num.num_len != target_buf.wstr_len)
                    target[party_num.num_len] = target[party_num.num_len] | 0xF0;
                
                #ifndef _WIN32
                for(dual_sys = MN_DUAL_SYS_1; dual_sys < MMI_DUAL_SYS_MAX; dual_sys++)
                {
                    MNSMS_SetAssertSmsDestAddrEx(dual_sys, target);
                }
                #endif
            }
            MMK_CloseWin(MMIENG_ASSERTTARGET_WIN_ID);
        }
        break;

    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

/********************************************************************************
 NAME:          AppendForbidPLMNItem
 DESCRIPTION:   
 PARAM IN:      list_id - 
 PARAM OUT:     return forbid PLMN num
 AUTHOR:        allen
 DATE:          2004.11.05
********************************************************************************/
LOCAL uint32 AppendForbidPLMNItem(MMI_CTRL_ID_T list_id)
{
    GUILIST_ITEM_T      item_t = {0};
    GUILIST_ITEM_DATA_T item_data = {0};
    wchar wstr[6] = {0};
    uint32 i = 0;
    MN_PHONE_FPLMN_LIST_T s_mmieng_fplmn = {0};
#ifndef _WIN32
    if (ERR_MNPHONE_NO_ERR != MNPHONE_GetFplmnListEx(MN_DUAL_SYS_1, &s_mmieng_fplmn))//%#discuss
        s_mmieng_fplmn.plmn_num = 0;
#else
    s_mmieng_fplmn.plmn_num = 2;
    s_mmieng_fplmn.plmn_arr[0].mcc = 460;
    s_mmieng_fplmn.plmn_arr[0].mnc = 00;        // PLMN_CMCC
    s_mmieng_fplmn.plmn_arr[1].mcc = 460;
    s_mmieng_fplmn.plmn_arr[1].mnc = 01;        // PLMN_UNICOM
#endif   
    if (0 == s_mmieng_fplmn.plmn_num)
        return 0;
    
    item_t.item_style    = GUIITEM_STYLE_1RADIO_ENG;
    item_t.item_data_ptr = &item_data;
    
    item_data.item_content[0].item_data_type = GUIITEM_DATA_TEXT_BUFFER;
    
    //set softkey
    item_data.softkey_id[0] = (MMI_TEXT_ID_T)TXT_ENG_CLEAR;
    //item_data.softkey_id[1] = (MMI_TEXT_ID_T)TXT_NULL;
    item_data.softkey_id[2] = (MMI_TEXT_ID_T)TXT_ENG_RETURN;
    
    GUILIST_SetMaxItem( list_id, (uint16)s_mmieng_fplmn.plmn_num, FALSE );//max item 4
    GUILIST_SetOwnSofterKey(list_id,TRUE);

    for ( i = 0; i < s_mmieng_fplmn.plmn_num; i++ )
    {        
        char str[6] = {0};
        SCI_MEMSET(wstr,0,6);
        sprintf( str, "%03d", s_mmieng_fplmn.plmn_arr[i].mcc );     // country code
        sprintf( str + 3 , "%02d", s_mmieng_fplmn.plmn_arr[i].mnc );    // network code
        item_data.item_content[0].item_data.text_buffer.wstr_len = 5;

        item_data.item_content[0].item_data.text_buffer.wstr_ptr = wstr;

        MMI_STRNTOWSTR( wstr, GUILIST_STRING_MAX_NUM, (uint8*)str, 6, item_data.item_content[0].item_data.text_buffer.wstr_len );
        //item_data.item_content[0].item_data.text_buffer.is_ucs2 = FALSE;
        
        GUILIST_AppendItem( list_id, &item_t );
        // clear forbid PLMN
        s_mmieng_fplmn.plmn_arr[i].mcc = 0;
        s_mmieng_fplmn.plmn_arr[i].mnc = 0;
    }
    // clear forbid PLMN
    s_mmieng_fplmn.plmn_num = 0;
    
    GUILIST_SetCurItemIndex(MMIENG_LISTBOX_CTRL_ID, 0);
    GUILIST_SetSelectedItem(MMIENG_LISTBOX_CTRL_ID, 0, FALSE);
    return (s_mmieng_fplmn.plmn_num);
}

/********************************************************************************
 NAME:          HandlePLMNPromptWindow
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        allen
 DATE:          2004.11.08
********************************************************************************/
/*LOCAL MMI_RESULT_E HandlePLMNPromptWindow(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    
    switch (msg_id)
    {
        case MSG_CLOSE_WINDOW:
            MMK_CloseWin(MMIENG_FORBIDPLMN_WIN_ID);             
        default:
            result = MMIPUB_HandleAlertWinMsg(win_id,msg_id,param);
            break;
    }
    return (result);
}
*/
/********************************************************************************
 NAME:          EngForbidPLMNWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        allen
 DATE:          2004.11.05
********************************************************************************/
LOCAL MMI_RESULT_E EngForbidPLMNWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    
    //SCI_TRACE_LOW:">>>>>>>>>  enter EngForbidPLMNWinHandleMsg, msg_id = 0x%02X"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_4674_112_2_18_2_17_50_137,(uint8*)"d", msg_id);
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        if (0 == AppendForbidPLMNItem(MMIENG_LISTBOX_CTRL_ID))
        {
            MMIPUB_OpenAlertWarningWin(TXT_ENG_NO_PLMN);
            MMK_CloseWin(MMIENG_FORBIDPLMN_WIN_ID);
        }
        else
        {
            MMK_SetAtvCtrl(MMIENG_FORBIDPLMN_WIN_ID, MMIENG_LISTBOX_CTRL_ID);
        }
        break;

    case MSG_CTL_CANCEL:
        MMK_CloseWin(MMIENG_FORBIDPLMN_WIN_ID);
        break;


    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_OK:
    case MSG_APP_WEB:
    {
        // forbid PLMN data have been cleared when append PLMN items
        MN_PHONE_FPLMN_LIST_T s_mmieng_fplmn = {0};
        #ifndef _WIN32
        if (ERR_MNPHONE_NO_ERR != MNPHONE_GetFplmnListEx(MN_DUAL_SYS_1, &s_mmieng_fplmn))//%#discuss
        {
            MNPHONE_SetFplmnListEx(MN_DUAL_SYS_1, &s_mmieng_fplmn);//%#discuss
        }
        #endif
        MMK_CloseWin(MMIENG_FORBIDPLMN_WIN_ID);
    }
        break;

    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

/********************************************************************************
 NAME:          EngNetLostWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        allen
 DATE:          2004.09.27
********************************************************************************/
LOCAL MMI_RESULT_E EngNetLostWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{   
    char text_buf[64] = {0};
    char text_temp[16] = {0};
     wchar wstr[64] = {0};
    
     char* str = PNULL;
    int32 length = 0;
    int32 offset = 0;
    int32 no_cell = 0;
    int32 search_times = 0;
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:  
        #ifndef _WIN32
        no_cell = MNPHONE_GetTimesOfNoCellAvailableEx(MN_DUAL_SYS_1);//%#discuss
        search_times = MNPHONE_GetTimesOfSearchPlmnEx(MN_DUAL_SYS_1);//%#discuss
        #else
        no_cell = 0;
        search_times = 0;
        #endif
        
        str =  "No Cell:\n";
        length= strlen(str);    
    SCI_MEMCPY(text_buf + offset, str, length);
    offset += length;

    SCI_MEMSET((char*)text_temp, 0, 16);
    sprintf((char*)text_temp, "%ld\n", no_cell);
    length= strlen(text_temp);
    SCI_MEMCPY(text_buf + offset, text_temp, length);
    offset += length;

        str = "Net Research:\n";
       length= strlen(str);     
     SCI_MEMCPY(text_buf + offset, str, length);
    offset += length;
            
    SCI_MEMSET((char*)text_temp, 0, 16);
    sprintf((char*)text_temp, "%ld", search_times);
    length= strlen(text_temp);
    SCI_MEMCPY(text_buf + offset, text_temp, length);
    offset += length;

        MMI_STRNTOWSTR( wstr, 64, (uint8*)text_buf, offset, offset );

    GUITEXT_SetString(MMIENG_TEXTBOX1_CTRL_ID, wstr, offset, FALSE);
        break;

    case MSG_CTL_CANCEL:
    case MSG_CTL_MIDSK:
    case MSG_CTL_OK:
    case MSG_APP_CANCEL:
    case MSG_APP_OK:
    case MSG_APP_WEB:
        MMK_CloseWin(MMIENG_NETLOST_WIN_ID);
        break;
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

/********************************************************************************
 NAME:          GetTCVInfoStr
 DESCRIPTION:   
 PARAM IN:      tcv_buf - 
                buf_len - 
 PARAM OUT:     net info string len
 AUTHOR:        allen
 DATE:          2004.09.27
********************************************************************************/
LOCAL int GetTCVInfoStr(uint8* tcv_buf, uint8 buf_len)
{
    uint32 temperature = 0;
    uint32 current = 0;
    uint32 value = 0;
    
    uint8 digit_buf1[19] = {0};
    int len1 = 0;
    int offset = 0;

    if(PNULL == tcv_buf)
    {
        //SCI_TRACE_LOW:"mmieng_win.c GetTCVInfoStr tcv_buf == null"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_4808_112_2_18_2_17_50_138,(uint8*)"");
        return -1;
    }    
    //SCI_TRACE_LOW:"mmieng_win.c GetTCVInfoStr buf_len is %d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_4811_112_2_18_2_17_50_139,(uint8*)"d",buf_len);
    if(2 > buf_len)
    {
        return -2;
    }
    
    #ifndef _WIN32
    temperature = ADC_GetTemperature();
    current = ADC_GetChargeCurrent();
    value = ADC_GetValue(0);
    #endif
    
    ////////////////
    //  Temperature
    ////////////////
    MMI_MEMCPY(tcv_buf + offset, buf_len - offset, "<Temperature>", 13, 13);
    offset += 13;
    tcv_buf[offset] = CR_CHAR;
    offset += 1;
    MMIAPICOM_Int2Str(temperature, digit_buf1, 18);
    len1 = SCI_STRLEN((char*)digit_buf1);
    MMI_MEMCPY(tcv_buf + offset, buf_len - offset, digit_buf1, 18, len1);
    offset += len1;
    tcv_buf[offset] = CR_CHAR;
    offset += 1;
    ////////////////////
    //  Charge Current
    ////////////////////
    MMI_MEMCPY(tcv_buf + offset, buf_len - offset, "<Charge Current>", 16, 16);
    offset += 16;
    tcv_buf[offset] = CR_CHAR;
    offset += 1;
    MMIAPICOM_Int2Str(current, digit_buf1, 18);
    len1 = SCI_STRLEN((char*)digit_buf1);
    MMI_MEMCPY(tcv_buf + offset, buf_len - offset, digit_buf1, 18, len1);
    offset += len1;
    tcv_buf[offset] = CR_CHAR;
    offset += 1;
    ////////////
    //  Volume
    ////////////
    MMI_MEMCPY(tcv_buf + offset, buf_len - offset, "<Volume>", 8, 8);
    offset += 8;
    tcv_buf[offset] = CR_CHAR;
    offset += 1;
    MMIAPICOM_Int2Str(value, digit_buf1, 18);
    len1 = SCI_STRLEN((char*)digit_buf1);
    MMI_MEMCPY(tcv_buf + offset, buf_len - offset, digit_buf1, 18, len1);
    offset += len1;
    return (offset);
}

/********************************************************************************
 NAME:          EngTCVWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        allen
 DATE:          2004.09.27
********************************************************************************/
LOCAL MMI_RESULT_E EngTCVWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    //GUI_RECT_T rect = MMITHEME_GetClientRect();
    MMI_STRING_T text = {0};
    uint8 buf[151] = {0};
    wchar wstr[151] = {0};
    char* str = PNULL;
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    //GUI_LCD_DEV_INFO  lcd_dev_info = {GUI_MAIN_LCD_ID, GUI_BLOCK_MAIN};
    
    //SCI_TRACE_LOW:">>>>>>>>>  enter EngTCVWinHandleMsg, msg_id = 0x%02X"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_4882_112_2_18_2_17_51_140,(uint8*)"d", msg_id);
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
    //  LCD_FillRect(&lcd_dev_info, rect, mmi_eng_display.bkgd_color);            

        str = (char*)buf;
        text.wstr_len = GetTCVInfoStr(buf, 150);
        text.wstr_ptr = wstr;
        MMI_STRNTOWSTR( wstr, 150, (uint8*)str, text.wstr_len, text.wstr_len );
        GUITEXT_SetString(MMIENG_TEXTBOX1_CTRL_ID, text.wstr_ptr, text.wstr_len, FALSE);
        break;
        
    case MSG_FULL_PAINT:
        //LCD_FillRect(&lcd_dev_info, rect, mmi_eng_display.bkgd_color);
        break;

    case MSG_CTL_CANCEL:
    case MSG_CTL_MIDSK:
    case MSG_CTL_OK:
    case MSG_APP_OK:
    case MSG_APP_CANCEL:
    case MSG_APP_WEB:
        MMK_CloseWin(MMIENG_TCV_WIN_ID);
        break;
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}
#if 0
/********************************************************************************
 NAME:          HandleAFCWaitWindow
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        allen
 DATE:          2004.09.28
********************************************************************************/
LOCAL MMI_RESULT_E HandleAFCWaitWindow(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    
    switch (msg_id)
    {
    case MSG_CTL_CANCEL:
    case MSG_APP_CANCEL:
        #ifndef _WIN32
        MMK_CloseWin(MMIENG_AFC_WIN_ID);
        #else
        g_mmieng_afc_value = 10;        // simulator for window
        #endif
        MMK_CloseWin(MMIENG_WAITING_WIN_ID);
        break;

    case MSG_APP_RED:
        #ifndef _WIN32
        MMK_CloseWin(MMIENG_AFC_WIN_ID);
        #endif
        MMK_CloseWin(MMIENG_WAITING_WIN_ID);
        result = MMI_RESULT_TRUE;
        break;
        
    default:
        result = MMIPUB_HandleWaitWinMsg(win_id, msg_id, param);
        break;
    }
    return (result);
}

/********************************************************************************
 NAME:          EngAFCWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        allen
 DATE:          2004.09.27
********************************************************************************/
LOCAL MMI_RESULT_E EngAFCWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    GUI_RECT_T rect = MMITHEME_GetClientRect();
    uint8 data_buf[20] = {0};
    wchar wstr[30] = {0};
    char* str = PNULL;
    MMI_STRING_T text1 = {0}; 
    MMI_STRING_T text2 = {0}; 
    MMI_STRING_T text3 = {0}; 
    MMI_STRING_T text = {0};
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    BOOLEAN l1_result = TRUE;
    GUI_LCD_DEV_INFO    lcd_dev_info = {GUI_MAIN_LCD_ID, GUI_BLOCK_MAIN};
     GUI_RECT_T      prg_rect = rect ;
     GUI_RECT_T lab_rect  = rect ;
        
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
         lab_rect.bottom  =  ((rect.top  + rect.bottom)>>1) - 1;
        lab_rect.top = lab_rect.bottom - 40;
        GUILABEL_SetRect(MMIENG_LABEL1_CTRL_ID, &lab_rect, FALSE);
        
        prg_rect.top = ((rect.top  + rect.bottom)>>1) + 1;
        prg_rect.bottom= prg_rect.top + 30;
        prg_rect.left += 1;
        prg_rect.right -= 1;          
        GUIPRGBOX_SetRect(MMIENG_PRGBOX_CTRL_ID,&prg_rect);
        GUILABEL_SetBackgroundColor(MMIENG_LABEL1_CTRL_ID, mmi_eng_display.bkgd_color);
        GUIPRGBOX_SetParamByCtrl(MMIENG_PRGBOX_CTRL_ID, MMIENG_AFC_MAX_VALUE, MMIENG_AFC_MAX_VALUE);
       
        s_mmieng_afc_inited = FALSE;

        if (!s_mmieng_afc_inited)
        {
            str = MMIENG_WAIT_MSG;
            text.wstr_len = strlen(str);
            text.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, 150, (uint8*)str, text.wstr_len, text.wstr_len );
            MMIPUB_OpenWaitWin(1,&text,PNULL,PNULL,MMIENG_WAITING_WIN_ID,IMAGE_NULL,
                ANIM_PUBWIN_WAIT,WIN_ONE_LEVEL,MMIPUB_SOFTKEY_ONE,HandleAFCWaitWindow);
            
#ifndef _WIN32
            l1_result = L1API_GetAFC(P_APP);
            if (!l1_result)
            {
                MMK_CloseWin(MMIENG_WAITING_WIN_ID);
                MMK_CloseWin(MMIENG_AFC_WIN_ID);
            }
#else
            l1_result = TRUE;
#endif
        }
        
        sprintf((char*)data_buf, "%ld", g_mmieng_afc_value);        
        str = (char*)data_buf;
        text1.wstr_len = strlen(str);
        text1.wstr_ptr = wstr;
        MMI_STRNTOWSTR( wstr, 30, (uint8*)str, text1.wstr_len, text1.wstr_len );        
        GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &text1, FALSE);        
        break;

        case MSG_LCD_SWITCH:
        lab_rect.bottom  =  ((rect.top  + rect.bottom)>>1) - 1;
        lab_rect.top = lab_rect.bottom - 40;
        GUILABEL_SetRect(MMIENG_LABEL1_CTRL_ID, &lab_rect, FALSE);
        prg_rect.top = ((rect.top  + rect.bottom)>>1) + 1;
        prg_rect.bottom= prg_rect.top + 30;
        prg_rect.left += 1;
        prg_rect.right -= 1;  
            GUIPRGBOX_SetRect(MMIENG_PRGBOX_CTRL_ID,&prg_rect);
        break;
              
    case MSG_FULL_PAINT:
        LCD_FillRect(&lcd_dev_info, rect, mmi_eng_display.bkgd_color);
        break;
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(MMIENG_AFC_WIN_ID);
        break;

    case MSG_CTL_MIDSK:
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        text1.wstr_ptr = PNULL;
        text1.wstr_len = 0;
        text3.wstr_ptr = PNULL;
        text3.wstr_len = 0;
#ifndef _WIN32

        if (L1API_SetAFC(g_mmieng_afc_value) == SCI_TRUE)
        {
            text2.wstr_ptr = s_saved_wstr;//"Saved";
            text2.wstr_len = 5;
        }
        else
        {
            text2.wstr_ptr = s_fail_saved_wstr; //"Fail saved";
            text2.wstr_len = 10;
        }
#else
        text2.wstr_ptr = s_saved_wstr;//"Saved";
        text2.wstr_len = 5;
#endif
        MMK_CloseWin(MMIENG_AFC_WIN_ID);
        MMIEng_SetResultWinText(text1, text2, text3);
        MMK_CreateWin((uint32*)MMIENG_SHOW3RESULT_WIN_TAB, PNULL);
        break;

    case MSG_KEYDOWN_UP:
        if (g_mmieng_afc_value < MMIENG_AFC_MAX_VALUE)
        {
            g_mmieng_afc_value += 3000;
            if (g_mmieng_afc_value > MMIENG_AFC_MAX_VALUE)
                g_mmieng_afc_value = MMIENG_AFC_MAX_VALUE;
            sprintf((char*)data_buf, "%ld", g_mmieng_afc_value);

            str = (char*)data_buf;
            text1.wstr_len = strlen(str);
            text1.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, 30, (uint8*)str, text1.wstr_len, text1.wstr_len );

            GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &text1, TRUE);
            GUIPRGBOX_SetPosByCtrl(TRUE,g_mmieng_afc_value,g_mmieng_afc_value,MMIENG_PRGBOX_CTRL_ID);
        }
        break;
        
    case MSG_KEYDOWN_DOWN:
        if (g_mmieng_afc_value > 0)
        {
            if (g_mmieng_afc_value > 3000)
                g_mmieng_afc_value -= 3000;
            else
                g_mmieng_afc_value = 0;
            sprintf((char*)data_buf, "%ld", g_mmieng_afc_value);

            str = (char*)data_buf;
            text1.wstr_len = strlen(str);
            text1.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, 30, (uint8*)str, text1.wstr_len, text1.wstr_len );

        GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &text1, TRUE);
            GUIPRGBOX_SetPosByCtrl(TRUE,g_mmieng_afc_value,g_mmieng_afc_value,MMIENG_PRGBOX_CTRL_ID);
        }
        break;
        
    case MSG_KEYDOWN_LEFT:
        if (g_mmieng_afc_value > 0)
        {
            g_mmieng_afc_value--;
            sprintf((char*)data_buf, "%ld", g_mmieng_afc_value);

            str = (char*)data_buf;
            text1.wstr_len = strlen(str);
            text1.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, 30, (uint8*)str, text1.wstr_len, text1.wstr_len );

            GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &text1, TRUE);
            GUIPRGBOX_SetPosByCtrl(TRUE,g_mmieng_afc_value,g_mmieng_afc_value,MMIENG_PRGBOX_CTRL_ID);
        }
        break;
        
    case MSG_KEYDOWN_RIGHT:
        if (g_mmieng_afc_value < MMIENG_AFC_MAX_VALUE)
        {
            g_mmieng_afc_value++;
            sprintf((char*)data_buf, "%ld", g_mmieng_afc_value);

            str = (char*)data_buf;
            text1.wstr_len = strlen(str);
            text1.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, 30, (uint8*)str, text1.wstr_len, text1.wstr_len );

            GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &text1, TRUE);
            GUIPRGBOX_SetPosByCtrl(TRUE,g_mmieng_afc_value,g_mmieng_afc_value,MMIENG_PRGBOX_CTRL_ID);
        }
        break;

    case MSG_GET_FOCUS:     
    case MSG_ENG_L1_GET_CNF:
        LCD_FillRect(&lcd_dev_info, rect, mmi_eng_display.bkgd_color);
        if (!s_mmieng_afc_inited)
        {
            s_mmieng_afc_inited = TRUE;
            //LCD_FillRect(&lcd_dev_info, rect, mmi_eng_display.bkgd_color);
            
            // AFC valid value is in 0 ~~ 1023
            //SCI_PASSERT(g_mmieng_afc_value <= MMIENG_AFC_MAX_VALUE, ("EngAFCWinHandleMsg: g_mmieng_afc_value is %d",g_mmieng_afc_value));         
            if (g_mmieng_afc_value > MMIENG_AFC_MAX_VALUE)
            {
                //SCI_TRACE_LOW:"EngAFCWinHandleMsg: g_mmieng_afc_value is %d"
                SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_5156_112_2_18_2_17_51_141,(uint8*)"d",g_mmieng_afc_value);
                g_mmieng_afc_value = MMIENG_AFC_MAX_VALUE;
            }
            SCI_MEMSET((char*)data_buf, 0, 20);
            sprintf((char*)data_buf, "%ld", g_mmieng_afc_value);

            str = (char*)data_buf;
            text1.wstr_len = strlen(str);
            text1.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, 30, (uint8*)str, text1.wstr_len, text1.wstr_len );

            GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &text1, FALSE);
            GUIPRGBOX_SetPosByCtrl(FALSE,g_mmieng_afc_value,g_mmieng_afc_value,MMIENG_PRGBOX_CTRL_ID);
            if (MSG_ENG_L1_GET_CNF == msg_id)
            {
                MMK_PostMsg(win_id, MSG_FULL_PAINT, NULL, 0);
            }
        }
        break;
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }

    return (result);
}

LOCAL MMI_RESULT_E EngAFCWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    const int32 buffer_size = 32;
    uint8 data_buf[32 + 1] = {0};
    wchar wstr[32 + 1] = {0};
    char* str = PNULL;
    int32 length = 0;
    MMI_STRING_T text = {0} ;
    BOOLEAN l1_result = FALSE;
    
    switch (msg_id) 
    {
     case MSG_OPEN_WINDOW:     
        s_mmieng_afc_inited = FALSE;
        if (!s_mmieng_afc_inited)
        {
            str = MMIENG_WAIT_MSG;
            length  = SCI_STRLEN(str);          
            MMI_STRNTOWSTR( wstr, buffer_size, (uint8*)str,length, length);
            text.wstr_ptr = wstr;
            text.wstr_len =  length;            
            MMIPUB_OpenWaitWin(1,&text,PNULL,PNULL,MMIENG_WAITING_WIN_ID,IMAGE_NULL,
                ANIM_PUBWIN_WAIT,WIN_ONE_LEVEL,MMIPUB_SOFTKEY_ONE,HandleAFCWaitWindow);            
#ifndef  WIN32
            l1_result = L1API_GetAFC(P_APP);
            if (!l1_result)
            {
                MMK_CloseWin(MMIENG_WAITING_WIN_ID);
                MMK_CloseWin(MMIENG_AFC_WIN_ID);
            }
#else
            l1_result = TRUE;
#endif
        }
        break;
        case MSG_GET_FOCUS: 
            //lint -fallthrough
    case MSG_ENG_L1_GET_CNF:    
        //LCD_FillRect( MMITHEME_GetDefaultLcdDev(), rect, mmi_eng_display.bkgd_color);
        if (!s_mmieng_afc_inited)
        {
            s_mmieng_afc_inited = TRUE;        
            
            // AFC valid value is in 0 ~~ 1023
            //SCI_PASSERT(g_mmieng_afc_value <= MMIENG_AFC_MAX_VALUE, ("EngAFCWinHandleMsg: g_mmieng_afc_value is %d",g_mmieng_afc_value));         
            if (g_mmieng_afc_value > MMIENG_AFC_MAX_VALUE)
            {
                //SCI_TRACE_LOW:"EngAFCWinHandleMsg: g_mmieng_afc_value is %d"
                SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_5231_112_2_18_2_17_51_142,(uint8*)"d",g_mmieng_afc_value);
                g_mmieng_afc_value = MMIENG_AFC_MAX_VALUE;
            }
            SCI_MEMSET((char*)data_buf, 0, buffer_size + 1);
            sprintf((char*)data_buf, "%ld", g_mmieng_afc_value);
            str = (char*)data_buf;
            length = SCI_STRLEN(str);           
            MMI_STRNTOWSTR( wstr, buffer_size, (uint8*)str, text.wstr_len, text.wstr_len );
            GUITEXT_SetString( MMIENG_TEXTBOX1_CTRL_ID,  wstr,  length,  FALSE);
             if (MSG_ENG_L1_GET_CNF == msg_id)
            {
                MMK_PostMsg(win_id, MSG_FULL_PAINT, NULL, 0);
            }
        }
        break;
    

     case MSG_KEYDOWN_CANCEL:
            //lint -fallthrough
    case MSG_CTL_CANCEL:
            //lint -fallthrough
    case MSG_KEYDOWN_OK:
            //lint -fallthrough
    case MSG_CTL_OK:
      MMK_CloseWin(MMIENG_AFC_WIN_ID);
        break;

        default:
        break;
        }
    return (l1_result);
}
/********************************************************************************
 NAME:          HandlePAWaitWindow
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        allen
 DATE:          2004.09.28
********************************************************************************/
LOCAL MMI_RESULT_E HandlePAWaitWindow(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    
    switch (msg_id)
    {
    case MSG_CTL_CANCEL:
    case MSG_APP_CANCEL:
        #ifndef _WIN32
        MMK_CloseWin(MMIENG_PA_WIN_ID);
        #else
        //g_mmieng_pa_value = 10;     // simulator for window
        #endif
        MMK_CloseWin(MMIENG_WAITING_WIN_ID);
        break;

    case MSG_APP_RED:
        #ifndef _WIN32
        MMK_CloseWin(MMIENG_PA_WIN_ID);
        #endif
        MMK_CloseWin(MMIENG_WAITING_WIN_ID);
        result = MMI_RESULT_TRUE;
        break;
        
    default:
        result = MMIPUB_HandleWaitWinMsg(win_id, msg_id, param);
        break;
    }
    return (result);
}

/********************************************************************************
 NAME:          EngPAWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        allen
 DATE:          2004.09.27
********************************************************************************/

LOCAL MMI_RESULT_E EngPAWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    GUI_RECT_T rect = MMITHEME_GetClientRect();
    uint8 data_buf[20] = {0};
    wchar wstr[30] = {0};
    char* str = PNULL;
    MMI_STRING_T text = {0}; 
    MMI_STRING_T text1 = {0}; 
    MMI_STRING_T text2 = {0}; 
    MMI_STRING_T text3 = {0}; 
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    BOOLEAN l1_result = TRUE;
    GUI_LCD_DEV_INFO    lcd_dev_info = {GUI_MAIN_LCD_ID, GUI_BLOCK_MAIN};
    GUI_RECT_T          prg_rect = rect ;
    GUI_RECT_T   lab_rect = rect;
    
        
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        
        lab_rect.bottom  =  ((rect.top  + rect.bottom)>>1) - 1;
        lab_rect.top = lab_rect.bottom - 40;
        GUILABEL_SetRect(MMIENG_LABEL1_CTRL_ID, &lab_rect, FALSE);
        prg_rect.top = ((rect.top  + rect.bottom)>>1 )+ 1;
        prg_rect.bottom= prg_rect.top + 30;
        prg_rect.left += 1;
        prg_rect.right -= 1;  
        GUIPRGBOX_SetRect(MMIENG_PRGBOX_CTRL_ID,&prg_rect);       
        GUILABEL_SetBackgroundColor(MMIENG_LABEL1_CTRL_ID, mmi_eng_display.bkgd_color);
        GUIPRGBOX_SetParamByCtrl(MMIENG_PRGBOX_CTRL_ID, MMIENG_PA_MAX_VALUE, MMIENG_PA_MAX_VALUE);
        s_mmieng_pa_inited = FALSE;
        if (!s_mmieng_pa_inited)
        {
            // L1 will transfer the PA data by message, MMI should receive them in application 's PS message function
            // when MMI get them, MMI will close the wait window, then PA window will re-get focus
            str = MMIENG_WAIT_MSG;
            text.wstr_len = strlen(str);
            text.wstr_ptr = wstr;
            MMIPUB_OpenWaitWin(1,&text,PNULL,PNULL,MMIENG_WAITING_WIN_ID,IMAGE_NULL,
               ANIM_PUBWIN_WAIT,WIN_ONE_LEVEL,MMIPUB_SOFTKEY_ONE,HandlePAWaitWindow);
            #ifndef _WIN32
            l1_result = L1API_GetPA(P_APP);
            if (!l1_result)
            {
                MMK_CloseWin(MMIENG_WAITING_WIN_ID);
                MMK_CloseWin(MMIENG_PA_WIN_ID);
            }
            #else
            l1_result = TRUE;
            #endif
        }
            sprintf((char*)data_buf, "%ld", g_mmieng_pa_value);
            
            str = (char*)data_buf;
            text1.wstr_len = strlen(str);
            text1.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, 30, (uint8*)str, text1.wstr_len, text1.wstr_len );

 //           GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &text1, FALSE);
 //           GUIPRGBOX_SetPosByCtrl(TRUE,g_mmieng_pa_value,g_mmieng_pa_value,MMIENG_PRGBOX_CTRL_ID);

        break;
        
        case MSG_LCD_SWITCH:
        lab_rect.bottom  =  ((rect.top  + rect.bottom)>>1) - 1;
        lab_rect.top = lab_rect.bottom - 40;
        GUILABEL_SetRect(MMIENG_LABEL1_CTRL_ID, &lab_rect, FALSE);
        prg_rect.top = ((rect.top  + rect.bottom)>>1) + 1;
        prg_rect.bottom= prg_rect.top + 30;
        prg_rect.left += 1;
        prg_rect.right -= 1;  
        GUIPRGBOX_SetRect(MMIENG_PRGBOX_CTRL_ID,&prg_rect);
      break;
              
    case MSG_FULL_PAINT:
        LCD_FillRect(&lcd_dev_info, rect, mmi_eng_display.bkgd_color);
        break;
        

    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(MMIENG_PA_WIN_ID);
        break;

    case MSG_CTL_MIDSK:
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        text1.wstr_ptr = PNULL;
        text1.wstr_len = 0;
        text3.wstr_ptr = PNULL;
        text3.wstr_len = 0;
        #ifndef _WIN32
        if (L1API_SetPA(g_mmieng_pa_value) == SCI_TRUE)
        {
            text2.wstr_ptr = s_saved_wstr;//"Saved";
            text2.wstr_len = 5;
        }
        else
        {
            text2.wstr_ptr = s_fail_saved_wstr;//"Fail saved";
            text2.wstr_len = 10;
        }
        #else
        text2.wstr_ptr = s_saved_wstr;//"Saved";
        text2.wstr_len = 5;
        #endif
        MMK_CloseWin(MMIENG_PA_WIN_ID);
        MMIEng_SetResultWinText(text1, text2, text3);
        MMK_CreateWin((uint32*)MMIENG_SHOW3RESULT_WIN_TAB, PNULL);
        break;

    case MSG_KEYDOWN_UP:
        if (g_mmieng_pa_value < MMIENG_PA_MAX_VALUE)
        {
            g_mmieng_pa_value += 3000;
            if (g_mmieng_pa_value > MMIENG_PA_MAX_VALUE)
                g_mmieng_pa_value = MMIENG_PA_MAX_VALUE;
            sprintf((char*)data_buf, "%ld", g_mmieng_pa_value);
            
            str = (char*)data_buf;
            text1.wstr_len = strlen(str);
            text1.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, 30, (uint8*)str, text1.wstr_len, text1.wstr_len );

            GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &text1, TRUE);
            GUIPRGBOX_SetPosByCtrl(TRUE,g_mmieng_pa_value,g_mmieng_pa_value,MMIENG_PRGBOX_CTRL_ID);
        }
        break;
        
    case MSG_KEYDOWN_DOWN:
        if (g_mmieng_pa_value > 0)
        {
            if (g_mmieng_pa_value > 3000)
                g_mmieng_pa_value -= 3000;
            else
                g_mmieng_pa_value = 0;
            sprintf((char*)data_buf, "%ld", g_mmieng_pa_value);
            
            str = (char*)data_buf;
            text1.wstr_len = strlen(str);
            text1.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, 30, (uint8*)str, text1.wstr_len, text1.wstr_len );

            GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &text1, TRUE);
            GUIPRGBOX_SetPosByCtrl(TRUE,g_mmieng_pa_value,g_mmieng_pa_value,MMIENG_PRGBOX_CTRL_ID);
        }
        break;
        
    case MSG_KEYDOWN_LEFT:
        if (g_mmieng_pa_value > 0)
        {
            g_mmieng_pa_value--;
            sprintf((char*)data_buf, "%ld", g_mmieng_pa_value);

            str = (char*)data_buf;
            text1.wstr_len = strlen(str);
            text1.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, 30, (uint8*)str, text1.wstr_len, text1.wstr_len );

            GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &text1, TRUE);
            GUIPRGBOX_SetPosByCtrl(TRUE,g_mmieng_pa_value,g_mmieng_pa_value,MMIENG_PRGBOX_CTRL_ID);
        }
        break;
        
    case MSG_KEYDOWN_RIGHT:
        if (g_mmieng_pa_value < MMIENG_PA_MAX_VALUE)
        {
            g_mmieng_pa_value++;
            sprintf((char*)data_buf, "%ld", g_mmieng_pa_value);

            str = (char*)data_buf;
            text1.wstr_len = strlen(str);
            text1.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, 30, (uint8*)str, text1.wstr_len, text1.wstr_len );

            GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &text1, TRUE);
            GUIPRGBOX_SetPosByCtrl(TRUE,g_mmieng_pa_value,g_mmieng_pa_value,MMIENG_PRGBOX_CTRL_ID);
        }
        break;
    
    case MSG_GET_FOCUS:         
    case MSG_ENG_L1_GET_CNF:
        LCD_FillRect(&lcd_dev_info, rect, mmi_eng_display.bkgd_color);
        if (!s_mmieng_pa_inited)
        {
            s_mmieng_pa_inited = TRUE;
            
            // AFC valid value is in 0 ~~ 65535
            SCI_PASSERT(g_mmieng_pa_value <= MMIENG_PA_MAX_VALUE, ("EngPAWinHandleMsg: g_mmieng_pa_value is %d",g_mmieng_pa_value));            
            SCI_MEMSET((char*)data_buf, 0, 20);
            sprintf((char*)data_buf, "%ld", g_mmieng_pa_value);

            str = (char*)data_buf;
            text1.wstr_len = strlen(str);
            text1.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, 30, (uint8*)str, text1.wstr_len, text1.wstr_len );

            GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &text1, FALSE);
            GUIPRGBOX_SetPosByCtrl(FALSE,g_mmieng_pa_value,g_mmieng_pa_value,MMIENG_PRGBOX_CTRL_ID);
            if (MSG_ENG_L1_GET_CNF == msg_id)
            {
                MMK_PostMsg(win_id, MSG_FULL_PAINT, NULL, 0);
            }
        }
        break;
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

LOCAL MMI_RESULT_E EngPAWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    const int32 buffer_size = 32;
    uint8 data_buf[32 + 1] = {0};
    wchar wstr[32 + 1] = {0};
    char* str = PNULL;
    int32 length = 0;
    MMI_STRING_T text = {0} ;
    BOOLEAN l1_result = FALSE;
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:     
        s_mmieng_pa_inited = FALSE;
        if (!s_mmieng_pa_inited)
        {
            // L1 will transfer the PA data by message, MMI should receive them in application 's PS message function
            // when MMI get them, MMI will close the wait window, then PA window will re-get focus
            str = MMIENG_WAIT_MSG;
            length  = SCI_STRLEN(str);          
            MMI_STRNTOWSTR( wstr, buffer_size, (uint8*)str,length, length);
            text.wstr_ptr = wstr;
            text.wstr_len =  length;       
            MMIPUB_OpenWaitWin(1,&text,PNULL,PNULL,MMIENG_WAITING_WIN_ID,IMAGE_NULL,
                ANIM_PUBWIN_WAIT,WIN_ONE_LEVEL,MMIPUB_SOFTKEY_ONE,HandlePAWaitWindow);
#ifndef  WIN32
            l1_result = L1API_GetPA(P_APP);
            if (!l1_result)
            {
                MMK_CloseWin(MMIENG_WAITING_WIN_ID);
                MMK_CloseWin(MMIENG_PA_WIN_ID);
            }
#else
            l1_result = TRUE;
#endif
        }         
    break;
    case MSG_GET_FOCUS:
        //lint -fallthrough
    case MSG_ENG_L1_GET_CNF:
        // LCD_FillRect( MMITHEME_GetDefaultLcdDev(),  rect, mmi_eng_display.bkgd_color);
        if (!s_mmieng_pa_inited)
        {
            s_mmieng_pa_inited = TRUE;     
            
            // AFC valid value is in 0 ~~ 1023
            //SCI_PASSERT(g_mmieng_afc_value <= MMIENG_AFC_MAX_VALUE, ("EngAFCWinHandleMsg: g_mmieng_afc_value is %d",g_mmieng_afc_value));         
            SCI_MEMSET((char*)data_buf, 0, buffer_size + 1);
            
            sprintf((char*)data_buf, "%ld\n%ld\n%ld\n%ld", g_mmieng_pa_value[0],
                g_mmieng_pa_value[1],g_mmieng_pa_value[2],g_mmieng_pa_value[3]);          
            
            str = (char*)data_buf;
            length = SCI_STRLEN(str);           
            MMI_STRNTOWSTR( wstr, buffer_size, (uint8*)str, text.wstr_len, text.wstr_len );
            GUITEXT_SetString( MMIENG_TEXTBOX1_CTRL_ID,  wstr,  length,  FALSE);
            if (MSG_ENG_L1_GET_CNF == msg_id)
            {
                MMK_PostMsg(win_id, MSG_FULL_PAINT, NULL, 0);
            }
        }
        break;
                
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:   
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
        MMK_CloseWin(MMIENG_PA_WIN_ID);
        break;
        
    default:
        break;
    }
    return(l1_result);
}


/********************************************************************************
 NAME:          HandleAGCWaitWindow
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        allen
 DATE:          2004.09.28
********************************************************************************/
LOCAL MMI_RESULT_E HandleAGCWaitWindow(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    
    switch (msg_id)
    {
    case MSG_CTL_CANCEL:
    case MSG_APP_CANCEL:
        #ifndef _WIN32
        MMK_CloseWin(MMIENG_AGC_WIN_ID);
        #else
        g_mmieng_agc_value = 10;        // simulator for window
        #endif
        MMK_CloseWin(MMIENG_WAITING_WIN_ID);
        break;

    case MSG_APP_RED:
        #ifndef _WIN32
        MMK_CloseWin(MMIENG_AGC_WIN_ID);
        #endif
        MMK_CloseWin(MMIENG_WAITING_WIN_ID);
        result = MMI_RESULT_TRUE;
        break;
        
    default:
        result = MMIPUB_HandleWaitWinMsg(win_id, msg_id, param);
        break;
    }
    return (result);
}

/********************************************************************************
 NAME:          GetAGCInfoStr
 DESCRIPTION:   
 PARAM IN:      agc_buf - 
                buf_len - 
 PARAM OUT:     agc info string len
 AUTHOR:        allen
 DATE:          2004.09.28
********************************************************************************/
LOCAL int GetAGCInfoStr(uint8* agc_buf, uint8 buf_len)
{
    uint8 digit_buf1[19] = {0};

    int len1 = 0;
    int offset = 0;
    
    if(PNULL == agc_buf)
    {
        //SCI_TRACE_LOW:"mmieng_win.c GetAGCInfoStr agc_buf == null"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_5662_112_2_18_2_17_52_143,(uint8*)"");
        return -1;
    }    
    //SCI_TRACE_LOW:"mmieng_win.c GetAGCInfoStr buf_len is %d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_5665_112_2_18_2_17_52_144,(uint8*)"d",buf_len);
    if(2 > buf_len)
    {
        return -2;
    }
    MMI_MEMCPY(agc_buf + offset, buf_len - offset, "<AGC Value>", 11, 11);
    offset += 11;
    agc_buf[offset] = CR_CHAR;
    offset += 1;
    MMIAPICOM_Int2Str(g_mmieng_agc_value, digit_buf1, 18);
    len1 = SCI_STRLEN((char*)digit_buf1);
    MMI_MEMCPY(agc_buf + offset, buf_len - offset, digit_buf1, 18, len1);
    offset += len1;
    return (offset);
}

/********************************************************************************
 NAME:          EngAGCWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        allen
 DATE:          2004.09.27
********************************************************************************/
LOCAL MMI_RESULT_E EngAGCWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    GUI_RECT_T rect = MMITHEME_GetClientRect();
    uint8 text_buf[151] = {0};
    wchar wstr[151] = {0};
    char* str = PNULL;
    MMI_STRING_T text = {0};
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    BOOLEAN l1_result = TRUE;
    GUI_LCD_DEV_INFO    lcd_dev_info = {GUI_MAIN_LCD_ID, GUI_BLOCK_MAIN};
        
    //SCI_TRACE_LOW:">>>>>>>>>  enter EngAGCWinHandleMsg, msg_id = 0x%02X"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_5701_112_2_18_2_17_52_145,(uint8*)"d", msg_id);
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        s_mmieng_agc_inited = FALSE;
        if (!s_mmieng_agc_inited)
        {
            // L1 will transfer the AGC data by message, MMI should receive them in application 's PS message function
            // when MMI get them, MMI will close the wait window, then AGC window will re-get focus
               MMIPUB_OpenWaitWin(1,&text,PNULL,PNULL,MMIENG_WAITING_WIN_ID,IMAGE_NULL,
                ANIM_PUBWIN_WAIT,WIN_ONE_LEVEL,MMIPUB_SOFTKEY_ONE,HandleAGCWaitWindow);
            #ifndef _WIN32
            l1_result = L1API_GetAGC(P_APP);
            if (!l1_result)
            {
                MMK_CloseWin(MMIENG_WAITING_WIN_ID);
                MMK_CloseWin(MMIENG_AGC_WIN_ID);
            }
            #else
            l1_result = TRUE;
            #endif
        }
        break;
    
        case MSG_FULL_PAINT:                
            //LCD_FillRect(&lcd_dev_info, rect, mmi_eng_display.bkgd_color);  
        break;
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(MMIENG_AGC_WIN_ID);
        break;
        
    case MSG_CTL_MIDSK:
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        MMK_CloseWin(MMIENG_AGC_WIN_ID);
        break;

    case MSG_GET_FOCUS: 
    case MSG_ENG_L1_GET_CNF:
        if (!s_mmieng_agc_inited)
        {
            s_mmieng_agc_inited = TRUE; 
            
           LCD_FillRect(&lcd_dev_info, rect, mmi_eng_display.bkgd_color);

            str = (char*)text_buf;
            text.wstr_len =  GetAGCInfoStr(text_buf, 150);
            text.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, 150, (uint8*)str, text.wstr_len, text.wstr_len );


            GUITEXT_SetString(MMIENG_TEXTBOX1_CTRL_ID, text.wstr_ptr, text.wstr_len, FALSE);
            if (MSG_ENG_L1_GET_CNF == msg_id)
            {
                MMK_PostMsg(win_id, MSG_FULL_PAINT, NULL, 0);
            }
        }
        break;
        
    case MSG_CLOSE_WINDOW:
        break;
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }

    return (result);
}
#endif

/********************************************************************************
 NAME:          HandleErrRateWaitWindow
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        allen
 DATE:          2004.09.28
********************************************************************************/
LOCAL MMI_RESULT_E HandleErrRateWaitWindow(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    
    switch (msg_id)
    {
    case MSG_CTL_CANCEL:
    case MSG_APP_CANCEL:
        #ifndef _WIN32
        MMK_CloseWin(MMIENG_ERRRATE_WIN_ID);
        #else
        g_mmieng_total_pch_number = 1024;       // simulator for window
        g_mmieng_lost_pch_number = 5;           // simulator for window
        #endif
        MMK_CloseWin(MMIENG_WAITING_WIN_ID);
        break;

    case MSG_APP_RED:
        #ifndef _WIN32
        MMK_CloseWin(MMIENG_ERRRATE_WIN_ID);
        #endif
        MMK_CloseWin(MMIENG_WAITING_WIN_ID);
        result = MMI_RESULT_TRUE;
        break;
        
    default:
        result = MMIPUB_HandleWaitWinMsg(win_id, msg_id, param);
        break;
    }
    return (result);
}

/********************************************************************************
 NAME:          GetErrRateInfoStr
 DESCRIPTION:   
 PARAM IN:      rate_buf - 
                buf_len - 
 PARAM OUT:     errrate info string len
 AUTHOR:        allen
 DATE:          2004.09.28
********************************************************************************/
LOCAL int GetErrRateInfoStr(uint8* rate_buf, uint8 buf_len)
{
    uint8 digit_buf1[19] = {0};
    int len1 = 0;
    int offset = 0;
    
    if(PNULL == rate_buf)
    {
        //SCI_TRACE_LOW:"mmieng_win.c GetErrRateInfoStr rate_buf == null"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_5831_112_2_18_2_17_53_146,(uint8*)"");
        return -1;
    }    
    //SCI_TRACE_LOW:"mmieng_win.c GetErrRateInfoStr buf_len is %d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_5834_112_2_18_2_17_53_147,(uint8*)"d",buf_len);
    if(2 > buf_len)
    {
        return -2;
    }
    
    ////////////////
    //  total pch
    ////////////////
    MMI_MEMCPY(rate_buf + offset, buf_len - offset, "<Total>", 7, 7);
    offset += 7;
    rate_buf[offset] = CR_CHAR;
    offset += 1;
    MMIAPICOM_Int2Str(g_mmieng_total_pch_number, digit_buf1, 18);
    len1 = SCI_STRLEN((char*)digit_buf1);
    MMI_MEMCPY(rate_buf + offset, buf_len - offset, digit_buf1, 18, len1);
    offset += len1;
    rate_buf[offset] = CR_CHAR;
    offset += 1;
    ////////////////////
    //  lost pch
    ////////////////////
    MMI_MEMCPY(rate_buf + offset, buf_len - offset, "<Lost>", 6, 6);
    offset += 6;
    rate_buf[offset] = CR_CHAR;
    offset += 1;
    MMIAPICOM_Int2Str(g_mmieng_lost_pch_number, digit_buf1, 18);
    len1 = SCI_STRLEN((char*)digit_buf1);
    MMI_MEMCPY(rate_buf + offset, buf_len - offset, digit_buf1, 18, len1);
    offset += len1;
    return (offset);
}

/********************************************************************************
 NAME:          EngErrRateWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        allen
 DATE:          2004.09.27
********************************************************************************/
LOCAL MMI_RESULT_E EngErrRateWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    //GUI_RECT_T rect = MMITHEME_GetClientRect();
    uint8 text_buf[151] = {0};
    wchar wstr[151] = {0};
    char* str = PNULL;
    MMI_STRING_T text = {0};
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    BOOLEAN l1_result = TRUE;
    //GUI_LCD_DEV_INFO  lcd_dev_info = {GUI_MAIN_LCD_ID, GUI_BLOCK_MAIN};
        
    //SCI_TRACE_LOW:">>>>>>>>>  enter EngErrRateWinHandleMsg, msg_id = 0x%02X"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_5887_112_2_18_2_17_53_148,(uint8*)"d", msg_id);
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        s_mmieng_errrate_inited = FALSE;
        if (!s_mmieng_errrate_inited)
        {
            str = MMIENG_WAIT_MSG;
            text.wstr_len = strlen(str);
            text.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, 150, (uint8*)str, text.wstr_len, text.wstr_len );

            MMIPUB_OpenWaitWin(1,&text,PNULL,PNULL,MMIENG_WAITING_WIN_ID,IMAGE_NULL,
                ANIM_PUBWIN_WAIT,WIN_ONE_LEVEL,MMIPUB_SOFTKEY_ONE,HandleErrRateWaitWindow);
            // L1 will transfer the error rate data by message, MMI should receive them in application 's PS message function
            // when MMI get them, MMI will close the wait window, then ERRRATE window will re-get focus
            #ifndef _WIN32
            l1_result = L1API_GetBlockErrorRatio(P_APP);
            SCI_TRACE_LOW("EngErrRateWinHandleMsg: l1_result=%d", l1_result);
            if (!l1_result)
            {
                //MMK_CloseWin(MMIENG_ERRRATE_WIN_ID);//bug 1631940
                MMK_CloseWin(MMIENG_WAITING_WIN_ID);
            }
            #else
            l1_result = TRUE;
            #endif
        }
        break;
        
    case MSG_FULL_PAINT:     
        break;
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(MMIENG_ERRRATE_WIN_ID);
        break;

    case MSG_CTL_MIDSK:
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        MMK_CloseWin(MMIENG_ERRRATE_WIN_ID);
        break;
        
    case MSG_GET_FOCUS:
        if (!s_mmieng_errrate_inited)
        {
            s_mmieng_errrate_inited = TRUE;
            
            //LCD_FillRect(&lcd_dev_info, rect, mmi_eng_display.bkgd_color);

            str = (char*)text_buf;
            text.wstr_len =  GetErrRateInfoStr(text_buf, 150);
            text.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, 150, (uint8*)str, text.wstr_len, text.wstr_len );
            GUITEXT_SetString(MMIENG_TEXTBOX1_CTRL_ID, text.wstr_ptr, text.wstr_len, FALSE);
        }
        break;
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }

    return (result);
}

/********************************************************************************
 NAME:			MMIAPIENG_get usb log
 DESCRIPTION:		
 AUTHOR:		fen.xie
 DATE:			2010.07.06
********************************************************************************/
PUBLIC int32 MMIENG_GetUSBLog(BOOLEAN *is_on)
{    
    MN_RETURN_RESULT_E  return_value = MN_RETURN_FAILURE;
    MMINV_READ(MMINV_ENG_USBLOG,is_on,return_value);        
    if(MN_RETURN_SUCCESS!=return_value)
    {
        *is_on = FALSE;      
        MMINV_WRITE(MMINV_ENG_USBLOG,is_on);
    } 
    return return_value;
}

/********************************************************************************
 NAME:			MMIAPIENG_Set usb log
 DESCRIPTION:		
 AUTHOR:		fen.xie
 DATE:			2010.07.06
********************************************************************************/
PUBLIC int32 MMIENG_SetUSBLog(BOOLEAN is_on)
{
    MMINV_WRITE(MMINV_ENG_USBLOG,&is_on);
    return 0;
}

/********************************************************************************
 NAME:          EngARMLOGPOWERWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        allen
 DATE:          2004.09.27
********************************************************************************/
LOCAL MMI_RESULT_E EngUSBLOGWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{   
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_LISTBOX_CTRL_ID;
    BOOLEAN is_on = FALSE;
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        GUILIST_SetMaxItem(ctrl_id,MMISET_OPEN_CLOSE_ITEM, FALSE );//max item 2        
           
        MMIENG_GetUSBLog(&is_on);
        GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
        MMIAPISET_AppendListItemByTextIdExt(TXT_COMM_CLOSE,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
        MMIAPISET_AppendListItemByTextIdExt(TXT_OPEN_COMN,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);         

        //set selected item
        GUILIST_SetSelectedItem(ctrl_id, is_on, TRUE);
        //set current item
        GUILIST_SetCurItemIndex(ctrl_id,is_on);
        
        MMK_SetAtvCtrl(win_id,ctrl_id);     
        break;
        
    case MSG_FULL_PAINT:
        break;  
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
        is_on = GUILIST_GetCurItemIndex(ctrl_id);       
        //MMINV_WRITE(MMINV_ENG_USBLOG,&is_on);  
        MMIENG_SetUSBLog(is_on);
        //MMIPUB_OpenAlertSuccessWin(TXT_COMPLETE);       
        MMK_CloseWin(win_id);
        break;      
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    
    return (result);
}
/********************************************************************************
 NAME:          EngAudioRead
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     目前返回值无正常意义，需要统一
 AUTHOR:        allen
 DATE:          2004.09.27
********************************************************************************/
LOCAL uint32 EngAudioRead(uint32 menu_id , int16 * vol_array)
{  
    NV_AUDIO_E   audio_mode=NV_AUDIO_HEADSET_E;     //对应dsp_audio nv
    AUDIO_DEVICE_MODE_TYPE_E arm_audio_mode = AUDIO_DEVICE_MODE_HANDFREE;  //MP3 audio对应的是audio_arm***.nvm
    AUDIO_NV_ARM_MODE_INFO_T s_arm_audiomode_param={0};
    AUDIO_NV_ARM_MODE_INFO_T *audmod_arm_devmod_ptr = &s_arm_audiomode_param;
    AUDIO_NV_ARM_RESULT_E    result = AUDIO_NV_ARM_NO_ERROR; 
    char  *name_ptr = PNULL;
    uint8  name_len = 0;
    uint32 arm_volume = 0;
    uint offset=0; 
    uint16 iLoop=0;
    uint16 jLoop=0;
    
    //SCI_TRACE_LOW:"EngAudioRead:%d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_6032_112_2_18_2_17_53_149,(uint8*)"d",menu_id,MMIENG_MENU_ID_MAX);
    switch(menu_id)
    {
        
    case ID_ENG_AUDIO_HANDSET_RECEIVER:
        //offset+=18;
        offset=110;
        audio_mode=NV_AUDIO_HANDSET_E;
        break;
    case ID_ENG_AUDIO_HANDSET_SIDETONE:
        //offset+=24;
        offset=92;
        audio_mode=NV_AUDIO_HANDSET_E;
        break;
    case ID_ENG_AUDIO_HANDSET_MIC:
        offset=68;
        audio_mode=NV_AUDIO_HANDSET_E;        
        break;

    case ID_ENG_AUDIO_HEADSET_EAR:
        //offset+=42;
        offset=110;
        audio_mode=NV_AUDIO_HEADSET_E;        
        break;
    case ID_ENG_AUDIO_HEADSET_MIC:
        offset=68;
        audio_mode=NV_AUDIO_HEADSET_E;        
        break;

    case ID_ENG_AUDIO_HANDSFREE_SPEAKER:
        //offset+=42;
        offset=110;
        audio_mode=NV_AUDIO_HANDSFREE_E;
        break;
    case ID_ENG_AUDIO_HANDSFREE_MIC:
        offset+=68;
        audio_mode=NV_AUDIO_HANDSFREE_E;
        break;

    case ID_ENG_AUDIO_MP4HFTP_SPEAKER:
        offset+=110;
        audio_mode=NV_AUDIO_MP4HFTP_E;        
        break;

    case ID_ENG_AUDIO_MP4HFTR_MIC:
        offset+=68;
        audio_mode=NV_AUDIO_MP4HFTP_E;
        break;

    case ID_ENG_AUDIO_MP4HEADSET_EAR:
        audio_mode=NV_AUDIO_MP4HEADSET_E;
        break;
#if defined (PLATFORM_ANTISW3)
    case ID_ENG_AUDIO_RECORD_MIC:
        offset+=68;
        audio_mode=NV_AUDIO_RECORD_HANDSFREE_E;
        break;
#endif
    case ID_ENG_AUDIO_BT_EAR:
        //offset+=42;
        offset=110;
        audio_mode=NV_AUDIO_BTHS_E;
        break; 
    case ID_ENG_AUDIO_BT_MIC:
        offset=68;
        audio_mode=NV_AUDIO_BTHS_E;
        break;        
        
    case ID_ENG_AUDIO_MP3_LOUDSPK_SPEAKER:
        arm_audio_mode = AUDIO_DEVICE_MODE_HANDFREE;
        s_mp3_gain_array = &s_mp3_handsfree[0];
        break;
    case ID_ENG_AUDIO_MP3_EARPHONE_EAR:
        arm_audio_mode = AUDIO_DEVICE_MODE_EARPHONE;
        s_mp3_gain_array = &s_mp3_headset[0];
        break;
    case ID_ENG_AUDIO_MP3_HEADFREE_SPEAKER:
        arm_audio_mode = AUDIO_DEVICE_MODE_EARFREE;
        s_mp3_gain_array = &s_mp3_headfree[0];
        break;
    default:
        break;
    }   
    //SCI_TRACE_LOW:"EngAudioRead"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_6090_112_2_18_2_17_53_150,(uint8*)"");

    if(menu_id!=ID_ENG_AUDIO_MP3_LOUDSPK_SPEAKER
        &&menu_id!=ID_ENG_AUDIO_MP3_EARPHONE_EAR
        &&menu_id!=ID_ENG_AUDIO_MP3_HEADFREE_SPEAKER)
    {   
        AUDMOD_DEVMOD_T mode_param={0};
        if(SCI_ERROR==PROD_ReadAudioParam(audio_mode,&mode_param))
        {
            return SCI_ERROR;
        }

        if(menu_id==ID_ENG_AUDIO_BT_MIC||menu_id==ID_ENG_AUDIO_HANDSET_MIC
        ||menu_id==ID_ENG_AUDIO_HANDSFREE_MIC||menu_id==ID_ENG_AUDIO_MP4HFTR_MIC
        ||menu_id==ID_ENG_AUDIO_RECORD_MIC||menu_id==ID_ENG_AUDIO_HEADSET_MIC)
        {
            SCI_MEMCPY(vol_array,mode_param.tAudioStruct.extend2+offset,MMIENG_AUDIO_VOL_MAX*sizeof(uint16));
        }
        else
        {
            SCI_MEMCPY(vol_array,mode_param.tAudioStruct.extend+offset,MMIENG_AUDIO_VOL_MAX*sizeof(uint16));
        }
        for(iLoop = 0 ;iLoop<MMIENG_AUDIO_VOL_MAX;iLoop++)
        {
            vol_array[iLoop]=(int16)((20*MMIENG_Log((double)vol_array[iLoop]/4096,10)+0.5));/*lint !e747*/
            
            //SCI_TRACE_LOW:"EngAudioRead:log"
            SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_6111_112_2_18_2_17_53_151,(uint8*)"");
            if(vol_array[iLoop]<-18)
            {
                vol_array[iLoop]=-18;
            }
            else if(vol_array[iLoop]>18)
            {
                vol_array[iLoop]=18;
            }
            if(vol_array[iLoop]<0)
            {
                vol_array[iLoop]+=17;//修正负数4舍5入情况
            }
            else
            {
                vol_array[iLoop]+=18;
            }
        }
             
    }
    else  //MP3 audio
    {       
        name_ptr = AUDIONVARM_GetAudioModeName(arm_audio_mode);
        if (PNULL == name_ptr)
        {
            SCI_TRACE_LOW("EngAudioRead:AUDIONVARM_GetAudioModeName name_ptr is null!\n");
            return SCI_ERROR;
        }
        name_len = strlen(name_ptr);
        if (name_len >= AUDIO_NV_ARM_MODE_NAME_MAX_LEN)
        {
            SCI_TRACE_LOW("EngAudioRead:AUDIONVARM_GetAudioModeName name_len>=AUDIO_NV_ARM_MODE_NAME_MAX_LEN!\n");
            return SCI_ERROR;
        }
        SCI_MEMCPY(audmod_arm_devmod_ptr->ucModeName, name_ptr, name_len);
        audmod_arm_devmod_ptr->ucModeName[name_len] = '\0';

        result = AUDIONVARM_GetModeParam(name_ptr, audmod_arm_devmod_ptr);
        if(result != AUDIO_NV_ARM_NO_ERROR)
        {
            SCI_TRACE_LOW("EngAudioRead:AUDIONVARM_GetModeParam result=%d!\n", result);
            return SCI_ERROR;
        }

        //to find the gain index in s_mp3_gain_array[];
        for(iLoop = 0 ;iLoop<MMIENG_MP3_AUDIO_VOL_MAX;iLoop++)
        {
            arm_volume = audmod_arm_devmod_ptr->tAudioNvArmModeStruct.app_config_info_set.app_config_info->arm_volume[iLoop+1];
            
            for(jLoop = 1 ;jLoop<MMIENG_AUDIO_GAIN_LEVEL_MAX;jLoop++)
            {               
                if(s_mp3_gain_array[jLoop].hex_value == arm_volume)
                {
                    vol_array[iLoop] = jLoop;
                    break;
                }
            } 

            if(MMIENG_AUDIO_GAIN_LEVEL_MAX == jLoop)  //if not in the array;
            {
                vol_array[iLoop] = (uint16)((MMIENG_AUDIO_GAIN_LEVEL_MAX-1)*iLoop)/(uint16)(MMIENG_MP3_AUDIO_VOL_MAX);
            }
        }
    }
    //SCI_TRACE_LOW:"EngAudioRead:end"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_6135_112_2_18_2_17_53_152,(uint8*)"");
    return SCI_SUCCESS;
}
/********************************************************************************
 NAME:          EngARMLOGPOWERWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        allen
 DATE:          2004.09.27
********************************************************************************/
LOCAL uint32 EngAudioWrite(uint32 menu_id , int16 *vol_array)
{  
    NV_AUDIO_E   audio_mode=NV_AUDIO_HEADSET_E;
    AUDIO_DEVICE_MODE_TYPE_E arm_audio_mode = AUDIO_DEVICE_MODE_HANDFREE;
    AUDIO_NV_ARM_MODE_INFO_T s_arm_audiomode_param={0};
    AUDIO_NV_ARM_MODE_INFO_T *audmod_arm_devmod_ptr = &s_arm_audiomode_param;
    AUDIO_NV_ARM_RESULT_E    result = AUDIO_NV_ARM_NO_ERROR; 
#ifdef AUDIO_PARAM_ARM   
    AUDIO_RESULT_E set_devmode_result = AUDIO_NO_ERROR;
#endif
    uint offset=0;
    uint16 iLoop=0;
    uint16 jLoop=0; 
    uint16 buf=0;
    switch(menu_id)
    {
        
    case ID_ENG_AUDIO_HANDSET_RECEIVER:
        //offset+=18;
        offset=110;
        audio_mode=NV_AUDIO_HANDSET_E;        
        break;
    case ID_ENG_AUDIO_HANDSET_SIDETONE:
        //offset+=24;
        offset=92;
        audio_mode=NV_AUDIO_HANDSET_E;        
        break;
    case ID_ENG_AUDIO_HANDSET_MIC:
        offset=68;
        audio_mode=NV_AUDIO_HANDSET_E;        
        break;

    case ID_ENG_AUDIO_HEADSET_EAR:
        //offset+=42;
        offset=110;
        audio_mode=NV_AUDIO_HEADSET_E;        
        break;
    case ID_ENG_AUDIO_HEADSET_MIC:
        offset+=68;
        audio_mode=NV_AUDIO_HEADSET_E;        
        break;

    case ID_ENG_AUDIO_HANDSFREE_SPEAKER:
        //offset+=42;
        offset=110;
        audio_mode=NV_AUDIO_HANDSFREE_E;
        break;
    case ID_ENG_AUDIO_HANDSFREE_MIC:
        offset+=68;
        audio_mode=NV_AUDIO_HANDSFREE_E;
        break;

    case ID_ENG_AUDIO_MP4HFTP_SPEAKER:
        offset+=110;
        audio_mode=NV_AUDIO_MP4HFTP_E;        
        break;

    case ID_ENG_AUDIO_MP4HFTR_MIC:
        offset+=68;
        audio_mode=NV_AUDIO_MP4HFTP_E;
        break;

    case ID_ENG_AUDIO_MP4HEADSET_EAR:
        audio_mode=NV_AUDIO_MP4HEADSET_E;
        break;
#if defined (PLATFORM_ANTISW3)
    case ID_ENG_AUDIO_RECORD_MIC:
        offset+=68;
        audio_mode=NV_AUDIO_RECORD_HANDSFREE_E;
        break;
#endif
    case ID_ENG_AUDIO_BT_EAR:
        //offset+=42;
        offset=110;
        audio_mode=NV_AUDIO_BTHS_E;
        break; 
    case ID_ENG_AUDIO_BT_MIC:
        offset+=68;
        audio_mode=NV_AUDIO_BTHS_E;
        break; 

    case ID_ENG_AUDIO_MP3_LOUDSPK_SPEAKER:
        arm_audio_mode = AUDIO_DEVICE_MODE_HANDFREE;
        break;
    case ID_ENG_AUDIO_MP3_EARPHONE_EAR:
        arm_audio_mode = AUDIO_DEVICE_MODE_EARPHONE;
        break;
    case ID_ENG_AUDIO_MP3_HEADFREE_SPEAKER:
        arm_audio_mode = AUDIO_DEVICE_MODE_EARFREE;
        break;
    default:
        break;
    }       
    
    if(menu_id!=ID_ENG_AUDIO_MP3_LOUDSPK_SPEAKER
        &&menu_id!=ID_ENG_AUDIO_MP3_EARPHONE_EAR
        &&menu_id!=ID_ENG_AUDIO_MP3_HEADFREE_SPEAKER)
    {
        AUDMOD_DEVMOD_T mode_param={0};
        if(SCI_ERROR==PROD_ReadAudioParam(audio_mode,&mode_param))
        {
            return SCI_ERROR;
        }
        buf=(uint16)(MMIENG_Pow(10.0,(double)(*s_volValue-18)/20)*4096);
        if(menu_id==ID_ENG_AUDIO_BT_MIC||menu_id==ID_ENG_AUDIO_HANDSET_MIC
        ||menu_id==ID_ENG_AUDIO_HANDSFREE_MIC||menu_id==ID_ENG_AUDIO_MP4HFTR_MIC
        ||menu_id==ID_ENG_AUDIO_RECORD_MIC||menu_id==ID_ENG_AUDIO_HEADSET_MIC)
        {
           *(mode_param.tAudioStruct.extend2+offset+(s_volValue-s_vol_array))=buf;
        }
        else
        {
            *(mode_param.tAudioStruct.extend+offset+(s_volValue-s_vol_array))=buf;
        }
        if(SCI_ERROR==PROD_WriteAudioParam(audio_mode,&mode_param,TRUE))
        {
            return SCI_ERROR;
        }
    }  
    else
    {
        char  *name_ptr = PNULL;
        uint8  name_len = 0;
        //将1-35中的级别（数组下标）转化为相应的十六进制值
        for(iLoop = 0 ;iLoop<MMIENG_MP3_AUDIO_VOL_MAX;iLoop++)
        {
            jLoop = vol_array[iLoop];   //取下标值                                           //+1表示存储1-35
            audmod_arm_devmod_ptr->tAudioNvArmModeStruct.app_config_info_set.app_config_info->arm_volume[iLoop+1] = s_mp3_gain_array[jLoop].hex_value;    
        }
        //设置audio mode param
        name_ptr = AUDIONVARM_GetAudioModeName(arm_audio_mode);
        if (PNULL == name_ptr)
        {
            SCI_TRACE_LOW("EngAudioRead:AUDIONVARM_GetAudioModeName name_ptr is null!\n");
            return SCI_ERROR;
        }
        name_len = strlen(name_ptr);
        if (name_len >= AUDIO_NV_ARM_MODE_NAME_MAX_LEN)
        {
            SCI_TRACE_LOW("EngAudioRead:AUDIONVARM_GetAudioModeName name_len>=AUDIO_NV_ARM_MODE_NAME_MAX_LEN!\n");
            return SCI_ERROR;
        }
        SCI_MEMCPY(audmod_arm_devmod_ptr->ucModeName, name_ptr, name_len);
        audmod_arm_devmod_ptr->ucModeName[name_len] = '\0';

        result = AUDIONVARM_GetModeParam(name_ptr, audmod_arm_devmod_ptr);
        if(result != AUDIO_NV_ARM_NO_ERROR)
        {
            SCI_TRACE_LOW("EngAudioRead:AUDIONVARM_GetModeParam result=%d!\n", result);
            return SCI_ERROR;
        }
        result = AUDIONVARM_WriteModeParamToFlash((char *)audmod_arm_devmod_ptr->ucModeName, audmod_arm_devmod_ptr);
        result = AUDIONVARM_SetModeParam((char *)audmod_arm_devmod_ptr->ucModeName, audmod_arm_devmod_ptr);
        if(result != AUDIO_NV_ARM_NO_ERROR)
        {
            SCI_TRACE_LOW("EngAudioWrite:AUDIONVARM_SetModeParam result=%d\n", result);
            return SCI_ERROR;
        }
        else
        {          
#ifdef AUDIO_PARAM_ARM   
            set_devmode_result = AUDIO_SetDevModeEx(INVALID_HANDLE, arm_audio_mode);
            SCI_TRACE_LOW("EngAudioWrite:AUDIO_SetDevModeEx result=%d\n", set_devmode_result);
#else
            AUDIO_SetDevMode(arm_audio_mode);
#endif
        }
    }
    return SCI_SUCCESS;
}
/********************************************************************************
 NAME:          EngARMLOGPOWERWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        allen
 DATE:          2004.09.27
********************************************************************************/
LOCAL MMI_RESULT_E EngAudioSetWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{   
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_LISTBOX_CTRL_ID;
    uint8 iLoop=0; 
    uint32 menu_id= (uint32)MMK_GetWinAddDataPtr(win_id);
    uint8 data_buf[20] = {0};   
    uint8 vol_max = MMIENG_AUDIO_VOL_MAX; 
    
    if(menu_id==ID_ENG_AUDIO_MP3_LOUDSPK_SPEAKER
        || menu_id==ID_ENG_AUDIO_MP3_EARPHONE_EAR
        || menu_id==ID_ENG_AUDIO_MP3_HEADFREE_SPEAKER)
    {
        vol_max = MMIENG_MP3_AUDIO_VOL_MAX;  //MP3为15级音量     
    }

    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        GUILIST_SetMaxItem(ctrl_id,vol_max, FALSE );//max item 2
        EngAudioRead(menu_id,s_vol_array);
        while(iLoop!=vol_max)
        {  
            if(menu_id!=ID_ENG_AUDIO_MP3_LOUDSPK_SPEAKER
                &&menu_id!=ID_ENG_AUDIO_MP3_EARPHONE_EAR
                &&menu_id!=ID_ENG_AUDIO_MP3_HEADFREE_SPEAKER)
            {
                sprintf((char*)data_buf, "%ld",s_vol_array[iLoop]);
            }
            else
            {   
                sprintf((char*)data_buf, "%g", s_mp3_gain_array[s_vol_array[iLoop]].total_gain); 
                SCI_TRACE_LOW("s_vol_array[%d]=%d\n",iLoop,s_vol_array[iLoop]);
            }
            MMIENG_AppendListItemByTextId(s_vol_table[iLoop++],TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_TWO_LINE_TEXT_AND_TEXT,data_buf);
        }
        MMK_SetAtvCtrl(win_id,ctrl_id);     
        break;
        
  
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
     iLoop = GUILIST_GetCurItemIndex(ctrl_id);  
     s_volValue=&s_vol_array[iLoop];
     if(menu_id!=ID_ENG_AUDIO_MP3_LOUDSPK_SPEAKER
         &&menu_id!=ID_ENG_AUDIO_MP3_EARPHONE_EAR
         &&menu_id!=ID_ENG_AUDIO_MP3_HEADFREE_SPEAKER)
     {
            MMK_CreateWin((uint32*)MMIENG_AUDIOVOL_WIN_TAB, (ADD_DATA)(menu_id));
     }
     else
     {
          MMK_CreateWin((uint32*)MMIENG_AUDIOMP3_WIN_TAB, (ADD_DATA)(menu_id));
     }
        break;  
        
    case MSG_ENG_AUDIO_REFREH:  
        //EngAudioRead(menu_id,s_vol_array);
        GUILIST_RemoveAllItems( ctrl_id);
        iLoop=0;
        while(iLoop!=vol_max)
        {  
            if(menu_id!=ID_ENG_AUDIO_MP3_LOUDSPK_SPEAKER
                &&menu_id!=ID_ENG_AUDIO_MP3_EARPHONE_EAR
                &&menu_id!=ID_ENG_AUDIO_MP3_HEADFREE_SPEAKER)
            {
                sprintf((char*)data_buf, "%ld",s_vol_array[iLoop]);
            }
            else
            {   
                sprintf((char*)data_buf, "%g", s_mp3_gain_array[s_vol_array[iLoop]].total_gain); 
            }
            MMIENG_AppendListItemByTextId(s_vol_table[iLoop++],TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_TWO_LINE_TEXT_AND_TEXT,data_buf);
        }
        MMK_PostMsg(win_id, MSG_FULL_PAINT, NULL, 0);
        break;
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    
    return (result);
}

/*****************************************************************************/
//  Description : to append one item to listbox by text id and set soft keys
//  Global resource dependence : 
//  Author:zhaohui
//  Note: 
/*****************************************************************************/

LOCAL double MMIENG_Coef(int n)    
{    
    double t=0.0;
    if(n==0) return 0;    
    t=1.0/n;    
    if(n%2==0) t=-t;    
    return t;    
}//x^n的系数    


LOCAL double MMIENG_Horner(double x)    
{    
    const int N=100;  
    int i=0;
    double u=MMIENG_Coef(N);    
    for(i=N-1;i>=0;i--)    
        u=u*x+MMIENG_Coef(i);    
    return u;    
}    

LOCAL double MMIENG_Sqrt(double b)    
{    
    double x=1;int step=0;    
    while((x*x-b<-0.000000000000001||x*x-b>0.000000000000001)&&step<50)    
    {x=(b/x+x)/2.0;step++;}    
    return x;    
}//开平方    

LOCAL double MMIENG_Ln(double x)//ln(1+x)=x-x^2/2+x^3/3-x^4/4……    
{    
    int i=0;
    if(x>1.5)    
    {    
        for(;x>1.25;i++)    
            x=MMIENG_Sqrt(x);    
        return (1<<i)*MMIENG_Horner(x-1);   /*lint !e790*/ 
    }    
    else if(x<0.7&&x>0)    
    {    
        for(i=0;x<0.7;i++)    
            x=MMIENG_Sqrt(x);    
        return (1<<i)*MMIENG_Horner(x-1);    /*lint !e790*/ 
    }    
    else if(x>0) 
    {
        return MMIENG_Horner(x-1);
    }
    return 0;
}    
/*****************************************************************************/
//  Description : to append one item to listbox by text id and set soft keys
//  Global resource dependence : 
//  Author:zhaohui
//  Note: 
/*****************************************************************************/
LOCAL double MMIENG_Log(double m,double base)    
{    
    if(m==0)
    {
        return 0;
    }
    return MMIENG_Ln(m)/MMIENG_Ln(base);//换底公式    
}  

LOCAL double MMIENG_Exp(double x)    
{    
    const int N=100; 
    double sum=1;   
    int i=0;
    for(i=N;i>0;i--)    
    {    
        sum/=i;    
        sum*=x;    
        sum+=1;    
    }    
    return sum;    
    
}//e^x≈1+x+x^2/2!+x^3/3!+……+x^n/n!    

LOCAL double MMIENG_Pow(double m,double n)    
{    
    return MMIENG_Exp(n*MMIENG_Ln(m));    
}   

/*****************************************************************************/
//  Description : to append one item to listbox by text id and set soft keys
//  Global resource dependence : 
//  Author:zhaohui
//  Note: 
/*****************************************************************************/
LOCAL void MMIENG_AppendListItemByTextId(                                   
                                                MMI_TEXT_ID_T        text_id,
                                                MMI_TEXT_ID_T        left_softkey_id,
                                                MMI_TEXT_ID_T        middle_softkey_id,
                                                MMI_TEXT_ID_T        right_softkey_id,
                                                MMI_CTRL_ID_T        ctrl_id,
                                                GUIITEM_STYLE_E      item_style,
                                                uint8 * data_buf
                                                )
{
    GUILIST_ITEM_T      item_t = {0};
    GUILIST_ITEM_DATA_T item_data = {0};
    
    wchar wbuf[30] = {0};

    item_t.item_style    = item_style;
    item_t.item_data_ptr = &item_data;
    
    item_data.item_content[0].item_data_type    = GUIITEM_DATA_TEXT_ID;
    item_data.item_content[0].item_data.text_id = text_id;
    
    
    item_data.item_content[1].item_data.text_buffer.wstr_len= strlen((char*)data_buf);
     item_data.item_content[1].item_data.text_buffer.wstr_ptr = wbuf;
    MMI_STRNTOWSTR(wbuf, 30, data_buf, 
        item_data.item_content[1].item_data.text_buffer.wstr_len,
        item_data.item_content[1].item_data.text_buffer.wstr_len );

    item_data.item_content[1].item_data_type = GUIITEM_DATA_TEXT_BUFFER;    
    
    item_data.softkey_id[0] = left_softkey_id;
    item_data.softkey_id[1] = middle_softkey_id;
    item_data.softkey_id[2] = right_softkey_id;
    
    GUILIST_AppendItem( ctrl_id, &item_t );      
}

/********************************************************************************
 NAME:          EngPAWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        allen
 DATE:          2004.09.27
********************************************************************************/
LOCAL MMI_RESULT_E EngAudioVolWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{   
    uint8 data_buf[31] = {0};
    wchar wstr[31] = {0};
    int32 buff_length = 30;
    char* str = PNULL;
    MMI_STRING_T text = {0}; 
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    uint32 menu_id= (uint32)MMK_GetWinAddDataPtr(win_id);
    GUI_LCD_DEV_INFO    lcd_dev_info = {GUI_MAIN_LCD_ID, GUI_BLOCK_MAIN};
    const GUI_RECT_T client_rect = MMITHEME_GetClientRectEx(win_id);
    GUI_RECT_T          prg_rect = client_rect;   
    uint16      prg_rect_interval_from_win_border = (client_rect.right - client_rect.left + 1)/20;
    uint16      prg_rect_height =  2*GUIFONT_GetHeight(MMI_DEFAULT_TEXT_FONT);
    uint16      lab_rect_height =  GUIFONT_GetHeight(MMI_DEFAULT_TEXT_FONT);
    GUI_RECT_T lab_rect = client_rect;
    static int16 volume = 0;
        
    switch (msg_id)
    {
    case MSG_OPEN_WINDOW:
#ifndef PLATFORM_UWS6121E
        prg_rect.top = (client_rect.bottom + client_rect.top) >> 1 ;
#else
		prg_rect.top = (client_rect.bottom - client_rect.top - MMITHEME_GetWinTitleHeight()) >> 1 ;
#endif
        prg_rect.bottom = prg_rect.top + prg_rect_height;
        prg_rect.left += prg_rect_interval_from_win_border;
        prg_rect.right -= prg_rect_interval_from_win_border;
        lab_rect.bottom = prg_rect.top - lab_rect_height;
        lab_rect.top  = lab_rect.bottom - lab_rect_height;
        GUILABEL_SetRect(MMIENG_LABEL1_CTRL_ID, &lab_rect, FALSE);       
        GUIPRGBOX_SetRect(MMIENG_PRGBOX_CTRL_ID,&prg_rect);
        GUIWIN_SetSoftkeyTextId(MMIENG_AudioVol_WIN_ID,  (MMI_TEXT_ID_T)TXT_ENG_OK, (MMI_TEXT_ID_T)TXT_NULL, (MMI_TEXT_ID_T)TXT_ENG_RETURN, FALSE);
        
        GUILABEL_SetBackgroundColor(MMIENG_LABEL1_CTRL_ID, MMI_BACKGROUND_COLOR);
        LCD_FillRect(&lcd_dev_info, client_rect, MMI_BACKGROUND_COLOR);
        //GUILABEL_SetFontParam(MMIENG_LABEL1_CTRL_ID, mmi_eng_display.text_font, mmi_eng_display.spec_text_color, mmi_eng_display.char_space);
        GUILABEL_SetFont(MMIENG_LABEL1_CTRL_ID, MMI_DEFAULT_TEXT_FONT, MMI_RED_COLOR);

        volume = *s_volValue;
        
         sprintf((char*)data_buf, "%ld", volume);
        
        str = (char*)data_buf;
        text.wstr_len = strlen(str);
        text.wstr_ptr = wstr;
        MMI_STRNTOWSTR( wstr, buff_length, (uint8*)str, text.wstr_len, text.wstr_len );
        
        GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &text, FALSE);
        
       // volValue= (uint16)(uint32)(MMK_GetWinAddDataPtr(win_id));
        GUIPRGBOX_SetParamByCtrl(MMIENG_PRGBOX_CTRL_ID, MMIENG_AUDIO_SET_VOLMAX, MMIENG_AUDIO_SET_VOLMAX);
        GUIPRGBOX_SetPosByCtrl(FALSE,volume,volume,MMIENG_PRGBOX_CTRL_ID);
        
        break;
        
    case MSG_LCD_SWITCH:
         prg_rect.top = (client_rect.bottom + client_rect.top) >> 1 ;
        prg_rect.bottom = prg_rect.top + prg_rect_height;
        prg_rect.left += prg_rect_interval_from_win_border;
        prg_rect.right -= prg_rect_interval_from_win_border;
        lab_rect.bottom = prg_rect.top - lab_rect_height ;
        lab_rect.top  = lab_rect.bottom - lab_rect_height;
        GUILABEL_SetRect(MMIENG_LABEL1_CTRL_ID, &lab_rect, FALSE);       
        GUIPRGBOX_SetRect(MMIENG_PRGBOX_CTRL_ID,&prg_rect);
        break;
        
    case MSG_FULL_PAINT:
         LCD_FillRect(&lcd_dev_info, client_rect, MMI_BACKGROUND_COLOR);

        break;
#ifdef MMI_PDA_SUPPORT
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
     case MSG_CTL_PENOK:
        if (PNULL != param)
        {
            uint32 src_id = ((MMI_NOTIFY_T*)param)->src_id;
        
            switch (src_id)
            {
            case MMICOMMON_BUTTON_SOFTKEY_LEFT_CTRL_ID:
                MMK_SendMsg(win_id, MSG_APP_OK, PNULL);
                break;
            case MMICOMMON_BUTTON_SOFTKEY_RIGHT_CTRL_ID:
                MMK_SendMsg(win_id, MSG_APP_CANCEL, PNULL);
                break;
            default:
                break;
            }
        }
        break;
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
#endif
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        //MMK_PostMsg(MMIENG_AUDIOSET_WIN_ID, MSG_ENG_AUDIO_REFREH, NULL, 0); 
        MMK_CloseWin(MMIENG_AudioVol_WIN_ID);
        break;
        
    case MSG_CTL_MIDSK:
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:    
        //MMIPUB_OpenAlertSuccessWin(TXT_COMPLETE);
        *s_volValue = volume;
        EngAudioWrite(menu_id,s_vol_array);
        MMK_CloseWin(MMIENG_AudioVol_WIN_ID);
        MMK_PostMsg(MMIENG_AUDIOSET_WIN_ID, MSG_ENG_AUDIO_REFREH, NULL, 0);
        break;
        
    case MSG_KEYDOWN_LEFT:
        if (volume > 0)
        {
            volume-=1;
//             if (volume < 0)
//                     volume = 0;    
            sprintf((char*)data_buf, "%ld", volume);
            
            str = (char*)data_buf;
            text.wstr_len = strlen(str);
            text.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, buff_length, (uint8*)str, text.wstr_len, text.wstr_len );
            
            GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &text, TRUE);
            GUIPRGBOX_SetPosByCtrl(TRUE,volume,volume,MMIENG_PRGBOX_CTRL_ID);
        }
        break;
        
    case MSG_KEYDOWN_RIGHT:
        if (volume < MMIENG_AUDIO_SET_VOLMAX)
        {
            volume += 1;
//             if (volume > MMIENG_AUDIO_SET_VOLMAX)
//                 volume = MMIENG_AUDIO_SET_VOLMAX;
            sprintf((char*)data_buf, "%ld", volume);
            
            str = (char*)data_buf;
            text.wstr_len = strlen(str);
            text.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, buff_length, (uint8*)str, text.wstr_len, text.wstr_len );
            
            GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &text, TRUE);
            GUIPRGBOX_SetPosByCtrl(TRUE,volume,volume,MMIENG_PRGBOX_CTRL_ID);
        }
        break;

#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_TP_PRESS_DOWN:
    case MSG_TP_PRESS_MOVE:
        if(param == 0) break;
        {
            GUI_RECT_T progressbar_rect = {0};
            uint16 progressbar_length = 0;
            GUI_POINT_T tp_point = {0};
            
            GUIAPICTRL_GetRect(MMIENG_PRGBOX_CTRL_ID,&progressbar_rect); /*lint !e516*/
            progressbar_length = (progressbar_rect.right - progressbar_rect.left + 1);
            tp_point.x= MMK_GET_TP_X(param);
            tp_point.y = MMK_GET_TP_Y(param);
            
            if(!GUI_PointIsInRect(tp_point,progressbar_rect)) break;

            volume = (tp_point.x - progressbar_rect.left + 1)*MMIENG_AUDIO_SET_VOLMAX/progressbar_length;
            sprintf((char*)data_buf, "%ld", volume);            
            str = (char*)data_buf;
            text.wstr_len = strlen(str);
            text.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, buff_length, (uint8*)str, text.wstr_len, text.wstr_len );
            
            GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &text, TRUE);
            GUIPRGBOX_SetPosByCtrl(TRUE,volume,volume,MMIENG_PRGBOX_CTRL_ID);
            
             
        }
        break;
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527

#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_TP_PRESS_UP:
        break;
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}
/********************************************************************************
 NAME:          MMIENG_DextoInt
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        
 DATE:      
********************************************************************************/
LOCAL int16 MMIENG_DextoInt(uint8 * buf)
{
    uint8 * pTemp=buf;
    int16 result=0;
    while(*pTemp!='\0')
    {
           if((*pTemp)>='0'&&(*pTemp)<='9')
           {
                  *pTemp-='0';
           }
           else if((*pTemp)>='a'&&(*pTemp)<='f')
           {
               *pTemp=*pTemp-'a'+10;
           }
           else if((*pTemp)>='A'&&(*pTemp)<='F')
           {
               *pTemp=*pTemp-'A'+10;
           }
           else
           {    
               result = -1;
               break;
           }
           result=result*16+*pTemp;
           pTemp++;
    }
    return result;
}

/********************************************************************************
 NAME:          AudioMp3AppendListItem
 DESCRIPTION:   Used for Mp3 volume edit window
 PARAM IN:      menu_id - which MMIENG_AUDIO_MP3_GAIN_T array to be used 
                index - selected item index
 AUTHOR:        leon.wang
 DATE:          2012.9.11
********************************************************************************/
LOCAL void AudioMp3AppendListItem(uint16 index)
{
    MMI_CTRL_ID_T           list_ctrl_id = MMIENG_MP3_LISTBOX_CTRL_ID;
    wchar                   txt_array[10] = {0};
    char                    buf[10] = {0};
    uint16                  txt_len = 0;
    uint16                  iloop = 0;
    
    GUILIST_SetMaxItem(list_ctrl_id,MMIENG_AUDIO_GAIN_LEVEL_MAX, FALSE);

    for(iloop=0; iloop< MMIENG_AUDIO_GAIN_LEVEL_MAX; iloop++)
    {       
        sprintf(buf, "%g", s_mp3_gain_array[iloop].total_gain);
        SCI_MEMSET(txt_array, 0,  10*sizeof(wchar));
        txt_len = SCI_STRLEN(buf);
        txt_len = MIN(txt_len,9);
        MMI_STRNTOWSTR(txt_array, 9, (uint8*)buf, 9, txt_len);
        MMIAPISET_AppendListItemByTextBuffer(txt_array, 
                                            txt_len, 
                                            0,
                                            TXT_ENG_OK, 
                                            TXT_NULL, 
                                            TXT_ENG_RETURN, 
                                            list_ctrl_id,
                                            GUIITEM_STYLE_1RADIO_ENG
                                            );
    }
    
    GUILIST_SetSelectedItem(list_ctrl_id, index, TRUE);
    GUILIST_SetCurItemIndex(list_ctrl_id, index);
} 

/********************************************************************************
 NAME:          EngWapUAWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        
 DATE:      
********************************************************************************/

LOCAL MMI_RESULT_E EngAudioMp3WinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E        result = MMI_RESULT_TRUE;
    uint32  menu_id= (uint32)MMK_GetWinAddDataPtr(win_id);
    MMI_CTRL_ID_T ctrl_id = MMIENG_MP3_LISTBOX_CTRL_ID;
    
    switch (msg_id)
    {
    case MSG_OPEN_WINDOW:   
        AudioMp3AppendListItem((uint16)*s_volValue);
        MMK_SetAtvCtrl(win_id, ctrl_id);
        break;

#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
     case MSG_CTL_PENOK:
        if (PNULL != param)
        {
            uint32 src_id = ((MMI_NOTIFY_T*)param)->src_id;
        
            switch (src_id)
            {
            case MMIENG_MP3_LISTBOX_CTRL_ID:
            case MMICOMMON_BUTTON_SOFTKEY_LEFT_CTRL_ID:
                 MMK_SendMsg(win_id, MSG_APP_OK, PNULL);
                 break;
            case MMICOMMON_BUTTON_SOFTKEY_RIGHT_CTRL_ID:
                 MMK_SendMsg(win_id, MSG_APP_CANCEL, PNULL);
                break;
            default:
                break;
            }
        }
        break;
#endif
 //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_APP_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK: 
    case MSG_APP_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        {        
            //save to nv
            int16 volume = GUILIST_GetCurItemIndex(ctrl_id);

            *s_volValue = volume;
            EngAudioWrite(menu_id,s_vol_array); 
            MMK_PostMsg(MMIENG_AUDIOSET_WIN_ID, MSG_ENG_AUDIO_REFREH, NULL, 0);
            MMK_CloseWin(win_id);
        }
        break;
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

#ifdef WIN32
/*****************************************************************************/
//  Description:    The function read PROD parameters about audio from NVItem .
//  Global resource dependence: 
//  Author:         Benjamin.Wang
//  Note:           
/*****************************************************************************/
PUBLIC uint32 PROD_ReadAudioParam(  
             NV_AUDIO_E   audio_mode,
             void*        mode_param_ptr
             )
{


    return SCI_SUCCESS;
    
}
/*****************************************************************************/
//  Description:    The function write PROD parameters about audio to NVItem .
//  Global resource dependence: 
//  Author:         Benjamin.Wang
//  Note:           is_flush：SCI_FALSE-〉表示数据只写入CACHE，SCI_TRUE->表示数据写入NV，请flush数据Cache
/*****************************************************************************/
PUBLIC uint32 PROD_WriteAudioParam(
    //const uint8* pucModeName, 
    NV_AUDIO_E   audio_mode, 
    void*        mode_param_ptr,
    BOOLEAN      is_flush
    )
{   
    return SCI_SUCCESS;    
}
#endif

/********************************************************************************
 NAME:          EngARMLOGPOWERWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        allen
 DATE:          2004.09.27
********************************************************************************/
LOCAL MMI_RESULT_E EngCAPOUTPUTWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{   
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_LISTBOX_CTRL_ID;
    BOOLEAN is_on = FALSE;
    MN_RETURN_RESULT_E  return_value = MN_RETURN_FAILURE;
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        GUILIST_SetMaxItem(ctrl_id,MMISET_OPEN_CLOSE_ITEM, FALSE );//max item 2        
        MMINV_READ(MMIENG_NV_CAP_OUTPUT,&is_on,return_value);        
        if(MN_RETURN_SUCCESS!=return_value)
        {
#ifdef MMI_GPRS_SUPPORT
            is_on = TCPIPDEBUG_IsPktOutputEnable();
#endif
            MMINV_WRITE(MMIENG_NV_CAP_OUTPUT,&is_on);
        }             
 
        GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
        MMIAPISET_AppendListItemByTextIdExt(TXT_COMM_OFF,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
        MMIAPISET_AppendListItemByTextIdExt(TXT_COMM_ON,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);         

        //set selected item
        GUILIST_SetSelectedItem(ctrl_id, is_on, TRUE);
        //set current item
        GUILIST_SetCurItemIndex(ctrl_id,is_on);
        
        MMK_SetAtvCtrl(win_id,ctrl_id);     
        break;
        
    case MSG_FULL_PAINT:
        break;  
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
        is_on = GUILIST_GetCurItemIndex(ctrl_id);       
        MMINV_WRITE(MMIENG_NV_CAP_OUTPUT,&is_on);
#ifdef MMI_GPRS_SUPPORT
#ifndef _WIN32
        TCPIPDEBUG_EnablePktOutput( is_on );
#endif
#endif
       // MMIPUB_OpenAlertSuccessWin(TXT_COMPLETE);       
        MMK_CloseWin(win_id);
        break;      
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    
    return (result);
}
/********************************************************************************
 NAME:          EngContrastWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        allen
 DATE:          2004.09.27
********************************************************************************/
//LOCAL MMI_RESULT_E EngContrastWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
//{
//  GUI_RECT_T rect = {ENG_CLIENT_LEFT, ENG_CLIENT_TOP, ENG_CLIENT_RIGHT, ENG_CLIENT_BOTTOM};
//  uint8 data_buf[20] = {0};
//  MMI_STRING_T text = {0};
//  MMI_RESULT_E result = MMI_RESULT_TRUE;
//  GUI_LCD_DEV_INFO    lcd_dev_info = {GUI_MAIN_LCD_ID, GUI_BLOCK_MAIN};
//      
//  switch (msg_id) 
//  {
//  case MSG_OPEN_WINDOW:
//      LCD_FillRect(&lcd_dev_info, rect, mmi_eng_display.bkgd_color);
//      
//      GUILABEL_SetBackgroundColor(MMIENG_LABEL1_CTRL_ID, mmi_eng_display.bkgd_color);
//      // first get the LCD 's min & max contrast value
//      // at the same time, get the current LCD 's contrast real value(not grade value)
//      #ifndef _WIN32
//      GUIREF_LCDGetInfo(SUB_LCD_ID, &s_mmieng_lcd_info);
//      s_mmieng_contrast_value = MMIAPISET_GetSubLCDContrastValue(SUB_LCD_ID);
//      LCD_SetContrast(SUB_LCD_ID, s_mmieng_contrast_value);
//      //s_mmieng_contrast_value = s_mmieng_lcd_info.contrast_defaut;
//      #else
//      s_mmieng_lcd_info.contrast_min = 0;
//      s_mmieng_lcd_info.contrast_max = 63;
//      s_mmieng_contrast_value = 16;
//      #endif
//      SCI_PASSERT(s_mmieng_lcd_info.contrast_max > s_mmieng_lcd_info.contrast_min, 
//          ("EngContrastWinHandleMsg: s_mmieng_lcd_info.contrast_max is %d,s_mmieng_lcd_info.contrast_min is %d",s_mmieng_lcd_info.contrast_max,s_mmieng_lcd_info.contrast_min));
//      SCI_PASSERT(s_mmieng_contrast_value >= s_mmieng_lcd_info.contrast_min, 
//          ("EngContrastWinHandleMsg: s_mmieng_contrast_value is %d",s_mmieng_contrast_value));
//
//      GUIPRGBOX_SetPosByCtrl(FALSE,
//            s_mmieng_contrast_value - s_mmieng_lcd_info.contrast_min,
//          s_mmieng_contrast_value - s_mmieng_lcd_info.contrast_min,
//            s_mmieng_lcd_info.contrast_max - s_mmieng_lcd_info.contrast_min,
//            MMIENG_PRGBOX_CTRL_ID);
//      break;
//      
//  case MSG_FULL_PAINT:
//              LCD_FillRect(&lcd_dev_info, rect, mmi_eng_display.bkgd_color);
//      SCI_MEMSET((char*)data_buf, 0, 20);
//      sprintf((char*)data_buf, "%d", s_mmieng_contrast_value);
//      text.wstr_ptr = data_buf;
//      text.wstr_len = SCI_STRLEN((char*)data_buf);
//      GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &text, FALSE);
//      GUIWIN_SetSoftkeyTextId(MMIENG_CONTRAST_WIN_ID, (MMI_TEXT_ID_T)TXT_ENG_OK, (MMI_TEXT_ID_T)TXT_NULL, (MMI_TEXT_ID_T)TXT_ENG_RETURN, FALSE);
//      break;
//      
//  case MSG_KEYDOWN_FLIP:      // close flip
//  case MSG_KEYDOWN_RED:
//      MMIAPISET_ResetSubLcdContrast(SUB_LCD_ID);
//      MMK_CloseWin(MMIENG_CONTRAST_WIN_ID);
//      break;
//
//  case MSG_KEYDOWN_OK:
//  case MSG_CTL_OK:
//    case MSG_APP_WEB:
//      break;
//
//    case MSG_KEYDOWN_CANCEL:      
//  case MSG_CTL_CANCEL:
//      //not restore the current contrast value
//      MMIAPISET_ResetSubLcdContrast(SUB_LCD_ID);
//      MMK_CloseWin(MMIENG_CONTRAST_WIN_ID);
//      break;
//  
//  case MSG_KEYDOWN_UP:
//  case MSG_KEYLONG_UP:
//      if (s_mmieng_contrast_value < s_mmieng_lcd_info.contrast_max)
//      {
//          s_mmieng_contrast_value += (s_mmieng_lcd_info.contrast_max - s_mmieng_lcd_info.contrast_min) / 10;
//          if (s_mmieng_contrast_value > s_mmieng_lcd_info.contrast_max)
//              s_mmieng_contrast_value = s_mmieng_lcd_info.contrast_max;
//          sprintf((char*)data_buf, "%d", s_mmieng_contrast_value);
//          text.wstr_ptr = data_buf;
//          text.wstr_len = SCI_STRLEN((char*)data_buf);
//          GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &text, TRUE);
//            GUIPRGBOX_SetPosByCtrl(TRUE,
//                s_mmieng_contrast_value - s_mmieng_lcd_info.contrast_min,
//              s_mmieng_contrast_value - s_mmieng_lcd_info.contrast_min,
//                s_mmieng_lcd_info.contrast_max - s_mmieng_lcd_info.contrast_min,
//                MMIENG_PRGBOX_CTRL_ID);
//      
//          #ifndef  _WIN32
//          LCD_SetContrast(SUB_LCD_ID, s_mmieng_contrast_value);
//          #endif
//      }
//      break;
//      
//  case MSG_KEYDOWN_DOWN:
//  case MSG_KEYLONG_DOWN:
//      if (s_mmieng_contrast_value > s_mmieng_lcd_info.contrast_min)
//      {
//          s_mmieng_contrast_value -= (s_mmieng_lcd_info.contrast_max - s_mmieng_lcd_info.contrast_min) / 10;
//          if (s_mmieng_contrast_value < s_mmieng_lcd_info.contrast_min)
//              s_mmieng_contrast_value = s_mmieng_lcd_info.contrast_min;
//          sprintf((char*)data_buf, "%d", s_mmieng_contrast_value);
//          text.wstr_ptr = data_buf;
//          text.wstr_len = SCI_STRLEN((char*)data_buf);
//          GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &text, TRUE);
//            GUIPRGBOX_SetPosByCtrl(TRUE,
//                s_mmieng_contrast_value - s_mmieng_lcd_info.contrast_min,
//              s_mmieng_contrast_value - s_mmieng_lcd_info.contrast_min,
//                s_mmieng_lcd_info.contrast_max - s_mmieng_lcd_info.contrast_min,
//                MMIENG_PRGBOX_CTRL_ID);
//      
//          #ifndef  _WIN32
//          LCD_SetContrast(SUB_LCD_ID, s_mmieng_contrast_value);
//          #endif
//      }
//      break;
//      
//  case MSG_KEYDOWN_LEFT:
//  case MSG_KEYLONG_LEFT:
//      if (s_mmieng_contrast_value > s_mmieng_lcd_info.contrast_min)
//      {
//          s_mmieng_contrast_value--;
//          sprintf((char*)data_buf, "%d", s_mmieng_contrast_value);
//          text.wstr_ptr = data_buf;
//          text.wstr_len = SCI_STRLEN((char*)data_buf);
//          GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &text, TRUE);
//            GUIPRGBOX_SetPosByCtrl(TRUE,
//                s_mmieng_contrast_value - s_mmieng_lcd_info.contrast_min,
//              s_mmieng_contrast_value - s_mmieng_lcd_info.contrast_min,
//                s_mmieng_lcd_info.contrast_max - s_mmieng_lcd_info.contrast_min,
//                MMIENG_PRGBOX_CTRL_ID);
//          
//          #ifndef  _WIN32
//          LCD_SetContrast(SUB_LCD_ID, s_mmieng_contrast_value);
//          #endif
//      }
//      break;
//      
//  case MSG_KEYDOWN_RIGHT:
//  case MSG_KEYLONG_RIGHT:
//      if (s_mmieng_contrast_value < s_mmieng_lcd_info.contrast_max)
//      {
//          s_mmieng_contrast_value++;
//          sprintf((char*)data_buf, "%d", s_mmieng_contrast_value);
//          text.wstr_ptr = data_buf;
//          text.wstr_len = SCI_STRLEN((char*)data_buf);
//          GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &text, TRUE);
//          GUIPRGBOX_SetPosByCtrl(TRUE,
//                s_mmieng_contrast_value - s_mmieng_lcd_info.contrast_min,
//              s_mmieng_contrast_value - s_mmieng_lcd_info.contrast_min,
//                s_mmieng_lcd_info.contrast_max - s_mmieng_lcd_info.contrast_min,
//                MMIENG_PRGBOX_CTRL_ID);
//      
//          #ifndef  _WIN32
//          LCD_SetContrast(SUB_LCD_ID, s_mmieng_contrast_value);
//          #endif
//      }
//      break;
//      
//  case MSG_CLOSE_WINDOW:
//      SCI_MEMSET(&s_mmieng_lcd_info,0,sizeof(LCD_INFO_T));
//      if(PNULL != s_mmieng_lcd_info.lcdbuff_ptr)
//      {
//          SCI_Free(s_mmieng_lcd_info.lcdbuff_ptr);
//      }
//      
//      break;
//  
//  default:
//      result = MMI_RESULT_FALSE;
//      break;
//  }
//  return (result);
//}

/********************************************************************************
 NAME:          EngBrightnessWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        allen
 DATE:          2004.09.27
********************************************************************************/
LOCAL MMI_RESULT_E EngBrightnessWinHandleMsg(
                                             MMI_WIN_ID_T win_id, 
                                             MMI_MESSAGE_ID_E msg_id,
                                             DPARAM param
                                             )
{
    uint8               data_buf[20]    = {0};
    wchar wstr[20] = {0};
    char* str = PNULL;
    MMI_RESULT_E        result          = MMI_RESULT_TRUE;
    MMI_STRING_T        text            = {0};
    GUI_LCD_DEV_INFO    lcd_dev_info    = {GUI_MAIN_LCD_ID, GUI_BLOCK_MAIN};
    GUI_RECT_T         client_rect            = MMITHEME_GetClientRect();
    GUI_RECT_T          prg_rect =  client_rect;
    GUI_RECT_T          lab_rect = client_rect;
        
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        lab_rect.bottom = ((client_rect.top + client_rect.bottom )>>1) - 1;
        lab_rect.top = lab_rect.bottom - 40;
        prg_rect.top = ((client_rect.top + client_rect.bottom )>>1 )+ 1;
        prg_rect.bottom = prg_rect.top + 30;
        prg_rect.left += 1;
        prg_rect.right -= 1;        
        
         GUILABEL_SetRect(MMIENG_LABEL1_CTRL_ID, &lab_rect, FALSE); 
    GUILABEL_SetBackgroundColor(MMIENG_LABEL1_CTRL_ID,  mmi_eng_display.bkgd_color);
        GUIPRGBOX_SetRect(MMIENG_PRGBOX_CTRL_ID,&prg_rect);
    
        s_mmieng_brightness_value = MMIAPISET_GetRealBacklightValue();
    sprintf((char*)data_buf, "%d", s_mmieng_brightness_value);
            
            str = (char*)data_buf;
            text.wstr_len = strlen(str);
            text.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, 20, (uint8*)str, text.wstr_len, text.wstr_len );

        GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &text, FALSE);          
        GUIPRGBOX_SetParamByCtrl(MMIENG_PRGBOX_CTRL_ID, s_mmieng_save_brightness_value - 1, s_mmieng_save_brightness_value - 1);
            GUIPRGBOX_SetPosByCtrl(FALSE,s_mmieng_brightness_value - 1,s_mmieng_brightness_value - 1,MMIENG_PRGBOX_CTRL_ID);
            
        #ifndef WIN32
        LCD_SetBackLightBrightness(s_mmieng_brightness_value);
        #endif
        break;

    case MSG_LCD_SWITCH:
        lab_rect.bottom = ((client_rect.top + client_rect.bottom )>>1) - 1;
        lab_rect.top = lab_rect.bottom - 40;
        prg_rect.top = ((client_rect.top + client_rect.bottom )>>1 )+ 1;
        prg_rect.bottom = prg_rect.top + 30;
        prg_rect.left += 1;
        prg_rect.right -= 1;        
        
         GUILABEL_SetRect(MMIENG_LABEL1_CTRL_ID, &lab_rect, FALSE);       
        GUIPRGBOX_SetRect(MMIENG_PRGBOX_CTRL_ID,&prg_rect);
        break;
        
    case MSG_FULL_PAINT:
        LCD_FillRect(&lcd_dev_info, client_rect, mmi_eng_display.bkgd_color);
/*      SCI_MEMSET((char*)data_buf, 0, 20);
        sprintf((char*)data_buf, "%d", s_mmieng_brightness_value);


        str = (char*)data_buf;
        text.wstr_len = strlen(str);
        text.wstr_ptr = wstr;
        MMI_STRNTOWSTR( wstr, 20, str, text.wstr_len, text.wstr_len );

        GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &text, FALSE);
        GUIWIN_SetSoftkeyTextId(win_id,  (MMI_TEXT_ID_T)TXT_ENG_OK, (MMI_TEXT_ID_T)TXT_NULL, (MMI_TEXT_ID_T)TXT_ENG_RETURN, FALSE);
    */  
        break;

    case MSG_CLOSE_WINDOW:
        MMIAPISET_ResetContrast(MAIN_LCD_ID);
        break;          
    
    case MSG_CTL_MIDSK:
    case MSG_KEYDOWN_OK:        
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        MMK_CloseWin(win_id);
        break;

    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMIAPISET_ResetContrast(MAIN_LCD_ID);
        MMK_CloseWin(win_id);
        break;

    case MSG_LOSE_FOCUS:
        MMIAPISET_ResetContrast(MAIN_LCD_ID);
        break;

    case MSG_GET_FOCUS:     
         GUIPRGBOX_SetPosByCtrl(FALSE,s_mmieng_brightness_value - 1,s_mmieng_brightness_value - 1,MMIENG_PRGBOX_CTRL_ID);
        
#ifndef  _WIN32
            LCD_SetBackLightBrightness(s_mmieng_brightness_value);
#endif
        break;

#ifdef MMI_PDA_SUPPORT
    case MSG_KEYDOWN_UPSIDE:
    case MSG_KEYDOWN_DOWNSIDE:
    case MSG_KEYPRESSUP_DOWNSIDE:
    case MSG_KEYPRESSUP_UPSIDE:
    case MSG_KEYREPEAT_UPSIDE:
    case MSG_KEYREPEAT_DOWNSIDE:
        break;
    case MSG_KEYLONG_DOWNSIDE:
#else
    case MSG_KEYDOWN_DOWN:
#endif
        if (s_mmieng_brightness_value - 10 > 0)
        {
            s_mmieng_brightness_value -= 10;
        }
        else
        {
            s_mmieng_brightness_value = 1;
        }
        {
            sprintf((char*)data_buf, "%d", s_mmieng_brightness_value);
            
            str = (char*)data_buf;
            text.wstr_len = strlen(str);
            text.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, 20, (uint8*)str, text.wstr_len, text.wstr_len );

        GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &text, TRUE);
            GUIPRGBOX_SetPosByCtrl(TRUE,s_mmieng_brightness_value - 1,s_mmieng_brightness_value - 1,MMIENG_PRGBOX_CTRL_ID);
        
            #ifndef  _WIN32
            LCD_SetBackLightBrightness(s_mmieng_brightness_value);
            #endif
        }
        MMK_SendMsg(win_id, MSG_FULL_PAINT, PNULL);
        break;

#ifdef MMI_PDA_SUPPORT
    case MSG_KEYLONG_UPSIDE:
#else
    case MSG_KEYDOWN_UP:
#endif
        if (s_mmieng_brightness_value + 10 <= s_mmieng_save_brightness_value)
        {
            s_mmieng_brightness_value +=10;
        }
        else
        {
            s_mmieng_brightness_value=s_mmieng_save_brightness_value;
        }

        {   
            sprintf((char*)data_buf, "%d", s_mmieng_brightness_value);

            str = (char*)data_buf;
            text.wstr_len = strlen(str);
            text.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, 20, (uint8*)str, text.wstr_len, text.wstr_len );

            GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &text, TRUE);
            GUIPRGBOX_SetPosByCtrl(TRUE,s_mmieng_brightness_value - 1,s_mmieng_brightness_value - 1,MMIENG_PRGBOX_CTRL_ID);
        
            #ifndef  _WIN32             
            LCD_SetBackLightBrightness(s_mmieng_brightness_value);
            #endif
        }
        MMK_SendMsg(win_id, MSG_FULL_PAINT, PNULL);
        break;

#ifdef MMI_PDA_SUPPORT
    case MSG_KEYUP_DOWNSIDE:
#else
    case MSG_KEYDOWN_LEFT:
#endif
        if (s_mmieng_brightness_value > 1)
        {
            s_mmieng_brightness_value--;
            
            sprintf((char*)data_buf, "%d", s_mmieng_brightness_value);
            
            str = (char*)data_buf;
            text.wstr_len = strlen(str);
            text.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, 20, (uint8*)str, text.wstr_len, text.wstr_len );

            GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &text, TRUE);
            GUIPRGBOX_SetPosByCtrl(TRUE,s_mmieng_brightness_value - 1,s_mmieng_brightness_value - 1,MMIENG_PRGBOX_CTRL_ID);
        
            #ifndef  _WIN32             
            LCD_SetBackLightBrightness(s_mmieng_brightness_value);
            #endif
        }
        MMK_SendMsg(win_id, MSG_FULL_PAINT, PNULL);
        break;

#ifdef MMI_PDA_SUPPORT
    case MSG_KEYUP_UPSIDE:
#else
    case MSG_KEYDOWN_RIGHT:
#endif
        if (s_mmieng_brightness_value < s_mmieng_save_brightness_value)
        {
            s_mmieng_brightness_value++;
            
            sprintf((char*)data_buf, "%d", s_mmieng_brightness_value);
            
            str = (char*)data_buf;
            text.wstr_len = strlen(str);
            text.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, 20, (uint8*)str, text.wstr_len, text.wstr_len );

            GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &text, TRUE);
            GUIPRGBOX_SetPosByCtrl(TRUE,s_mmieng_brightness_value - 1,s_mmieng_brightness_value - 1,MMIENG_PRGBOX_CTRL_ID);
        
            #ifndef  _WIN32
            LCD_SetBackLightBrightness(s_mmieng_brightness_value);
            #endif
        }
        MMK_SendMsg(win_id, MSG_FULL_PAINT, PNULL);
        break;
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }

    return (result);
}

/********************************************************************************
 NAME:          ShowSetAudioParamResult
 DESCRIPTION:   
 PARAM IN:      result - 
 PARAM OUT:     None
 AUTHOR:        allen
 DATE:          2004.11.08
********************************************************************************/
LOCAL void ShowSetAudioParamResult(BOOLEAN result)
{
    MMI_STRING_T text1 = {0}; 
    MMI_STRING_T text2 = {0}; 
    MMI_STRING_T text3 = {0}; 
    
    text1.wstr_ptr = s_set_wstr; /*lint !e605*/ //"Set";
    text1.wstr_len = 3;
    text2.wstr_ptr = s_audio_param_wstr;/*lint !e605*/ //"audio param";
    text2.wstr_len = 11;
    if (result)
    {
        text3.wstr_ptr = s_success_wstr;/*lint !e605*/ //"success";
        text3.wstr_len = 7;
    }
    else
    {
        text3.wstr_ptr = s_fail_wstr;/*lint !e605*/ //"fail";
        text3.wstr_len = 4;
    }
    MMIEng_SetResultWinText(text1, text2, text3);
    MMK_CreateWin((uint32*)MMIENG_SHOW3RESULT_WIN_TAB, PNULL);
}

/********************************************************************************
 NAME:          EngSidetoneWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        allen
 DATE:          2004.09.27
********************************************************************************/
LOCAL MMI_RESULT_E EngSidetoneWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{   
    MMI_STRING_T side_tone = {PNULL, 0};
#ifndef _WIN32
    AUDIO_TEST_DATA_T   audio_data = {0};
#endif
    MMI_RESULT_E result = MMI_RESULT_TRUE;  
        
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        // set window 's title
        switch (g_mmieng_voice_param)
        {
            case MMI_HANDHOLD_SIDETONE_GAIN:
                s_mmieng_audio_dev_mode = AUDIO_DEVICE_MODE_HANDHOLD;
                GUIWIN_SetTitleTextId(MMIENG_SIDETONE_WIN_ID, (MMI_TEXT_ID_T)TXT_ENG_HDSTSDTONE, FALSE);
                break;
                
            case MMI_EARPHONE_SIDETONE_GAIN:
                s_mmieng_audio_dev_mode = AUDIO_DEVICE_MODE_EARPHONE;
                GUIWIN_SetTitleTextId(MMIENG_SIDETONE_WIN_ID, (MMI_TEXT_ID_T)TXT_ENG_EARPHSDTONE, FALSE);
                break;

            default:
                break;
        }
        //rect.bottom = rect.top + 40;
        //GUIEDIT_SetStyle(MMIENG_EDITBOX1_CTRL_ID, GUIEDIT_STYLE_SINGLE);
        //GUIEDIT_SetRect(MMK_ConvertIdToHandle(MMIENG_EDITBOX1_CTRL_ID),  &rect);      
        GUIEDIT_SetSoftkey(MMIENG_EDITBOX1_CTRL_ID, 0, 1, TXT_NULL, TXT_ENG_OK, PNULL);

        //Bug 1916792
        GUIEDIT_SetStyle(MMIENG_EDITBOX1_CTRL_ID, GUIEDIT_STYLE_SINGLE);
        GUIEDIT_SetAlign(MMIENG_EDITBOX1_CTRL_ID, ALIGN_HVMIDDLE);
        GUIEDIT_SetIm(MMIENG_EDITBOX1_CTRL_ID,GUIIM_TYPE_SYS,GUIIM_TYPE_SYS);

        MMK_SetAtvCtrl(MMIENG_SIDETONE_WIN_ID, MMIENG_EDITBOX1_CTRL_ID);
        break;
/*
    case MSG_LCD_SWITCH:
        rect.bottom = rect.top + 40;
        GUIEDIT_SetRect(MMK_ConvertIdToHandle(MMIENG_EDITBOX1_CTRL_ID),  &rect);
        break;
    */  
    case MSG_FULL_PAINT:
     //   {
     //       GUI_RECT_T rect = MMITHEME_GetClientRect();     
     //       GUI_LCD_DEV_INFO    lcd_dev_info = {GUI_MAIN_LCD_ID, GUI_BLOCK_MAIN};
   //         LCD_FillRect(&lcd_dev_info, rect, MMI_WINDOW_BACKGROUND_COLOR);
   //    }
        //GUIWIN_SetSoftkeyTextId(MMIENG_SIDETONE_WIN_ID,  (MMI_TEXT_ID_T)TXT_ENG_OK, (MMI_TEXT_ID_T)TXT_NULL, (MMI_TEXT_ID_T)TXT_ENG_RETURN, FALSE);
        break;
    
    case MSG_APP_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(MMIENG_SIDETONE_WIN_ID);
        break;

#ifdef MMI_PDA_SUPPORT

#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
        if (PNULL != param)
        {
            uint32 src_id = ((MMI_NOTIFY_T*)param)->src_id;
            
            switch (src_id)
            {
            case MMICOMMON_BUTTON_SOFTKEY_LEFT_CTRL_ID:
                MMK_SendMsg(win_id,MSG_APP_OK, PNULL);

                break;
            case MMICOMMON_BUTTON_SOFTKEY_MIDDLE_CTRL_ID:
                break;
            case MMICOMMON_BUTTON_SOFTKEY_RIGHT_CTRL_ID:
                MMK_SendMsg(win_id,MSG_APP_CANCEL, PNULL);
                break;           
            default:
                break;
            }
        }
        break;
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527        
#else        
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
#endif
    case MSG_CTL_MIDSK: 
    case MSG_APP_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        GUIEDIT_GetString(MMIENG_EDITBOX1_CTRL_ID, &side_tone);
        if (side_tone.wstr_len > 0)
        {
            #ifndef WIN32
            if (AUDIO_NO_ERROR == AUD_GetEngineeringParameter(s_mmieng_audio_dev_mode, &audio_data))
            {
                audio_data.digital_sidetone_gain = atoi((char*)side_tone.wstr_ptr);/*lint !e63*/

                AUD_SetEngineeringParameter(s_mmieng_audio_dev_mode, audio_data);
            }
            else
            {
                ShowSetAudioParamResult(FALSE);
            }
            #endif
            MMK_CloseWin(MMIENG_SIDETONE_WIN_ID);
        }
        //else
        //{
        //  MMK_SetAtvCtrl(MMIENG_SIDETONE_WIN_ID, MMIENG_EDITBOX1_CTRL_ID);
        //}
        break;

    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

/********************************************************************************
 NAME:          EngVoiceParamWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        allen
 DATE:          2004.09.27
********************************************************************************/
LOCAL MMI_RESULT_E EngVoiceParamWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_STRING_T text = {0};
    wchar wstr[30] = {0};
    char temp_str[30] = {0};
    char* str = PNULL;
    uint16 length= 30;
    MMI_STRING_T up_link = {PNULL, 0};
    MMI_STRING_T down_link = {PNULL, 0};
#ifndef _WIN32
     AUDIO_TEST_DATA_T audio_data = {0};
#endif
    MMI_RESULT_E result = MMI_RESULT_TRUE;
 
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        GUIFORM_SetStyle(MMIENG_FORM1_CTRL_ID,GUIFORM_STYLE_UNIT);
        GUIFORM_SetStyle(MMIENG_FORM2_CTRL_ID,GUIFORM_STYLE_UNIT);
        GUIFORM_SetType(MMIENG_FORM_CTRL_ID, GUIFORM_TYPE_TP);
		
        str = "Uplink:";
        text.wstr_len = strlen(str);
        text.wstr_ptr = wstr;
        MMI_STRNTOWSTR( wstr, 30, (uint8*)str, text.wstr_len, text.wstr_len );

        GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &text, FALSE);

        str = "Downlink:";
        text.wstr_len = strlen(str);
        text.wstr_ptr = wstr;
        MMI_STRNTOWSTR( wstr, 30, (uint8*)str, text.wstr_len, text.wstr_len );

        GUILABEL_SetText(MMIENG_LABEL2_CTRL_ID, &text, FALSE);
        // set window 's title
        switch (g_mmieng_voice_param)
        {
            case MMI_HANDHOLD_DIGITAL_GAIN:
                s_mmieng_audio_dev_mode = AUDIO_DEVICE_MODE_HANDHOLD;
                GUIWIN_SetTitleTextId(MMIENG_VOICEPARAM_WIN_ID, (MMI_TEXT_ID_T)TXT_ENG_HDSTDGT, FALSE);
                break;
                
            case MMI_HANDFREE_DIGITAL_GAIN:
                s_mmieng_audio_dev_mode = AUDIO_DEVICE_MODE_HANDFREE;
                GUIWIN_SetTitleTextId(MMIENG_VOICEPARAM_WIN_ID, (MMI_TEXT_ID_T)TXT_ENG_HDFREDGT, FALSE);
                break;
                
            case MMI_EARPHONE_DIGITAL_GAIN:
                s_mmieng_audio_dev_mode = AUDIO_DEVICE_MODE_EARPHONE;
                GUIWIN_SetTitleTextId(MMIENG_VOICEPARAM_WIN_ID, (MMI_TEXT_ID_T)TXT_ENG_EARPHDGT, FALSE);
                break;
                
            case MMI_HANDHOLD_PGA_GAIN:
                s_mmieng_audio_dev_mode = AUDIO_DEVICE_MODE_HANDHOLD;
                GUIWIN_SetTitleTextId(MMIENG_VOICEPARAM_WIN_ID, (MMI_TEXT_ID_T)TXT_ENG_HDSTPGA, FALSE);
                break;
                
            case MMI_HANDFREE_PGA_GAIN:
                s_mmieng_audio_dev_mode = AUDIO_DEVICE_MODE_HANDFREE;
                GUIWIN_SetTitleTextId(MMIENG_VOICEPARAM_WIN_ID, (MMI_TEXT_ID_T)TXT_ENG_HDFREPGA, FALSE);
                break;
            
            case MMI_EARPHONE_PGA_GAIN:
                s_mmieng_audio_dev_mode = AUDIO_DEVICE_MODE_EARPHONE;
                GUIWIN_SetTitleTextId(MMIENG_VOICEPARAM_WIN_ID, (MMI_TEXT_ID_T)TXT_ENG_EARPHPGA, FALSE);
                break;
                
            case MMI_HANDHOLD_DIGITAL_SCALE:
                s_mmieng_audio_dev_mode = AUDIO_DEVICE_MODE_HANDHOLD;
                GUIWIN_SetTitleTextId(MMIENG_VOICEPARAM_WIN_ID, (MMI_TEXT_ID_T)TXT_ENG_HDSTSCL, FALSE);
                break;
                
            case MMI_HANDFREE_DIGITAL_SCALE:
                s_mmieng_audio_dev_mode = AUDIO_DEVICE_MODE_HANDFREE;
                GUIWIN_SetTitleTextId(MMIENG_VOICEPARAM_WIN_ID, (MMI_TEXT_ID_T)TXT_ENG_HDFRESCL, FALSE);
                break;
                
            case MMI_EARPHONE_DIGITAL_SCALE:
                s_mmieng_audio_dev_mode = AUDIO_DEVICE_MODE_EARPHONE;
                GUIWIN_SetTitleTextId(MMIENG_VOICEPARAM_WIN_ID, (MMI_TEXT_ID_T)TXT_ENG_EARPHSCL, FALSE);
                break;
                
            default:
                break;
        }
        GUIEDIT_SetStyle(MMIENG_EDITBOX1_CTRL_ID, GUIEDIT_STYLE_SINGLE);
        GUIEDIT_SetSoftkey(MMIENG_EDITBOX1_CTRL_ID,2,1,TXT_ENG_RETURN,TXT_ENG_CLEAR,PNULL);
        GUIEDIT_SetStyle(MMIENG_EDITBOX2_CTRL_ID, GUIEDIT_STYLE_SINGLE);
        GUIEDIT_SetSoftkey(MMIENG_EDITBOX2_CTRL_ID,2,1,TXT_ENG_RETURN,TXT_ENG_CLEAR,PNULL);
        MMK_SetAtvCtrl(MMIENG_VOICEPARAM_WIN_ID, MMIENG_EDITBOX1_CTRL_ID);
 #ifndef WIN32       
        // first input the up link
        s_mmieng_up_down_link = 0;

        if (AUDIO_NO_ERROR != AUD_GetEngineeringParameter(s_mmieng_audio_dev_mode, &audio_data))
        {
            //error
            ShowSetAudioParamResult(FALSE);
        }

        else
        {
            audio_data.UL_digital_gain = 101;
            audio_data.DL_digital_gain = 102;
            audio_data.UL_PGA_gain = 201;
            audio_data.DL_PGA_gain = 202;
            audio_data.UL_digital_scale = 301;
            audio_data.DL_digital_scale = 302;
         }
#endif
        switch (g_mmieng_voice_param)
        {
        case MMI_HANDHOLD_DIGITAL_GAIN:
        case MMI_HANDFREE_DIGITAL_GAIN:
        case MMI_EARPHONE_DIGITAL_GAIN:
#ifndef _WIN32
            SCI_MEMSET(temp_str, 0 , length);                
            SCI_MEMSET(wstr, 0 , length*2);
            length = sprintf(temp_str, "%d", audio_data.UL_digital_gain);
            MMI_STRNTOWSTR(wstr, 30, (uint8*)temp_str, length, length);
            GUIEDIT_SetString(MMIENG_EDITBOX1_CTRL_ID, wstr,length);
            
            SCI_MEMSET(temp_str, 0 , length);
            SCI_MEMSET(wstr, 0 , length*2);
            length = sprintf(temp_str, "%d", audio_data.DL_digital_gain);
            MMI_STRNTOWSTR(wstr, 30, (uint8*)temp_str, length, length);
            GUIEDIT_SetString(MMIENG_EDITBOX2_CTRL_ID, wstr,length);
#endif
            break;
            
            
        case MMI_HANDHOLD_PGA_GAIN:
        case MMI_HANDFREE_PGA_GAIN:
        case MMI_EARPHONE_PGA_GAIN:
#ifndef _WIN32
            SCI_MEMSET(temp_str, 0 , length);                
            SCI_MEMSET(wstr, 0 , length*2);
            length = sprintf(temp_str, "%d", audio_data.UL_PGA_gain);
            MMI_STRNTOWSTR(wstr, 30, (uint8*)temp_str, length, length);
            GUIEDIT_SetString(MMIENG_EDITBOX1_CTRL_ID, wstr,length);
            
            SCI_MEMSET(temp_str, 0 , length);
            SCI_MEMSET(wstr, 0 , length*2);
            length = sprintf(temp_str, "%d", audio_data.DL_PGA_gain);
            MMI_STRNTOWSTR(wstr, 30, (uint8*)temp_str, length, length);
            GUIEDIT_SetString(MMIENG_EDITBOX2_CTRL_ID, wstr,length);
#endif
            break;
            
        case MMI_HANDHOLD_DIGITAL_SCALE:
        case MMI_HANDFREE_DIGITAL_SCALE:
        case MMI_EARPHONE_DIGITAL_SCALE:   
#ifndef _WIN32            
            SCI_MEMSET(temp_str, 0 , length);                
            SCI_MEMSET(wstr, 0 , length*2);
            length = sprintf(temp_str, "%d", audio_data.UL_digital_scale);
            MMI_STRNTOWSTR(wstr, 30, (uint8*)temp_str, length, length);
            GUIEDIT_SetString(MMIENG_EDITBOX1_CTRL_ID, wstr,length);
            
            SCI_MEMSET(temp_str, 0 , length);
            SCI_MEMSET(wstr, 0 , length*2);
            length = sprintf(temp_str, "%d", audio_data.DL_digital_scale);
            MMI_STRNTOWSTR(wstr, 30, (uint8*)temp_str, length, length);
            GUIEDIT_SetString(MMIENG_EDITBOX2_CTRL_ID, wstr,length);
#endif
            break;
            
            
        default:
            break;
        }
        
        break;  

    /*      
    case MSG_FULL_PAINT:
        LCD_FillRect(&lcd_dev_info, client_rect, mmi_eng_display.bkgd_color);
        GUIWIN_SetSoftkeyTextId(MMIENG_VOICEPARAM_WIN_ID,  (MMI_TEXT_ID_T)TXT_ENG_OK, (MMI_TEXT_ID_T)TXT_NULL, (MMI_TEXT_ID_T)TXT_ENG_RETURN, FALSE);
        break;
*/

    case MSG_APP_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(MMIENG_VOICEPARAM_WIN_ID);
        break;

#ifdef MMI_PDA_SUPPORT
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
        if (PNULL != param)
        {
            uint32 src_id = ((MMI_NOTIFY_T*)param)->src_id;
            
            switch (src_id)
            {
            case MMICOMMON_BUTTON_SOFTKEY_LEFT_CTRL_ID:
                MMK_SendMsg(win_id,MSG_APP_OK, PNULL);

                break;
            case MMICOMMON_BUTTON_SOFTKEY_MIDDLE_CTRL_ID:
                break;
            case MMICOMMON_BUTTON_SOFTKEY_RIGHT_CTRL_ID:
                MMK_SendMsg(win_id,MSG_APP_CANCEL, PNULL);
                break;           
            default:
                break;
            }
        }
        break;
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527        
#else        
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
#endif
    case MSG_CTL_MIDSK:
    case MSG_APP_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        GUIEDIT_GetString(MMIENG_EDITBOX1_CTRL_ID, &up_link);
        GUIEDIT_GetString(MMIENG_EDITBOX2_CTRL_ID, &down_link);
        if (0 == up_link.wstr_len)
        {
            //MMK_SetAtvCtrl(MMIENG_VOICEPARAM_WIN_ID, MMIENG_EDITBOX1_CTRL_ID);
            s_mmieng_up_down_link = 0;
            MMK_PostMsg(win_id, MSG_FULL_PAINT, NULL, 0);
        }
        else if (0 == down_link.wstr_len)
        {
            //MMK_SetAtvCtrl(MMIENG_VOICEPARAM_WIN_ID, MMIENG_EDITBOX2_CTRL_ID);
            s_mmieng_up_down_link = 1;
            MMK_PostMsg(win_id, MSG_FULL_PAINT, NULL, 0);
        }
        else
        {
#ifndef _WIN32
                switch (g_mmieng_voice_param)
                {
                    case MMI_HANDHOLD_DIGITAL_GAIN:
                    case MMI_HANDFREE_DIGITAL_GAIN:
                    case MMI_EARPHONE_DIGITAL_GAIN:
                        audio_data.UL_digital_gain = atoi((char*)up_link.wstr_ptr);
                        audio_data.DL_digital_gain = atoi((char*)down_link.wstr_ptr);
                        break;


                    case MMI_HANDHOLD_PGA_GAIN:
                    case MMI_HANDFREE_PGA_GAIN:
                    case MMI_EARPHONE_PGA_GAIN:
                        audio_data.UL_PGA_gain = atoi((char*)up_link.wstr_ptr);
                        audio_data.DL_PGA_gain = atoi((char*)down_link.wstr_ptr);
                        break;

                    case MMI_HANDHOLD_DIGITAL_SCALE:
                    case MMI_HANDFREE_DIGITAL_SCALE:
                    case MMI_EARPHONE_DIGITAL_SCALE:
                        audio_data.UL_digital_scale = atoi((char*)up_link.wstr_ptr);
                        audio_data.DL_digital_scale = atoi((char*)down_link.wstr_ptr);
                        break;

                        
                    default:
                        break;
                }
                if(AUDIO_NO_ERROR != AUD_SetEngineeringParameter(s_mmieng_audio_dev_mode, audio_data)) 
                {            //error
                     ShowSetAudioParamResult(FALSE);
                }
                else
                {
                    MMK_CloseWin(MMIENG_VOICEPARAM_WIN_ID);      
                }
#endif
          }
        break;
        
    case MSG_KEYDOWN_UP:
    case MSG_KEYDOWN_DOWN:
        if (0 == s_mmieng_up_down_link)
        {
            MMK_SetAtvCtrl(MMIENG_VOICEPARAM_WIN_ID, MMIENG_EDITBOX2_CTRL_ID);
            s_mmieng_up_down_link = 1;
        }
        else
        {
            MMK_SetAtvCtrl(MMIENG_VOICEPARAM_WIN_ID, MMIENG_EDITBOX1_CTRL_ID);
            s_mmieng_up_down_link = 0;
        }
        MMK_PostMsg(win_id, MSG_FULL_PAINT, NULL, 0);
        break;
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

/********************************************************************************
 NAME:          GetProductionSNStr
 DESCRIPTION:   
 PARAM IN:      pd_buf - 
                buf_len - 
 PARAM OUT:     production info string len
 AUTHOR:        allen
 DATE:          2004.10.04
********************************************************************************/
LOCAL int32 GetProductionSNStr(uint8* pd_buf, uint8 buf_len, 
                        const PRODUCTION_TEST_INFO_T *s_mmieng_product )
{
    int len1 = 0;
    int offset = 0;
  
    if(PNULL == pd_buf)
    {
        //SCI_TRACE_LOW:"mmieng_win.c GetProductionSNStr pd_buf == null"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_7674_112_2_18_2_17_56_153,(uint8*)"");
        return -1;
    }    
    //SCI_TRACE_LOW:"mmieng_win.c GetProductionSNStr buf_len is %d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_7677_112_2_18_2_17_56_154,(uint8*)"d",buf_len);
    if(2 > buf_len)
    {
        return -2;
    }
    
    ////////////////
    //  S/N
    ////////////////
    MMI_MEMCPY(pd_buf + offset, buf_len - offset, "<S/N>", 5, 5);
    offset += 5;
    pd_buf[offset] = CR_CHAR;
    offset += 1;
    len1 = SCI_STRLEN(s_mmieng_product->serial_num);
     MMI_MEMCPY(pd_buf + offset, buf_len - offset, s_mmieng_product->serial_num, 32, len1);
    offset += len1;
    pd_buf[offset] = CR_CHAR;
    offset += 1;

    return (offset);
}



/********************************************************************************
 NAME:          GetProductionInfoStr
 DESCRIPTION:   
 PARAM IN:      pd_buf - 
                buf_len - 
 PARAM OUT:     production info string len
 AUTHOR:        allen
 DATE:          2004.10.04
********************************************************************************/
/*
LOCAL int GetProductionInfoStr(uint8* pd_buf, uint8 buf_len)
{
    uint16 i = 0;
    int len1 = 0;
    int offset = 0;
    
    SCI_ASSERT(pd_buf != PNULL);
    SCI_PASSERT(buf_len >= 2, ("GetProductionInfoStr: buf_len is %d",buf_len));
        
    ////////////////
    //  S/N
    ////////////////
    MMI_MEMCPY(pd_buf + offset, buf_len - offset, "<S/N>", 5, 5);
    offset += 5;
    pd_buf[offset] = CR_CHAR;
    offset += 1;
    len1 = SCI_STRLEN(s_mmieng_product.serial_num);
    MMI_MEMCPY(pd_buf + offset, buf_len - offset, s_mmieng_product.serial_num, 32, len1);
    offset += len1;
    pd_buf[offset] = CR_CHAR;
    offset += 1;
    ////////////////////////////
    //  station test result
    ////////////////////////////
    MMI_MEMCPY(pd_buf + offset, buf_len - offset, "<Station Result>", 16, 16);
    offset += 16;
    for (i = 0; i < s_mmieng_product.total_item_num; i++)
    {
        pd_buf[offset] = CR_CHAR;
        offset += 1;
        /////
        len1 = SCI_STRLEN(s_mmieng_product.item_info[i].item_name);
        MMI_MEMCPY(pd_buf + offset, buf_len - offset, s_mmieng_product.item_info[i].item_name, 20, len1);
        offset += len1;
        MMI_MEMCPY(pd_buf + offset, buf_len - offset, ": ", 2, 2);
        offset += 2;
        if (PRODUCTION_TEST_SUCCESS == s_mmieng_product.item_info[i].error_code)
        {
            MMI_MEMCPY(pd_buf + offset, buf_len - offset, "Passed", 6, 6);
            offset += 6;
        }
        else if (PRODUCTION_TEST_NOT_DONE == s_mmieng_product.item_info[i].error_code)
        {
            MMI_MEMCPY(pd_buf + offset, buf_len - offset, "No test", 7, 7);
            offset += 7;
        }
        else
        {
            MMI_MEMCPY(pd_buf + offset, buf_len - offset, "Fail", 4, 4);
            offset += 4;
        }
    }
    return (offset);
}
*/


/********************************************************************************
 NAME:          EngProductSNWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        allen
 DATE:          2004.09.27
********************************************************************************/
LOCAL MMI_RESULT_E EngProductSNWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
#ifndef _WIN32
     uint8 text_buf[151] = {0};
	 wchar wstr[151] = {0};
	 uint8* str = PNULL;
#endif   
    MMI_STRING_T text1 = {0}; 
    MMI_STRING_T text2 = {0}; 
    MMI_STRING_T text3 = {0}; 
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    //GUI_LCD_DEV_INFO  lcd_dev_info = {GUI_MAIN_LCD_ID, GUI_BLOCK_MAIN};
        
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        {
#ifndef _WIN32
             PRODUCTION_TEST_INFO_T s_mmieng_product = {0};
             
        if (SCI_SUCCESS == SCI_GetProductionTestInfo(&s_mmieng_product))
        {
#ifndef _WIN32
            text1.wstr_len = GetProductionSNStr(text_buf, 150,&s_mmieng_product);
#else
            text1.wstr_len = 0;
#endif
            str = text_buf;
            text1.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, 150, (uint8*)str, text1.wstr_len, text1.wstr_len );

            GUITEXT_SetString(MMIENG_TEXTBOX1_CTRL_ID, text1.wstr_ptr, text1.wstr_len, FALSE);
        }
        else
#endif
        {
            MMK_CloseWin(MMIENG_PRODUCT_WIN_ID);
            text1.wstr_ptr = s_fail_to_wstr;   /*lint !e605*/     //"Fail to";
            text1.wstr_len = 7;
            text2.wstr_ptr = s_get_production_wstr; /*lint !e605*/ //"get production";
            text2.wstr_len = 14;
            MMIEng_SetResultWinText(text1, text2, text3);
            MMK_CreateWin((uint32*)MMIENG_SHOW3RESULT_WIN_TAB, PNULL);
        }
      }  
        MMK_SetAtvCtrl(MMIENG_PRODUCT_WIN_ID, MMIENG_TEXTBOX1_CTRL_ID);
        break;        

    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(MMIENG_PRODUCT_WIN_ID);
        break;

    case MSG_CTL_MIDSK:
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        MMK_CloseWin(MMIENG_PRODUCT_WIN_ID);
        break;
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

/********************************************************************************
 NAME:          EngProductWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        allen
 DATE:          2004.09.27
********************************************************************************/
LOCAL MMI_RESULT_E EngProductWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    const int32 buffer_size = 1024 ;
    uint8 text_buf[1025] = {0};
    wchar wstr[1025] = {0};     
    int32 str_length = 1024 ;
    MMI_RESULT_E result = MMI_RESULT_TRUE; 
    GUI_LCD_DEV_INFO  lcd_dev_info = {GUI_MAIN_LCD_ID, GUI_BLOCK_MAIN};
    
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        LCD_FillRect(&lcd_dev_info, MMITHEME_GetClientRect(), mmi_eng_display.bkgd_color);
        str_length = GetProductionInfoStr((char*)text_buf, buffer_size);      
        MMI_STRNTOWSTR(wstr, buffer_size, text_buf, buffer_size, str_length);        
        GUITEXT_SetString(MMIENG_TEXTBOX1_CTRL_ID , wstr , (uint16)str_length, FALSE);       
        MMK_SetAtvCtrl(MMIENG_PRODUCT_WIN_ID, MMIENG_TEXTBOX1_CTRL_ID);
        break;

    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(MMIENG_PRODUCT_WIN_ID);
        break;

    case MSG_CTL_MIDSK:
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        MMK_CloseWin(MMIENG_PRODUCT_WIN_ID);
        break;
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

/********************************************************************************
 NAME:          ShowSetPowerKeyResult
 DESCRIPTION:   
 PARAM IN:      result -- 
 PARAM OUT:     None
 AUTHOR:        allen
 DATE:          2004.09.27
********************************************************************************/
LOCAL void ShowSetPowerKeyResult(BOOLEAN result)
{
    MMI_STRING_T text1 = {0}; 
    MMI_STRING_T text2 = {0}; 
    MMI_STRING_T text3 = {0}; 
    
    text1.wstr_ptr = s_long_press_wstr;     /*lint !e605*///"long press";
    text1.wstr_len = 10;
    text2.wstr_ptr = s_red_key_will_wstr;   /*lint !e605*///"red key will";
    text2.wstr_len = 12;
    if (result)
    {
        text3.wstr_ptr = s_power_off_wstr;  /*lint !e605*///"power off";
        text3.wstr_len = 9;
    }
    else
    {
        text3.wstr_ptr = s_do_nothing_wstr; /*lint !e605*///"do nothing";
        text3.wstr_len = 10;
    }
    MMIEng_SetResultWinText(text1, text2, text3);
    MMK_CreateWin((uint32*)MMIENG_SHOW3RESULT_WIN_TAB, PNULL);
}

/********************************************************************************
 NAME:          AppendPowerKeyItem
 DESCRIPTION:   
 PARAM IN:      list_id - 
 PARAM OUT:     None
 AUTHOR:        allen
 DATE:          2004.10.11
********************************************************************************/
LOCAL void AppendPowerKeyItem(MMI_CTRL_ID_T list_id)
{
    GUILIST_ITEM_T      item_t = {0};/*lint !e64*/
    GUILIST_ITEM_DATA_T item_data = {0};/*lint !e64*/
    
    GUILIST_SetMaxItem( list_id, 2, FALSE );//max item 2
    GUILIST_SetOwnSofterKey(list_id,TRUE);

    item_t.item_style    = GUIITEM_STYLE_1RADIO_ENG;
    item_t.item_data_ptr = &item_data;
    
    item_data.item_content[0].item_data_type    = GUIITEM_DATA_TEXT_ID;
    item_data.item_content[0].item_data.text_id = TXT_ENG_YES;
    
    //set softkey
    item_data.softkey_id[0] = (MMI_TEXT_ID_T)TXT_ENG_OK;
    //item_data.softkey_id[1] = (MMI_TEXT_ID_T)TXT_NULL;
    item_data.softkey_id[2] = (MMI_TEXT_ID_T)TXT_ENG_RETURN;
    
    GUILIST_AppendItem( list_id, &item_t );
    
    item_data.item_content[0].item_data.text_id = TXT_ENG_NO;
    
    GUILIST_AppendItem( list_id, &item_t );
    
    if (MMIAPIENG_GetPowerKeyFlag())
    {
        GUILIST_SetSelectedItem( list_id, 0, TRUE );
        GUILIST_SetCurItemIndex( list_id, 0);
    }
    else
    {
        GUILIST_SetSelectedItem( list_id, 1, TRUE );
        GUILIST_SetCurItemIndex( list_id, 1 );
    }
}

/********************************************************************************
 NAME:          AppendListItem
 DESCRIPTION:   
 PARAM IN:      list_id - 
 PARAM OUT:     None
 AUTHOR:        songbin.zeng
 DATE:          2006.08.08
********************************************************************************/
LOCAL void AppendListItem(
                            MMI_CTRL_ID_T list_id,
                            MMI_TEXT_ID_T *text_id_tab,
                            int32 tab_len
                            )
{
    uint16                  i         = 0;
    GUILIST_ITEM_T      item_t    = {0};/*lint !e64*/
    GUILIST_ITEM_DATA_T item_data = {0};/*lint !e64*/
    
    item_t.item_style    = GUIITEM_STYLE_1RADIO_ENG;
    item_t.item_data_ptr = &item_data;
    
    item_data.item_content[0].item_data_type = GUIITEM_DATA_TEXT_ID;
    
    item_data.softkey_id[0] = (MMI_TEXT_ID_T)TXT_ENG_OK;
    //item_data.softkey_id[1] = (MMI_TEXT_ID_T)TXT_NULL;
    item_data.softkey_id[2] = (MMI_TEXT_ID_T)TXT_ENG_RETURN;    
    
    for ( i = 0; i < tab_len; i ++ )
    {
        item_data.item_content[0].item_data.text_id = text_id_tab[i];
        
        GUILIST_AppendItem( list_id, &item_t );
    }
}


/********************************************************************************
 NAME:          EngPowerKeyWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        allen
 DATE:          2004.10.11
********************************************************************************/
LOCAL MMI_RESULT_E EngPowerKeyWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        AppendPowerKeyItem(MMIENG_LISTBOX_CTRL_ID);     
        MMK_SetAtvCtrl(MMIENG_POWERKEY_WIN_ID, MMIENG_LISTBOX_CTRL_ID);
        break;
        
    case MSG_FULL_PAINT:
        break;      

    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(MMIENG_POWERKEY_WIN_ID);
        break;

    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        {
            uint16      index = 0;
            BOOLEAN     keyflag = TRUE;

            index = GUILIST_GetCurItemIndex(MMIENG_LISTBOX_CTRL_ID);

            keyflag = (0 == index);

            MMIAPIENG_SetPowerKeyFlag(keyflag);

            ShowSetPowerKeyResult(keyflag);

            MMK_CloseWin(MMIENG_POWERKEY_WIN_ID);
        }
        break;
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

#ifdef DSP_USB_LOG
/********************************************************************************
 NAME:          EngDspCardLogEnableWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        xuefang.jiang  
 DATE:          20110729
********************************************************************************/
LOCAL MMI_RESULT_E EngDspCardLogEnableWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_LISTBOX_CTRL_ID;
    BOOLEAN is_on = FALSE;
    //MN_RETURN_RESULT_E  return_value = MN_RETURN_FAILURE;
    MMIFILE_DEVICE_E file_dev = MMI_DEVICE_SDCARD;  
    MMI_TEXT_ID_T text_id = TXT_NULL;
    BOOLEAN is_udcard = FALSE;
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        GUILIST_SetMaxItem(ctrl_id,MMISET_OPEN_CLOSE_ITEM, FALSE );//max item 2  

        is_on = (BOOLEAN)REFPARAM_GetDspCardLogFlag();
        //SCI_TRACE_LOW:"is_on %d"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_8076_112_2_18_2_17_57_155,(uint8*)"d",is_on);
        /*MMINV_READ(NV_REF_PARAMETER,&is_on,return_value);        
        if(MN_RETURN_SUCCESS!=return_value)
        {
            is_on = FALSE;      
            MMINV_WRITE(NV_REF_PARAMETER,&is_on);
        }   */          
 
        GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
        MMIAPISET_AppendListItemByTextIdExt(TXT_COMM_CLOSE,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
        MMIAPISET_AppendListItemByTextIdExt(TXT_OPEN_COMN,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);         

        //set selected item
        GUILIST_SetSelectedItem(ctrl_id, is_on, TRUE);
        //set current item
        GUILIST_SetCurItemIndex(ctrl_id,is_on);
        
        MMK_SetAtvCtrl(win_id,ctrl_id);     
        break;
        
    case MSG_FULL_PAINT:
        break;  
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    
        is_on = (BOOLEAN)GUILIST_GetCurItemIndex(ctrl_id);  
        if(is_on==FALSE)
        {
#ifndef WIN32
            SIO_DSPCardLogClose(); 
#endif
            //SCI_TRACE_LOW:"is_on_close %d"
            SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_8115_112_2_18_2_17_57_156,(uint8*)"d",is_on);
        }
        else
        {

            // 判断保存文件所需空间是否不足
            if(!MMIAPIFMM_GetDeviceTypeStatus(file_dev))
            {
                //device selected doesn't exist!
                text_id = MMIAPIFMM_GetAlertTextIDByDev((file_dev));
            
                //SCI_TRACE_LOW:"IS sdcard %d"
                SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_8126_112_2_18_2_17_57_157,(uint8*)"d",is_udcard);
            
                MMIPUB_OpenAlertWinByTextId(PNULL,
                                            text_id,
                                            TXT_NULL,
                                            IMAGE_PUBWIN_WARNING,
    										PNULL,
                                            PNULL,
                                            MMIPUB_SOFTKEY_ONE,
                                            PNULL);
            }
            
            else
            {
#ifndef WIN32
 
                SIO_DSPCardLogOpen();
#endif
                //SCI_TRACE_LOW:"is_on_open %d"
                SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_8144_112_2_18_2_17_57_158,(uint8*)"d",is_on);
            }   
            
        }
        //MMINV_WRITE(NV_REF_PARAMETER,&is_on); 
        MMK_CloseWin(win_id);
        //MMIPUB_OpenAlertSuccessWin(TXT_COMPLETE);  
		
        result = MMI_RESULT_TRUE;  
        break;      
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    
    return (result);
}
#endif
/********************************************************************************
 NAME:          EngSenSorModeWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        songbin.zeng
 DATE:          2006.08.08
********************************************************************************/
LOCAL MMI_RESULT_E EngSensorModeWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    uint16                  index = 0;
    MMI_RESULT_E            result = MMI_RESULT_TRUE;
    MMI_TEXT_ID_T           text_id_tab[] = {TXT_ENG_DEFAULT, TXT_ENG_RGB, TXT_ENG_YUV};
    int16                   item_total_num = sizeof(text_id_tab) / sizeof(MMI_TEXT_ID_T);
    MMI_CTRL_ID_T           list_id = MMIENG_LISTBOX_CTRL_ID;
    MMIENG_SENSOR_MODE_E    mode = MMIENG_SENSOR_MODE_DEFAULT;
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        GUILIST_SetMaxItem(list_id, item_total_num, FALSE );//max item 3
        GUILIST_SetOwnSofterKey(list_id,TRUE);
        AppendListItem(
            list_id, 
            text_id_tab, 
            item_total_num
            );
        
        mode = MMIAPIENG_GetSensorMode();
        
        //SCI_TRACE_LOW:"MMIENG_WIN.C EngSensorModeWinHandleMsg mode is %d,item_total_num is %d"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_8194_112_2_18_2_17_57_159,(uint8*)"dd",mode,item_total_num);
        if((int16)mode >=  item_total_num)
        {
            return MMI_RESULT_FALSE;
        }
        GUILIST_SetSelectedItem(list_id, (uint16)mode, TRUE);
        GUILIST_SetCurItemIndex(list_id, (int16)mode);
        MMK_SetAtvCtrl(win_id, list_id);
        break;
        
    case MSG_FULL_PAINT:
        break;
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        index = GUILIST_GetCurItemIndex(list_id);
        //SCI_TRACE_LOW:"MMIENG_WIN.C EngSensorModeWinHandleMsg index is %d,item_total_num is %d"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_8217_112_2_18_2_17_57_160,(uint8*)"dd",index,item_total_num);
        if((int16)index >=  item_total_num)
        {
            return MMI_RESULT_FALSE;
        }
        MMIAPIENG_SetSensorMode((MMIENG_SENSOR_MODE_E)index);
        //success!
       // MMIPUB_OpenAlertSuccessWin(TXT_COMPLETE);
        MMK_CloseWin(win_id);
        break;
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    
    return (result);
}
/********************************************************************************
//MS00216980 cheney
 NAME:			EngCMCCTestWinHandleMsg
 DESCRIPTION:	
 PARAM IN:		win_id - 
				msg_id - 
				param - 
 PARAM OUT:		
 AUTHOR:		cheney.chen
 DATE:			2010.12.09
********************************************************************************/
LOCAL MMI_RESULT_E EngCMCCTestWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    //uint16 					index = 0;
    MMI_RESULT_E 			result = MMI_RESULT_TRUE;
    MMI_TEXT_ID_T 			text_id_tab[] = {TXT_ENG_CMCC_BUSINESS_SERVER, TXT_ENG_CMCC_TEST_SERVER};
    int16					item_total_num = sizeof(text_id_tab) / sizeof(MMI_TEXT_ID_T);
    MMI_CTRL_ID_T   		list_id = MMIENG_LISTBOX_CTRL_ID;
    BOOLEAN 	test_flag =  FALSE;
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        GUILIST_SetMaxItem(list_id, item_total_num, FALSE );//max item 2
        GUILIST_SetOwnSofterKey(list_id,TRUE);
        AppendListItem(
            list_id, 
            text_id_tab, 
            item_total_num
            );
        
        test_flag = MMIAPIENG_GetCMCCTestFlag();
        
        GUILIST_SetSelectedItem(list_id, (uint16)test_flag, TRUE);
        GUILIST_SetCurItemIndex(list_id, (int16)test_flag);
        MMK_SetAtvCtrl(win_id, list_id);
        break;
        
    case MSG_FULL_PAINT:
        break;
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
	
        test_flag = GUILIST_GetCurItemIndex(list_id);
	 //SCI_TRACE_LOW:"[mmieng] list_id = %d"
	 SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_8286_112_2_18_2_17_57_161,(uint8*)"d", test_flag);
        MMIAPIENG_SetCMCCTestFlag(&test_flag);
        //success!
        //MMIPUB_OpenAlertSuccessWin(TXT_ENG_SUCCESS_NEED_RESET);
        MMK_CloseWin(win_id);
        break;
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    
    return (result);
}

/********************************************************************************
 NAME:          EngDVCovFrameFre2ListItemPos
 DESCRIPTION:   
 PARAM IN:
 PARAM OUT:     
 AUTHOR:        songbin.zeng
 DATE:          2006.12.05
********************************************************************************/
LOCAL int16 EngDVCovFrameFre2ListItemPos(MMIENG_DV_FRAME_FRE_E dv_frame_frequency)
{
    int16 item_pos = 0;
    
    switch(dv_frame_frequency)
    {
    case MMIENG_DV_FRAME_FRE_7HZ:
        item_pos = 0;
        break;
        
    case MMIENG_DV_FRAME_FRE_10HZ:
        item_pos = 1;
        break;
        
    case MMIENG_DV_FRAME_FRE_15HZ:
        item_pos = 2;
        break;

    case MMIENG_DV_FRAME_FRE_20HZ:
        item_pos = 3;
        break;

    case MMIENG_DV_FRAME_FRE_25HZ:
        item_pos = 4;
        break;

    case MMIENG_DV_FRAME_FRE_30HZ:
        item_pos = 5;
        break;

    default:
        //SCI_TRACE_LOW:"MMIENG_WIN.C EngDVCovFrameFre2ListItemPos dv_frame_frequency is %d"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_8339_112_2_18_2_17_58_162,(uint8*)"d", dv_frame_frequency);
        break;
    }

    return item_pos;
}

/********************************************************************************
 NAME:          EngDVCovListItemPos2FrameFre
 DESCRIPTION:   
 PARAM IN:
 PARAM OUT:     
 AUTHOR:        songbin.zeng
 DATE:          2006.12.05
********************************************************************************/
LOCAL MMIENG_DV_FRAME_FRE_E EngDVCovListItemPos2FrameFre(int16 item_pos)
{
    MMIENG_DV_FRAME_FRE_E dv_frame_frequency = MMIENG_DV_FRAME_FRE_7HZ;
    
    switch(item_pos)
    {
    case 0:
        dv_frame_frequency = MMIENG_DV_FRAME_FRE_7HZ;
        break;
        
    case 1:
        dv_frame_frequency = MMIENG_DV_FRAME_FRE_10HZ;
        break;
        
    case 2:
        dv_frame_frequency = MMIENG_DV_FRAME_FRE_15HZ;
        break;

    case 3:
        dv_frame_frequency = MMIENG_DV_FRAME_FRE_20HZ;
        break;

    case 4:
        dv_frame_frequency = MMIENG_DV_FRAME_FRE_25HZ;
        break;

    case 5:
        dv_frame_frequency = MMIENG_DV_FRAME_FRE_30HZ;
        break;

    default:
        //SCI_TRACE_LOW:"MMIENG_WIN.C EngDVCovListItemPos2FrameFre item_pos is %d"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_8384_112_2_18_2_17_58_163,(uint8*)"d",item_pos);
        break;
    }

    return dv_frame_frequency;
}


/********************************************************************************
 NAME:          EngDVFrameFreWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        songbin.zeng
 DATE:          2006.12.05
********************************************************************************/
LOCAL MMI_RESULT_E EngDVFrameFreWinHandleMsg(
                                             MMI_WIN_ID_T win_id, 
                                             MMI_MESSAGE_ID_E msg_id,
                                             DPARAM param
                                             )
{
    MMI_RESULT_E            result = MMI_RESULT_TRUE;
    MMI_TEXT_ID_T           text_id_tab[] = {
                                            TXT_ENG_DV_FRAME_FRE_10, 
                                            TXT_ENG_DV_FRAME_FRE_15, 
                                            TXT_ENG_DV_FRAME_FRE_20,
                                            TXT_ENG_DV_FRAME_FRE_25,
                                            TXT_ENG_DV_FRAME_FRE_30
                                            };
    int16                   item_pos = 0;
    int16                   item_total_num = 0;
    MMI_CTRL_ID_T           list_id = MMIENG_LISTBOX_CTRL_ID;
    MMIENG_DV_FRAME_FRE_E   dv_frame_frequency = MMIENG_DV_FRAME_FRE_MIN;

    item_total_num = ARR_SIZE(text_id_tab);
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        GUILIST_SetMaxItem(list_id, item_total_num, FALSE );//max item 5
        GUILIST_SetOwnSofterKey(list_id,TRUE);
        AppendListItem(
                    list_id, 
                    text_id_tab, 
                    item_total_num
                    );
        
        dv_frame_frequency = MMIAPIENG_GetDVFrameFre();
                item_pos =EngDVCovFrameFre2ListItemPos(dv_frame_frequency);

        GUILIST_SetSelectedItem(list_id, (uint16)item_pos, TRUE);
        GUILIST_SetCurItemIndex(list_id, (int16)item_pos);
        MMK_SetAtvCtrl(win_id, list_id);
        break;
        
    case MSG_FULL_PAINT:
        break;
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(MMIENG_DV_FRAME_FRE_WIN_ID);
        break;
    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        item_pos = GUILIST_GetCurItemIndex(list_id);
                dv_frame_frequency = EngDVCovListItemPos2FrameFre(item_pos);
        MMIAPIENG_SetDVFrameFre(dv_frame_frequency);
        //success!
        //MMIPUB_OpenAlertSuccessWin(TXT_COMPLETE);
        MMK_CloseWin(win_id);
        break;
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    
    return (result);
}

/********************************************************************************
 NAME:          AppendBandSelectItem
 DESCRIPTION:   
 PARAM IN:      list_id - 
 PARAM OUT:     None
 AUTHOR:        allen
 DATE:          2004.10.08
********************************************************************************/
LOCAL void AppendBandSelectItem(MMI_CTRL_ID_T ctrl_id)
{
    uint32                  total_item = 0;
    uint32                  i = 0;
    
    total_item = ARR_SIZE(s_mmieng_sel_band_txt_tab);
    GUILIST_SetMaxItem(ctrl_id, total_item, FALSE );//max item 5
    GUILIST_SetOwnSofterKey(ctrl_id,TRUE);

    for(i = 0; i < total_item; i ++)
    {
        MMIAPISET_AppendListItemByTextIdExt(s_mmieng_sel_band_txt_tab[i],TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
    }
    
    // get current band
    switch (MNPHONE_GetBandEx(MMIAPISET_GetActiveSim()))//%#discuss
    {
    case MN_PHONE_BAND_PCS:
        i = 0;
        break;
        
    case MN_PHONE_BAND_GSM:
        i = 1;
        break;
        
    case MN_PHONE_BAND_DCS:
        i = 2;
        break;
                    
    case MN_PHONE_BAND_GSM_DCS:
        i = 3;
        break;
    
    case MN_PHONE_BAND_GSM850_GSM_DCS_PCS:
        i = 4;
        break;
        
    default:
        i = 4;
        break;
    }
    
    if (i < total_item)
    {
        //set select item
        GUILIST_SetSelectedItem(ctrl_id, i,TRUE);
        //set current item
        GUILIST_SetCurItemIndex(ctrl_id, i);
       
    }
}

/********************************************************************************
 NAME:          EngBandSelectWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        allen
 DATE:          2004.10.08
********************************************************************************/
LOCAL MMI_RESULT_E EngBandSelectWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_CTRL_ID_T ctrl_id = MMIENG_LISTBOX_CTRL_ID;
    uint16 index = 0;
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MN_PHONE_BAND_TYPE_E    sel_band = {0};
    MMI_STRING_T    wait_text = {0};
    ERR_MNPHONE_CODE_E mn_error = ERR_MNPHONE_NOT_RIGHT_PARAM ;

    MMI_GetLabelTextByLang(TXT_COMMON_WAITING, &wait_text);
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        AppendBandSelectItem(ctrl_id);
        MMK_SetAtvCtrl(MMIENG_BANDSELECT_WIN_ID, ctrl_id);
        break;
        
    case MSG_FULL_PAINT:
       
        break;
 
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_APP_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        index = GUILIST_GetCurItemIndex(MMIENG_LISTBOX_CTRL_ID);
        switch (index)
        {
        case 0:     // PCS
            sel_band = MN_PHONE_BAND_PCS;
            break;
            
        case 1:     // GSM
            sel_band = MN_PHONE_BAND_GSM;
            break;
            
        case 2:     // DCS
            sel_band = MN_PHONE_BAND_DCS;
            break;
            
        case 3:     // DUAL BAND
            sel_band = MN_PHONE_BAND_GSM_DCS;
            break;

        case 4:     // DUADRUPLE BAND
            sel_band = MN_PHONE_BAND_GSM850_GSM_DCS_PCS;
            break;
            
        default:
            //SCI_TRACE_LOW:"MMIENG_WIN.C EngBandSelectWinHandleMsg index is %d"
            SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_8590_112_2_18_2_17_58_164,(uint8*)"d",index);
            break;
        }

        if (!MMIAPISET_GetFlyMode())
        {
            MN_DUAL_SYS_E dual_sys = MN_DUAL_SYS_1;
            
            for(dual_sys = MN_DUAL_SYS_1; dual_sys < MMI_DUAL_SYS_MAX; dual_sys++)
            {
                if(MMIAPIPHONE_IsSimAvailable(dual_sys))
                {
                   mn_error = MNPHONE_SelectBandEx(dual_sys, sel_band);                 
                   //SCI_TRACE_LOW:"MMIENG_WIN.C,EngBandSelectWinHandleMsg,MNPHONE_SelectBandEx, sim%d, result = %d"
                   SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_8604_112_2_18_2_17_58_165,(uint8*)"dd",dual_sys + 1,mn_error);
                }
            }
        }
        if(ERR_MNPHONE_NO_ERR == mn_error)
        {
#ifndef WIN32
            MMIPUB_OpenWaitWin(1,&wait_text,PNULL,PNULL,MAIN_WAIT_WIN_ID,IMAGE_NULL,
                ANIM_PUBWIN_WAIT,WIN_ONE_LEVEL,MMIPUB_SOFTKEY_NONE,PNULL);
#endif    
        }
        else
        {
            MMI_STRING_T text_str = {0};
            uint8 str_buf[100] = {0};
            wchar w_str_buf[100] = {0};
            int32 length = 0;      
            sprintf((char*)str_buf,"SIM set fail");
            length = SCI_STRLEN((char*)str_buf);
            MMI_STRNTOWSTR(w_str_buf,100, str_buf,length, length);               
            text_str.wstr_ptr = w_str_buf;      
            text_str.wstr_len = length;
            MMIPUB_OpenAlertWinByTextPtr(PNULL,&text_str,PNULL,IMAGE_PUBWIN_FAIL,PNULL,PNULL,
                MMIPUB_SOFTKEY_ONE,PNULL);
        }

        break;
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

/********************************************************************************
 NAME:          MMIAPIENG_BandSelectCnf
 DESCRIPTION:   
 PARAM IN:      None 
 PARAM OUT:     None
 AUTHOR:        songbin.zeng
 DATE:          2006.11.16
********************************************************************************/
PUBLIC void MMIAPIENG_BandSelectCnf(DPARAM  param)
{
    APP_MN_SET_BAND_CNF_T    band_select_cnf = *((APP_MN_SET_BAND_CNF_T *)param);
    //MMISET_DUALSYS_TYPE_E e_dualsys_setting = MMIAPISET_GetMultiSysSetting();
    MMI_STRING_T text_str = {0};
    uint8        str_buf[100] = {0};
    wchar     w_str_buf[100] = {0};

    if (band_select_cnf.is_ok)
    {
        //success!
        sprintf((char*)str_buf,"SIM%d set done",(band_select_cnf.dual_sys+1));
        MMI_STRNTOWSTR(w_str_buf,100, str_buf,strlen((char*)str_buf),strlen((char*)str_buf));       
        //text_str.is_ucs2 = 0;
        text_str.wstr_ptr = w_str_buf;
        text_str.wstr_len = strlen((char*)str_buf);
        MMIPUB_OpenAlertWinByTextPtr(PNULL,&text_str,PNULL,IMAGE_PUBWIN_SUCCESS,PNULL,PNULL,MMIPUB_SOFTKEY_ONE,PNULL);
    }
    else
    {   
        sprintf((char*)str_buf,"SIM%d set fail",(band_select_cnf.dual_sys+1));
        MMI_STRNTOWSTR(w_str_buf,100, str_buf,strlen((char*)str_buf),strlen((char*)str_buf));               
        //text_str.is_ucs2 = 0;
        text_str.wstr_ptr = w_str_buf;      
        text_str.wstr_len = strlen((char*)str_buf);
        MMIPUB_OpenAlertWinByTextPtr(PNULL,&text_str,PNULL,IMAGE_PUBWIN_FAIL,PNULL,PNULL,MMIPUB_SOFTKEY_ONE,PNULL);
    }
    // get current band
    if (MMK_IsOpenWin(MMIENG_BANDSELECT_WIN_ID))
    {
        MMK_CloseWin(MAIN_WAIT_WIN_ID);
        MMK_CloseWin(MMIENG_BANDSELECT_WIN_ID);
    }
   
}

/*****************************************************************************/
//  Description : is eng band select cmd
//  Global resource dependence : 
//  Author: jian.ma
//  Note: 
/*****************************************************************************/
PUBLIC BOOLEAN MMIAPIENG_IsBandSelectWinOpen(void)
{
    return MMK_IsOpenWin(MMIENG_BANDSELECT_WIN_ID);
}

/*********************************************************************************
 NAME:          MMIAPIENG_CreateProductWin
 DESCRIPTION:   
 PARAM IN:      
 PARAM OUT:     
 AUTHOR:        songbin.zeng
 DATE:          2006.10.11
********************************************************************************/
PUBLIC BOOLEAN MMIAPIENG_CreateProductWin(void)
{
    return MMK_CreateWin((uint32*)MMIENG_PRODUCT_WIN_TAB, PNULL);
}

/********************************************************************************
 NAME:          MMIAPIENG_CreateProductSNWin
 DESCRIPTION:   
 PARAM IN:      
 PARAM OUT:     
 AUTHOR:        songbin.zeng
 DATE:          2006.10.11
********************************************************************************/
BOOLEAN MMIAPIENG_CreateProductSNWin(void)
{
    return MMK_CreateWin((uint32*)MMIENG_PRODUCT_SN_WIN_TAB, PNULL);
}

/********************************************************************************
 NAME:          MMIAPIENG_CreatePhoneInfoWin
 DESCRIPTION:   
 PARAM IN:      
 PARAM OUT:     
 AUTHOR:        songbin.zeng
 DATE:          2006.10.11
********************************************************************************/
PUBLIC BOOLEAN MMIAPIENG_CreatePhoneInfoWin(void)
{
    return MMK_CreateWin((uint32*)MMIENG_SHOWPHONE_WIN_TAB, PNULL);
}

LOCAL MMI_RESULT_E OpenPSCellWin(uint32 dual_sys, BOOLEAN isReturnOK, DPARAM param)
{
    if (isReturnOK)
    {
        return MMK_CreateWin((uint32 *) MMIENG_PSCELL_WIN_TAB, (ADD_DATA)dual_sys); 
    }
    else
    {
        return MMI_RESULT_FALSE;
    }
}
/********************************************************************************
 NAME:          MMIAPIENG_CreateShowNetWin
 DESCRIPTION:   
 PARAM IN:      
 PARAM OUT:     
 AUTHOR:        songbin.zeng
 DATE:          2006.10.11
********************************************************************************/
PUBLIC BOOLEAN MMIAPIENG_CreateShowNetWin(void)
{    
#ifndef MMI_DUALMODE_ENABLE
    uint16  sim_ok = 0;
    uint32  sim_num = 0;

    sim_num = MMIAPIPHONE_GetSimAvailableNum(&sim_ok, 1);

    if (0 == sim_num)
    {
        MMIAPIPHONE_AlertSimNorOKStatus();
        return 0;
    }
    else if (1 == sim_num)
    {
        MMK_CreateWin((uint32 *) MMIENG_PSCELL_WIN_TAB, (ADD_DATA)sim_ok); 
        return 1;        
    }
    else
    {
        MMI_WIN_ID_T    selectSimWinID = MMIENG_SIM_SELECT_WIN_ID;
        MMIPHONE_SELECT_SIM_DATA_T  caller_data={0};
        //return MMK_CreateWin((uint32 *) MMIENG_SHOW_RF_WIN_TAB, PNULL);    
        //return MMK_CreateWin((uint32 *) MMIENG_PSCELL_WIN_TAB, 0);    
        // return MMK_CreateWin((uint32 *) MMIENG_SIM_SELECT_WIN_TAB, PNULL);    

        caller_data.append_type = (uint32)MMISET_APPEND_SYS_OK;
        caller_data.callback_func = OpenPSCellWin ;
        caller_data.select_type= MMIPHONE_SELECTION_SIM_ONLY;
        caller_data.publist_id = MMIENG_LISTBOX_CTRL_ID;
        caller_data.win_id_ptr = &selectSimWinID;
        caller_data.user_data  = PNULL;
        caller_data.extra_data = PNULL;

        return MMIAPIPHONE_OpenSelectSimWin(&caller_data);
    }
#else
    return MMK_CreateWin((uint32 *) MMIENG_SHOWNET_WIN_TAB, PNULL);    
#endif
}

PUBLIC BOOLEAN MMIAPIENG_CreateShowGprsTestWin(void)
{
    MMK_CreateWin((uint32 *) MMIENG_GPRS_TEST_WIN_TAB, PNULL);
    return TRUE;
}
/********************************************************************************
 NAME:          MMIAPIENG_CreateRFWin
 DESCRIPTION:   
 PARAM IN:      
 PARAM OUT:     
 AUTHOR:        songbin.zeng
 DATE:          2006.11.22
********************************************************************************/
PUBLIC BOOLEAN MMIAPIENG_CreateRFWin(void)
{
    return MMK_CreateWin((uint32 *) MMIENG_SHOW_RF_WIN_TAB, PNULL);
}

/********************************************************************************
 NAME:          EngShowRFWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      
 PARAM OUT:     
 AUTHOR:        songbin.zeng
 DATE:      0   2006.11.22
********************************************************************************/
LOCAL MMI_RESULT_E EngShowRFWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{

    MMI_RESULT_E result = MMI_RESULT_TRUE;
    LOCAL uint8 s_mmieng_rf_timer_id = 0;
    LOCAL MMIENG_RF_CELL_E sel_cell = MMIENG_RF_CELL_ALL;
    
    switch (msg_id) 
    {
        case MSG_OPEN_WINDOW:
            {
                GUI_FONT_T font = MMI_DEFAULT_BIG_FONT ;
                GUITEXT_SetFont(MMIENG_TEXTBOX1_CTRL_ID, &font, 0 );
            }
            DrawRFWin(MMIENG_RF_CELL_ALL);
            sel_cell = MMIENG_RF_CELL_ALL;
                    
            // create refresh timer
            if(0 != s_mmieng_rf_timer_id)
            {
                MMK_StopTimer(s_mmieng_rf_timer_id);
            }
            s_mmieng_rf_timer_id = MMK_CreateWinTimer(win_id, MMIENG_RF_TIME, FALSE);
            MMK_SetAtvCtrl(win_id, MMIENG_TEXTBOX1_CTRL_ID); 
            break;
            
        case MSG_FULL_PAINT:                 
            break;
        case MSG_KEYUP_UP:
        case MSG_KEYUP_DOWN:
            if (s_mmieng_rf_timer_id != 0)
            {
                MMK_StopTimer(s_mmieng_rf_timer_id);
                s_mmieng_rf_timer_id = 0;
                s_mmieng_rf_timer_id = MMK_CreateWinTimer(win_id, MMIENG_RF_TIME, FALSE);
            }
            break;
        case MSG_APP_LEFT:
            if (MMIENG_RF_CELL_C0 !=sel_cell)
            {
                sel_cell --;
                DrawRFWin(sel_cell);
            }
            else
            {
                sel_cell = MMIENG_RF_CELL_ALL;
                DrawRFWin(sel_cell);
            }
            break;

         case MSG_APP_RIGHT:
             if (MMIENG_RF_CELL_ALL !=sel_cell)
             {
                 sel_cell ++;
                 DrawRFWin(sel_cell);
             }
             else
             {
                 sel_cell = MMIENG_RF_CELL_C0;
                 DrawRFWin(sel_cell);
             }
             break;
        case MSG_CTL_CANCEL:
        case MSG_APP_CANCEL:
            MMK_CloseWin(win_id);
            break;
            
        case MSG_TIMER:
            if (*(uint8*)param == s_mmieng_rf_timer_id) 
            {
                DrawRFWin(sel_cell);            
                s_mmieng_rf_timer_id = MMK_CreateWinTimer(win_id, MMIENG_RF_TIME, FALSE);
            }
            else
            {
                result = MMI_RESULT_FALSE;      // need additional process
            }           
            break;
                
        case MSG_LOSE_FOCUS:
            MMK_PauseTimer(s_mmieng_rf_timer_id);
            break;
            
        case MSG_GET_FOCUS:            
            MMK_ResumeTimer(s_mmieng_rf_timer_id);
            break;
            
        case MSG_CLOSE_WINDOW:
            if (s_mmieng_rf_timer_id != 0)
            {
                MMK_StopTimer(s_mmieng_rf_timer_id);
                s_mmieng_rf_timer_id = 0;
            }
            break;
        
        default:
            result = MMI_RESULT_FALSE;
            break;
    }
    return (result);
}

/********************************************************************************
 NAME:          GetRFCellInfo
 DESCRIPTION:   
 PARAM IN:      
 PARAM OUT:     
 AUTHOR:        songbin.zeng
 DATE:          2006.11.22
********************************************************************************/
LOCAL BOOLEAN GetRFCellInfo(
                                                                MMIENG_RF_CELL_INFO_T *info, 
                                                                MMIENG_RF_CELL_E cell
                                                                )
{
#ifndef _WIN32
    MN_ENG_CELL_BASIC_INFO_T cell_basic_info = {0};
    MN_ENG_CELL_IDLE_INFO_T  cell_idle_info = {0};
    int cell_index = 0;
#endif

    if(PNULL == info)
    {
        //SCI_TRACE_LOW:"mmieng_win.c GetRFCellInfo info == null"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_8909_112_2_18_2_17_59_166,(uint8*)"");
        return FALSE;
    } 

    SCI_MEMSET(info, 0, sizeof(MMIENG_RF_CELL_INFO_T));

#ifndef _WIN32

    if (MN_RETURN_SUCCESS != MNENG_GetCellBasicInfo(&cell_basic_info))
    {
        
    }
    else
    {}

    if (MN_RETURN_SUCCESS != MNENG_GetCellIdleInfo(&cell_idle_info))
    {
        
    }
    else
    {}
    
    switch (cell)
    {
        case MMIENG_RF_CELL_C0:
        {
            MN_ENG_SCELL_TRAF_INFO_T scell_traf_info = {0};
                    MN_ENG_SCELL_CTRL_INFO_T scell_ctrl_info = {0};

            info->BCH = cell_basic_info.scell_info.arfcn;
            info->BSIC = (cell_basic_info.scell_info.bsic.ncc << 3) + cell_basic_info.scell_info.bsic.bcc;
            info->CELID = cell_basic_info.scell_info.cell_id;
            info->LAC = cell_basic_info.scell_info.lai.lac;

            info->BRXL = cell_idle_info.scell_info.rssi + 110;
            
            info->C1 = cell_idle_info.scell_info.c1;
            info->C2 = cell_idle_info.scell_info.c2;


            if (MN_RETURN_SUCCESS == MNENG_GetSCellTrafInfo(&scell_traf_info))
            {
                info->TN = scell_traf_info.channel_dec.tn;
                info->TXLEV = scell_traf_info.power_level;
                info->TAV = scell_traf_info.ta;
            }
            

            if (MN_RETURN_SUCCESS == MNENG_GetSCellCtrlInfo(&scell_ctrl_info))
            {
                           info->DSC = scell_ctrl_info.ctl_chn_param.dsc;
                info->RLT = scell_ctrl_info.rlt;
                           info->CBA = scell_ctrl_info.rach_param.cba;
            }
        

            info->CBQ = 0;//待定
            break;
        }
        
        case MMIENG_RF_CELL_N0:
        case MMIENG_RF_CELL_N1:
        case MMIENG_RF_CELL_N2:
        case MMIENG_RF_CELL_N3:
        case MMIENG_RF_CELL_N4:
        case MMIENG_RF_CELL_N5:
            switch (cell)
            {
            case MMIENG_RF_CELL_N0:
                cell_index = 0;
                break;
            case MMIENG_RF_CELL_N1:
                cell_index = 1;
                break;

            case MMIENG_RF_CELL_N2:
                cell_index = 2;
                break;

            case MMIENG_RF_CELL_N3:
                cell_index = 3;
                break;

            case MMIENG_RF_CELL_N4:
                cell_index = 4;
                break;

            case MMIENG_RF_CELL_N5:
                cell_index = 5;
                break;

            default:
                //SCI_TRACE_LOW:"MMIENG_WIN.C GetRFCellInfo cell is %d"
                SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_9001_112_2_18_2_17_59_167,(uint8*)"d",cell);
                break;
            }
            
            //SCI_TRACE_LOW:"MMIENG_MAIN.C GetRFCellInfo cell_index is %d"
            SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_9005_112_2_18_2_17_59_168,(uint8*)"d",cell_index);
            if(cell_index >=  MN_MAX_NCELL_NUM)
            {
                return FALSE;
            }
            info->BCH = cell_basic_info.ncell_info[cell_index].arfcn;
            info->BSIC = (cell_basic_info.scell_info.bsic.ncc << 3) + cell_basic_info.scell_info.bsic.bcc;
            info->CELID = cell_basic_info.ncell_info[cell_index].cell_id;
            info->LAC = cell_basic_info.ncell_info[cell_index].lai.lac;
            
            info->BRXL = cell_idle_info.ncell_info[cell_index].rssi + 110;
            info->C1 = cell_idle_info.ncell_info[cell_index].c1;
            info->C2 = cell_idle_info.ncell_info[cell_index].c2;
            
            info->CBA = 0;//待定
            info->CBQ = 0;//待定
            info->ALIG = 0;//待定
            info->FFSET = 0;//待定
            break;

        default:        
            //SCI_TRACE_LOW:"MMIENG_WIN.C GetRFCellInfo cell is %d"
            SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_9026_112_2_18_2_17_59_169,(uint8*)"d",cell);
            break;
    }
#endif
    return TRUE;
}

/********************************************************************************
 NAME:          DrawRFWin
 DESCRIPTION:   
 PARAM IN:      
 PARAM OUT:     
 AUTHOR:        songbin.zeng
 DATE:          2006.11.22
********************************************************************************/
LOCAL void DrawRFWin(
                     MMIENG_RF_CELL_E cell
                     )
{

     MMIENG_RF_CELL_INFO_T rf_info = {0};

    uint32 i = 0;
    uint32 j = 0;

    uint32 row = 0;
    uint32 col = 0;
    char rf_data_str[20] = {0};
    wchar wstr[20] = {0};
    wchar w_cr[] = {CR_CHAR,0};
//     char* str = PNULL;
    wchar buffer[1024] = {0};
    const uint32 buffer_length = 1023;
    uint32 offset = 0;
    uint32 len = 0;
    wchar ch = ':';
    

    switch (cell)
    {       
    case MMIENG_RF_CELL_ALL:
        {
            const wchar * row_str_ptr[] = { s_space_wstr, s_bch_wstr, s_brxl_wstr, s_c1_wstr, s_c2_wstr };
        
            const wchar * col_str_ptr[] = { s_c0_wstr, s_n0_wstr, s_n1_wstr, s_n2_wstr, s_n3_wstr, s_n4_wstr, s_n5_wstr };
    
            int32 rf_data[5] = {0};
            MMIENG_RF_CELL_E cur_cell = MMIENG_RF_CELL_C0;    
            
           
           row = ARR_SIZE(row_str_ptr);     /*lint !e661*/
             //draw title text  
            for(i = 0; i < row; i ++)
            {
                len = MMIAPICOM_Wstrlen(row_str_ptr[i]);
                MMIAPICOM_Wstrncpy(buffer + offset, row_str_ptr[i],len);
                offset += len ;

                len = MMIAPICOM_Wstrlen(s_space_wstr);
                MMIAPICOM_Wstrncpy(buffer + offset, s_space_wstr,len);
                offset += len ;
            }       
            MMIAPICOM_Wstrncpy(buffer + offset, w_cr,1);
            offset += 1 ;     
            
            //draw content text
            col = ARR_SIZE(col_str_ptr);
        
            for(i = 0; i < col; i ++)
            {
             
                len = MMIAPICOM_Wstrlen(col_str_ptr[i]);  
                MMIAPICOM_Wstrncpy(buffer + offset, col_str_ptr[i],len);
                offset += len ;                
                
                len = MMIAPICOM_Wstrlen(s_space_wstr);
                MMIAPICOM_Wstrncpy(buffer + offset, s_space_wstr,len);
                offset += len ;
                       
                switch (i)
                {
                case 0:
                    cur_cell = MMIENG_RF_CELL_C0;
                    break;
                case 1:
                    cur_cell = MMIENG_RF_CELL_N0;
                    break;
                    
                case 2:
                    cur_cell = MMIENG_RF_CELL_N1;
                    break;
                    
                case 3:
                    cur_cell = MMIENG_RF_CELL_N2;
                    break;
                    
                case 4:
                    cur_cell = MMIENG_RF_CELL_N3;
                    break;
                    
                case 5:
                    cur_cell = MMIENG_RF_CELL_N4;
                    break;
                    
                case 6:
                    cur_cell = MMIENG_RF_CELL_N5;
                    break;
                    
                default:
                    //SCI_TRACE_LOW:"MMIENG_WIN.C DrawRFWin index is %d"
                    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_9134_112_2_18_2_17_59_170,(uint8*)"d",i);
                    break;
                }
                GetRFCellInfo(&rf_info, cur_cell);
                rf_data[0] = rf_info.BCH;
                rf_data[1] = rf_info.BRXL;
                rf_data[2] = rf_info.C1;
                rf_data[3] = rf_info.C2;
                
                for (j = 1; j < row; j ++)  /*lint !e661*/
                {   
                    SCI_MEMSET(rf_data_str, 0 ,  sizeof(rf_data_str));
                    sprintf(rf_data_str, "%d ", rf_data[j]);        /*lint !e661*/
                    len = SCI_STRLEN(rf_data_str);
                    if( 20 > len)
                    {
                          MMI_STRNTOWSTR( wstr, 20, (uint8*)rf_data_str, len, len );
                    }          
                    if( offset + len < buffer_length)
                    {
                        MMIAPICOM_Wstrncpy(buffer + offset, wstr,len);       
                        offset += len ;   
                    }
                }
                  MMIAPICOM_Wstrncpy(buffer + offset, w_cr,1);
                     offset += 1 ;    
            }
            GUITEXT_SetString(MMIENG_TEXTBOX1_CTRL_ID, buffer,offset, TRUE);
            break;
            }
            
        case MMIENG_RF_CELL_C0:
            {
                const wchar * wstr_ptr[] = {
                    s_bch_wstr, s_brxl_wstr, s_bsic_wstr, s_dsc_wstr, s_txlev_wstr, s_tn_wstr, s_rlt_wstr, 
                        s_tav_wstr, s_cba_wstr, s_cbq_wstr, s_c1_wstr, s_c2_wstr };
                int32 rf_data[12] = {0};    
                
               
                   GetRFCellInfo(&rf_info, cell);
                rf_data[0] = rf_info.BCH;
                rf_data[1] = rf_info.BRXL;
                rf_data[2] = rf_info.BSIC;
                rf_data[3] = rf_info.DSC;
                rf_data[4] = rf_info.TXLEV;
                rf_data[5] = rf_info.TN;
                rf_data[6] = rf_info.RLT;
                rf_data[7] = rf_info.TAV;
                rf_data[8] = rf_info.CBA;
                rf_data[9] = rf_info.CBQ;
                rf_data[10] = rf_info.C1;
                rf_data[11] = rf_info.C2;               
                for(i = 0; i < 6; i ++)
                {                    
                    for (j = 0; j < 2; j ++)
                    {  
                        //draw content text
                        len = MMIAPICOM_Wstrlen(wstr_ptr[i * 2 + j]);                    
                      MMIAPICOM_Wstrncpy(buffer + offset, wstr_ptr[i * 2 + j],len);
                      offset += len ;     

                       len = MMIAPICOM_Wstrlen(s_space_wstr);
                       MMIAPICOM_Wstrncpy(buffer + offset, s_space_wstr,len);
                        offset += len ;

                     //draw content ":"
                       MMIAPICOM_Wstrncpy(buffer + offset, &ch,1);
                      offset += 1 ;    

                       len = MMIAPICOM_Wstrlen(s_space_wstr);
                      MMIAPICOM_Wstrncpy(buffer + offset, s_space_wstr,len);
                      offset += len ;
                        //draw rf data
                      sprintf(rf_data_str, "%d  ", (int)rf_data[i * 2 + j]);
                      len = strlen(rf_data_str);
                      MMI_STRNTOWSTR( wstr, 20, (uint8*)rf_data_str, len, len );
                      MMIAPICOM_Wstrncpy(buffer + offset, wstr,len);
                      offset += len ;                      
                 }
                  MMIAPICOM_Wstrncpy(buffer + offset, w_cr,1);
                    offset += 1 ;   
                }
                GUITEXT_SetString(MMIENG_TEXTBOX1_CTRL_ID, buffer,offset, TRUE);
                break;
            } 
            
        case MMIENG_RF_CELL_N0:
        case MMIENG_RF_CELL_N1:
        case MMIENG_RF_CELL_N2:
        case MMIENG_RF_CELL_N3:
        case MMIENG_RF_CELL_N4:
        case MMIENG_RF_CELL_N5:      
            {
                const wchar * wstr_ptr[] = { s_bch_wstr, s_brxl_wstr, s_bsic_wstr, s_cba_wstr, s_celid_wstr,
                     s_cbq_wstr, s_alig_wstr, s_c1_wstr, s_lac_wstr, s_c2_wstr, s_ffset_wstr };
                const wchar * title_ptr[] = { s_c0_wstr, s_n0_wstr, s_n1_wstr, s_n2_wstr, s_n3_wstr, s_n4_wstr, s_n5_wstr };
                int32 rf_data[12] = {0};            
                   GetRFCellInfo(&rf_info, cell);
                rf_data[0] = rf_info.BCH;
                rf_data[1] = rf_info.BRXL;
                rf_data[2] = rf_info.BSIC;
                rf_data[3] = rf_info.CBA;
                rf_data[4] = rf_info.CELID;
                rf_data[5] = rf_info.CBQ;
                rf_data[6] = rf_info.ALIG;
                rf_data[7] = rf_info.C1;
                rf_data[8] = rf_info.LAC;
                rf_data[9] = rf_info.C2;
                rf_data[10] = rf_info.FFSET;

                //draw title text                        
                  len = MMIAPICOM_Wstrlen(title_ptr[cell]);
                  MMI_STRNTOWSTR( wstr, 20, (uint8*)rf_data_str, len, len );
                  MMIAPICOM_Wstrncpy(buffer + offset, title_ptr[cell],len);
                  offset += len ;        
                  
                  MMIAPICOM_Wstrncpy(buffer + offset, w_cr,1);
                    offset += 1 ;   
                                           
                for(i = 0; i < 6; i ++)
                {                   
                    for (j = 0; j < 2; j ++)
                    {                       
                      if((i * 2 + j) >= 11) break;
                        //draw content text
                        len = MMIAPICOM_Wstrlen(wstr_ptr[i * 2 + j]);                    
                      MMIAPICOM_Wstrncpy(buffer + offset, wstr_ptr[i * 2 + j],len);
                      offset += len ;     
                      
                       len = MMIAPICOM_Wstrlen(s_space_wstr);
                       MMIAPICOM_Wstrncpy(buffer + offset, s_space_wstr,len);
                        offset += len ;

                     //draw content ":"
                       MMIAPICOM_Wstrncpy(buffer + offset, &ch,1);
                      offset += 1 ;    

                       len = MMIAPICOM_Wstrlen(s_space_wstr);
                      MMIAPICOM_Wstrncpy(buffer + offset, s_space_wstr,len);
                      offset += len ;
                      
                        //draw rf data
                      sprintf(rf_data_str, "%d  ", (int)rf_data[i * 2 + j]);
                      len = strlen(rf_data_str);
                      MMI_STRNTOWSTR( wstr, 20, (uint8*)rf_data_str, len, len );
                      MMIAPICOM_Wstrncpy(buffer + offset, wstr,len);
                      offset += len ;                      
                 }
                  MMIAPICOM_Wstrncpy(buffer + offset, w_cr,1);
                    offset += 1 ;   
                }   
                 GUITEXT_SetString(MMIENG_TEXTBOX1_CTRL_ID, buffer,offset, TRUE);
                break;
            }
            
        default:
            //SCI_TRACE_LOW:"MMIENG_WIN.C DrawRFWin cell is %d"
            SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_9290_112_2_18_2_17_59_171,(uint8*)"d",cell);
            break;
        }
}

/********************************************************************************
 NAME:          MMIAPIENG_CreateWinDVFrameFre
 DESCRIPTION:   
 PARAM IN:      
 PARAM OUT:     
 AUTHOR:        songbin.zeng
 DATE:          2006.12.05
********************************************************************************/
PUBLIC BOOLEAN MMIAPIENG_CreateWinDVFrameFre(void)
{
    return MMK_CreateWin((uint32 * )MMIENG_DV_FRAME_FRE_TAB, PNULL);
}

#if 0
/********************************************************************************
 NAME:          EngWapUAWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        
 DATE:      
********************************************************************************/
LOCAL MMI_RESULT_E EngWapUAProfileWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMIBROWSER_UA_T     wap_ua={0};
    MMI_CTRL_ID_T       editbox_ctrl_id = MMIENG_WAPUAPROFILE_CTRL_ID;
    MMI_RESULT_E        result = MMI_RESULT_TRUE;
    MN_RETURN_RESULT_E  return_value = MN_RETURN_FAILURE;
    MMI_STRING_T string_info = {0};
    uint16              wap_ua_len = 0;
    wchar wstr[MMIBROWSER_MAX_URL_LEN + 1] = {0};

    switch (msg_id)
    {
    case MSG_OPEN_WINDOW:
        //set im
        GUIEDIT_SetIm(editbox_ctrl_id,
            GUIIM_TYPE_ENGLISH|GUIIM_TYPE_ABC|GUIIM_TYPE_DIGITAL,
            GUIIM_TYPE_ENGLISH);

        SCI_MEMSET(&wap_ua,0,sizeof(MMIBROWSER_UA_T));
        MMINV_READ(MMINV_BROWSER_UA,&wap_ua,return_value);
        if (return_value==MN_RETURN_SUCCESS)
        {
            wap_ua_len = strlen((char *)(wap_ua.uaprofile));

            MMI_STRNTOWSTR( wstr, MMIBROWSER_MAX_URL_LEN, wap_ua.uaprofile, wap_ua_len, wap_ua_len );

            GUIEDIT_SetString(editbox_ctrl_id,
                                            wstr,
                                            wap_ua_len
                                            );
        }
        else
        {
            GUIEDIT_ClearAllStr(editbox_ctrl_id);
        }
        MMK_SetAtvCtrl(win_id,editbox_ctrl_id);
        break;

    case MSG_APP_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK: 
    case MSG_APP_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        //save to nv
        SCI_MEMSET(&string_info,0,sizeof(MMI_STRING_T));
        GUIEDIT_GetString(
                                    editbox_ctrl_id,
                                    &string_info);

        MMI_WSTRNTOSTR( wap_ua.uaprofile, MMIBROWSER_MAX_URL_LEN, string_info.wstr_ptr, string_info.wstr_len, string_info.wstr_len );
        
        MMIBRW_SetUAProfile( wap_ua.uaprofile, string_info.wstr_len);
        MMK_CloseWin(win_id);
        break;

    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

/********************************************************************************
 NAME:          EngWapUAWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        
 DATE:      
********************************************************************************/
LOCAL MMI_RESULT_E EngWapUAWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMIBROWSER_UA_T     wap_ua={0};
    MMI_CTRL_ID_T       editbox_ctrl_id = MMIENG_WAPUA_CTRL_ID;
    MMI_RESULT_E        result = MMI_RESULT_TRUE;
    MN_RETURN_RESULT_E  return_value = MN_RETURN_FAILURE;
    MMI_STRING_T string_info = {0};
    uint16              wap_ua_len = 0;
    wchar wstr[MMIBROWSER_MAX_URL_LEN + 1] = {0};

    switch (msg_id)
    {
    case MSG_OPEN_WINDOW:
        //set im
        GUIEDIT_SetIm(editbox_ctrl_id,
            GUIIM_TYPE_ENGLISH|GUIIM_TYPE_ABC|GUIIM_TYPE_DIGITAL,
            GUIIM_TYPE_ENGLISH);

        SCI_MEMSET(&wap_ua,0,sizeof(MMIBROWSER_UA_T));
        MMINV_READ(MMINV_BROWSER_UA,&wap_ua,return_value);
        if (return_value==MN_RETURN_SUCCESS)
        {
            wap_ua_len = strlen((char *)(wap_ua.user_agent));

            MMI_STRNTOWSTR( wstr, MMIBROWSER_MAX_URL_LEN, wap_ua.user_agent, wap_ua_len, wap_ua_len );

            GUIEDIT_SetString(editbox_ctrl_id,
                                            wstr,
                                            wap_ua_len
                                            );
        }
        else
        {
            GUIEDIT_ClearAllStr(editbox_ctrl_id);
        }
        MMK_SetAtvCtrl(win_id,editbox_ctrl_id);
        break;

    
    case MSG_APP_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
    case MSG_APP_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        //save to nv
        SCI_MEMSET(&string_info,0,sizeof(MMI_STRING_T));
        GUIEDIT_GetString(
                                    editbox_ctrl_id,
                                    &string_info);

        MMI_WSTRNTOSTR( wap_ua.user_agent, MMIBROWSER_MAX_URL_LEN, string_info.wstr_ptr, string_info.wstr_len, string_info.wstr_len );

        MMIBRW_SetUA( wap_ua.user_agent, string_info.wstr_len);
        MMK_CloseWin(win_id);
        break;

    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

/********************************************************************************
 NAME:          EngWapMmsSasTestModeWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        hui.zhao
 DATE:          
********************************************************************************/
LOCAL MMI_RESULT_E EngWapMmsSasTestModeWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_LISTBOX_CTRL_ID;
    uint16 cur_selection = 0;
    BOOLEAN is_test_mode_open = FALSE;
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        GUILIST_SetMaxItem(ctrl_id,MMISET_OPEN_CLOSE_ITEM, FALSE );//max item 2
        //GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
        MMIAPISET_AppendListItemByTextIdExt(TXT_OPEN_COMN,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_ONE_LINE_RADIO);
        MMIAPISET_AppendListItemByTextIdExt(TXT_COMM_CLOSE,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_ONE_LINE_RADIO);  
        
        if (MMIAPIENG_GetWapMmsSasTestMode())
        {
            cur_selection = 0;
        }
        else
        {
            cur_selection = 1;
        }
        
        //set selected item
        GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
        
        //set current item
        GUILIST_SetCurItemIndex(ctrl_id,cur_selection);
        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;
        
    case MSG_FULL_PAINT:
        break;
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_KEYDOWN_OK:
        break;  
        
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;

    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
        if (0 == cur_selection)
        {
            is_test_mode_open = TRUE;
        }
        else
        {
            is_test_mode_open = FALSE;
        }     
        SetWapMmsSasTestMode(is_test_mode_open);
        MMIPUB_OpenAlertSuccessWin(TXT_COMPLETE);      
        MMK_CloseWin( win_id );
        break;

    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

/********************************************************************************
 NAME:          SetWapMmsSasTestMode
 DESCRIPTION:   
 PARAM IN:      
 PARAM OUT:     
 AUTHOR:        hui.zhao
 DATE:          2009.07.27
********************************************************************************/
LOCAL BOOLEAN SetWapMmsSasTestMode(BOOLEAN is_on)
{
    MMINV_WRITE(MMIENG_NV_WAPMMS_SAS_TEST_MODE_ID, &is_on);

    return TRUE;
}
#endif

/********************************************************************************
 NAME:          BtAddressInfoWinHandle
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        
 DATE:      
********************************************************************************/
LOCAL MMI_RESULT_E BtAddressInfoWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E        result = MMI_RESULT_TRUE;

#ifdef  BLUETOOTH_SUPPORT
    
    MMI_STRING_T        address_info_str = {0};
    BT_ADDRESS          device_addr = {0};
    uint8               addr_str[MMIENG_ADDR_INFO_MAX_LEN] = {0};
    wchar               addr_wstr[MMIENG_ADDR_INFO_MAX_LEN] = {0};    
    MMI_CTRL_ID_T       ctrl_id = MMIENG_BTADDRESS_CTRL_ID;  

    switch (msg_id)
    {
    case MSG_OPEN_WINDOW:               
        MMIAPIBT_GetAddress(&device_addr);
        sprintf((char *)addr_str, "%02x:%02x:%02x:%02x:%02x:%02x",device_addr.addr[5],device_addr.addr[4],device_addr.addr[3],
        device_addr.addr[2],device_addr.addr[1],device_addr.addr[0]);
        address_info_str.wstr_len = MIN(strlen((char *)addr_str), MMIENG_ADDR_INFO_MAX_LEN);/*lint !e666*/
        address_info_str.wstr_ptr = addr_wstr;
        MMI_STRNTOWSTR(address_info_str.wstr_ptr, MMIENG_ADDR_INFO_MAX_LEN, addr_str, MMIENG_ADDR_INFO_MAX_LEN, address_info_str.wstr_len);
        //address_info_str.is_ucs2 = FALSE;
        GUITEXT_SetString(ctrl_id,address_info_str.wstr_ptr, address_info_str.wstr_len, FALSE);
        MMK_SetAtvCtrl(win_id,ctrl_id);
        GUIWIN_SetSoftkeyTextId(win_id,  (MMI_TEXT_ID_T)TXT_NULL, (MMI_TEXT_ID_T)TXT_NULL, (MMI_TEXT_ID_T)STXT_RETURN, FALSE);
        break;


    case MSG_CTL_CANCEL:
    case MSG_APP_CANCEL:
        MMK_CloseWin(win_id);
        break;
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }

#endif
    
    return (result);
}
#ifdef BLUETOOTH_SUPPORT
/********************************************************************************
 NAME:          BtAddressInfoWinHandle
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        
 DATE:      
********************************************************************************/
LOCAL MMI_RESULT_E BtVerInfoWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E        result = MMI_RESULT_TRUE;

#ifdef  BLUETOOTH_SUPPORT
    int32                        len = 0;
    char*            bt_version_info = PNULL;
    wchar*                     dst_ptr = PNULL;
    MMI_CTRL_ID_T       ctrl_id = MMIENG_BTADDRESS_CTRL_ID;

    switch (msg_id)
    {
    case MSG_OPEN_WINDOW:
        #ifdef WIN32
           bt_version_info = "host:15.36P11 controller:";
        #else
            bt_version_info = SCI_GetBTVersionInfo();
        #endif
        len = strlen(bt_version_info);
		dst_ptr =SCI_ALLOC_APP((len+1)*sizeof(wchar));
		SCI_MEMSET(dst_ptr,0,((len+1)*sizeof(wchar)));
		MMIAPICOM_StrToWstr(bt_version_info, dst_ptr);
		GUITEXT_SetString(ctrl_id,dst_ptr, len, FALSE);
		SCI_FREE(dst_ptr);
		MMK_SetAtvCtrl(win_id,ctrl_id);
		GUIWIN_SetSoftkeyTextId(win_id,  (MMI_TEXT_ID_T)TXT_NULL, (MMI_TEXT_ID_T)TXT_NULL, (MMI_TEXT_ID_T)STXT_RETURN, FALSE);
		break;


    case MSG_CTL_CANCEL:
    case MSG_APP_CANCEL:
        MMK_CloseWin(win_id);
        break;
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }

#endif
    
    return (result);
}
/********************************************************************************
 NAME:          BTBQBModeWinHandleMsg   
 AUTHOR:        Leon.Wang
 DATE:          2012.12.4
********************************************************************************/
LOCAL MMI_RESULT_E BTBQBModeWinHandleMsg(MMI_WIN_ID_T win_id, 
										MMI_MESSAGE_ID_E msg_id, 
										DPARAM param)
{
	MMI_RESULT_E  result = MMI_RESULT_TRUE;
#ifdef BLUETOOTH_SUPPORT
    MMI_CTRL_ID_T ctrl_id = MMIENG_LISTBOX_CTRL_ID;
    uint16        cur_selection = 0;
	BOOLEAN       bqb_state = FALSE;
	BT_STATUS     ret_code = BT_SUCCESS;
	MMI_STRING_T  error_info = {0};
	char          error_txt[50] = {0};
	wchar         error_wtxt[50] = {0};
#ifndef WIN32
	bqb_state = UART_GetControllerBqbMode();
#endif
    switch (msg_id) 
    {
	case MSG_OPEN_WINDOW:
		GUILIST_SetMaxItem(ctrl_id,MMISET_OPEN_CLOSE_ITEM, FALSE );//max item 2
		GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
		MMIAPISET_AppendListItemByTextIdExt(TXT_OPEN_COMN,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
		MMIAPISET_AppendListItemByTextIdExt(TXT_COMM_CLOSE,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);  
		
		if (!bqb_state)
		{
			cur_selection = 1;
		}		
		GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
		GUILIST_SetCurItemIndex(ctrl_id,cur_selection);
		MMK_SetAtvCtrl(win_id,ctrl_id);
		break;
		
	case MSG_FULL_PAINT:
		break;
		
	case MSG_KEYDOWN_CANCEL:
	case MSG_KEYDOWN_OK:
		break;
		
	case MSG_CTL_CANCEL:
		MMK_CloseWin(win_id);
		break;
		
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
	case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
	case MSG_CTL_MIDSK:
	case MSG_CTL_OK:
	case MSG_APP_WEB:
		cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
#ifndef WIN32
		if (0 == cur_selection && !bqb_state)
		{
            UART_SetControllerBqbMode(TRUE);
		}
		else if(1 == cur_selection && bqb_state)
		{
            UART_SetControllerBqbMode(FALSE);
		}
#endif
		MMK_CloseWin(win_id);
		break;
		
	default:
		result = MMI_RESULT_FALSE;
		break;
    }

#endif
	return result;
}
/********************************************************************************
 NAME:          EngBTopenBQPModeWin   
 AUTHOR:        Leon.Wang
 DATE:          2012.12.4
********************************************************************************/
PUBLIC void EngBTopenBQBModeWin(void)
{
    MMK_CreateWin((uint32*)MMIENG_BT_BQB_MODE_TAB, PNULL);
}
/********************************************************************************
 NAME:          EngBTopenBQPModeWin   
 AUTHOR:        Leon.Wang
 DATE:          2012.12.4
********************************************************************************/
PUBLIC void EngBTopenNOSIGNALTESTModeWin(void)
{
    if (TRUE == BT_GetState())
    {
    #ifndef WIN32
        _stop_bt();
    #endif
    }
    else
    {
    #ifndef WIN32
        _start_bt();//turn on bt
    #endif
    }
	MMK_CreateWin((uint32*)MMIENG_BT_NOSIGNAL_TEST_TAB, PNULL);
}
PUBLIC void EngBTopenVerInfoWin(void)
{
	MMK_CreateWin((uint32*)MMIENG_BT_VER_INFO_TAB, PNULL);
}
#endif
/*********************************************************************************/
#define  TX_LE_PHY_NUM   4
#define  TX_PAC_PAYLOAD_NUM   8
#define  TX_PATTERN_NUM   5
#define  TX_PAC_TYPE_NUM   30
#define  TX_POWER_TYPE_NUM   2
#define  TX_PARAM_LEN   32
#define  RX_MODE_INDEX_NUM  2
#define  RX_LE_PHY_NUM  3
BT_NONSIG_PARAM   TX_data = {0};
BT_NONSIG_PARAM   RX_data = {0};

BT_NONSIG_PARAM   BLE_TX_data = {0};
BT_NONSIG_PARAM   BLE_RX_data = {0};

BT_ADDRESS           RXaddr = {0};
BT_ADDRESS           BLE_RXaddr = {0};
BT_NONSIG_DATA     RX_data_show = {0};
BT_NONSIGCALLBACK RXcallback;

MMI_TEXT_ID_T  tx_le_phy[TX_LE_PHY_NUM] = {TXT_BT_NOSIGNAL_LE_PHY1,TXT_BT_NOSIGNAL_LE_PHY2,TXT_BT_NOSIGNAL_LE_PHY3,TXT_BT_NOSIGNAL_LE_PHY4};

MMI_TEXT_ID_T  tx_pac_payload[TX_PAC_PAYLOAD_NUM] = {TXT_BT_NOSIGNAL_PAC_PAYLOAD1,TXT_BT_NOSIGNAL_PATTERN5,
	TXT_BT_NOSIGNAL_PATTERN3,TXT_BT_NOSIGNAL_PAC_PAYLOAD4,TXT_BT_NOSIGNAL_PATTERN2,TXT_BT_NOSIGNAL_PATTERN1,
	TXT_BT_NOSIGNAL_PAC_PAYLOAD3,TXT_BT_NOSIGNAL_PAC_PAYLOAD2};

MMI_TEXT_ID_T tx_pattern[TX_PATTERN_NUM] = {TXT_BT_NOSIGNAL_PATTERN1, TXT_BT_NOSIGNAL_PATTERN2,
	TXT_BT_NOSIGNAL_PATTERN3,TXT_BT_NOSIGNAL_PATTERN4,TXT_BT_NOSIGNAL_PATTERN5};

MMI_TEXT_ID_T ble_tx_pattern[] = {TXT_BT_NOSIGNAL_PATTERN4, TXT_BT_NOSIGNAL_PATTERN5,
                                  TXT_BT_NOSIGNAL_PATTERN3, TXT_BT_NOSIGNAL_PAC_PAYLOAD4, TXT_BT_NOSIGNAL_PATTERN2, TXT_BT_NOSIGNAL_PATTERN1,
                                  TXT_BT_NOSIGNAL_PAC_PAYLOAD3, TXT_BT_NOSIGNAL_PAC_PAYLOAD2
                                  };

MMI_TEXT_ID_T BT_pac_type[TX_PAC_TYPE_NUM] = {TXT_BT_NOSIGNAL_PAC_TYPE1, TXT_BT_NOSIGNAL_PAC_TYPE2,
	TXT_BT_NOSIGNAL_PAC_TYPE3,TXT_BT_NOSIGNAL_PAC_TYPE4,TXT_BT_NOSIGNAL_PAC_TYPE5,TXT_BT_NOSIGNAL_PAC_TYPE6,
	TXT_BT_NOSIGNAL_PAC_TYPE7,TXT_BT_NOSIGNAL_PAC_TYPE8,TXT_BT_NOSIGNAL_PAC_TYPE9,TXT_BT_NOSIGNAL_PAC_TYPE10,
	TXT_BT_NOSIGNAL_PAC_TYPE11,TXT_BT_NOSIGNAL_PAC_TYPE12,TXT_BT_NOSIGNAL_PAC_TYPE13,TXT_BT_NOSIGNAL_PAC_TYPE14,
	TXT_BT_NOSIGNAL_PAC_TYPE15,TXT_BT_NOSIGNAL_PAC_TYPE16,TXT_BT_NOSIGNAL_PAC_TYPE17,TXT_BT_NOSIGNAL_PAC_TYPE18,
	TXT_BT_NOSIGNAL_PAC_TYPE19,TXT_BT_NOSIGNAL_PAC_TYPE20,TXT_BT_NOSIGNAL_PAC_TYPE21,TXT_BT_NOSIGNAL_PAC_TYPE22,
	TXT_BT_NOSIGNAL_PAC_TYPE23,TXT_BT_NOSIGNAL_PAC_TYPE24,TXT_BT_NOSIGNAL_PAC_TYPE25,TXT_BT_NOSIGNAL_PAC_TYPE26,
	TXT_BT_NOSIGNAL_PAC_TYPE27,TXT_BT_NOSIGNAL_PAC_TYPE28,TXT_BT_NOSIGNAL_PAC_TYPE29,TXT_BT_NOSIGNAL_PAC_TYPE30};

MMI_TEXT_ID_T tx_power_type[TX_POWER_TYPE_NUM] = {TXT_BT_NOSIGNAL_POWER_TYPE0,TXT_BT_NOSIGNAL_POWER_TYPE1};
char tx_power_type_num[TX_POWER_TYPE_NUM] = {0,1};

MMI_TEXT_ID_T rx_mod_index[RX_MODE_INDEX_NUM] = {TXT_BT_NOSIGNAL_MOD_INDEX1,TXT_BT_NOSIGNAL_MOD_INDEX2};
MMI_TEXT_ID_T rx_le_phy[RX_LE_PHY_NUM] = {TXT_BT_NOSIGNAL_LE_PHY1,TXT_BT_NOSIGNAL_LE_PHY2,TXT_BT_NOSIGNAL_LE_PHY5};

uint8 tx_pattern_value[TX_PATTERN_NUM] = {1, 2,3,4,9};

uint16 tx_pac_len[TX_PAC_TYPE_NUM] ={0,0,18,17,27,10,20,30,9,29,121,183,120,180,224,339,0,0,54,30,60,90,83,29,367,552,360,540,679,1021};
uint16 BT_pac_lvalue[TX_PAC_TYPE_NUM] ={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,20,22,21,23,24,25,26,27,28,29,30,31};

/*********************************************************************************/

#ifdef BLUETOOTH_SUPPORT
/********************************************************************************
 NAME:          EngBTNoSignalTestWinHandleMsg
 DESCRIPTION:  display bt input para 
 PARAM IN:      win_id -  msg_id -  param - 
 PARAM OUT:     
 AUTHOR:        chao.chen
 DATE:          2015.11.30
********************************************************************************/
LOCAL MMI_RESULT_E EngBTNoSignalTestWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
	MMI_RESULT_E  result = MMI_RESULT_TRUE;

	MMI_CTRL_ID_T ctrl_id = MMIENG_BT_NOSIGNAL_TESTCTRL_ID;
	uint16        cur_selection = 0;
	BOOLEAN       ssp_state = FALSE;
	BT_STATUS     ret_code = BT_SUCCESS;
	MMI_STRING_T  error_info = {0};
	char          error_txt[50] = {0};
	wchar         error_wtxt[50] = {0};
	switch (msg_id) 
	{
	case MSG_OPEN_WINDOW:
    {
        if (TRUE == BT_GetState())
        {
#ifndef WIN32
            _start_bt();//turn on bt
#endif
        }

		GUILIST_SetMaxItem(ctrl_id,4, FALSE );//max item 4
		GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
		MMIENGSET_AppendListItemByTextIdExt(TXT_ENG_ENTER_BT_NOSIGNAL_TX,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1STR_ENG);
		MMIENGSET_AppendListItemByTextIdExt(TXT_ENG_ENTER_BT_NOSIGNAL_RX,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1STR_ENG);  
		MMIENGSET_AppendListItemByTextIdExt(TXT_ENG_ENTER_BT_NOSIGNAL_BLE_TX,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1STR_ENG);
		MMIENGSET_AppendListItemByTextIdExt(TXT_ENG_ENTER_BT_NOSIGNAL_BLE_RX,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1STR_ENG);  
		
		GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
		GUILIST_SetCurItemIndex(ctrl_id,cur_selection);
		MMK_SetAtvCtrl(win_id,ctrl_id);
    }
		break;
		
	case MSG_FULL_PAINT:
		break;

		
#ifdef TOUCH_PANEL_SUPPORT 
	case MSG_CTL_PENOK:
#endif 
	case MSG_CTL_MIDSK:
	case MSG_CTL_OK:
	case MSG_APP_WEB:
		cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
		switch(cur_selection)
		{
			case 0:
				MMK_CreateWin((uint32*)MMIENG_BT_NOSIGNAL_TX_TAB, PNULL);
				break;
			case 1:
				MMK_CreateWin((uint32*)MMIENG_BT_NOSIGNAL_RX_TAB, PNULL);
				break;
			case 2:
				MMK_CreateWin((uint32*)MMIENG_BT_NOSIGNAL_BLE_TX_TAB, PNULL);
				break;
			case 3:
				MMK_CreateWin((uint32*)MMIENG_BT_NOSIGNAL_BLE_RX_TAB, PNULL);
				break;
			default:
				//SCI_TraceLow("[ENG] error unknown select [%s] [%d] ",__FUNCTION__,__LINE__);
				break;
		}
		break;

	case MSG_CTL_CANCEL:    
	case MSG_APP_CANCEL:
        if (TRUE == BT_GetState())
        {
#ifndef WIN32
            _stop_bt();
#endif
        }
        MMK_CloseWin(win_id);
		break;
		
	default:
		result = MMI_RESULT_FALSE;
		break;
    }

	return result;
}
#endif
#ifdef BT_BLE_SUPPORT
/********************************************************************************
 NAME:          BT_GetTXParam
 DESCRIPTION:  display bt input para 
 PARAM IN:      win_id -  msg_id -  param - 
 PARAM OUT:     
 AUTHOR:        chao.chen
 DATE:          2015.11.30
********************************************************************************/
LOCAL void BT_GetTXParam(void)
{
    char buf [TX_PARAM_LEN]={0};
	MMI_STRING_T        pattern_str   = {0};
	MMI_STRING_T        channel_str = {0};
	MMI_STRING_T        pac_type_str  = {0};
	MMI_STRING_T        power_type_str  = {0};
	MMI_STRING_T        tx_power_value  = {0};
	MMI_STRING_T        tx_pac_cnt  = {0};
	uint16   cur_pattern_index = 0;
	uint16   cur_pac_type_index = 0;
	uint16   cur_pow_type_index = 0;

	//setlist
	cur_pattern_index =  GUISETLIST_GetCurIndex(MMIENG_BT_NOSIGNAL_EDIT_CTRL1_ID);
	cur_pac_type_index =  GUISETLIST_GetCurIndex(MMIENG_BT_NOSIGNAL_EDIT_CTRL3_ID);
	cur_pow_type_index =  GUISETLIST_GetCurIndex(MMIENG_BT_NOSIGNAL_EDIT_CTRL4_ID);	
	SCI_MEMSET(&TX_data, 0, sizeof(BT_NONSIG_PARAM));

    //paterrn
	MMI_GetLabelTextByLang(tx_pattern[cur_pattern_index], &pattern_str);
	SCI_MEMSET(buf,0,TX_PARAM_LEN);
	MMI_WSTRNTOSTR((uint8*)buf, TX_PARAM_LEN, pattern_str.wstr_ptr, pattern_str.wstr_len,MIN(TX_PARAM_LEN,pattern_str.wstr_len));
	TX_data.pattern = tx_pattern_value[cur_pattern_index];

    //tx channel
	GUIEDIT_GetString(MMIENG_BT_NOSIGNAL_EDIT_CTRL2_ID, &channel_str);
	SCI_MEMSET(buf,0,TX_PARAM_LEN);
	MMI_WSTRNTOSTR((uint8*)buf, TX_PARAM_LEN, channel_str.wstr_ptr, channel_str.wstr_len,MIN(TX_PARAM_LEN,channel_str.wstr_len));
	TX_data.channel =  atoi(buf);

    //tx pac type
	MMI_GetLabelTextByLang(BT_pac_type[cur_pac_type_index], &pac_type_str);
	SCI_MEMSET(buf,0,TX_PARAM_LEN);
	MMI_WSTRNTOSTR((uint8*)buf, TX_PARAM_LEN, pac_type_str.wstr_ptr, pac_type_str.wstr_len,MIN(TX_PARAM_LEN,pac_type_str.wstr_len));
	TX_data.pac.pac_type = BT_pac_lvalue[cur_pac_type_index];
	//tx pac len
	TX_data.pac.pac_len =tx_pac_len[cur_pac_type_index];

    //tx power type
	TX_data.item.power.power_type = cur_pow_type_index;

    //tx power value
	GUIEDIT_GetString(MMIENG_BT_NOSIGNAL_EDIT_CTRL5_ID, &tx_power_value);
	SCI_MEMSET(buf,0,TX_PARAM_LEN);
	MMI_WSTRNTOSTR((uint8*)buf, TX_PARAM_LEN, tx_power_value.wstr_ptr, tx_power_value.wstr_len,MIN(TX_PARAM_LEN,tx_power_value.wstr_len));
	TX_data.item.power.power_value = atoi(buf);
    //tx pac cnt
	GUIEDIT_GetString(MMIENG_BT_NOSIGNAL_EDIT_CTRL6_ID, &tx_pac_cnt);
	SCI_MEMSET(buf,0,TX_PARAM_LEN);
	MMI_WSTRNTOSTR((uint8*)buf, TX_PARAM_LEN, tx_pac_cnt.wstr_ptr, tx_pac_cnt.wstr_len,MIN(TX_PARAM_LEN,tx_pac_cnt.wstr_len));
	TX_data.pac.pac_cnt = atoi(buf);
}

/********************************************************************************
 NAME:          BT_GetTXParam
 DESCRIPTION:  display bt input para 
 PARAM IN:      win_id -  msg_id -  param - 
 PARAM OUT:     
 AUTHOR:        chao.chen
 DATE:          2015.11.30
********************************************************************************/
LOCAL void ENGBT_GetBLETXParam(void)
{   
	uint32 uiCurrentIndex = 0;
	MMI_STRING_T		temp_wstr   = {0};
	char buf [TX_PARAM_LEN]={0};

	//LE_PHY
	uiCurrentIndex = GUISETLIST_GetCurIndex(MMIENG_BT_NOSIGNAL_EDIT_CTRL8_ID);
    BLE_TX_data.le_phy = uiCurrentIndex + 1;

	//Pac Payload
	uiCurrentIndex = GUISETLIST_GetCurIndex(MMIENG_BT_NOSIGNAL_EDIT_CTRL9_ID);
    BLE_TX_data.pac.pac_type = uiCurrentIndex;

	//Pattern
	uiCurrentIndex = GUISETLIST_GetCurIndex(MMIENG_BT_NOSIGNAL_EDIT_CTRL1_ID);
    BLE_TX_data.pattern = uiCurrentIndex;

	//Channel
	GUIEDIT_GetString(MMIENG_BT_NOSIGNAL_EDIT_CTRL2_ID, &temp_wstr);
	SCI_MEMSET(buf,0,TX_PARAM_LEN);
	MMI_WSTRNTOSTR((uint8*)buf, TX_PARAM_LEN, temp_wstr.wstr_ptr, temp_wstr.wstr_len,MIN(TX_PARAM_LEN,temp_wstr.wstr_len));
    BLE_TX_data.channel = atoi(buf);

	//Data length
	GUIEDIT_GetString(MMIENG_BT_NOSIGNAL_EDIT_CTRL10_ID, &temp_wstr);
	SCI_MEMSET(buf,0,TX_PARAM_LEN);
	MMI_WSTRNTOSTR((uint8*)buf, TX_PARAM_LEN, temp_wstr.wstr_ptr, temp_wstr.wstr_len,MIN(TX_PARAM_LEN,temp_wstr.wstr_len));
#if defined (PLATFORM_ANTISW3)
    MMI_WSTRNTOSTR((uint8*)buf, TX_PARAM_LEN, temp_wstr.wstr_ptr, temp_wstr.wstr_len,MIN(TX_PARAM_LEN,temp_wstr.wstr_len));
    BLE_TX_data.pac.pac_cnt = atoi(buf);//ANTISW3 use this value as BLE TX Data Length
#endif

	//Pac Type
	uiCurrentIndex = GUISETLIST_GetCurIndex(MMIENG_BT_NOSIGNAL_EDIT_CTRL3_ID);
	MMI_GetLabelTextByLang(tx_power_type[uiCurrentIndex], &temp_wstr);
	SCI_MEMSET(buf,0,TX_PARAM_LEN);
	MMI_WSTRNTOSTR((uint8*)buf, TX_PARAM_LEN, temp_wstr.wstr_ptr, temp_wstr.wstr_len,MIN(TX_PARAM_LEN,temp_wstr.wstr_len));
	//tx_power_type_num[uiCurrentIndex];

	//Pac Len 
	GUIEDIT_GetString(MMIENG_BT_NOSIGNAL_EDIT_CTRL7_ID, &temp_wstr);
	SCI_MEMSET(buf,0,TX_PARAM_LEN);
	MMI_WSTRNTOSTR((uint8*)buf, TX_PARAM_LEN, temp_wstr.wstr_ptr, temp_wstr.wstr_len,MIN(TX_PARAM_LEN,temp_wstr.wstr_len));

	//Power Type
	uiCurrentIndex = GUISETLIST_GetCurIndex(MMIENG_BT_NOSIGNAL_EDIT_CTRL4_ID);
    BLE_TX_data.item.power.power_type = uiCurrentIndex;

	//Power Value 
	GUIEDIT_GetString(MMIENG_BT_NOSIGNAL_EDIT_CTRL5_ID, &temp_wstr);
	SCI_MEMSET(buf,0,TX_PARAM_LEN);
	MMI_WSTRNTOSTR((uint8*)buf, TX_PARAM_LEN, temp_wstr.wstr_ptr, temp_wstr.wstr_len,MIN(TX_PARAM_LEN,temp_wstr.wstr_len));
    BLE_TX_data.item.power.power_value = atoi(buf);

	//Pac Cnt
	GUIEDIT_GetString(MMIENG_BT_NOSIGNAL_EDIT_CTRL6_ID, &temp_wstr);
	SCI_MEMSET(buf,0,TX_PARAM_LEN);
	MMI_WSTRNTOSTR((uint8*)buf, TX_PARAM_LEN, temp_wstr.wstr_ptr, temp_wstr.wstr_len,MIN(TX_PARAM_LEN,temp_wstr.wstr_len));
#if defined (PLATFORM_ANTISW3)
    //do not se this value in ANTISW3
#else
    MMI_WSTRNTOSTR((uint8*)buf, TX_PARAM_LEN, temp_wstr.wstr_ptr, temp_wstr.wstr_len,MIN(TX_PARAM_LEN,temp_wstr.wstr_len));
    BLE_TX_data.pac.pac_cnt = atoi(buf);
#endif
}
#endif


/********************************************************************************
 NAME:          StringToADDR
 DESCRIPTION:  display bt input para 
 PARAM IN:      win_id -  msg_id -  param - 
 PARAM OUT:     
 AUTHOR:        chao.chen
 DATE:          2015.11.30
********************************************************************************/
LOCAL BT_ADDRESS StringToADDR(uint8 input[12])
{
       uint16  i = 0;
       for( i = 0; i < 12; i++ )
	{
		if(input[i] >= 48 && input[i] <= 57)     //”0” C “9”
		{
			input[i] -= 0x30;
		}

		else if(input[i] >= 65 && input[i] <= 70)     //”A” C “F”
		{
			input[i] -= 0x37;
		}
		else if(input[i] >= 97 && input[i] <= 102)    //”a” C “f”
		{
			input[i] -= 0x57;
		}
	}
 
	for( i = 0; i < 6; i++)
	{
	       RXaddr.addr[i] = input[2*i]*16 + input[2*i+1];
	}
	
      return RXaddr;
}


/********************************************************************************
 NAME:          BT_GetRXParam
 DESCRIPTION:  display bt input para 
 PARAM IN:      win_id -  msg_id -  param - 
 PARAM OUT:     
 AUTHOR:        chao.chen
 DATE:          2015.11.30
********************************************************************************/
LOCAL void BT_GetRXParam(void)
{

	int i = 0;
	uint8               addr_str[MMIENG_ADDR_INFO_MAX_LEN] = {0};
	wchar               addr_wstr[MMIENG_ADDR_INFO_MAX_LEN] = {0};
	wchar               buf [TX_PARAM_LEN] = {0};
	MMI_STRING_T        channel_str        = {0};
	MMI_STRING_T        pac_type_str       = {0};
	MMI_STRING_T        rain_str           = {0};
	MMI_STRING_T        add_str            = {0};
	uint16       cur_pac_type_index        = 0;
	uint8             addr_temp[12]        = {0};


    //channel
	GUIEDIT_GetString(MMIENG_BT_NOSIGNAL_EDIT_CTRL7_ID, &channel_str);
	SCI_MEMSET(buf,0,TX_PARAM_LEN);
	MMI_WSTRNTOSTR((uint8*)buf, TX_PARAM_LEN, channel_str.wstr_ptr, channel_str.wstr_len,MIN(TX_PARAM_LEN,channel_str.wstr_len));
	RX_data.channel  =  atoi(buf);

    //pac type
	cur_pac_type_index =  GUISETLIST_GetCurIndex(MMIENG_BT_NOSIGNAL_EDIT_CTRL8_ID);
	MMI_GetLabelTextByLang(BT_pac_type[cur_pac_type_index], &pac_type_str);
	SCI_MEMSET(buf,0,TX_PARAM_LEN);
	MMI_WSTRNTOSTR((uint8*)buf, TX_PARAM_LEN, pac_type_str.wstr_ptr, pac_type_str.wstr_len,MIN(TX_PARAM_LEN,pac_type_str.wstr_len));
	RX_data.pac.pac_type = BT_pac_lvalue[cur_pac_type_index];

    //RX Gain
	GUIEDIT_GetString(MMIENG_BT_NOSIGNAL_EDIT_CTRL9_ID, &rain_str);
	SCI_MEMSET(buf,0,TX_PARAM_LEN);
	MMI_WSTRNTOSTR((uint8*)buf, TX_PARAM_LEN, rain_str.wstr_ptr, rain_str.wstr_len,MIN(TX_PARAM_LEN,rain_str.wstr_len));
	RX_data.item.rx_gain = atoi(buf);

    //default vaule
	RX_data.pattern =7;
	RX_data.pac.pac_len = 0;
	RX_data.pac.pac_cnt = 0;
	
    //RX addrss	
	GUIEDIT_GetString(MMIENG_BT_NOSIGNAL_EDIT_CTRL10_ID, &add_str);
	SCI_MEMSET(addr_temp,0,12);
	MMI_WSTRNTOSTR((uint8*)addr_temp, TX_PARAM_LEN, add_str.wstr_ptr, add_str.wstr_len,MIN(TX_PARAM_LEN,add_str.wstr_len));

	StringToADDR(addr_temp);

	SCI_TRACE_LOW("BT_GetRXParam RXaddr_addr : RXaddr.addr[0]  %d, RXaddr.addr[1]  %d, RXaddr.addr[2]  %d, RXaddr.addr[3]  %d, RXaddr.addr[4]  %d, RXaddr.addr[5]  %d", 
		RXaddr.addr[0], RXaddr.addr[1], RXaddr.addr[2], RXaddr.addr[3], RXaddr.addr[4], RXaddr.addr[5]);

}

LOCAL void MMIENG_StringToADDR(uint8 input[12],uint8 size,uint8* output)
{
	uint8 i =0;
	for( i = 0; i < size; i++ )
	{
		if(input[i] >= 48 && input[i] <= 57)	 //”0” C “9”
		{
			input[i] -= 0x30;
		}
		else if(input[i] >= 65 && input[i] <= 70)	  //”A” C “F”
		{
			input[i] -= 0x37;
		}
		else if(input[i] >= 97 && input[i] <= 102)	  //”a” C “f”
		{
			input[i] -= 0x57;
		}
	}

	for( i = 0; i < (size/2); i++)
	{
		  output[i] = input[2*i]*16 + input[2*i+1];
	}
}

/********************************************************************************
 NAME:          ENGBT_GetBLERXParam
 DESCRIPTION:  display bt input para 
 PARAM IN:      win_id -  msg_id -  param - 
 PARAM OUT:     
 AUTHOR:        chao.chen
 DATE:          2015.11.30
********************************************************************************/
LOCAL void ENGBT_GetBLERXParam(void)
{
#ifdef  PLATFORM_ANTISW3

	int i;
	uint32                uiCurIndex = 0;
	MMI_STRING_T          temp_wstr  = {0};
	char                  buf [TX_PARAM_LEN]={0};
	uint32                uiAddr = 0;

    //Mod Index
	uiCurIndex =  GUISETLIST_GetCurIndex(MMIENG_BT_NOSIGNAL_EDIT_CTRL1_ID);
    BLE_RX_data.le_rx_mod_index = uiCurIndex;

	//LE PHY
	uiCurIndex =  GUISETLIST_GetCurIndex(MMIENG_BT_NOSIGNAL_EDIT_CTRL2_ID);
    BLE_RX_data.le_phy = uiCurIndex+1;

	//Channel
	GUIEDIT_GetString(MMIENG_BT_NOSIGNAL_EDIT_CTRL7_ID, &temp_wstr);
	SCI_MEMSET(buf,0,TX_PARAM_LEN);
	MMI_WSTRNTOSTR((uint8*)buf, TX_PARAM_LEN, temp_wstr.wstr_ptr, temp_wstr.wstr_len,MIN(TX_PARAM_LEN,temp_wstr.wstr_len));
    BLE_RX_data.channel = atoi(buf);

	//Pac Type
	uiCurIndex =  GUISETLIST_GetCurIndex(MMIENG_BT_NOSIGNAL_EDIT_CTRL8_ID);
    BLE_RX_data.pac.pac_type = BT_pac_lvalue[uiCurIndex];

	//Gain
	GUIEDIT_GetString(MMIENG_BT_NOSIGNAL_EDIT_CTRL9_ID, &temp_wstr);
	SCI_MEMSET(buf,0,TX_PARAM_LEN);
	MMI_WSTRNTOSTR((uint8*)buf, TX_PARAM_LEN, temp_wstr.wstr_ptr, temp_wstr.wstr_len,MIN(TX_PARAM_LEN,temp_wstr.wstr_len));
    BLE_RX_data.item.rx_gain = atoi(buf);

	//Addr
	#if 0//ndef WIN32
	if (3 != BTI_BtChipId())
    #endif
    {
        GUIEDIT_GetString(MMIENG_BT_NOSIGNAL_EDIT_CTRL10_ID, &temp_wstr);
        SCI_MEMSET(buf,0,TX_PARAM_LEN);
        MMI_WSTRNTOSTR((uint8*)buf, TX_PARAM_LEN, temp_wstr.wstr_ptr, temp_wstr.wstr_len,MIN(TX_PARAM_LEN,temp_wstr.wstr_len));

        //StringToADDR
        {
            uint16	i = 0;
            for( i = 0; i < 12; i++ )
            {
                if( buf[i] >= 48 && buf[i] <= 57 ) //”0” C “9”
                {
                    buf[i] -= 0x30;
                }
            else if( buf[i] >= 65 && buf[i] <= 70 ) //”A” C “F”
            {
                buf[i] -= 0x37;
            } else if( buf[i] >= 97 && buf[i] <= 102 ) //”a” C “f”
            {
                buf[i] -= 0x57;
            }
        }
            for( i = 0; i < 6; i++ )
            {
                BLE_RXaddr.addr[i] = buf[2 * i] * 16 + buf[2 * i + 1];
            }
        }
    }
        SCI_TRACE_LOW("BT_GetRXParam BLE RXaddr_addr : RXaddr.addr[0]  %x, RXaddr.addr[1]  %x, RXaddr.addr[2]  %x, RXaddr.addr[3]  %x, RXaddr.addr[4]  %x, RXaddr.addr[5]  %x", 
        BLE_RXaddr.addr[0], BLE_RXaddr.addr[1], BLE_RXaddr.addr[2], BLE_RXaddr.addr[3], BLE_RXaddr.addr[4], BLE_RXaddr.addr[5]);
#endif
}

#ifdef BLUETOOTH_SUPPORT

/********************************************************************************
 NAME:          MMIBTInitRXData
 DESCRIPTION:  display bt input para 
 PARAM IN:      win_id -  msg_id -  param - 
 PARAM OUT:     
 AUTHOR:        chao.chen
 DATE:          2015.11.30
********************************************************************************/
LOCAL void MMIBTInitRXData(void)
{
#if 0
	RX_data_show.rssi = 0x4a;
	RX_data_show.status = 0;
	RX_data_show.pkt_cnt = 0x44444444;
	RX_data_show.pkt_err_cnt = 0x33333333;
	RX_data_show.bit_cnt = 0x66666666;
	RX_data_show.bit_err_cnt =0x22222222;
#else
	RX_data_show.rssi = 0;
	RX_data_show.status = 0;
	RX_data_show.pkt_cnt = 0;
	RX_data_show.pkt_err_cnt = 0;
	RX_data_show.bit_cnt = 0;
	RX_data_show.bit_err_cnt = 0;
#endif
}

/********************************************************************************
 NAME:          MMIBT_GetRXDataCallback
 DESCRIPTION:  display bt input para 
 PARAM IN:      win_id -  msg_id -  param - 
 PARAM OUT:     
 AUTHOR:        chao.chen
 DATE:          2015.11.30
********************************************************************************/
LOCAL void MMIBT_GetRXDataCallback( BT_NONSIG_DATA* data)
{
	RX_data_show.rssi = data->rssi;
	RX_data_show.status = data->status;
	RX_data_show.pkt_cnt = data->pkt_cnt;
	RX_data_show.pkt_err_cnt = data->pkt_err_cnt;
	RX_data_show.bit_cnt = data->bit_cnt;
	RX_data_show.bit_err_cnt =data->bit_err_cnt;

	SCI_TRACE_LOW("MMIBT_GetRXDataCallback: status %d, rssi %d, pkt_cnt %d, pkt_err_cnt %d, bit_cnt %d, bit_err_cnt %d", 
           RX_data_show.status, RX_data_show.rssi, RX_data_show.pkt_cnt, RX_data_show.pkt_err_cnt, RX_data_show.bit_cnt, RX_data_show.bit_err_cnt);
}

//PER = Pkt_err_cnt/ Pkt_all_cnt
//BER = bit_err_cnt /bit_all_cnt

/********************************************************************************
 NAME:          GetRXDataInfoStr
 DESCRIPTION:  display bt input para 
 PARAM IN:      win_id -  msg_id -  param - 
 PARAM OUT:     
 AUTHOR:        chao.chen
 DATE:          2015.11.30
********************************************************************************/
LOCAL int GetRXDataInfoStr(uint8* phone_buf, uint32 buf_len)
{
	char tmp_buf1[20] = {0};
	uint32 offset = 0;
	char*  temp_ptr = PNULL;
	float per = 0;
	float ber = 0;
	
	if(!((0==RX_data_show.pkt_cnt)||(0==RX_data_show.bit_cnt)))
	{
		per = (float)RX_data_show.pkt_err_cnt / RX_data_show.pkt_cnt;
		ber = (float) RX_data_show.bit_err_cnt / RX_data_show.bit_cnt;
	}
//Status
	MMI_MEMCPY(phone_buf + offset, buf_len - offset, "Status:", 7, 7);
	offset += 7;
//	phone_buf[offset] = CR_CHAR;
//	offset += 1;
	if(0==RX_data_show.status)
	{
		temp_ptr = (char*)"success";
	}else{
		temp_ptr = (char*)"failed";
	}
//	sprintf(tmp_buf1, "%ld", RX_data_show.status);
    sprintf(tmp_buf1, "%s", temp_ptr);
	MMI_MEMCPY(phone_buf + offset, buf_len - offset, tmp_buf1, 19, SCI_STRLEN(tmp_buf1));
	offset += SCI_STRLEN(tmp_buf1);
	phone_buf[offset] = LF_CHAR;
	offset += 1;
#if 0	
//RSSI
	MMI_MEMCPY(phone_buf + offset, buf_len - offset, "RSSI:", 5, 5);
	offset += 5;
//	phone_buf[offset] = CR_CHAR;
//	offset += 1;
	sprintf(tmp_buf1, "%ld", 0 -RX_data_show.rssi);
	MMI_MEMCPY(phone_buf + offset, buf_len - offset, tmp_buf1, 19, SCI_STRLEN(tmp_buf1));
	offset += SCI_STRLEN(tmp_buf1);	
	phone_buf[offset] = LF_CHAR;
	offset += 1;
#endif
//pkt_cnt
	MMI_MEMCPY(phone_buf + offset, buf_len - offset, "pkt_cnt:", 8, 8);
	offset += 8;
//	phone_buf[offset] = CR_CHAR;
//	offset += 1;
	sprintf(tmp_buf1, "%ld", RX_data_show.pkt_cnt);
	MMI_MEMCPY(phone_buf + offset, buf_len - offset, tmp_buf1, 19, SCI_STRLEN(tmp_buf1));
	offset += SCI_STRLEN(tmp_buf1);
	phone_buf[offset] = LF_CHAR;
	offset += 1;
//pkt_err_cnt
	MMI_MEMCPY(phone_buf + offset, buf_len - offset, "pkt_err_cnt:", 12, 12);
	offset += 12;
//	phone_buf[offset] = CR_CHAR;
//	offset += 1;
	sprintf(tmp_buf1, "%ld", RX_data_show.pkt_err_cnt);
	MMI_MEMCPY(phone_buf + offset, buf_len - offset, tmp_buf1, 19, SCI_STRLEN(tmp_buf1));
	offset += SCI_STRLEN(tmp_buf1);
	phone_buf[offset] = LF_CHAR;
	offset += 1;
//per
	MMI_MEMCPY(phone_buf + offset, buf_len - offset, "per:", 4, 4);
	offset += 4;
	sprintf(tmp_buf1, "%f", (float)per*100);
	MMI_MEMCPY(phone_buf + offset, buf_len - offset, tmp_buf1, 19, SCI_STRLEN(tmp_buf1));
	offset += SCI_STRLEN(tmp_buf1);	
	MMI_MEMCPY(phone_buf + offset, buf_len - offset, "%", 1, 1);
	offset += 1;	
	phone_buf[offset] = LF_CHAR;
	offset += 1;	
//bit_cnt
	MMI_MEMCPY(phone_buf + offset, buf_len - offset, "bit_cnt:", 8, 8);
	offset += 8;
//	phone_buf[offset] = CR_CHAR;
//	offset += 1;
	sprintf(tmp_buf1, "%ld", RX_data_show.bit_cnt);
	MMI_MEMCPY(phone_buf + offset, buf_len - offset, tmp_buf1, 19, SCI_STRLEN(tmp_buf1));
	offset += SCI_STRLEN(tmp_buf1);
	phone_buf[offset] = LF_CHAR;
	offset += 1;
//bit_err_cnt
 	MMI_MEMCPY(phone_buf + offset, buf_len - offset, "bit_err_cnt:", 12, 12);
	offset += 12;
//	phone_buf[offset] = CR_CHAR;
//	offset += 1;
	sprintf(tmp_buf1, "%ld", RX_data_show.bit_err_cnt);
	MMI_MEMCPY(phone_buf + offset, buf_len - offset, tmp_buf1, 19, SCI_STRLEN(tmp_buf1));
	offset += SCI_STRLEN(tmp_buf1);
	phone_buf[offset] = LF_CHAR;
	offset += 1;
//ber
	MMI_MEMCPY(phone_buf + offset, buf_len - offset, "ber:", 4, 4);
	offset += 4;
	sprintf(tmp_buf1, "%f", (float)ber*100);
	MMI_MEMCPY(phone_buf + offset, buf_len - offset, tmp_buf1, 19, SCI_STRLEN(tmp_buf1));
	offset += SCI_STRLEN(tmp_buf1);	
	MMI_MEMCPY(phone_buf + offset, buf_len - offset, "%", 1, 1);
	offset += 1;	
	phone_buf[offset] = LF_CHAR;
	offset += 1;

    return (offset);
}

/********************************************************************************
 NAME:          ShowRXDataInfo
 DESCRIPTION:  display bt input para 
 PARAM IN:      win_id -  msg_id -  param - 
 PARAM OUT:     
 AUTHOR:        chao.chen
 DATE:          2015.11.30
********************************************************************************/
LOCAL void ShowRXDataInfo(   BOOLEAN   need_update )
{

	uint8 buf[521] = {0};
	wchar wstr[521] = {0};
	char* str = PNULL;
	MMI_STRING_T text = {0};
	MMI_RESULT_E result = MMI_RESULT_TRUE;

	str = (char*)buf;
	if(GetRXDataInfoStr(buf, 520) > 0)
	{
		text.wstr_len = GetRXDataInfoStr(buf, 520);
		MMI_STRNTOWSTR( wstr, 520, (uint8*)str, text.wstr_len, text.wstr_len );
		text.wstr_ptr = wstr;
		GUITEXT_SetString(MMIENG_BT_NOSIGNAL_INFO_CTRL_ID, text.wstr_ptr,text.wstr_len, FALSE);
	}

}


/********************************************************************************
 NAME:          EngBTRXInforWinHandleMsg
 DESCRIPTION:  display bt input para 
 PARAM IN:      win_id -  msg_id -  param - 
 PARAM OUT:     
 AUTHOR:        chao.chen
 DATE:          2015.11.30
********************************************************************************/
LOCAL MMI_RESULT_E EngBTRXInforWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
	MMI_RESULT_E result = MMI_RESULT_TRUE;
		
    switch (msg_id) 
    {
	case MSG_OPEN_WINDOW:   
		MMK_SetAtvCtrl(win_id, MMIENG_BT_NOSIGNAL_INFO_CTRL_ID);
		MMIBTInitRXData();
		ShowRXDataInfo(FALSE);
		break;

	case MSG_FULL_PAINT:
		MMITHEME_UpdateRect();
		ShowRXDataInfo(TRUE);
		break;

	case MSG_APP_OK:
	case MSG_CTL_OK:	
		SCI_TRACE_LOW("[bt]  EngBTRXInforWinHandleMsg MSG_APP_OK ");
	#ifndef WIN32
        BT_GetNonSigRxData(MMIBT_GetRXDataCallback);
	#endif
	     MMK_SendMsg(win_id,MSG_FULL_PAINT,PNULL);     
		break;

	case MSG_CTL_CANCEL:    
	case MSG_APP_CANCEL:
		MMK_CloseWin(win_id);
		break;
        
	case MSG_TIMER:    
		break;

	case MSG_LOSE_FOCUS:
		break;

	case MSG_GET_FOCUS: 
		break;

	case MSG_CLOSE_WINDOW:
		break;
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}


/********************************************************************************
 NAME:          EngBTRXInforWinHandleMsg
 DESCRIPTION:  display bt input para 
 PARAM IN:      win_id -  msg_id -  param - 
 PARAM OUT:     
 AUTHOR:        chao.chen
 DATE:          2015.11.30
********************************************************************************/
LOCAL MMI_RESULT_E EngBTBleRXInforWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
	MMI_RESULT_E result = MMI_RESULT_TRUE;
		
    switch (msg_id) 
    {
	case MSG_OPEN_WINDOW:   
		MMK_SetAtvCtrl(win_id, MMIENG_BT_NOSIGNAL_INFO_CTRL_ID);
		MMIBTInitRXData();
		ShowRXDataInfo(FALSE);
		break;

	case MSG_FULL_PAINT:
		MMITHEME_UpdateRect();
		ShowRXDataInfo(TRUE);
		break;

	case MSG_APP_OK:
	case MSG_CTL_OK:	
		SCI_TRACE_LOW("[bt]  EngBTRXInforWinHandleMsg MSG_APP_OK ");
	#ifndef WIN32
        BT_BLE_GetNonSigRxData(MMIBT_GetRXDataCallback);
	#endif
	     MMK_SendMsg(win_id,MSG_FULL_PAINT,PNULL);
		break;

	case MSG_CTL_CANCEL:
	case MSG_APP_CANCEL:
		MMK_CloseWin(win_id);
		break;
        
	case MSG_TIMER:    
		break;

	case MSG_LOSE_FOCUS:
		break;

	case MSG_GET_FOCUS: 
		break;

	case MSG_CLOSE_WINDOW:
		break;
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

/********************************************************************************
 NAME:          EngBTNoSignalTxWinHandleMsg
 DESCRIPTION:  display bt input para 
 PARAM IN:      win_id -  msg_id -  param - 
 PARAM OUT:     
 AUTHOR:        chao.chen
 DATE:          2015.11.30
********************************************************************************/
LOCAL MMI_RESULT_E EngBTNoSignalTxWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
	MMI_STRING_T text = {0};
	wchar wstr[TX_PARAM_LEN] = {0};
	char* str = PNULL;
	uint32 i = 0;
	MMI_STRING_T itemStr = {0};
	GUISETLIST_ITEM_INFO_T item_info  ={0};
	MMI_RESULT_E result = MMI_RESULT_TRUE;
	char buf [TX_PARAM_LEN]={0};

    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:	
		
		GUIFORM_SetType(MMIENG_FORM_CTRL_ID, GUIFORM_TYPE_TP);

		GUIFORM_SetStyle(MMIENG_BT_NOSIGNAL_CTRL1_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_BT_NOSIGNAL_CTRL2_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_BT_NOSIGNAL_CTRL3_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_BT_NOSIGNAL_CTRL4_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_BT_NOSIGNAL_CTRL5_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_BT_NOSIGNAL_CTRL6_ID,GUIFORM_STYLE_UNIT);
	
		str = "TX Pattern";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_BT_NOSIGNAL_LABEL_CTRL1_ID, &text, FALSE);

		str = "TX Channel";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_BT_NOSIGNAL_LABEL_CTRL2_ID, &text, FALSE);  

		str = "TX Pac Type";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_BT_NOSIGNAL_LABEL_CTRL3_ID, &text, FALSE);

		str = "TX Power Type";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_BT_NOSIGNAL_LABEL_CTRL4_ID, &text, FALSE);

		str = "TX Power Value";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_BT_NOSIGNAL_LABEL_CTRL5_ID, &text, FALSE);

		str = "TX Power Cnt";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_BT_NOSIGNAL_LABEL_CTRL6_ID, &text, FALSE);
		
            //tx pattern
		for(i=0;i<TX_PATTERN_NUM;i++)
		{
			MMI_GetLabelTextByLang(tx_pattern[i], &itemStr);
			item_info.item_state = GUISETLIST_ITEM_STATE_TEXT;
			item_info.str_info.wstr_len = itemStr.wstr_len;
			item_info.str_info.wstr_ptr = itemStr.wstr_ptr;
			GUISETLIST_SetFontAlign(MMIENG_BT_NOSIGNAL_EDIT_CTRL1_ID,ALIGN_LEFT);
			GUISETLIST_AddItem(MMIENG_BT_NOSIGNAL_EDIT_CTRL1_ID, &item_info);
		}
		//tx pac type
		for(i=0;i<TX_PAC_TYPE_NUM;i++)
		{
			MMI_GetLabelTextByLang(BT_pac_type[i], &itemStr);
			item_info.item_state = GUISETLIST_ITEM_STATE_TEXT;
			item_info.str_info.wstr_len = itemStr.wstr_len;
			item_info.str_info.wstr_ptr = itemStr.wstr_ptr;
			GUISETLIST_SetFontAlign(MMIENG_BT_NOSIGNAL_EDIT_CTRL3_ID,ALIGN_LEFT);
			GUISETLIST_AddItem(MMIENG_BT_NOSIGNAL_EDIT_CTRL3_ID, &item_info);
		}
        //tx power type
        for(i=0;i<TX_POWER_TYPE_NUM;i++)
		{
			MMI_GetLabelTextByLang(tx_power_type[i], &itemStr);
			item_info.item_state = GUISETLIST_ITEM_STATE_TEXT;
			item_info.str_info.wstr_len = itemStr.wstr_len;
			item_info.str_info.wstr_ptr = itemStr.wstr_ptr;
			GUISETLIST_SetFontAlign(MMIENG_BT_NOSIGNAL_EDIT_CTRL4_ID,ALIGN_LEFT);
			GUISETLIST_AddItem(MMIENG_BT_NOSIGNAL_EDIT_CTRL4_ID, &item_info);
		}
        GUIFORM_SetChildDisplay(MMK_GetCtrlHandleByWin(win_id, MMIENG_FORM_CTRL_ID), MMK_GetCtrlHandleByWin(win_id, MMIENG_BT_NOSIGNAL_CTRL4_ID), GUIFORM_CHILD_DISP_HIDE);

		MMK_SetAtvCtrl(MMIENG_BT_NOSIGNAL_TX_WIN_ID, MMIENG_BT_NOSIGNAL_EDIT_CTRL1_ID);	
        break;
    case MSG_APP_OK:
    case MSG_CTL_OK:
		SCI_TRACE_LOW("[bt]  EngBTNoSignalTxWinHandleMsg  msgid:MSG_APP_OK");
		BT_GetTXParam();
#if defined (PLATFORM_ANTISW3)
#ifndef WIN32
        BT_SetNonSigTxTestMode(TRUE,&TX_data);
#endif
#endif
		MMIPUB_OpenAlertSuccessWin(TXT_COMPLETE);  
		break;

    case MSG_APP_CANCEL:
    case MSG_CTL_CANCEL:
		SCI_TRACE_LOW("[bt]  EngBTNoSignalTxWinHandleMsg  msgid:MSG_APP_CANCEL");
#if defined (PLATFORM_ANTISW3)
#ifndef WIN32
        BT_SetNonSigTxTestMode(FALSE,&TX_data);
#endif //stop tx
#endif
		MMK_CloseWin(MMIENG_BT_NOSIGNAL_TX_WIN_ID);
		break;	
    default:
		result = MMI_RESULT_FALSE;
		break;
    }
    return (result);
}


/********************************************************************************
 NAME:          EngBTNoSignalRxWinHandleMsg
 DESCRIPTION:  display bt input para 
 PARAM IN:      win_id -  msg_id -  param - 
 PARAM OUT:     
 AUTHOR:        chao.chen
 DATE:          2015.11.30
********************************************************************************/
LOCAL MMI_RESULT_E EngBTNoSignalRxWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
	MMI_STRING_T text = {0};
	wchar wstr[TX_PARAM_LEN] = {0};
	char* str = PNULL;
	uint32 i = 0;
	MMI_STRING_T itemStr = {0};
	GUISETLIST_ITEM_INFO_T item_info  ={0};
	MMI_RESULT_E result = MMI_RESULT_TRUE;

    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:	
	
		GUIFORM_SetType(MMIENG_FORM_CTRL_ID, GUIFORM_TYPE_TP);

		GUIFORM_SetStyle(MMIENG_BT_NOSIGNAL_CTRL7_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_BT_NOSIGNAL_CTRL8_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_BT_NOSIGNAL_CTRL9_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_BT_NOSIGNAL_CTRL10_ID,GUIFORM_STYLE_UNIT);
	
		str = "RX Channel";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_BT_NOSIGNAL_LABEL_CTRL7_ID, &text, FALSE);  

		str = "RX Pac Type";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_BT_NOSIGNAL_LABEL_CTRL8_ID, &text, FALSE);

		str = "RX Gain";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_BT_NOSIGNAL_LABEL_CTRL9_ID, &text, FALSE);

		str = "RX Addr";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_BT_NOSIGNAL_LABEL_CTRL10_ID, &text, FALSE);
		
		//RX pac type
		for(i=0;i<TX_PAC_TYPE_NUM;i++)
		{
			MMI_GetLabelTextByLang(BT_pac_type[i], &itemStr);
			item_info.item_state = GUISETLIST_ITEM_STATE_TEXT;
			item_info.str_info.wstr_len = itemStr.wstr_len;
			item_info.str_info.wstr_ptr = itemStr.wstr_ptr;
			GUISETLIST_SetFontAlign(MMIENG_BT_NOSIGNAL_EDIT_CTRL8_ID,ALIGN_LEFT);
			GUISETLIST_AddItem(MMIENG_BT_NOSIGNAL_EDIT_CTRL8_ID, &item_info);
		}
		MMK_SetAtvCtrl(MMIENG_BT_NOSIGNAL_RX_WIN_ID, MMIENG_BT_NOSIGNAL_EDIT_CTRL7_ID);
		
        break;  
      
    case MSG_FULL_PAINT:
            break;      

    case MSG_APP_OK:
    case MSG_CTL_OK:
        BT_GetRXParam();
#ifndef WIN32
        BT_SetNonSigRxTestMode(TRUE,&RX_data,&RXaddr);
#endif
        MMK_CreateWin((uint32 *) MMIENG_BT_NOSIGNAL_RX_INFO_TAB, PNULL); 
        break;
        
    case MSG_APP_CANCEL:
    case MSG_CTL_CANCEL:
#ifndef WIN32
        BT_SetNonSigRxTestMode(FALSE,&RX_data,&RXaddr);
#endif
        MMK_CloseWin(MMIENG_BT_NOSIGNAL_RX_WIN_ID);
        break;
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}


/********************************************************************************
 NAME:          EngBTNoSignalTxWinHandleMsg
 DESCRIPTION:  display bt input para 
 PARAM IN:      win_id -  msg_id -  param - 
 PARAM OUT:     
 AUTHOR:        chao.chen
 DATE:          2015.11.30
********************************************************************************/
LOCAL MMI_RESULT_E EngBTNoSignalBLETxWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
	MMI_STRING_T text = {0};
	wchar wstr[TX_PARAM_LEN] = {0};
	char* str = PNULL;
	uint32 i = 0;
	MMI_STRING_T itemStr = {0};
	GUISETLIST_ITEM_INFO_T item_info  ={0};
	MMI_RESULT_E result = MMI_RESULT_TRUE;
//	MMI_STRING_T tx_param_str[4] = {{PNULL, 0},{PNULL, 0},{PNULL, 0},{PNULL, 0}};
	char buf [TX_PARAM_LEN]={0};

    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:	
		
		GUIFORM_SetType(MMIENG_FORM_CTRL_ID, GUIFORM_TYPE_TP);

		GUIFORM_SetStyle(MMIENG_BT_NOSIGNAL_CTRL7_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_BT_NOSIGNAL_CTRL8_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_BT_NOSIGNAL_CTRL9_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_BT_NOSIGNAL_CTRL1_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_BT_NOSIGNAL_CTRL2_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_BT_NOSIGNAL_CTRL10_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_BT_NOSIGNAL_CTRL3_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_BT_NOSIGNAL_CTRL4_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_BT_NOSIGNAL_CTRL5_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_BT_NOSIGNAL_CTRL6_ID,GUIFORM_STYLE_UNIT);


		str = "BLE TX LE_PHY";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_BT_NOSIGNAL_LABEL_CTRL8_ID, &text, FALSE);

		str = "BLE TX Pac Payload";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_BT_NOSIGNAL_LABEL_CTRL9_ID, &text, FALSE);
		
		str = "BLE TX Pattern";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_BT_NOSIGNAL_LABEL_CTRL1_ID, &text, FALSE);

		str = "BLE TX Channel";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_BT_NOSIGNAL_LABEL_CTRL2_ID, &text, FALSE);  

		str = "BLE TX Data Length";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_BT_NOSIGNAL_LABEL_CTRL10_ID, &text, FALSE);  
		
		str = "BLE TX Pac Type";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_BT_NOSIGNAL_LABEL_CTRL3_ID, &text, FALSE);

		str = "BLE TX Pac Len";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_BT_NOSIGNAL_LABEL_CTRL7_ID, &text, FALSE);

		str = "BLE TX Power Type";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_BT_NOSIGNAL_LABEL_CTRL4_ID, &text, FALSE);

		str = "BLE TX Power Value";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_BT_NOSIGNAL_LABEL_CTRL5_ID, &text, FALSE);

		str = "BLE TX Pac Cnt";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_BT_NOSIGNAL_LABEL_CTRL6_ID, &text, FALSE);

		//tx le phy
		for(i=0;i<TX_LE_PHY_NUM;i++)
		{
			MMI_GetLabelTextByLang(tx_le_phy[i], &itemStr);
			item_info.item_state = GUISETLIST_ITEM_STATE_TEXT;
			item_info.str_info.wstr_len = itemStr.wstr_len;
			item_info.str_info.wstr_ptr = itemStr.wstr_ptr;
			GUISETLIST_SetFontAlign(MMIENG_BT_NOSIGNAL_EDIT_CTRL8_ID,ALIGN_LEFT);
			GUISETLIST_AddItem(MMIENG_BT_NOSIGNAL_EDIT_CTRL8_ID, &item_info);
		}
		
		//tx pac payload
		for(i=0;i<TX_PAC_PAYLOAD_NUM;i++)
		{
			MMI_GetLabelTextByLang(tx_pac_payload[i], &itemStr);
			item_info.item_state = GUISETLIST_ITEM_STATE_TEXT;
			item_info.str_info.wstr_len = itemStr.wstr_len;
			item_info.str_info.wstr_ptr = itemStr.wstr_ptr;
			GUISETLIST_SetFontAlign(MMIENG_BT_NOSIGNAL_EDIT_CTRL9_ID,ALIGN_LEFT);
			GUISETLIST_AddItem(MMIENG_BT_NOSIGNAL_EDIT_CTRL9_ID, &item_info);
		}
		
            //tx pattern
		for(i=0;i<8;i++)
		{
			MMI_GetLabelTextByLang(ble_tx_pattern[i], &itemStr);
			item_info.item_state = GUISETLIST_ITEM_STATE_TEXT;
			item_info.str_info.wstr_len = itemStr.wstr_len;
			item_info.str_info.wstr_ptr = itemStr.wstr_ptr;
			GUISETLIST_SetFontAlign(MMIENG_BT_NOSIGNAL_EDIT_CTRL1_ID,ALIGN_LEFT);
			GUISETLIST_AddItem(MMIENG_BT_NOSIGNAL_EDIT_CTRL1_ID, &item_info);
		}
		
		//tx pac type
		for(i=0;i<TX_POWER_TYPE_NUM;i++)
		{
			MMI_GetLabelTextByLang(tx_power_type[i], &itemStr);
			item_info.item_state = GUISETLIST_ITEM_STATE_TEXT;
			item_info.str_info.wstr_len = itemStr.wstr_len;
			item_info.str_info.wstr_ptr = itemStr.wstr_ptr;
			GUISETLIST_SetFontAlign(MMIENG_BT_NOSIGNAL_EDIT_CTRL3_ID,ALIGN_LEFT);
			GUISETLIST_AddItem(MMIENG_BT_NOSIGNAL_EDIT_CTRL3_ID, &item_info);
		}
		
     		 //tx power type
      		for(i=0;i<TX_POWER_TYPE_NUM;i++)
		{
			MMI_GetLabelTextByLang(tx_power_type[i], &itemStr);
			item_info.item_state = GUISETLIST_ITEM_STATE_TEXT;
			item_info.str_info.wstr_len = itemStr.wstr_len;
			item_info.str_info.wstr_ptr = itemStr.wstr_ptr;
			GUISETLIST_SetFontAlign(MMIENG_BT_NOSIGNAL_EDIT_CTRL4_ID,ALIGN_LEFT);
			GUISETLIST_AddItem(MMIENG_BT_NOSIGNAL_EDIT_CTRL4_ID, &item_info);
		}

        {//temp to remove
            GUIFORM_SetChildDisplay(MMK_GetCtrlHandleByWin(win_id, MMIENG_FORM_CTRL_ID), MMK_GetCtrlHandleByWin(win_id, MMIENG_BT_NOSIGNAL_CTRL3_ID), GUIFORM_CHILD_DISP_HIDE);
            GUIFORM_SetChildDisplay(MMK_GetCtrlHandleByWin(win_id, MMIENG_FORM_CTRL_ID), MMK_GetCtrlHandleByWin(win_id, MMIENG_BT_NOSIGNAL_CTRL4_ID), GUIFORM_CHILD_DISP_HIDE);
            GUIFORM_SetChildDisplay(MMK_GetCtrlHandleByWin(win_id, MMIENG_FORM_CTRL_ID), MMK_GetCtrlHandleByWin(win_id, MMIENG_BT_NOSIGNAL_CTRL5_ID), GUIFORM_CHILD_DISP_HIDE);
            GUIFORM_SetChildDisplay(MMK_GetCtrlHandleByWin(win_id, MMIENG_FORM_CTRL_ID), MMK_GetCtrlHandleByWin(win_id, MMIENG_BT_NOSIGNAL_CTRL6_ID), GUIFORM_CHILD_DISP_HIDE);
            GUIFORM_SetChildDisplay(MMK_GetCtrlHandleByWin(win_id, MMIENG_FORM_CTRL_ID), MMK_GetCtrlHandleByWin(win_id, MMIENG_BT_NOSIGNAL_CTRL7_ID), GUIFORM_CHILD_DISP_HIDE);
            GUIFORM_SetChildDisplay(MMK_GetCtrlHandleByWin(win_id, MMIENG_FORM_CTRL_ID), MMK_GetCtrlHandleByWin(win_id, MMIENG_BT_NOSIGNAL_CTRL9_ID), GUIFORM_CHILD_DISP_HIDE);
        }
		MMK_SetAtvCtrl(win_id, MMIENG_BT_NOSIGNAL_EDIT_CTRL8_ID);	
        break;

    case MSG_APP_OK:
    case MSG_CTL_OK:		
		ENGBT_GetBLETXParam();
#ifndef WIN32
        BT_BLE_SetNonSigTxTestMode(TRUE,&BLE_TX_data);
#endif
		MMIPUB_OpenAlertSuccessWin(TXT_COMPLETE);  
		break;

    case MSG_APP_CANCEL:
    case MSG_CTL_CANCEL:
#ifndef WIN32
        BT_BLE_SetNonSigTxTestMode(FALSE,&BLE_TX_data);
#endif //stop tx
		MMK_CloseWin(win_id);
		break;	
		
    default:
		result = MMI_RESULT_FALSE;
		break;
    }
    return (result);
}

/********************************************************************************
 NAME:          EngBTNoSignalBLERxWinHandleMsg
 DESCRIPTION:  display bt input para 
 PARAM IN:      win_id -  msg_id -  param - 
 PARAM OUT:     
 AUTHOR:        chao.chen
 DATE:          2015.11.30
********************************************************************************/
LOCAL MMI_RESULT_E EngBTNoSignalBLERxWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
	MMI_STRING_T text = {0};
	wchar wstr[TX_PARAM_LEN] = {0};
	char* str = PNULL;
	uint32 i = 0;
	MMI_STRING_T itemStr = {0};
	GUISETLIST_ITEM_INFO_T item_info  ={0};
	MMI_RESULT_E result = MMI_RESULT_TRUE;

    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:	
	
		GUIFORM_SetType(MMIENG_FORM_CTRL_ID, GUIFORM_TYPE_TP);

		GUIFORM_SetStyle(MMIENG_BT_NOSIGNAL_CTRL1_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_BT_NOSIGNAL_CTRL2_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_BT_NOSIGNAL_CTRL7_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_BT_NOSIGNAL_CTRL8_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_BT_NOSIGNAL_CTRL9_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_BT_NOSIGNAL_CTRL10_ID,GUIFORM_STYLE_UNIT);

#if 0 //ndef WIN32
        SCI_TraceLow( "[MMIENG] fun[%s] file[%d] len[%d]", __FUNCTION__, __LINE__,BTI_BtChipId());

        if (3 == BTI_BtChipId())//BT_CHIP_ID_UNISOC_NEMOL
        {
            GUIFORM_SetChildDisplay(MMK_GetCtrlHandleByWin(win_id, MMIENG_FORM_CTRL_ID), MMK_GetCtrlHandleByWin(win_id, MMIENG_BT_NOSIGNAL_CTRL10_ID), GUIFORM_CHILD_DISP_HIDE);
        }
        else
        {
            GUIFORM_SetChildDisplay(MMK_GetCtrlHandleByWin(win_id, MMIENG_FORM_CTRL_ID), MMK_GetCtrlHandleByWin(win_id, MMIENG_BT_NOSIGNAL_CTRL10_ID), GUIFORM_CHILD_DISP_NORMAL);
        }
#endif

		str = "BLE RX Mod_Index";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_BT_NOSIGNAL_LABEL_CTRL1_ID, &text, FALSE);

		str = "BLE RX LE_PHY";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_BT_NOSIGNAL_LABEL_CTRL2_ID, &text, FALSE);

		str = "BLE RX Channel";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_BT_NOSIGNAL_LABEL_CTRL7_ID, &text, FALSE);  

		str = "BLE RX Pac Type";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_BT_NOSIGNAL_LABEL_CTRL8_ID, &text, FALSE);

		str = "BLE RX Gain";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_BT_NOSIGNAL_LABEL_CTRL9_ID, &text, FALSE);

		str = "BLE RX Addr";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_BT_NOSIGNAL_LABEL_CTRL10_ID, &text, FALSE);

		//RX mod index 
		for(i=0;i<RX_MODE_INDEX_NUM;i++)
		{
			MMI_GetLabelTextByLang(rx_mod_index[i], &itemStr);
			item_info.item_state = GUISETLIST_ITEM_STATE_TEXT;
			item_info.str_info.wstr_len = itemStr.wstr_len;
			item_info.str_info.wstr_ptr = itemStr.wstr_ptr;
			GUISETLIST_SetFontAlign(MMIENG_BT_NOSIGNAL_EDIT_CTRL1_ID,ALIGN_LEFT);
			GUISETLIST_AddItem(MMIENG_BT_NOSIGNAL_EDIT_CTRL1_ID, &item_info);
		}

		//RX LE PHY
		for(i=0;i<RX_LE_PHY_NUM;i++)
		{
			MMI_GetLabelTextByLang(rx_le_phy[i], &itemStr);
			item_info.item_state = GUISETLIST_ITEM_STATE_TEXT;
			item_info.str_info.wstr_len = itemStr.wstr_len;
			item_info.str_info.wstr_ptr = itemStr.wstr_ptr;
			GUISETLIST_SetFontAlign(MMIENG_BT_NOSIGNAL_EDIT_CTRL2_ID,ALIGN_LEFT);
			GUISETLIST_AddItem(MMIENG_BT_NOSIGNAL_EDIT_CTRL2_ID, &item_info);
		}
		
		//RX pac type
		for(i=0;i<TX_POWER_TYPE_NUM;i++)
		{
			MMI_GetLabelTextByLang(tx_power_type[i], &itemStr);
			item_info.item_state = GUISETLIST_ITEM_STATE_TEXT;
			item_info.str_info.wstr_len = itemStr.wstr_len;
			item_info.str_info.wstr_ptr = itemStr.wstr_ptr;
			GUISETLIST_SetFontAlign(MMIENG_BT_NOSIGNAL_EDIT_CTRL8_ID,ALIGN_LEFT);
			GUISETLIST_AddItem(MMIENG_BT_NOSIGNAL_EDIT_CTRL8_ID, &item_info);
		}

        {//temp to remve
            GUIFORM_SetChildDisplay(MMK_GetCtrlHandleByWin(win_id, MMIENG_FORM_CTRL_ID), MMK_GetCtrlHandleByWin(win_id, MMIENG_BT_NOSIGNAL_CTRL8_ID), GUIFORM_CHILD_DISP_HIDE);
            GUIFORM_SetChildDisplay(MMK_GetCtrlHandleByWin(win_id, MMIENG_FORM_CTRL_ID), MMK_GetCtrlHandleByWin(win_id, MMIENG_BT_NOSIGNAL_CTRL9_ID), GUIFORM_CHILD_DISP_HIDE);
            GUIFORM_SetChildDisplay(MMK_GetCtrlHandleByWin(win_id, MMIENG_FORM_CTRL_ID), MMK_GetCtrlHandleByWin(win_id, MMIENG_BT_NOSIGNAL_CTRL10_ID), GUIFORM_CHILD_DISP_HIDE);
        }

		MMK_SetAtvCtrl(win_id, MMIENG_BT_NOSIGNAL_EDIT_CTRL1_ID);
		
        break;  
      
    case MSG_FULL_PAINT:
            break;      

    case MSG_APP_OK:
    case MSG_CTL_OK:
        ENGBT_GetBLERXParam();//need remake
#ifndef WIN32
        BT_BLE_SetNonSigRxTestMode(TRUE,&BLE_RX_data,&BLE_RXaddr);
#endif
        MMK_CreateWin((uint32 *) MMIENG_BT_NOSIGNAL_BLE_RX_INFO_TAB, PNULL); 
        break;
        
    case MSG_APP_CANCEL:
    case MSG_CTL_CANCEL:
#ifndef WIN32
        BT_BLE_SetNonSigRxTestMode(FALSE,&BLE_RX_data,&BLE_RXaddr);
#endif
        MMK_CloseWin(win_id);
        break;
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}


/********************************************************************************
 NAME:          BTSSPDebugModeWinHandleMsg   
 AUTHOR:        Leon.Wang
 DATE:          2012.11.14
********************************************************************************/
LOCAL MMI_RESULT_E BTSSPDebugModeWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
	MMI_RESULT_E  result = MMI_RESULT_TRUE;
#ifdef BLUETOOTH_SUPPORT
    MMI_CTRL_ID_T ctrl_id = MMIENG_LISTBOX_CTRL_ID;
    uint16        cur_selection = 0;
	BOOLEAN       ssp_state = FALSE;
	BT_STATUS     ret_code = BT_SUCCESS;
	MMI_STRING_T  error_info = {0};
	char          error_txt[50] = {0};
	wchar         error_wtxt[50] = {0};
#ifndef WIN32
	ssp_state = BT_GetSSPDebugMode();
#endif
    switch (msg_id) 
    {
	case MSG_OPEN_WINDOW:
		GUILIST_SetMaxItem(ctrl_id,MMISET_OPEN_CLOSE_ITEM, FALSE );//max item 2
		GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
		MMIAPISET_AppendListItemByTextIdExt(TXT_OPEN_COMN,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
		MMIAPISET_AppendListItemByTextIdExt(TXT_COMM_CLOSE,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);  
		
		if (!ssp_state)
		{
			cur_selection = 1;
		}		
		GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
		GUILIST_SetCurItemIndex(ctrl_id,cur_selection);
		MMK_SetAtvCtrl(win_id,ctrl_id);
		break;
		
	case MSG_FULL_PAINT:
		break;
		
	case MSG_KEYDOWN_CANCEL:
	case MSG_KEYDOWN_OK:
		break;
		
	case MSG_CTL_CANCEL:
		MMK_CloseWin(win_id);
		break;
		
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
	case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
	case MSG_CTL_MIDSK:
	case MSG_CTL_OK:
	case MSG_APP_WEB:
		cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
#ifndef WIN32
		if (0 == cur_selection && !ssp_state)
		{
		     ret_code = BT_SetSSPDebugMode(TRUE);
		}
		else if(1 == cur_selection && ssp_state)
		{
			 ret_code = BT_SetSSPDebugMode(FALSE);
		}
#endif
		if(BT_NOT_SUPPORTED==ret_code)
		{
		    sprintf(error_txt, "SSP Debug Mode is not support!");
			MMIAPICOM_StrToWstr((uint8*)error_txt, error_wtxt);
			error_info.wstr_ptr = error_wtxt;
			error_info.wstr_len = MMIAPICOM_Wstrlen(error_wtxt);

			MMIPUB_OpenAlertTextWinByTextPtr(PNULL, //display error_code
                &error_info,
			    PNULL,
				PNULL,
				MMIPUB_SOFTKEY_ONE,
			    PNULL);
		}
		else if(BT_SUCCESS!= ret_code)
		{
			sprintf(error_txt, "Error Code: %d", (uint16)(ret_code));
			MMIAPICOM_StrToWstr((uint8*)error_txt, error_wtxt);
			error_info.wstr_ptr = error_wtxt;
			error_info.wstr_len = MMIAPICOM_Wstrlen(error_wtxt);
			
			MMIPUB_OpenAlertTextWinByTextPtr(PNULL, //display error_code
                &error_info,
				PNULL,
				PNULL,
				MMIPUB_SOFTKEY_ONE,
			    PNULL);
		}
		
		MMK_CloseWin(win_id);
		break;
		
	default:
		result = MMI_RESULT_FALSE;
		break;
    }

#endif
	return result;
}




/********************************************************************************
 NAME:          EngBTopenSSPDebugWin   
 AUTHOR:        Leon.Wang
 DATE:          2012.11.14
********************************************************************************/
PUBLIC void EngBTopenSSPDebugWin(void)
{
    MMK_CreateWin((uint32*)MMIENG_BT_SSP_DEBUG_TAB, PNULL);
}
#endif

#ifdef BT_BLE_SUPPORT
/********************************************************************************
 NAME:          BTBLETestWinHandleMsg
 AUTHOR:        chunjuan.liang
 DATE:          2020.6.11
********************************************************************************/
PUBLIC MMI_RESULT_E BTBLETestWinHandleMsg(MMI_WIN_ID_T win_id,
                                        MMI_MESSAGE_ID_E msg_id,
                                        DPARAM param)
{
    MMI_RESULT_E  result = MMI_RESULT_TRUE;
#ifdef BLUETOOTH_SUPPORT
    MMI_CTRL_ID_T ctrl_id = MMIENG_LISTBOX_CTRL_ID;
    uint16        cur_selection = 0;
    BT_STATUS     ret_code = BT_SUCCESS;

    SCI_TRACE_LOW("BTBLETestWinHandleMsg MSG ID =%d",msg_id);
    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
            Eng_WCN_CheckOpenStatus(TRUE);
            GUILIST_SetMaxItem(ctrl_id,MMISET_OPEN_CLOSE_ITEM, FALSE );//max item 2
            GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
            MMIAPISET_AppendListItemByTextIdExt(TXT_OPEN_COMN,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
            MMIAPISET_AppendListItemByTextIdExt(TXT_COMM_CLOSE,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);

            GUIWIN_SetTitleTextId(win_id,TXT_ENG_BT_BLE_TEST,TRUE);
            MMK_SetAtvCtrl(win_id,ctrl_id);
            break;
        case MSG_FULL_PAINT:
            // get BLE test flag
            if(0 == ble_test_mode_get_cur_state())
            {
                cur_selection = 1;
            }
            SCI_TRACE_LOW("ble_test_mode_get_cur_state state is =%d",ble_test_mode_get_cur_state);
            GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
            GUILIST_SetCurItemIndex(ctrl_id,cur_selection);
            break;
        case MSG_KEYDOWN_CANCEL:
        case MSG_CTL_CANCEL:
            MMK_CloseWin(win_id);
            break;
#ifdef TOUCH_PANEL_SUPPORT
        case MSG_CTL_PENOK:
#endif
        case MSG_CTL_OK:
        case MSG_KEYDOWN_OK:
        case MSG_APP_WEB:
        case MSG_CTL_MIDSK:
            cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
            SCI_TRACE_LOW("[BLE_TEST]BTBLETestWinHandleMsg cur_selection =%d",cur_selection);
#ifndef WIN32
            if (0 == cur_selection)
            {
                //打开BLE 测试时，若BT是关闭状态，先打开BT
                if (FALSE == BT_GetState())
                {
                    _start_bt();//turn on bt(this API,turn on BT complete,excute next step
                }
                 // open BLE Test
                ble_test_mode_start();
                ble_test_mode_set_cur_state(1);
            }
            else if(1 == cur_selection)
            {
                // close BLE Test
                if (TRUE == BT_GetState())
                {
                    _stop_bt();//turn off bt,turn off BT complete,excute next step
                }
                ble_test_mode_set_cur_state(0);
            }
#endif
            //MMK_CloseWin(win_id); //bug1366693
            MMK_SendMsg(win_id,MSG_FULL_PAINT,PNULL);
            break;
        case MSG_CLOSE_WINDOW:
            Eng_WCN_CheckOpenStatus(FALSE);
            ble_test_mode_set_cur_state(0);
            break;
        default:
        result = MMI_RESULT_FALSE;
        break;
    }

#endif
    return result;
}
#ifdef UAL_BT_HFU_SUPPORT
/********************************************************************************
 NAME:          BTRoleTestWinHandleMsg
 AUTHOR:        chunjuan.liang
 DATE:          2020.1.20
********************************************************************************/
#define BT_MASTER        (1)// means phone
#define BT_SLAVER        (0)// means headset

LOCAL uint8   g_bt_role   = 0;
BOOLEAN eng_start_bt(void)
{   
    if (!BT_GetState() && (BT_SUCCESS != BT_Start())) 
    {   
        uint32 count = 0;

        /* Wait for BT to be ON, 20s at most */
        while (!BT_GetState() && (count++ < 200)) 
        {
        SCI_Sleep(100); 
        }
    }
    return BT_GetState();
}

void eng_stop_bt(void)
{
    if (BT_GetState() && (BT_SUCCESS != BT_Stop()))
    {
        /* Wait for BT to be OFF */
        while (BT_GetState())
        {
            SCI_Sleep(100);
        }
    }
}

/*****************************************************************************/
//  Description :MMIAPIENG_GetRole
//  Parameter: [In] None
//             [Out] None
//             [Return] 1: phone
//                      0:dialer
//  Author: chunjuan.liang
//  Note:
/*****************************************************************************/
PUBLIC uint8  MMIAPIENG_GetRole( void )
{
    SCI_TRACE_LOW("MMIENG_GetRole g_bt_role =%x",g_bt_role);
    return g_bt_role;
}
#ifdef ADULT_WATCH_SUPPORT
PUBLIC MMI_RESULT_E BTRoleTestWinHandleMsg(MMI_WIN_ID_T win_id,
                                                    MMI_MESSAGE_ID_E msg_id,
                                                    DPARAM param)
{
    MMI_RESULT_E  result = MMI_RESULT_TRUE;
#ifdef BLUETOOTH_SUPPORT
    MMI_CTRL_ID_T ctrl_id = MMIENG_LISTBOX_CTRL_ID;
    uint16        cur_selection = BT_ROLE_MAX_ITEM;
    
    uint8               bt_role = 0;

    SCI_TRACE_LOW("[ROLE_SET]BTRoleTestWinHandleMsg MSG ID =%x",msg_id);
#ifndef WIN32
    SCI_TRACE_LOW("[ROLE_SET]BTRoleTestWinHandleMsg role =%d",BT_Get_Product_Role());
#endif
    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
            GUILIST_SetMaxItem(ctrl_id,BT_ROLE_MAX_ITEM, FALSE );//max item 3
            GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
            MMIAPISET_AppendListItemByTextIdExt(TXT_ENG_BT_AUTO,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG); //auto
            MMIAPISET_AppendListItemByTextIdExt(TXT_ENG_BT_MASETER,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);//master
            MMIAPISET_AppendListItemByTextIdExt(TXT_ENG_BT_SLAVER,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);//slaver
            //set auto select gray
            GUILIST_SetItemGray(ctrl_id,0,TRUE); //UTODO:,for BLE

            GUIWIN_SetTitleTextId(win_id,TXT_ENG_BT_ROLE,TRUE);
            MMK_SetAtvCtrl(win_id,ctrl_id);
            break;
        case MSG_FULL_PAINT:
        {
            // get role
#ifndef WIN32
#ifdef BT_HFU_SUPPORT
            bt_role = BT_Get_Product_Role();
#endif
#endif
            if(BT_MASTER == bt_role)
            {
                cur_selection = 1;
            }else if(BT_SLAVER == bt_role)
            {
                cur_selection = 2;
            }else
            {
                SCI_TRACE_LOW("[ROLE_SET]BTRoleTestWinHandleMsg bt_role =%d",bt_role);
                cur_selection = 2;
            }

            GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
            GUILIST_SetCurItemIndex(ctrl_id,cur_selection);
        }
            break;
        case MSG_KEYDOWN_CANCEL:
        case MSG_CTL_CANCEL:
            MMK_CloseWin(win_id);
            break;
#ifdef TOUCH_PANEL_SUPPORT
        case MSG_CTL_PENOK:
#endif
        case MSG_CTL_OK:
        case MSG_KEYDOWN_OK:
        case MSG_APP_WEB:
        case MSG_CTL_MIDSK:
        {
#ifndef WIN32
#ifdef BT_HFU_SUPPORT
            uint8 pre_role = BT_Get_Product_Role();
#endif
#else
            uint8 pre_role = BT_MASTER;
#endif
            cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
            SCI_TRACE_LOW("[ROLE_SET]BTRoleTestWinHandleMsg cur_selection =%d",cur_selection);
            if (0 == cur_selection)
            {
                // TODO: BT  Auto
            }
            else if(1 == cur_selection)
            {
                //master
                g_bt_role = BT_MASTER;
                /*if switch role,must reset bt stack*/
                if(BT_MASTER != pre_role)
                {
#ifndef WIN32
                    if(BT_GetState())
                    {
                        eng_stop_bt();
#ifdef BT_HFU_SUPPORT
                        BT_Set_Product_Role(BT_MASTER); // is_phone =1 means phone, is_phone=0 means headset
#endif
                        eng_start_bt();
                    }
                    else
                    {
#ifdef BT_HFU_SUPPORT
                        BT_Set_Product_Role(BT_MASTER);
#endif
                    }
#endif
                }
            }
            else if(2 == cur_selection)
            {
                //slaver
                g_bt_role = BT_SLAVER;
                /*if switch role,must reset bt stack*/
                if(BT_SLAVER != pre_role)
                {
#ifndef WIN32
                    if(BT_GetState())
                    {
                        eng_stop_bt();
#ifdef BT_HFU_SUPPORT
                        BT_Set_Product_Role(BT_SLAVER); // is_phone =1 means phone, is_phone=0 means headset
#endif
                        eng_start_bt();
                    }
                    else
                    {
#ifdef BT_HFU_SUPPORT
                        BT_Set_Product_Role(BT_SLAVER);
#endif
                    }
#endif
                }
            }
            MMK_SendMsg(win_id,MSG_FULL_PAINT,PNULL);
        }
            break;
        default:
            result = MMI_RESULT_FALSE;
        break;
    }
#endif
    return result;
}
#endif
LOCAL MMI_RESULT_E BTLocalNameSetWinHandleMsg(MMI_WIN_ID_T win_id,
                                                    MMI_MESSAGE_ID_E msg_id,
                                                    DPARAM param)
{
    MMI_RESULT_E            result = MMI_RESULT_TRUE;    
    MMI_CTRL_ID_T           ctrl_id = MMIENG_EDITBOX1_CTRL_ID;
    MMI_STRING_T            str = {0};
    wchar local_name_buffer[UAL_BT_DEV_NAME_MAX_LEN + 1] = {0};
    ual_bt_status_e bt_res = UAL_BT_STATUS_ERROR;
    uint16          name_len = 0;
    uint16          name_max_len = UAL_BT_DEV_NAME_MAX_LEN;
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        {
#ifdef BBM_ROLE_SUPPORT
            Bbm_GetBTLocalName(local_name_buffer,name_max_len);
#endif
            name_len = MMIAPICOM_Wstrlen(local_name_buffer);
            TRACE_APP_ENGINEERMODE("name_len = %d",name_len);
            if(0 == name_len)
            {
                bt_res = ual_bt_dev_get_local_name(local_name_buffer,name_max_len+1);
            }
            TRACE_APP_ENGINEERMODE("[BT] get local name result:%d",bt_res);
            str.wstr_len= MMIAPICOM_Wstrlen(local_name_buffer);
            str.wstr_ptr = local_name_buffer;
            GUIEDIT_SetString(ctrl_id,  str.wstr_ptr, str.wstr_len);
            /*add for bug110091:*/
            GUIEDIT_SetIm(ctrl_id, GUIIM_TYPE_ABC|GUIIM_TYPE_DIGITAL, GUIIM_TYPE_ABC);/*lint !e655*/     
            /*end bug110091*/
            MMK_SetAtvCtrl(win_id, ctrl_id);
        }
        break;
        
    case MSG_FULL_PAINT:
        break;
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
        
    case MSG_APP_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
    case MSG_CTL_MIDSK:
        GUIEDIT_GetString(ctrl_id, &str);
        TRACE_APP_ENGINEERMODE("[BT] get string from edit ctrl:%ls,len:%d", str.wstr_ptr,str.wstr_len);
        bt_res = ual_bt_dev_set_local_name(str.wstr_ptr);
#ifdef BBM_ROLE_SUPPORT
        Bbm_SetBTLocalName(str.wstr_ptr);
#endif
        TRACE_APP_ENGINEERMODE("[BT] set local name result:%d",bt_res);
        MMK_CloseWin(win_id);
        break;
        
#ifdef MMI_PDA_SUPPORT
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
        if (PNULL != param)
        {
            uint32 src_id = ((MMI_NOTIFY_T*)param)->src_id;
            
            switch (src_id)
            {
            case MMICOMMON_BUTTON_SOFTKEY_LEFT_CTRL_ID:
                MMK_SendMsg(win_id, MSG_APP_OK, PNULL);
                break;
            case MMICOMMON_BUTTON_SOFTKEY_RIGHT_CTRL_ID:
                MMK_SendMsg(win_id, MSG_APP_CANCEL, PNULL);
                break;
            default:
                break;
            }
        }
        break;
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
#endif
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    
    return (result);
}

PUBLIC MMI_RESULT_E BTVisibilitySetWinHandleMsg(MMI_WIN_ID_T win_id,
                                                    MMI_MESSAGE_ID_E msg_id,
                                                    DPARAM param)
{
    MMI_RESULT_E  result = MMI_RESULT_TRUE;
#ifdef BLUETOOTH_SUPPORT
    MMI_CTRL_ID_T ctrl_id = MMIENG_LISTBOX_CTRL_ID;
    uint16        cur_selection = BT_ROLE_MAX_ITEM;
    ual_bt_visibility_opt_e visible_opt = UAL_BT_DEV_NONE_VISIBLE;

    SCI_TRACE_LOW("[BT_DEV]BTVisibilitySetTestWinHandleMsg MSG ID =%x",msg_id);
    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
            GUILIST_SetMaxItem(ctrl_id,BT_VISIBILITY_MAX_ITEM, FALSE );//max item 4
            GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
            MMIAPISET_AppendListItemByTextIdExt(TXT_ENG_BT_VISIBLE_NONE,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
            MMIAPISET_AppendListItemByTextIdExt(TXT_ENG_BT_ONLY_SEARCH_VISIBLE,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
            MMIAPISET_AppendListItemByTextIdExt(TXT_ENG_BT_ONLY_CONNECT_VISIBLE,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
            MMIAPISET_AppendListItemByTextIdExt(TXT_ENG_BT_SEARCH_CONNECT_VISIBLE,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);

            GUIWIN_SetTitleTextId(win_id,TXT_ENG_BT_VISIBLE_SET,TRUE);
            MMK_SetAtvCtrl(win_id,ctrl_id);
            break;
        case MSG_FULL_PAINT:
        {
            // get role
            visible_opt = ual_bt_dev_get_visible();
            if ( UAL_BT_DEV_VISIBLILITY_MAX >= visible_opt)
            {
                cur_selection = visible_opt;
            }
            else
            {
                cur_selection = UAL_BT_DEV_NONE_VISIBLE;
                SCI_TRACE_LOW("[BT_DEV]BTVisibilitySetTestWinHandleMsg MSG_FULL_PAINT  invalid visible_opt =%d",visible_opt);
            }
            
            SCI_TRACE_LOW("[BT_DEV]BTVisibilitySetTestWinHandleMsg MSG_FULL_PAINT cur_selection =%d",cur_selection);
            GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
            GUILIST_SetCurItemIndex(ctrl_id,cur_selection);
        }
            break;
        case MSG_KEYDOWN_CANCEL:
        case MSG_CTL_CANCEL:
            MMK_CloseWin(win_id);
            break;
#ifdef TOUCH_PANEL_SUPPORT
        case MSG_CTL_PENOK:
#endif
        case MSG_CTL_OK:
        case MSG_KEYDOWN_OK:
        case MSG_APP_WEB:
        case MSG_CTL_MIDSK:
        {
            cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
            SCI_TRACE_LOW("[BT_DEV]BTVisibilitySetTestWinHandleMsg cur_selection =%d",cur_selection);
            ual_bt_dev_set_visible(cur_selection);
            MMK_SendMsg(win_id,MSG_FULL_PAINT,PNULL);
        }
            break;
        default:
            result = MMI_RESULT_FALSE;
        break;
    }
#endif
    return result;
}
#endif

/********************************************************************************
 NAME:          Eng_WCN_CheckOpenStatus
 AUTHOR:        chunjuan.liang
 DATE:          2020.7.21
********************************************************************************/
PUBLIC void Eng_WCN_CheckOpenStatus(BOOLEAN is_enter)
{
    if(TRUE == is_enter)
    {
        if ((TRUE == BT_GetState()) ||(TRUE == MMIAPIWIFI_GetIsWlanOn()))
        {
            EngPopupPromptMsg(TXT_ENG_WCN_TIP_MSG);
        }
    }
    #ifdef BLUETOOTH_SUPPORT
    if (TRUE == BT_GetState())
    {
    #ifndef WIN32
        _stop_bt();
    #endif
    }
    #endif
    #ifdef MMI_WIFI_SUPPORT
    if(TRUE == MMIAPIWIFI_GetIsWlanOn())
    {
    #ifndef WIN32
        MMIAPIWIFI_Off();
    #endif
    }
    #endif
}

LOCAL void EngPopupPromptMsg(MMI_TEXT_ID_T txt_id)
{
    MMI_STRING_T txt_msg = {0};
    WATCH_SOFTKEY_TEXT_ID_T softkey={TXT_NULL,TXT_NULL,TXT_NULL};
    MMI_GetLabelTextByLang( txt_id, &txt_msg );
    WatchCOM_NoteWin_2Line_Enter(MMIENG_NOTE_WIN_ID,&txt_msg,0,softkey,PNULL);

    TRACE_APP_ENGINEERMODE("EngPopupPromptMsg");

}
/********************************************************************************
 NAME:          MMIENGBT_HandleBLEMsgProcess
 AUTHOR:        chunjuan.liang
 DATE:          2020.6.22
********************************************************************************/
PUBLIC MMI_RESULT_E MMIENGBT_HandleBLEMsgProcess(uint16 msg_id, const BT_MSG_T *msg_body_ptr)
{

    if (msg_body_ptr == NULL)
    {
        TRACE_APP_ENGINEERMODE("msg_body_ptr == NULL.");
        return FALSE;
    }

    TRACE_APP_ENGINEERMODE("[BLE_TEST]MMIENGBT_HandleBLEMsgProcess msg_id =%d",msg_id);

    switch(msg_id)
    {
        case MMI_BT_BLE_CONNECTED:
            TRACE_APP_ENGINEERMODE("[BLE_TEST] status=%d",msg_body_ptr->status);
            if(BT_SUCCESS == msg_body_ptr->status)
            {
                EngPopupPromptMsg(TXT_ENG_BLE_CONNECTED_SUCC);
            }else
            {
                EngPopupPromptMsg(TXT_ENG_BLE_CONNECTED_FAL);
            }
            break;
        case MMI_BT_BLE_DISCONNECTED:
            TRACE_APP_ENGINEERMODE("[BLE_TEST] status=%d",msg_body_ptr->status);
            if(BT_SUCCESS == msg_body_ptr->status)
            {
                EngPopupPromptMsg(TXT_ENG_BLE_DISCONNECTED_SUCC);
            }else
            {
                EngPopupPromptMsg(TXT_ENG_BLE_DISCONNECTED_FAIL);
            }
            break;
        case MMI_BT_BLE_DATA_IND:
            TRACE_APP_ENGINEERMODE("[BLE_TEST] status=%d",msg_body_ptr->status);
            if(BT_SUCCESS == msg_body_ptr->status)
            {
                EngPopupPromptMsg(TXT_ENG_BLE_DATA_IND_SUCC);
            }else
            {
                EngPopupPromptMsg(TXT_ENG_BLE_DATA_IND_FAIL);
            }
            break;
        default:
            SCI_TRACE_LOW("[BLE_TEST]default msg msg_id =%d",msg_id);
            break;
    }

}
#endif

/*******************************************************************************
     Telephony   
************* 
     Debug&log
*************
    Connectivity  1.FM
*************
    Hardware      1.VibrateTest
********************************************************************************/
//Telephony
PUBLIC void EngTelephonyOpenInfoWin(uint32 u_ID_ENG_Tele)
{
	switch(u_ID_ENG_Tele)
	{
        case ID_ENG_TEL_NETWORK_MODE_ALL:
            s_mmieng_sim_select_table_ptr = MMIENG_TELE_NETWORK_MODE_WIN_TAB;
            MMIAPIENG_SelectSimWIN(MMIENG_TELE_NETWORK_MODE_WIN_TAB,MMIENG_OpenOperatorSIMSelectWin);
            break;
        case ID_ENG_TEL_SIM_TRACE_ALL:
            MMK_CreateWin((uint32*)MMIENG_TELE_SIM_TRACE_WIN_TAB, PNULL);
            break;
        case ID_ENG_BAND_SELECT:
            s_mmieng_sim_select_table_ptr = MMIENG_TELE_BAND_SELECT_WIN_TAB;
            MMIAPIENG_SelectSimWIN(MMIENG_TELE_BAND_SELECT_WIN_TAB,MMIENG_OpenOperatorSIMSelectWin);
            break;
        case ID_ENG_TEL_NETINFO:
            s_mmieng_sim_select_table_ptr = MMIENG_NET_INFO_SHOW_WIN_TAB;
            MMIAPIENG_SelectSimWIN(MMIENG_NET_INFO_SHOW_WIN_TAB,MMIENG_OpenOperatorSIMSelectWin);
            break;
        case ID_ENG_NETINFO_STATISTICS:
            s_mmieng_sim_select_table_ptr = MMIENG_NETINFO_STATISTICS_WIN_TAB;
            MMIAPIENG_SelectSimWIN(MMIENG_NETINFO_STATISTICS_WIN_TAB,MMIENG_OpenOperatorSIMSelectWin);
            break;
        case ID_ENG_TEL_VOLTE_IMS_SET_ALL:
            s_mmieng_sim_select_table_ptr = MMIENG_IMS_NV_PARAM_ID_WIN_TAB;
            MMIAPIENG_SelectSimWIN(MMIENG_IMS_NV_PARAM_ID_WIN_TAB,MMIENG_OpenOperatorSIMSelectWin);
            break;
        case ID_ENG_TEL_PLMN_WHITE_LIST_ALL:
            MMK_CreateWin((uint32*)MMIENG_TELE_VOLTE_PLMN_WHITE_WIN_TAB, PNULL);
            break;
#ifdef MMI_VOLTE_SUPPORT
        case ID_ENG_TEL_VOLTE_ONOFF:
            MMK_CreateWin((uint32*)MMIENG_TELE_VOLTE_ONOFF_WIN_TAB, PNULL);
            break;
        case ID_ENG_TEL_IMS_PDN:
            s_mmieng_sim_select_table_ptr = MMIENG_TELE_IMS_PDN_WIN_TAB;
            MMIAPIENG_SelectSimWIN(MMIENG_TELE_IMS_PDN_WIN_TAB, MMIENG_OpenOperatorSIMSelectWin);
            break;
#endif
        case ID_ENG_TEL_CSFBGSM_DELAY:
            s_mmieng_sim_select_table_ptr = MMIENG_TELE_CSFB_GSM_WIN_TAB;
            MMIAPIENG_SelectSimWIN(MMIENG_TELE_CSFB_GSM_WIN_TAB,MMIENG_OpenOperatorSIMSelectWin);
            break;
        case ID_ENG_RESTORE_FACTORY_RESET:
            MMK_CreateWin((uint32*)MMIENG_FACTORY_RESET_WIN_TAB, PNULL);
            break;
        case ID_ENG_EDIT_SMS_CENTER_NUMBER:
            MMISMS_SMSCenterNumber();
            break;
        case ID_ENG_FAST_DORMANCY:
            MMK_CreateWin((uint32*)MMIENG_FAST_NORMANCY_WIN_TAB, PNULL);
            break;
        case ID_ENG_QOS_SWTICH:
            MMK_CreateWin((uint32*)MMIENG_QOS_SWTICH_WIN_TAB, PNULL);
            break;
        case ID_ENG_TEL_GPRS_POWER_SAVE_MODE:
            MMK_CreateWin((uint32*)MMIENG_GPRS_POWER_SAVE_MODE_WIN_TAB, PNULL);
            break;
        default:
            break;
    }
}

//Debug&log
PUBLIC void EngDebugAndLogOpenInfoWin(uint32 u_ID_ENG_DebugL)
{
	switch(u_ID_ENG_DebugL)
	{
		case ID_ENG_DEB_GPRS_ATTACH_SERVICE:
		    MMK_CreateWin((uint32*)MMIENG_DEBUG_GPRS_ATTACH_SER_WIN_TAB, PNULL);
		    break;
		case ID_ENG_DEB_THERMAL_SWITCH:
		   MMK_CreateWin((uint32*)MMIENG_DEBUG_THERMAL_SWITCH_WIN_TAB, PNULL);
		   break;
		case ID_ENG_DEB_APR_SET:
		   MMK_CreateWin((uint32*)MMIENG_DEBUG_APR_WIN_TAB, PNULL);
		   break;
		default :
			break;
	}
}

/********************************************************************************
 NAME:          EngHardWareCamLcdInfoWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      
 PARAM OUT:     
 AUTHOR:        James.Zhang
 DATE:      0   2007.11.28
********************************************************************************/
LOCAL MMI_RESULT_E EngDebugGprsAttachSerWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
	int32 index = 0;
	MMI_RESULT_E result = MMI_RESULT_TRUE;
	int32 list_id = MMIENG_COMMON_CTRL1_ID ;
	int32 flag = 0; // 0:OFF; 1: ON    

	switch (msg_id) 
	{
	case MSG_OPEN_WINDOW:
		{
			GUILIST_ITEM_T		item_t = {0};
			GUILIST_ITEM_DATA_T item_data = {0};	  
			
			GUILIST_SetMaxItem( list_id, 2, FALSE );
			GUILIST_SetOwnSofterKey(list_id,FALSE);
			
			item_t.item_style	 = GUIITEM_STYLE_1RADIO_ENG;
			item_t.item_data_ptr = &item_data;
			
			item_data.item_content[0].item_data_type	= GUIITEM_DATA_TEXT_ID; 	  
			
			item_data.item_content[0].item_data.text_id = TXT_OPEN_COMN;	
			GUILIST_AppendItem( list_id, &item_t );
			item_data.item_content[0].item_data.text_id = TXT_COMM_CLOSE;	 
			GUILIST_AppendItem( list_id, &item_t ); 					 
			
			//flag = ;
			if( 1 ==  flag)
			{
				index = 0;
			}
			else
			{
				index = 1;
			}
			GUILIST_SetSelectedItem( list_id,index, TRUE );
			GUILIST_SetCurItemIndex( list_id, index);		   
			MMK_SetAtvCtrl(win_id, list_id);
		}
		break;
		
	case MSG_FULL_PAINT:
		break;		
		
	case MSG_KEYDOWN_CANCEL:
	case MSG_CTL_CANCEL:
		MMK_CloseWin(win_id);
		break;
		
	case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
	case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
	case MSG_KEYDOWN_OK:
	case MSG_CTL_OK:
	case MSG_APP_WEB:
		index = GUILIST_GetCurItemIndex(list_id);			   
		if(0 == index)
		{  
		  //True
		}
		else if( 1	== index)
		{
		 //FALSE;
		}	
		
		MMK_CloseWin(win_id);
		break;
		
	default:
		result = MMI_RESULT_FALSE;
		break;
	}
	return (result);	
}


/********************************************************************************
 NAME:          EngHardWareCamLcdInfoWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      
 PARAM OUT:     
 AUTHOR:        James.Zhang
 DATE:      0   2007.11.28
********************************************************************************/
LOCAL MMI_RESULT_E EngDebugThermalSwitchWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
	int32 index = 0;
	MMI_RESULT_E result = MMI_RESULT_TRUE;
	int32 list_id = MMIENG_COMMON_CTRL1_ID ;
	int32 flag = 0; // 0:OFF; 1: ON    

	switch (msg_id) 
	{
	case MSG_OPEN_WINDOW:
		{
			GUILIST_ITEM_T		item_t = {0};
			GUILIST_ITEM_DATA_T item_data = {0};	  
			
			GUILIST_SetMaxItem( list_id, 2, FALSE );
			GUILIST_SetOwnSofterKey(list_id,FALSE);
			
			item_t.item_style	 = GUIITEM_STYLE_1RADIO_ENG;
			item_t.item_data_ptr = &item_data;
			
			item_data.item_content[0].item_data_type	= GUIITEM_DATA_TEXT_ID; 	  
			
			item_data.item_content[0].item_data.text_id = TXT_OPEN_COMN;	
			GUILIST_AppendItem( list_id, &item_t );
			item_data.item_content[0].item_data.text_id = TXT_COMM_CLOSE;	 
			GUILIST_AppendItem( list_id, &item_t ); 					 
			
			//flag = ;
			if( 1 ==  flag)
			{
				index = 0;
			}
			else
			{
				index = 1;
			}
			GUILIST_SetSelectedItem( list_id,index, TRUE );
			GUILIST_SetCurItemIndex( list_id, index);		   
			MMK_SetAtvCtrl(win_id, list_id);
		}
		break;
		
	case MSG_FULL_PAINT:
		break;		
		
	case MSG_KEYDOWN_CANCEL:
	case MSG_CTL_CANCEL:
		MMK_CloseWin(win_id);
		break;
		
	case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
	case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
	case MSG_KEYDOWN_OK:
	case MSG_CTL_OK:
	case MSG_APP_WEB:
		index = GUILIST_GetCurItemIndex(list_id);			   
		if(0 == index)
		{  
		  //True
		}
		else if( 1	== index)
		{
		 //FALSE;
		}	
		
		MMK_CloseWin(win_id);
		break;
		
	default:
		result = MMI_RESULT_FALSE;
		break;
	}
	return (result);	
}

/********************************************************************************
 NAME:          EngHardWareCamLcdInfoWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      
 PARAM OUT:     
 AUTHOR:        James.Zhang
 DATE:      0   2007.11.28
********************************************************************************/
LOCAL MMI_RESULT_E EngDebugAPRWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    enum{APR_UPLOAD,APR_SERVER,APR_DETECT_TIME,APR_GROUP,APR_VIEW_LOG,APR_AUTO_UPLOAD};
    MMI_MENU_GROUP_ID_T         group_id        =   0;
    MMI_RESULT_E                recode          =   MMI_RESULT_TRUE;
    MMI_RESULT_E                result = MMI_RESULT_TRUE;

    MMI_TEXT_ID_T               str_id[] = {TXT_ENG_DEB_APR_UPLOAD,TXT_ENG_DEB_APR_SERVER,TXT_ENG_DEB_APR_DETECT_TIME,TXT_ENG_DEB_APR_GROUP,TXT_ENG_DEB_APR_VIEW_LOG};
    int16                       i = 0;
    uint16                      max_items = 0;
    uint16                      cur_item = 0;
    MMI_CTRL_ID_T               ctrl_id = MMIENG_COMMON_CTRL1_ID;
    switch(msg_id) 
   {
        case MSG_OPEN_WINDOW:
			
			MMK_SetAtvCtrl(win_id,ctrl_id);
			max_items = 6;
			cur_item  = 0;
			GUILIST_SetMaxItem(ctrl_id,max_items, FALSE );
			GUILIST_SetListState(ctrl_id, GUILIST_STATE_SPLIT_LINE, FALSE);
			for(i = 0; i < max_items-1; i++) 
			{
				MMIENGSET_AppendListItemByTextIdExt(str_id[i],TXT_NULL,TXT_ENG_OK,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1STR_ENG);
			}
			GUILIST_SetListState(ctrl_id, GUILIST_STATE_SPLIT_LINE, FALSE);
			MMIAPISET_AppendListItemByTextIdExt(TXT_ENG_DEB_APR_AUTO_UPLOAD,TXT_NULL,TXT_ENG_OK,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1CHECK_ENG);

			//FUNC to get the state of APR_AUTO_UPLOAD
		 	CTRLLIST_SetItemStateById(ctrl_id,APR_AUTO_UPLOAD,GUIITEM_STATE_SELECTED,FALSE);

			GUILIST_SetSelectedItem(ctrl_id, cur_item, TRUE);
			GUILIST_SetCurItemIndex(ctrl_id, cur_item);
            		break;
					
        case MSG_FULL_PAINT:
        break;
#ifdef TOUCH_PANEL_SUPPORT 
        case MSG_CTL_PENOK:
#endif 
        case MSG_CTL_OK:
        case MSG_APP_OK:
        case MSG_APP_WEB:
        case MSG_CTL_MIDSK:
		{
			
			cur_item = GUILIST_GetCurItemIndex(ctrl_id);
			switch (cur_item) 
			{
				case APR_UPLOAD:
					//Upload  
					{
						if(1)//upload function   or use call back to warning Tester
						{
							MMIPUB_OpenAlertWarningWin(TXT_SUCCESS);
						}
						else
						{
							MMIPUB_OpenAlertWarningWin(TXT_ERROR);
						}
					}
					break;
				case APR_SERVER:
					MMK_CreateWin((uint32 *)MMIENG_DEBUG_APR_SERVER_WIN_TAB, PNULL);
					break;
				case APR_DETECT_TIME:
					MMK_CreatePubEditWin((uint32*)MMIENG_DEBUG_APR_DETECT_TIME_WIN_TAB,PNULL);
					break;
				case APR_GROUP:
					MMK_CreateWin((uint32*)MMIENG_DEBUG_APR_GROUP_WIN_TAB,PNULL);	
					break;
				case APR_VIEW_LOG:
					MMK_CreateWin((uint32*)MMIENG_DEBUG_APR_VIEW_LOG_WIN_TAB,PNULL);	
					break;
				case APR_AUTO_UPLOAD:
					if (GUILIST_GetItemState(GUILIST_GetItemPtrByIndex(ctrl_id, APR_AUTO_UPLOAD), GUIITEM_STATE_SELECTED))
					{
					    //GUILIST_SetSelectedItem(ctrl_id, APR_AUTO_UPLOAD, FALSE);
					   CTRLLIST_SetItemStateById(ctrl_id,APR_AUTO_UPLOAD,GUIITEM_STATE_SELECTED,FALSE);
						//Func
					}
					else
					{
					    CTRLLIST_SetItemStateById(ctrl_id,APR_AUTO_UPLOAD,GUIITEM_STATE_SELECTED,TRUE);
						//
					}
					break;
				default:
				break;
			}
		}
            break;

        case MSG_CTL_CANCEL:
        case MSG_APP_CANCEL:
            MMK_CloseWin(win_id);
            break;

        default:
            recode = MMI_RESULT_FALSE;
            break;
    }
    return recode;

}

LOCAL MMI_RESULT_E EngDebugAPRGroupWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
	MMI_RESULT_E result = MMI_RESULT_TRUE;

	switch (msg_id) 
	{
		case MSG_OPEN_WINDOW:	
		{
			uint8 ucCur_item = 0;
			wchar wstr[255] = {0};
			char* str = PNULL;
			MMI_STRING_T text = {0};
			
			GUIFORM_SetType(MMIENG_FORM_CTRL_ID, GUIFORM_TYPE_TP);

			GUIFORM_SetStyle(MMIENG_COMMON_CTRL4_ID,GUIFORM_STYLE_UNIT);

			GUILIST_SetMaxItem(MMIENG_COMMON_EDIT_CTRL5_ID,4, FALSE );//max item 2
			GUILIST_SetOwnSofterKey(MMIENG_COMMON_EDIT_CTRL5_ID,TRUE);
			MMIENGSET_AppendListItemByTextIdExt(TXT_ENG_DEB_APR_GROUP_CSSLAB,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,MMIENG_COMMON_EDIT_CTRL5_ID,GUIITEM_STYLE_1STR_ENG);
			MMIENGSET_AppendListItemByTextIdExt(TXT_ENG_DEB_APR_GROUP_CSFLAB,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,MMIENG_COMMON_EDIT_CTRL5_ID,GUIITEM_STYLE_1STR_ENG);
			MMIENGSET_AppendListItemByTextIdExt(TXT_ENG_DEB_APR_GROUP_CSFT,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,MMIENG_COMMON_EDIT_CTRL5_ID,GUIITEM_STYLE_1STR_ENG);
			MMIENGSET_AppendListItemByTextIdExt(TXT_ENG_DEB_APR_GROUP_Beta,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,MMIENG_COMMON_EDIT_CTRL5_ID,GUIITEM_STYLE_1STR_ENG);

			//func to get the select of group 
			//ucCur_item = ;
	 		GUILIST_SetSelectedItem(MMIENG_COMMON_EDIT_CTRL5_ID, ucCur_item, TRUE);
	 		GUILIST_SetCurItemIndex(MMIENG_COMMON_EDIT_CTRL5_ID, ucCur_item);

			//input manually label 
			str = "Input group manually";
			text.wstr_len = strlen(str);
			text.wstr_ptr = wstr;
			MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
			GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL4_ID, &text, FALSE);  

			//func to get buffer 
			
			//str = (char*)buf;
			//for test 
			str = "Test name";
			text.wstr_len = strlen(str);
			if(text.wstr_len > 0)
			{
				text.wstr_ptr = wstr;
				SCI_MEMSET(wstr, 0,  255*sizeof(wchar));
				MMI_STRNTOWSTR( wstr, 255, (uint8*)str, text.wstr_len, text.wstr_len );
				GUIEDIT_SetString(MMIENG_COMMON_EDIT_CTRL4_ID, text.wstr_ptr,text.wstr_len);
			}
			//GUILIST_SetItemInvalid(MMIENG_COMMON_EDIT_CTRL5_ID,1,TRUE);
			MMK_SetAtvCtrl(win_id, MMIENG_COMMON_EDIT_CTRL5_ID);
		
		}
		break;  
      
		case MSG_FULL_PAINT:
		        break;      

		case MSG_APP_OK:
		case MSG_CTL_OK:
		{
			uint32 iCurCtrl_id =0;
			uint8 iCurSelectIndex =0;

			iCurCtrl_id = MMK_GetActiveCtrlId(win_id);
			switch(iCurCtrl_id)
			{
				case MMIENG_COMMON_EDIT_CTRL5_ID :  
					{
						iCurSelectIndex = GUILIST_GetCurItemIndex(iCurCtrl_id);
						//set the select

						 MMK_CloseWin(MMIENG_DEBUG_APR_GROUP_WIN_ID);
					}
					break;
				
				case MMIENG_COMMON_EDIT_CTRL4_ID :
					{
						MMI_STRING_T        edit_str = {0};
						uint8 tmp_string[255] ={0};
						
						GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL4_ID,&edit_str);
						if(edit_str.wstr_len > 0)
						{
							MMIAPICOM_WstrToStr(edit_str.wstr_ptr,tmp_string);
							//set name 

							MMK_CloseWin(MMIENG_DEBUG_APR_GROUP_WIN_ID);	
						}
					}
					break;
				default :
					break;
			}
		}
       	 break;

		case MSG_APP_CANCEL:
		case MSG_CTL_CANCEL:

			MMK_CloseWin(MMIENG_DEBUG_APR_GROUP_WIN_ID);
			break;

		default:
			result = MMI_RESULT_FALSE;
			break;
	}
	return (result);
}
#define ENG_MAX_READ_NUM  (512) 

/********************************************************************************
 NAME:          EngDebugAPRViewLogWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      
 PARAM OUT:     
 AUTHOR:        James.Zhang
 DATE:      0   2007.11.28
********************************************************************************/
LOCAL MMI_RESULT_E EngDebugAPRViewLogWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{

	MMI_RESULT_E result = MMI_RESULT_TRUE;
	uint16          *uint16_str = PNULL;
	switch (msg_id) 
	{
		case MSG_OPEN_WINDOW:
			{
				MMI_STRING_T    text_s = {0};
				uint16          uint16_str_len = 0;
				uint16          temp_len = 0;
				uint32 bytes_read = 0;
				unsigned char* read_buff = NULL;
				unsigned short* file_name = L"E:\\apr.ini";
				SFS_HANDLE hHandle = 0;
				uint32 uiFileSize = 0;

				if(MMIFILE_IsFileExist(file_name, MMIAPICOM_Wstrlen(file_name)))
				{

					hHandle = MMIAPIFMM_CreateFile(file_name, SFS_MODE_READ|SFS_MODE_OPEN_EXISTING, NULL, NULL); 

					if( NULL  ==  hHandle )
					{
						return  FALSE ;
					}
					
					SFS_GetFileSize(hHandle,&uiFileSize);
					SFS_SetFilePointer(hHandle, 0, SFS_SEEK_BEGIN);

					read_buff = SCI_ALLOC_APP(uiFileSize+1);
					SCI_MEMSET(read_buff,0,uiFileSize+1);
					uint16_str = (uint16  *)SCI_ALLOC_APP((uiFileSize +1 )*2);
					SCI_MEMSET(uint16_str,0,(uiFileSize +1 )*2);
					
					if(PNULL == read_buff || PNULL== uint16_str )
					{
						MMIAPIFMM_CloseFile(hHandle);
						return  FALSE ;
					}
		
					if(SFS_NO_ERROR != SFS_ReadFile(hHandle, (void*)read_buff, uiFileSize, (uint32 *)&bytes_read, NULL))
					{
						MMIAPIFMM_CloseFile(hHandle);
						SCI_Free(read_buff);
						return  FALSE ;	
					}
					
					if(bytes_read)
					{
						MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)read_buff, bytes_read);
					}

					MMIAPIFMM_CloseFile(hHandle);
					SCI_Free(read_buff);
					
				}			

				text_s.wstr_ptr = uint16_str;
				text_s.wstr_len = uint16_str_len;
				GUITEXT_SetString(MMIENG_COMMON_EDIT_CTRL6_ID, text_s.wstr_ptr,text_s.wstr_len, FALSE);
				MMK_SetAtvCtrl( win_id, MMIENG_COMMON_EDIT_CTRL6_ID );
			}
			break;
			
		case MSG_FULL_PAINT:

			break;

#ifdef TOUCH_PANEL_SUPPORT 
		case MSG_CTL_PENOK:
#endif 
		case MSG_CTL_MIDSK:
		case MSG_APP_WEB:
		case MSG_CTL_OK:
		case MSG_APP_OK:
			SCI_Free((void * )uint16_str);
			MMK_CloseWin(win_id);
			break;
		case MSG_APP_RED:
		case MSG_CTL_CANCEL:	
		case MSG_APP_CANCEL:
			SCI_Free((void * )uint16_str);
			MMK_CloseWin(win_id);
			break;
			
		default:
			result = MMI_RESULT_FALSE;
			break;
	}

	return result;

}

/********************************************************************************
 NAME:          EngHardWareCamLcdInfoWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      
 PARAM OUT:     
 AUTHOR:        James.Zhang
 DATE:      0   2007.11.28
********************************************************************************/
LOCAL MMI_RESULT_E EngDebugAPRServerWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    
    MMI_RESULT_E                recode   =   MMI_RESULT_TRUE;

    MMI_TEXT_ID_T               str_id[] = {TXT_ENG_DEB_APR_SERVER_ANR,TXT_ENG_DEB_APR_SERVER_NATIVE_CRASH,TXT_ENG_DEB_APR_SERVER_JAVA_CRASH,TXT_ENG_DEB_APR_SERVER_MODEM_ASSERT,TXT_ENG_DEB_APR_SERVER_CRASH_CLASS};
    int16                              i = 0;
    uint16                            max_items = (sizeof(str_id)/sizeof(uint32));
    uint16                            cur_item = 0;
    BOOLEAN                        IsOpen = FALSE; //should get the state from NV
    MMI_CTRL_ID_T               ctrllist_id_option = MMIENG_COMMON_EDIT_CTRL2_ID,ctrllist_id_items = MMIENG_COMMON_EDIT_CTRL3_ID ;
    switch(msg_id) 
   {
        case MSG_OPEN_WINDOW:
		{
			GUIFORM_SetType(MMIENG_COMMON_CTRL1_ID, GUIFORM_TYPE_TP);
			
			GUIFORM_SetStyle(MMIENG_COMMON_CTRL2_ID,GUIFORM_STYLE_NORMAL);
			GUIFORM_SetStyle(MMIENG_COMMON_CTRL3_ID,GUIFORM_STYLE_NORMAL);

			//Open  State
			GUILIST_SetMaxItem(ctrllist_id_option,1, FALSE );	
			GUILIST_SetOwnSofterKey(ctrllist_id_option,TRUE);
			MMIAPISET_AppendListItemByTextIdExt(TXT_OPEN_COMN,TXT_NULL,TXT_ENG_OK,TXT_ENG_RETURN,ctrllist_id_option,GUIITEM_STYLE_1CHECK_ENG);
			//Get the state of APR option and Set 
			IsOpen = TRUE; //should get the state from NV
                   CTRLLIST_SetItemStateById(ctrllist_id_option,0,GUIITEM_STATE_SELECTED,IsOpen);

			//Set the items for open option
			
			GUILIST_SetMaxItem(ctrllist_id_items,max_items, FALSE );
			GUILIST_SetOwnSofterKey(ctrllist_id_items,TRUE);
			//when open is selected  then show items 
			if(!IsOpen)
			{
				GUIFORM_SetChildDisplay(MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_CTRL1_ID), MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_CTRL3_ID), GUIFORM_CHILD_DISP_HIDE);
			}
			else
			{
				 GUIFORM_SetChildDisplay(MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_CTRL1_ID), MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_CTRL3_ID), GUIFORM_CHILD_DISP_NORMAL);
			}
			
			//Set the items --> ANR ....
			for(i = 0; i < max_items; i++) 
			{
				MMIAPISET_AppendListItemByTextIdExt(str_id[i],TXT_NULL,TXT_ENG_OK,TXT_ENG_RETURN,ctrllist_id_items,GUIITEM_STYLE_ONE_LINE_CHECK_EXT);
			}
			//Set the check icon
			for(i = 0; i < max_items; i++ )
			{
				BOOLEAN status = TRUE; //should get the state from NV					
 				CTRLLIST_SetItemStateById(ctrllist_id_items,i,GUIITEM_STATE_SELECTED,status);
			}
			
			MMK_SetAtvCtrl(win_id,ctrllist_id_option);
            		break;
        	}			
        case MSG_FULL_PAINT:
			{
				MMI_HANDLE_T active_ctrl = MMK_GetActiveCtrl(win_id);
				MMI_HANDLE_T ctrllist_id_option_win = MMK_GetCtrlHandleByWin(win_id, ctrllist_id_option);

				if(ctrllist_id_option_win == active_ctrl )
				{
					GUILIST_SetSelectedItem(ctrllist_id_option, 0, TRUE);
					GUILIST_SetCurItemIndex(ctrllist_id_option, 0);
				}
				else
				{
					cur_item = GUILIST_GetCurItemIndex(ctrllist_id_items);
					GUILIST_SetSelectedItem(ctrllist_id_option, cur_item, TRUE);
					GUILIST_SetCurItemIndex(ctrllist_id_option, cur_item);
				}
			}
			MMITHEME_UpdateRect();
        	  break;
#ifdef TOUCH_PANEL_SUPPORT 
        case MSG_CTL_PENOK:
#endif 
        case MSG_CTL_OK:
        case MSG_APP_OK:
		{             

			MMI_HANDLE_T active_ctrl = MMK_GetActiveCtrl(win_id);
			MMI_HANDLE_T ctrllist_id_option_win = MMK_GetCtrlHandleByWin(win_id, ctrllist_id_option);
	
			if(ctrllist_id_option_win == active_ctrl )
			{
				
				if (GUILIST_GetItemState(GUILIST_GetItemPtrByIndex(ctrllist_id_option, 0), GUIITEM_STATE_SELECTED))// Server Open
				{
				   CTRLLIST_SetItemStateById(ctrllist_id_option,0,GUIITEM_STATE_SELECTED,FALSE);
				   GUIFORM_SetChildDisplay(MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_CTRL1_ID), MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_CTRL3_ID), GUIFORM_CHILD_DISP_HIDE);
				   //fucntion to close Server
				}
				else   //Server Close
				{
				    CTRLLIST_SetItemStateById(ctrllist_id_option,0,GUIITEM_STATE_SELECTED,TRUE);
				    GUIFORM_SetChildDisplay(MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_CTRL1_ID), MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_CTRL3_ID), GUIFORM_CHILD_DISP_NORMAL);
				    //function to Open server
				}

			}
			else
			{
				cur_item = GUILIST_GetCurItemIndex(ctrllist_id_items);
				if (GUILIST_GetItemState(GUILIST_GetItemPtrByIndex(ctrllist_id_items, cur_item), GUIITEM_STATE_SELECTED))  //selected  
				{
					CTRLLIST_SetItemStateById(ctrllist_id_items,cur_item,GUIITEM_STATE_SELECTED,FALSE);
					//func to remove the item 
				}
				else
				{
					CTRLLIST_SetItemStateById(ctrllist_id_items,cur_item,GUIITEM_STATE_SELECTED,TRUE);
				      //func to add item  
				}
			}
			MMK_SendMsg(win_id, MSG_FULL_PAINT, PNULL);
		}
            break;
			
        case MSG_APP_WEB:
        case MSG_CTL_MIDSK:
	      break;
		  
        case MSG_CTL_CANCEL:
        case MSG_APP_CANCEL:
		{
			for(i = 0; i < max_items; i++ )
			{
				// gather the item checked
				if (GUILIST_GetItemState(GUILIST_GetItemPtrByIndex(ctrllist_id_items, i), GUIITEM_STATE_SELECTED))
				{ 
					//Checked
					
				}
				else
				{
					//Unchecked
					
				}
			}
		}	
            MMK_CloseWin(win_id);
            break;

        default:
            recode = MMI_RESULT_FALSE;
            break;
    }
    return recode;

}

/*****************************************************************************/
//  Description : handle input username window message
//  Global resource dependence : 
//  Author: li.li
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E EngDebugAPRDetectTimeWinHandleMsg(
                                   MMI_WIN_ID_T	win_id, 
                                   MMI_MESSAGE_ID_E	msg_id, 
                                   DPARAM param
                                   )
{
    MMI_RESULT_E        ret=MMI_RESULT_TRUE;    
    MMI_CTRL_ID_T       ctrl_id=MMIENG_COMMON_EDIT_CTRL4_ID;

    switch(msg_id)
    {
    case MSG_OPEN_WINDOW:
        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;

    case MSG_CLOSE_WINDOW:        
        break;
        
    case MSG_CTL_MIDSK:
    case MSG_CTL_OK:
        {
            MMI_STRING_T 	text_str = {0};
          
            GUIEDIT_GetString(ctrl_id,&text_str);
            if(PNULL==text_str.wstr_ptr || 0==text_str.wstr_len)
            {
                break;
            }
		else
		{
			uint32 addr = 0;
			char temp_strig[6] = {0};
			MMIAPICOM_WstrToStr(text_str.wstr_ptr,temp_strig);
			sscanf(temp_strig, "%d", &addr);
			//Set Detec time 
			//func(addr);
		}
            
            MMK_CloseWin(win_id);
        }
        break;

    case MSG_APP_CANCEL:
    case MSG_CTL_CANCEL: 
        MMK_CloseWin(win_id);
        break;

    default:
        ret = MMI_RESULT_FALSE;
        break;
    }

    return ret;
}


#ifdef FM_SUPPORT
//Connectivity

/********************************************************************************
 NAME:          EngFMOpenInfoWin   
 AUTHOR:        Leon.Wang
 DATE:          2012.11.14
********************************************************************************/

PUBLIC void EngConnectivityOpenInfoWin(uint32 u_ID_ENG_Con )
{
	switch(u_ID_ENG_Con)
	{
		case ID_ENG_FM_REG_MODE:
		    MMK_CreateWin((uint32*)MMIENG_FM_REG_MODE_WIN_TAB, PNULL);
		    break;
		case ID_ENG_FM_OBSERVE_STATE:
		    MMK_CreateWin((uint32*)MMIENG_SHOW_FM_STATE_WIN_TAB, PNULL);
		    break;
		case ID_ENG_FM_DATA_CAPTURE:
		    MMK_CreateWin((uint32*)MMIENG_FM_DATA_CAPTURE_WIN_TAB, PNULL);
		    break;
		case ID_ENG_FM_CHANNEL_SET:
		    MMK_CreateWin((uint32*)MMIENG_FM_CHANNEL_SET_TAB, PNULL);
		    break;
        default:
            break;
	}
}

/********************************************************************************
 NAME:          GetFmStateInfoStr
 DESCRIPTION:   
 PARAM IN:      state_buf - 
                buf_len - 
 PARAM OUT:     state_buf info string len
 AUTHOR:        Shiwei Zhang
 DATE:          2016.06.16
********************************************************************************/
LOCAL int GetFmStateInfoStr(uint8* state_buf, uint32 buf_len)
{
    uint32 offset = 0;
    uint32 tempdata = 0;
    char tmp_buf1[MMIENG_FM_TEST_PARAM_MAX_LEN + 2] = {0};

    if(PNULL == state_buf)
    {
        SCI_TRACE_LOW("mmieng_win.c GetFmStateInfoStr state_buf == null");
        return -1;
    }
    
    SCI_TRACE_LOW("mmieng_win.c GetFmStateInfoStr buf_len is %d", buf_len);
#ifdef PLATFORM_ANTISW3
    if(248 > buf_len)
    {
        return -2;
    }

    MMI_MEMCPY(state_buf, buf_len, "<Seek Cnt>", 10, 10);
    offset = 10;
    state_buf[offset] = CR_CHAR;
    offset += 1;
    #ifndef WIN32
    tempdata = FM_OPERATION_get_seek_cnt_info();
    #else 
    tempdata =11;
    #endif
    sprintf(tmp_buf1, "%d", tempdata);
    MMI_MEMCPY(state_buf + offset, buf_len - offset, tmp_buf1, MMIENG_FM_TEST_PARAM_MAX_LEN + 2, SCI_STRLEN(tmp_buf1));
    offset += SCI_STRLEN(tmp_buf1);
    state_buf[offset] = CR_CHAR;
    offset += 1;

    MMI_MEMCPY(state_buf + offset, buf_len - offset, "<Freq Seek>", 11, 11);
    offset += 11;
    state_buf[offset] = CR_CHAR;
    offset += 1;
    #ifndef WIN32
    tempdata = FM_OPERATION_get_freq_seek_info();
    #else 
    tempdata = 2;
    #endif
    sprintf(tmp_buf1, "%d", tempdata);
    MMI_MEMCPY(state_buf + offset, buf_len - offset, tmp_buf1, MMIENG_FM_TEST_PARAM_MAX_LEN + 2, SCI_STRLEN(tmp_buf1));
    offset += SCI_STRLEN(tmp_buf1);
    state_buf[offset] = CR_CHAR;
    offset += 1;

    MMI_MEMCPY(state_buf + offset, buf_len - offset, "<Freq Offset>", 13, 13);
    offset += 13;
    state_buf[offset] = CR_CHAR;
    offset += 1;
    #ifndef WIN32
    tempdata = FM_OPERATION_get_freq_offset_info();
    #else
    tempdata = 3;
    #endif
    sprintf(tmp_buf1, "%d", tempdata);
    MMI_MEMCPY(state_buf + offset, buf_len - offset, tmp_buf1, MMIENG_FM_TEST_PARAM_MAX_LEN + 2, SCI_STRLEN(tmp_buf1));
    offset += SCI_STRLEN(tmp_buf1);
    state_buf[offset] = CR_CHAR;
    offset += 1;

    MMI_MEMCPY(state_buf + offset, buf_len - offset, "<Rf Rssi>", 9, 9);
    offset += 9;
    state_buf[offset] = CR_CHAR;
    offset += 1;
    #ifndef WIN32 
    tempdata = FM_OPERATION_get_rf_rssi_info();
    #else
    tempdata =4 ;
    #endif 
    sprintf(tmp_buf1, "%d", tempdata);
    MMI_MEMCPY(state_buf + offset, buf_len - offset, tmp_buf1, MMIENG_FM_TEST_PARAM_MAX_LEN + 2, SCI_STRLEN(tmp_buf1));
    offset += SCI_STRLEN(tmp_buf1);
    state_buf[offset] = CR_CHAR;
    offset += 1;

    MMI_MEMCPY(state_buf + offset, buf_len - offset, "<Inpwr>", 7, 7);
    offset += 7;
    state_buf[offset] = CR_CHAR;
    offset += 1;
    #ifndef WIN32 
    tempdata = FM_OPERATION_get_inpwr_info();
    #else 
    tempdata =5;
    #endif 
    sprintf(tmp_buf1, "%d", tempdata);
    MMI_MEMCPY(state_buf + offset, buf_len - offset, tmp_buf1, MMIENG_FM_TEST_PARAM_MAX_LEN + 2, SCI_STRLEN(tmp_buf1));
    offset += SCI_STRLEN(tmp_buf1);
    state_buf[offset] = CR_CHAR;
    offset += 1;

    MMI_MEMCPY(state_buf + offset, buf_len - offset, "<Fm Sts>", 8, 8);
    offset += 8;
    state_buf[offset] = CR_CHAR;
    offset += 1;
    #ifndef WIN32 
    tempdata = FM_OPERATION_get_fm_sts_info();
    #else 
    tempdata = 5;
    #endif
    sprintf(tmp_buf1, "%d", tempdata);
    MMI_MEMCPY(state_buf + offset, buf_len - offset, tmp_buf1, MMIENG_FM_TEST_PARAM_MAX_LEN + 2, SCI_STRLEN(tmp_buf1));
    offset += SCI_STRLEN(tmp_buf1);
    state_buf[offset] = CR_CHAR;
    offset += 1;

    MMI_MEMCPY(state_buf + offset, buf_len - offset, "<Rssi>", 6, 6);
    offset += 6;
    state_buf[offset] = CR_CHAR;
    offset += 1;
    #ifndef WIN32 
    tempdata = FM_OPERATION_get_rssi_info();
    #else 
    tempdata = 6;
    #endif
    sprintf(tmp_buf1, "%d", tempdata);
    MMI_MEMCPY(state_buf + offset, buf_len - offset, tmp_buf1, MMIENG_FM_TEST_PARAM_MAX_LEN + 2, SCI_STRLEN(tmp_buf1));
    offset += SCI_STRLEN(tmp_buf1);
    state_buf[offset] = CR_CHAR;
    offset += 1;

    MMI_MEMCPY(state_buf + offset, buf_len - offset, "<Agc sts>", 9, 9);
    offset += 9;
    state_buf[offset] = CR_CHAR;
    offset += 1;
    #ifndef WIN32 
    tempdata = FM_OPERATION_get_agc_sts_info();
    #else 
    tempdata = 7;
    #endif
    sprintf(tmp_buf1, "%d", tempdata);
    MMI_MEMCPY(state_buf + offset, buf_len - offset, tmp_buf1, MMIENG_FM_TEST_PARAM_MAX_LEN + 2, SCI_STRLEN(tmp_buf1));
    offset += SCI_STRLEN(tmp_buf1);
    state_buf[offset] = CR_CHAR;
    offset += 1;

    MMI_MEMCPY(state_buf + offset, buf_len - offset, "<Pwr30>", 7, 7);
    offset += 7;
    state_buf[offset] = CR_CHAR;
    offset += 1;
    #ifdef WIN32 
    tempdata = 8;
    #else 
    tempdata = FM_OPERATION_get_pwr30_info();
    #endif
    sprintf(tmp_buf1, "%d", tempdata);
    MMI_MEMCPY(state_buf + offset, buf_len - offset, tmp_buf1, MMIENG_FM_TEST_PARAM_MAX_LEN + 2, SCI_STRLEN(tmp_buf1));
    offset += SCI_STRLEN(tmp_buf1);
    state_buf[offset] = CR_CHAR;
    offset += 1;

    MMI_MEMCPY(state_buf + offset, buf_len - offset, "<Pwr31>", 7, 7);
    offset += 7;
    state_buf[offset] = CR_CHAR;
    offset += 1;
    #ifdef WIN32 
    tempdata = 9;
    #else 
    tempdata = FM_OPERATION_get_pwr31_info();
    #endif
    sprintf(tmp_buf1, "%d", tempdata);
    MMI_MEMCPY(state_buf + offset, buf_len - offset, tmp_buf1, MMIENG_FM_TEST_PARAM_MAX_LEN + 2, SCI_STRLEN(tmp_buf1));
    offset += SCI_STRLEN(tmp_buf1);
    state_buf[offset] = CR_CHAR;
    offset += 1;

    MMI_MEMCPY(state_buf + offset, buf_len - offset, "<Pilot>", 7, 7);
    offset += 7;
    state_buf[offset] = CR_CHAR;
    offset += 1;
    #ifdef WIN32 
    tempdata = 9;
    #else 
    tempdata = FM_OPERATION_get_pilot_info();
    #endif
    sprintf(tmp_buf1, "%d", tempdata);
    MMI_MEMCPY(state_buf + offset, buf_len - offset, tmp_buf1, MMIENG_FM_TEST_PARAM_MAX_LEN + 2, SCI_STRLEN(tmp_buf1));
    offset += SCI_STRLEN(tmp_buf1);
    state_buf[offset] = CR_CHAR;
    offset += 1;
#endif    
    return (offset);
}
LOCAL MMI_RESULT_E EngShowFmStateWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    uint8 buf[255] = {0};
    wchar wstr[255] = {0};
    char* str = PNULL;
    MMI_STRING_T text = {0};
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:

        str = (char*)buf;
        text.wstr_len = GetFmStateInfoStr(buf, 255);
        if(text.wstr_len > 0)
        {
            text.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, 255, (uint8*)str, text.wstr_len, text.wstr_len );
            GUITEXT_SetString(MMIENG_TEXTBOX1_CTRL_ID, text.wstr_ptr,text.wstr_len, FALSE);
        }
        MMK_SetAtvCtrl(MMIENG_SHOW_FM_STATE_WIN_ID, MMIENG_TEXTBOX1_CTRL_ID);
        break;
        
    case MSG_CTL_MIDSK:     
    case MSG_CTL_OK:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(MMIENG_SHOW_FM_STATE_WIN_ID);
        break;
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}
#endif
/********************************************************************************
 NAME:          WstrToNum
 DESCRIPTION:   if  PARAM is illegal, return 0 
 AUTHOR:        Shiwei Zhang
 DATE:          
********************************************************************************/
uint32 WstrToNum(wchar              *wstr_ptr,   //in:
                            uint16             wstr_len     //in:
                            )
{
    uint16 i = 0;
    uint32 value = 0;
    uint8   tmp_string[MMIENG_FM_TEST_PARAM_MAX_LEN] = {0};
    if (wstr_ptr == NULL || wstr_len == 0)
    {
        return 0;
    }
    else
    {
        for (i = 0; i < wstr_len; i++)
        {
            if((wstr_ptr[i] < '0') || (wstr_ptr[i] > '9' && wstr_ptr[i] < 'A') ||(wstr_ptr[i] > 'F' && wstr_ptr[i] < 'a')
                || (wstr_ptr[i] > 'f'))
            {
                return 0;
            }
        }
        MMIAPICOM_WstrToStr(wstr_ptr,tmp_string);
        sscanf(tmp_string, "%x", &value);
        return value;
    }
}
/********************************************************************************
 NAME:          NumToWstr
 DESCRIPTION:   if  PARAM is illegal, return 0, else return wstr_len
 AUTHOR:        Shiwei Zhang
 DATE:          
********************************************************************************/
uint32 NumToWstr(uint32             number,     //in:
                            wchar              *wstr_ptr   //out:
                            )
{
    uint32 wstr_len = 0;
    uint8   tmp_string[MMIENG_FM_TEST_PARAM_MAX_LEN] = {0};
    if (wstr_ptr == NULL)
    {
        return 0;
    }
    else
    {
        sprintf(tmp_string, "%x", number);
        MMIAPICOM_StrToWstr(tmp_string, wstr_ptr);
        wstr_len = MMIAPICOM_Wstrlen(wstr_ptr);
        return wstr_len;
    }
}
#ifdef FM_SUPPORT
/*****************************************************************************/
//  Description : handle eng fm register test win msg
//  Global resource dependence : 
//  Author: Shiwei Zhang
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E EngFmRegModeWinHandleMsg(
                                                   MMI_WIN_ID_T       win_id,
                                                   MMI_MESSAGE_ID_E   msg_id,
                                                   DPARAM             param
                                                   )
{
    uint32              addr = 0;
    uint32              data = 0;
    MMI_RESULT_E        result = MMI_RESULT_TRUE;
    MMI_STRING_T        edit_1_str = {0};
    MMI_STRING_T        edit_2_str = {0};
    wchar   local_wstr[MMIENG_FM_TEST_PARAM_MAX_LEN];   
    MMI_CTRL_ID_T       edit_1_ctrl_id = MMIENG_FM_REG_MODE_PARAM_1_EDIT_CTRL_ID;
    MMI_CTRL_ID_T       edit_2_ctrl_id = MMIENG_FM_REG_MODE_PARAM_2_EDIT_CTRL_ID;

    switch (msg_id)
    {
    case MSG_OPEN_WINDOW:
        GUILABEL_SetTextById(MMIENG_FM_REG_MODE_LABEL_1_CTRL_ID, TXT_ENG_FM_REG_MODE_ADDR, FALSE);
        GUILABEL_SetTextById(MMIENG_FM_REG_MODE_LABEL_2_CTRL_ID, TXT_ENG_FM_REG_MODE_DATA, FALSE);
        MMK_SetAtvCtrl(win_id,edit_1_ctrl_id);
        break;

    case MSG_FULL_PAINT:
        break;

    case MSG_NOTIFY_RESIZE:
        if (MMK_IsFocusWin(win_id))
        {
            MMK_SendMsg(win_id,MSG_FULL_PAINT,PNULL);
        }
        break;

    case MSG_APP_OK:
        break;
    case MSG_CTL_OK:
        SCI_TRACE_LOW("[ENG_FM] write rigster--------");//left key
        //get  reg address
        GUIEDIT_GetString(edit_1_ctrl_id,&edit_1_str);
        addr = WstrToNum(edit_1_str.wstr_ptr, edit_1_str.wstr_len);
        if (0 == addr)
        {
            MMIPUB_OpenAlertWarningWin(TXT_COMMON_FORMAT_ERROR);
            break;
        }
        //get writing data
        GUIEDIT_GetString(edit_2_ctrl_id,&edit_2_str);
        data = WstrToNum(edit_2_str.wstr_ptr, edit_2_str.wstr_len);
        if (0 == data)
        {
            MMIPUB_OpenAlertWarningWin(TXT_COMMON_FORMAT_ERROR);
            break;
        }
        SCI_TRACE_LOW("[ENG_FM] EngFmRegModeWinHandleMsg edit_1 hex addr = 0x%x",addr);
        SCI_TRACE_LOW("[ENG_FM] EngFmRegModeWinHandleMsg edit_1 hex data = 0x%x",addr);
        //write reg
        #ifndef WIN32
        FM_OPERATION_write_reg(addr, data);
        #endif
        break;
    case MSG_NOTIFY_MIDSK:
        SCI_TRACE_LOW("[ENG_FM] read rigster--------");//middle key
        //get reg address
        GUIEDIT_GetString(edit_1_ctrl_id,&edit_1_str);
        addr = WstrToNum(edit_1_str.wstr_ptr, edit_1_str.wstr_len);
        if (0 == addr)
        {
            MMIPUB_OpenAlertWarningWin(TXT_COMMON_FORMAT_ERROR);
            break;
        }
        SCI_TRACE_LOW("[ENG_FM] EngFmRegModeWinHandleMsg edit_1 hex addr = 0x%x",addr);
        //read reg data
        #ifndef WIN32
        FM_OPERATION_read_reg(addr, &data);
        #else
        data =1234;
        #endif
        SCI_TRACE_LOW("[ENG_FM] EngFmRegModeWinHandleMsg edit_1 hex data = 0x%x",data);
        edit_2_str.wstr_len = NumToWstr(data, local_wstr);
        edit_2_str.wstr_ptr = local_wstr;

        GUIEDIT_SetString(edit_2_ctrl_id,edit_2_str.wstr_ptr,edit_2_str.wstr_len);
        MMK_SendMsg(win_id,MSG_FULL_PAINT,PNULL);
 
        //SCI_TRACE_LOW("[ENG_FM] EngFmRegModeWinHandleMsg edit_1 %c%c%c%c", edit_1_str.wstr_ptr[0],edit_1_str.wstr_ptr[1],edit_1_str.wstr_ptr[2],edit_1_str.wstr_ptr[3]);
        //SCI_TRACE_LOW("[ENG_FM] EngFmRegModeWinHandleMsg edit_2 %c%c%c%c", edit_2_str.wstr_ptr[0],edit_2_str.wstr_ptr[1],edit_2_str.wstr_ptr[2],edit_2_str.wstr_ptr[3]);
        break;

    case MSG_CTL_CANCEL:
    case MSG_APP_CANCEL:
        MMK_CloseWin(win_id);
        break;

    default:
        result = MMI_RESULT_FALSE;
        break;
    }

    return (result);
}
/*****************************************************************************/
//  Description : handle eng fm data capture win msg
//  Global resource dependence : 
//  Author: Shiwei Zhang
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E EngFmDataCaptureWinHandleMsg(
                                                   MMI_WIN_ID_T       win_id,
                                                   MMI_MESSAGE_ID_E   msg_id,
                                                   DPARAM             param
                                                   )
{
    uint32              level = 0;
    uint32              num = 0;
    MMI_RESULT_E        result = MMI_RESULT_TRUE;
    MMI_STRING_T        edit_1_str = {0};
    MMI_STRING_T        edit_2_str = {0};
    wchar   local_wstr[MMIENG_FM_TEST_PARAM_MAX_LEN];   
    MMI_CTRL_ID_T       edit_1_ctrl_id = MMIENG_FM_DATA_CAPTURE_PARAM_1_EDIT_CTRL_ID;
    MMI_CTRL_ID_T       edit_2_ctrl_id = MMIENG_FM_DATA_CAPTURE_PARAM_2_EDIT_CTRL_ID;

    switch (msg_id)
    {
    case MSG_OPEN_WINDOW:
		
        GUILABEL_SetTextById(MMIENG_FM_DATA_CAPTURE_LABEL_1_CTRL_ID, TXT_ENG_FM_DATA_CAPTURE_LEVEL, FALSE);
        GUILABEL_SetTextById(MMIENG_FM_DATA_CAPTURE_LABEL_2_CTRL_ID, TXT_ENG_FM_DATA_CAPTURE_NUM, FALSE);
        MMK_SetAtvCtrl(win_id,edit_1_ctrl_id);

        break;

    case MSG_FULL_PAINT:
        break;

    case MSG_NOTIFY_RESIZE:
        if (MMK_IsFocusWin(win_id))
        {
            MMK_SendMsg(win_id,MSG_FULL_PAINT,PNULL);
        }
        break;

    case MSG_APP_OK:
        break;
    case MSG_CTL_OK:
    case MSG_NOTIFY_MIDSK:
        SCI_TRACE_LOW("[ENG_FM] do capture--------");//left key
        //get  reg address
        GUIEDIT_GetString(edit_1_ctrl_id,&edit_1_str);
        level = WstrToNum(edit_1_str.wstr_ptr, edit_1_str.wstr_len);
        if (0 == level)
        {
            MMIPUB_OpenAlertWarningWin(TXT_COMMON_FORMAT_ERROR);
            break;
        }
        //get writing data
        GUIEDIT_GetString(edit_2_ctrl_id,&edit_2_str);
        num = WstrToNum(edit_2_str.wstr_ptr, edit_2_str.wstr_len);
        if (0 == num)
        {
            MMIPUB_OpenAlertWarningWin(TXT_COMMON_FORMAT_ERROR);
            break;
        }
        SCI_TRACE_LOW("[ENG_FM] EngFmRegModeWinHandleMsg edit_1 hex level = 0x%x",level);
        SCI_TRACE_LOW("[ENG_FM] EngFmRegModeWinHandleMsg edit_1 hex data = 0x%x",num);
        //do data_capture
        #ifndef WIN32
        FM_OPERATION_data_capture(level, num);
        #endif
        break;

    case MSG_CTL_CANCEL:
    case MSG_APP_CANCEL:
        MMK_CloseWin(win_id);
        break;

    default:
        result = MMI_RESULT_FALSE;
        break;
    }

    return (result);
}

/********************************************************************************
 NAME:          EngFMSetChannelTestWinHandleMsg
 DESCRIPTION:  display bt input para 
 PARAM IN:      win_id -  msg_id -  param - 
 PARAM OUT:     
 AUTHOR:        chao.chen
 DATE:          2015.11.30
********************************************************************************/
LOCAL MMI_RESULT_E EngFMSetChannelTestWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
	MMI_STRING_T text = {0};
	wchar wstr[TX_PARAM_LEN] = {0};
	char* str = PNULL;
	uint32 i = 0;
	MMI_STRING_T itemStr = {0};
	MMI_STRING_T        edit_1_str = {0};
	GUISETLIST_ITEM_INFO_T item_info  ={0};
	MMI_RESULT_E result = MMI_RESULT_TRUE;

    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
			
		GUIFORM_SetType(MMIENG_FORM_CTRL_ID, GUIFORM_TYPE_TP);

		GUIFORM_SetStyle(MMIENG_COMMON_CTRL1_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_COMMON_CTRL2_ID,GUIFORM_STYLE_UNIT);
		
		GUIWIN_SetSoftkeyTextId(win_id,  (MMI_TEXT_ID_T)TXT_ENG_FM_EAR, (MMI_TEXT_ID_T)TXT_ENG_FM_EXTRA, (MMI_TEXT_ID_T)TXT_ENG_RETURN, FALSE);

		str = "Set FM Channel";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL1_ID, &text, FALSE);
		
		str = "Set Ear and Ext Switch";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL2_ID, &text, FALSE);
		GUIEDIT_SetStyle(MMIENG_COMMON_EDIT_CTRL2_ID, GUIEDIT_STYLE_SINGLE);


		//	PUBLIC void CTRLBASEFLEX_SetSoftkey (
		//	    MMI_CTRL_ID_T                    ctrl_id,    //in:
		//	    uint16                           index,      //in:softkey index    0:left 1:mid  2:right 
		//	    uint16                           str_len,    //in:0,  legth > strlen --->change the softkey when the str inpuit on LCD 
		//	    MMI_TEXT_ID_T                    text_1,     //in:<str_len     display text_1
		//	    MMI_TEXT_ID_T                    text_2,     //in:>=str_len    display text_2
		//	    MMITHEME_EDIT_SET_BUTTON_PFUNC   setsoftkey  //in:优先通过函数设置softkey[in:字符串指针in:字符串长度,out:softkey值]
		//	)

		GUIEDIT_SetSoftkey(MMIENG_COMMON_EDIT_CTRL2_ID,0,0,TXT_ENG_COMMON_SET,TXT_ENG_COMMON_SET,PNULL);
		GUIEDIT_SetSoftkey(MMIENG_COMMON_EDIT_CTRL2_ID,1,0,NULL,NULL,PNULL);
		GUIEDIT_SetSoftkey(MMIENG_COMMON_EDIT_CTRL2_ID,2,0,TXT_ENG_RETURN,TXT_ENG_RETURN,PNULL);
		
		GUILIST_SetMaxItem(MMIENG_COMMON_EDIT_CTRL3_ID,4, FALSE );//max item 2
		GUILIST_SetOwnSofterKey(MMIENG_COMMON_EDIT_CTRL3_ID,TRUE);
		MMIENGSET_AppendListItemByTextIdExt(TXT_ENG_FM_RDS_BLER_SET,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,MMIENG_COMMON_EDIT_CTRL3_ID,GUIITEM_STYLE_1STR_ENG);
		MMIENGSET_AppendListItemByTextIdExt(TXT_ENG_FM_NOISE_SCAN,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,MMIENG_COMMON_EDIT_CTRL3_ID,GUIITEM_STYLE_1STR_ENG);
		MMIENGSET_AppendListItemByTextIdExt(TXT_ENG_FM_TUNE_MODE,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,MMIENG_COMMON_EDIT_CTRL3_ID,GUIITEM_STYLE_1STR_ENG);
		MMIENGSET_AppendListItemByTextIdExt(TXT_ENG_FM_AUDIO_MODE,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,MMIENG_COMMON_EDIT_CTRL3_ID,GUIITEM_STYLE_1STR_ENG);
		MMK_SetAtvCtrl(win_id, MMIENG_COMMON_EDIT_CTRL1_ID);
		
        break;  
      
    case MSG_FULL_PAINT:
            break;

    case MSG_CTL_MIDSK:
    case MSG_APP_WEB:
		{
			uint32 iCurCtrl_id =0;
			float fFMChannel = 0;
			uint8 tmp_string[10] ={0};
		
			iCurCtrl_id = MMK_GetActiveCtrlId(win_id);
			switch(iCurCtrl_id)
			{
				case MMIENG_COMMON_EDIT_CTRL1_ID: //set as extra

					GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL1_ID,&edit_1_str);
					MMIAPICOM_WstrToStr(edit_1_str.wstr_ptr,tmp_string);
       				sscanf(tmp_string, "%f", &fFMChannel);
					SCI_TRACE_LOW("[ENG] Set Channel and Play [%d] ",fFMChannel);
					//Extra Set
					break;
				default :
						break;
			}
		}
		break;

    case MSG_APP_OK:
    case MSG_CTL_OK:
	{
		int iCurSelectIndex =0;
		uint32 iCurCtrl_id =0;
		
		float fFMChannel = 0;
		uint32 uiFMTimes=0;
		uint8 tmp_string[10] ={0};
	
		iCurCtrl_id = MMK_GetActiveCtrlId(win_id);
		switch(iCurCtrl_id)
		{
			case MMIENG_COMMON_EDIT_CTRL1_ID:   //set as ear
				{
					GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL1_ID,&edit_1_str);
					MMIAPICOM_WstrToStr(edit_1_str.wstr_ptr,tmp_string);
       				sscanf(tmp_string, "%f", &fFMChannel);
					SCI_TRACE_LOW("[ENG] Set Channel and Play [%d] ",fFMChannel);
					//Ear Set
				}
				break;
			case MMIENG_COMMON_EDIT_CTRL2_ID:  //change time
				{
					GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL2_ID,&edit_1_str);
					MMIAPICOM_WstrToStr(edit_1_str.wstr_ptr,tmp_string);
       				sscanf(tmp_string, "%d", &uiFMTimes);
					SCI_TRACE_LOW("[ENG] Set Change times [%d] ",uiFMTimes);
				}
				break;	
				
		      case MMIENG_TEXTBOX1_CTRL_ID:
				{
					GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL1_ID,&edit_1_str);
					MMIAPICOM_WstrToStr(edit_1_str.wstr_ptr,tmp_string);
					sscanf(tmp_string, "%d", &uiFMTimes);
					SCI_TRACE_LOW("[ENG] Set Change times [%d] ",uiFMTimes);
				}
				break;
			
			case MMIENG_COMMON_EDIT_CTRL3_ID:
				{
					enum { ENG_FM_RDS_BLER = 0,ENG_FM_NOISE_SCAN = 1,ENG_FM_TUNE_MODE = 2,ENG_FM_AUDIO_MODE = 3};
					iCurSelectIndex = GUILIST_GetCurItemIndex(iCurCtrl_id);
				      switch(iCurSelectIndex)
					{
						case ENG_FM_RDS_BLER:
							MMK_CreateWin((uint32*)MMIENG_SHOW_FM_RDS_BLER_TAB, PNULL);
							break;
						case ENG_FM_NOISE_SCAN: 
							MMK_CreateWin((uint32*)MMIENG_SHOW_FM_NOISE_SCAN_TAB, PNULL);
							break;
						case ENG_FM_TUNE_MODE:
							MMK_CreateWin((uint32*)MMIENG_SHOW_FM_TUNE_MODE_TAB, PNULL);
							break;
						case ENG_FM_AUDIO_MODE:
							MMK_CreateWin((uint32*)MMIENG_SHOW_FM_AUDIO_MODE_TAB, PNULL);
							break;
						default:
							SCI_TRACE_LOW("[ENG] FM iCurSelectIndex unknown  ");
							break;								
					}
				}
				break;			
		}
	}
        break;
        
    case MSG_APP_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

/********************************************************************************
 NAME:          EngShowFMRdsBler_WINMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        zhaohui
 DATE:          2008.09.19
********************************************************************************/
LOCAL MMI_RESULT_E EngShowFMRdsBler_WINMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E            result = MMI_RESULT_TRUE;
    GUI_RECT_T                rect = MMITHEME_GetFullScreenRect();
    GUI_LCD_DEV_INFO    lcd_dev_info = {GUI_MAIN_LCD_ID, GUI_BLOCK_MAIN};
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
	MMK_SetAtvCtrl(win_id, MMIENG_3RDPARTY_VERSION_CTRL_ID);
	{
		wchar        unicode_cr = 0x0d;
		MMI_STRING_T    cr_s = {0};
		MMI_STRING_T    text_s = {0};
		uint16           uint16_str[30 + 1] = {0};
		uint16           uint16_str_len = 0;
		char*           temp_ptr = PNULL;
		uint16          temp_len = 0;
		char            sRDS_BLER[50] = {0};
		cr_s.wstr_ptr = &unicode_cr;
		cr_s.wstr_len = 1;

		//set BLER
		temp_ptr =  sRDS_BLER;
#ifndef WIN32
		sprintf(sRDS_BLER,"RDS BLER : %d%% ",93);
#else
		sprintf(sRDS_BLER,"RDS BLER : %d%% ",93);
#endif
		temp_len = SCI_STRLEN((char*)temp_ptr);
		MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)temp_ptr, temp_len );
		MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行

		text_s.wstr_ptr = uint16_str;
		text_s.wstr_len = uint16_str_len;

		GUITEXT_SetString(MMIENG_3RDPARTY_VERSION_CTRL_ID, text_s.wstr_ptr, text_s.wstr_len, FALSE);
	}
        break;
        
    case MSG_FULL_PAINT:
        lcd_dev_info.lcd_id = GUI_MAIN_LCD_ID;
        lcd_dev_info.block_id = GUI_BLOCK_MAIN;
        LCD_FillRect(&lcd_dev_info, rect, mmi_eng_display.bkgd_color);
        break;

    case MSG_APP_OK:
    case MSG_CTL_OK: 
    case MSG_APP_CANCEL:
    case MSG_CTL_CANCEL:
         MMK_CloseWin(win_id);
        break;
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

/********************************************************************************
 NAME:          EngShowFMRdsBler_WINMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        zhaohui
 DATE:          2008.09.19
********************************************************************************/

LOCAL MMI_RESULT_E EngFMNoiseScanWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
	MMI_STRING_T text = {0};
	wchar wstr[TX_PARAM_LEN] = {0};
	char* str = PNULL;
	uint32 i = 0;
	MMI_STRING_T itemStr = {0};
	MMI_STRING_T        edit_1_str = {0};
	GUISETLIST_ITEM_INFO_T item_info  ={0};
	MMI_RESULT_E result = MMI_RESULT_TRUE;

    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
			
		GUIFORM_SetType(MMIENG_FORM_CTRL_ID, GUIFORM_TYPE_TP);

		GUIFORM_SetStyle(MMIENG_COMMON_CTRL4_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_COMMON_CTRL5_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_COMMON_CTRL6_ID,GUIFORM_STYLE_UNIT);

		str = "Start freqency(MHz)";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL4_ID, &text, FALSE);

		str = "End freqency(MHz)";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL5_ID, &text, FALSE);

		str = "Delay(ms)";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL6_ID, &text, FALSE);

		MMK_SetAtvCtrl(win_id, MMIENG_COMMON_EDIT_CTRL4_ID);
		
        break;  
      
    case MSG_FULL_PAINT:
            break;      

    case MSG_APP_OK:
    case MSG_CTL_OK:

	  MMK_CreateWin((uint32 *) MMIENG_SHOW_FM_NOISE_SCAN_SHOW_TAB, PNULL)     ; 
        break;
        
    case MSG_APP_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}


uint32 ui_scan_show_timer = 0;

/********************************************************************************
 NAME:          EngFMNoiseScanShowWinHandleMsg
 DESCRIPTION:  display bt input para 
 PARAM IN:      win_id -  msg_id -  param - 
 PARAM OUT:     
 AUTHOR:        chao.chen
 DATE:          2015.11.30
********************************************************************************/
LOCAL MMI_RESULT_E EngFMNoiseScanShowWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
	MMI_RESULT_E  result = MMI_RESULT_TRUE;

	MMI_CTRL_ID_T ctrl_id = MMIENG_BT_NOSIGNAL_TESTCTRL_ID;
	uint16        cur_selection = 0;
	static float fFMFreqBegin=0 , fFMFreqEnd = 0;

	MMI_STRING_T        Get_edit_str = {0};
	wchar  txt_array[50] = {0};
	char buf[25] = {0};
	uint16  txt_len = 0;
	static uint32 uiMaxItem = 0;
	static uint32 uiFMDelayTime = 0;
	switch (msg_id) 
	{
	case MSG_OPEN_WINDOW:
		{
			uint8 tmp_string[10] ={0};

			GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL4_ID,&Get_edit_str);
			MMIAPICOM_WstrToStr(Get_edit_str.wstr_ptr,tmp_string);
			sscanf(tmp_string, "%f", &fFMFreqBegin);

			GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL5_ID,&Get_edit_str);
			MMIAPICOM_WstrToStr(Get_edit_str.wstr_ptr,tmp_string);
			sscanf(tmp_string, "%f", &fFMFreqEnd);

			GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL6_ID,&Get_edit_str);
			MMIAPICOM_WstrToStr(Get_edit_str.wstr_ptr,tmp_string);
			sscanf(tmp_string, "%d", &uiFMDelayTime);
			if(fFMFreqEnd>fFMFreqBegin)
			{
				uiMaxItem = (fFMFreqEnd - fFMFreqBegin)/(0.1)+1;
			}
			else
			{
				SCI_TRACE_LOW("[ENG] err Set Change times [%d] ",fFMFreqBegin);
			}
			
			GUILIST_SetMaxItem(ctrl_id,uiMaxItem+1, FALSE );//max item 2
			GUILIST_SetOwnSofterKey(ctrl_id,TRUE);

			sprintf(buf, "Freq      Rssi        Snr");
			SCI_MEMSET(txt_array, 0,  50*sizeof(wchar));
			txt_len = SCI_STRLEN(buf);
			MMI_STRNTOWSTR(txt_array, 50, (uint8*)buf, 50, txt_len);
			MMIAPISET_AppendListItemByTextBuffer(txt_array, 
			                        txt_len, 
			                        0,
			                        TXT_ENG_OK, 
			                        TXT_NULL, 
			                        TXT_ENG_RETURN, 
			                        ctrl_id,
			                        GUIITEM_STYLE_1STR_ENG
			                        );
			
			GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
			GUILIST_SetCurItemIndex(ctrl_id,cur_selection);
			MMIDEFAULT_AllowTurnOffBackLight( FALSE );
			MMK_SetAtvCtrl(win_id,ctrl_id);
			ui_scan_show_timer = MMK_CreateWinTimer( win_id, uiFMDelayTime, TRUE );
		}
		break;
		
	case MSG_FULL_PAINT:
		GUILIST_SetSelectedItem(ctrl_id, GUILIST_GetTotalItemNum(ctrl_id)-1, TRUE);
		GUILIST_SetCurItemIndex(ctrl_id,GUILIST_GetTotalItemNum(ctrl_id)-1);
		MMITHEME_UpdateRect();
		break;

		
#ifdef TOUCH_PANEL_SUPPORT 
	case MSG_CTL_PENOK:
#endif 
	case MSG_CTL_MIDSK:
	case MSG_CTL_OK:
	case MSG_APP_WEB:
		
		break;
	        
      case MSG_TIMER:
        {
		if ( 0 != ui_scan_show_timer )
		{
			MMK_StopTimer( ui_scan_show_timer );
			ui_scan_show_timer = 0;
		}
		sprintf(buf, "%.1f      %d      %d",fFMFreqBegin,uiMaxItem,2);				
		fFMFreqBegin+=0.1;
		SCI_MEMSET(txt_array, 0,  50*sizeof(wchar));
		txt_len = SCI_STRLEN(buf);
		MMI_STRNTOWSTR(txt_array, 50, (uint8*)buf, 50, txt_len);
		MMIAPISET_AppendListItemByTextBuffer(txt_array, 
		                        txt_len, 
		                        0,
		                        TXT_ENG_OK, 
		                        TXT_NULL, 
		                        TXT_ENG_RETURN, 
		                        ctrl_id,
		                        GUIITEM_STYLE_1STR_ENG
		                        );
		
		if(--uiMaxItem)
		{
			 ui_scan_show_timer = MMK_CreateWinTimer( win_id, uiFMDelayTime, TRUE );
		}
		MMK_SendMsg(win_id, MSG_FULL_PAINT, PNULL);
        }
        break;
	case MSG_CTL_CANCEL:    
	case MSG_APP_CANCEL:
		MMIDEFAULT_AllowTurnOffBackLight( TRUE );
		
		if ( 0 != ui_scan_show_timer )
		{
			MMK_StopTimer( ui_scan_show_timer );
			ui_scan_show_timer = 0;
		}

		MMK_CloseWin(win_id);
		break;
		
	default:
		result = MMI_RESULT_FALSE;
		break;
    }

	return result;
}

/********************************************************************************
 NAME:          ENGFM_GetAudioModeParam
 DESCRIPTION:  display bt input para 
 PARAM IN:      win_id -  msg_id -  param - 
 PARAM OUT:     
 AUTHOR:        chao.chen
 DATE:          2015.11.30
********************************************************************************/
LOCAL void ENGFM_GetAudioModeParam(void)
{
	uint32                uiCurIndex = 0;
	MMI_STRING_T    temp_wstr  = {0};
	char                  buf [TX_PARAM_LEN]={0};

	//softmute hbound
	GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL7_ID, &temp_wstr);
	SCI_MEMSET(buf,0,TX_PARAM_LEN);
	MMI_WSTRNTOSTR((uint8*)buf, TX_PARAM_LEN, temp_wstr.wstr_ptr, temp_wstr.wstr_len,MIN(TX_PARAM_LEN,temp_wstr.wstr_len));

	//softmute lbound 
	GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL8_ID, &temp_wstr);
	SCI_MEMSET(buf,0,TX_PARAM_LEN);
	MMI_WSTRNTOSTR((uint8*)buf, TX_PARAM_LEN, temp_wstr.wstr_ptr, temp_wstr.wstr_len,MIN(TX_PARAM_LEN,temp_wstr.wstr_len));

	//power 
	GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL9_ID, &temp_wstr);
	SCI_MEMSET(buf,0,TX_PARAM_LEN);
	MMI_WSTRNTOSTR((uint8*)buf, TX_PARAM_LEN, temp_wstr.wstr_ptr, temp_wstr.wstr_len,MIN(TX_PARAM_LEN,temp_wstr.wstr_len));

	//retardation
	GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL10_ID, &temp_wstr);
	SCI_MEMSET(buf,0,TX_PARAM_LEN);
	MMI_WSTRNTOSTR((uint8*)buf, TX_PARAM_LEN, temp_wstr.wstr_ptr, temp_wstr.wstr_len,MIN(TX_PARAM_LEN,temp_wstr.wstr_len));

	//snr
	GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL11_ID, &temp_wstr);
	SCI_MEMSET(buf,0,TX_PARAM_LEN);
	MMI_WSTRNTOSTR((uint8*)buf, TX_PARAM_LEN, temp_wstr.wstr_ptr, temp_wstr.wstr_len,MIN(TX_PARAM_LEN,temp_wstr.wstr_len));

}

/********************************************************************************
 NAME:          ENGFM_SetTuneModeParam
 DESCRIPTION:  display bt input para 
 PARAM IN:      win_id -  msg_id -  param - 
 PARAM OUT:     
 AUTHOR:        chao.chen
 DATE:          2015.11.30
********************************************************************************/
LOCAL void ENGFM_SetAudioModeParam(MMI_WIN_ID_T win_id)
{
	uint32  i = 0;
	wchar  wchar_buffer[TX_PARAM_LEN + 1] = {0};
	uint8   char_buffer[TX_PARAM_LEN + 1] = {0};


	//softmute hbound
	GUIEDIT_ClearAllStr(MMIENG_COMMON_EDIT_CTRL7_ID);
	_snprintf((char*)char_buffer, TX_PARAM_LEN, "%d",1231);
	MMIAPICOM_StrToWstr(char_buffer, wchar_buffer);           
	GUIEDIT_SetString(MMIENG_COMMON_EDIT_CTRL7_ID, wchar_buffer, MMIAPICOM_Wstrlen(wchar_buffer));

	//softmute lbound 
	GUIEDIT_ClearAllStr(MMIENG_COMMON_EDIT_CTRL8_ID);
	_snprintf((char*)char_buffer, TX_PARAM_LEN, "%d",1231);
	MMIAPICOM_StrToWstr(char_buffer, wchar_buffer);           
	GUIEDIT_SetString(MMIENG_COMMON_EDIT_CTRL8_ID, wchar_buffer, MMIAPICOM_Wstrlen(wchar_buffer));

	//power 
	GUIEDIT_ClearAllStr(MMIENG_COMMON_EDIT_CTRL9_ID);
	_snprintf((char*)char_buffer, TX_PARAM_LEN, "%d",1231);
	MMIAPICOM_StrToWstr(char_buffer, wchar_buffer);           
	GUIEDIT_SetString(MMIENG_COMMON_EDIT_CTRL9_ID, wchar_buffer, MMIAPICOM_Wstrlen(wchar_buffer));

	//retardation
	GUIEDIT_ClearAllStr(MMIENG_COMMON_EDIT_CTRL10_ID);
	_snprintf((char*)char_buffer, TX_PARAM_LEN, "%d",1231);
	MMIAPICOM_StrToWstr(char_buffer, wchar_buffer);           
	GUIEDIT_SetString(MMIENG_COMMON_EDIT_CTRL10_ID, wchar_buffer, MMIAPICOM_Wstrlen(wchar_buffer));

	//snr
	GUIEDIT_ClearAllStr(MMIENG_COMMON_EDIT_CTRL11_ID);
	_snprintf((char*)char_buffer, TX_PARAM_LEN, "%d",1234);
	MMIAPICOM_StrToWstr(char_buffer, wchar_buffer);           
	GUIEDIT_SetString(MMIENG_COMMON_EDIT_CTRL11_ID, wchar_buffer, MMIAPICOM_Wstrlen(wchar_buffer));

	MMK_SendMsg(win_id, MSG_FULL_PAINT, PNULL);	
	
}

/********************************************************************************
 NAME:          ENGFM_GetTuneModeParam
 DESCRIPTION:  display bt input para 
 PARAM IN:      win_id -  msg_id -  param - 
 PARAM OUT:     
 AUTHOR:        chao.chen
 DATE:          2015.11.30
********************************************************************************/
LOCAL void ENGFM_GetTuneModeParam(void)
{
	uint32                uiCurIndex = 0;
	MMI_STRING_T    temp_wstr  = {0};
	char                  buf [TX_PARAM_LEN]={0};
	char                  buf_out[TX_PARAM_LEN]={0};
	uint32               uiAddr_tune = 0;
	//rssi  
	GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL7_ID, &temp_wstr);
	SCI_MEMSET(buf,0,TX_PARAM_LEN);
	MMI_WSTRNTOSTR((uint8*)buf, TX_PARAM_LEN, temp_wstr.wstr_ptr, temp_wstr.wstr_len,MIN(TX_PARAM_LEN,temp_wstr.wstr_len));

	//snr 
	GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL8_ID, &temp_wstr);
	SCI_MEMSET(buf,0,TX_PARAM_LEN);
	MMI_WSTRNTOSTR((uint8*)buf, TX_PARAM_LEN, temp_wstr.wstr_ptr, temp_wstr.wstr_len,MIN(TX_PARAM_LEN,temp_wstr.wstr_len));

	//freq offset 
	GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL9_ID, &temp_wstr);
	SCI_MEMSET(buf,0,TX_PARAM_LEN);
	MMI_WSTRNTOSTR((uint8*)buf, TX_PARAM_LEN, temp_wstr.wstr_ptr, temp_wstr.wstr_len,MIN(TX_PARAM_LEN,temp_wstr.wstr_len));
	sscanf(buf,"%x",&uiAddr_tune);
	//MMIENG_StringToADDR(buf,4,buf_out);

	//pilot power
	GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL10_ID, &temp_wstr);
	SCI_MEMSET(buf,0,TX_PARAM_LEN);
	MMI_WSTRNTOSTR((uint8*)buf, TX_PARAM_LEN, temp_wstr.wstr_ptr, temp_wstr.wstr_len,MIN(TX_PARAM_LEN,temp_wstr.wstr_len));
	sscanf(buf,"%x",&uiAddr_tune);
	//MMIENG_StringToADDR(buf,4,buf_out);

	//noise power
	GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL11_ID, &temp_wstr);
	SCI_MEMSET(buf,0,TX_PARAM_LEN);
	MMI_WSTRNTOSTR((uint8*)buf, TX_PARAM_LEN, temp_wstr.wstr_ptr, temp_wstr.wstr_len,MIN(TX_PARAM_LEN,temp_wstr.wstr_len));
	sscanf(buf,"%x",&uiAddr_tune);
	//MMIENG_StringToADDR(buf,4,buf_out);

}

/********************************************************************************
 NAME:          ENGFM_SetTuneModeParam
 DESCRIPTION:  display bt input para 
 PARAM IN:      win_id -  msg_id -  param - 
 PARAM OUT:     
 AUTHOR:        chao.chen
 DATE:          2015.11.30
********************************************************************************/
LOCAL void ENGFM_SetTuneModeParam(MMI_WIN_ID_T win_id)
{
	uint32  i = 0;
	wchar  wchar_buffer[TX_PARAM_LEN + 1] = {0};
	uint8   char_buffer[TX_PARAM_LEN + 1] = {0};

	//rssi
	GUIEDIT_ClearAllStr(MMIENG_COMMON_EDIT_CTRL7_ID);
	_snprintf((char*)char_buffer, TX_PARAM_LEN, "%d",1231);
	MMIAPICOM_StrToWstr(char_buffer, wchar_buffer);           
	GUIEDIT_SetString(MMIENG_COMMON_EDIT_CTRL7_ID, wchar_buffer, MMIAPICOM_Wstrlen(wchar_buffer));

	//snr 
	GUIEDIT_ClearAllStr(MMIENG_COMMON_EDIT_CTRL8_ID);
	_snprintf((char*)char_buffer, TX_PARAM_LEN, "%d",1231);
	MMIAPICOM_StrToWstr(char_buffer, wchar_buffer);           
	GUIEDIT_SetString(MMIENG_COMMON_EDIT_CTRL8_ID, wchar_buffer, MMIAPICOM_Wstrlen(wchar_buffer));

	//freq offset 
	GUIEDIT_ClearAllStr(MMIENG_COMMON_EDIT_CTRL9_ID);
	_snprintf((char*)char_buffer, TX_PARAM_LEN, "%x",1231);
	MMIAPICOM_StrToWstr(char_buffer, wchar_buffer);           
	GUIEDIT_SetString(MMIENG_COMMON_EDIT_CTRL9_ID, wchar_buffer, MMIAPICOM_Wstrlen(wchar_buffer));

	//pilot power
	GUIEDIT_ClearAllStr(MMIENG_COMMON_EDIT_CTRL10_ID);
	_snprintf((char*)char_buffer, TX_PARAM_LEN, "%x",1231);
	MMIAPICOM_StrToWstr(char_buffer, wchar_buffer);           
	GUIEDIT_SetString(MMIENG_COMMON_EDIT_CTRL10_ID, wchar_buffer, MMIAPICOM_Wstrlen(wchar_buffer));

	//noise power
	GUIEDIT_ClearAllStr(MMIENG_COMMON_EDIT_CTRL11_ID);
	_snprintf((char*)char_buffer, TX_PARAM_LEN, "%x",1231);
	MMIAPICOM_StrToWstr(char_buffer, wchar_buffer);           
	GUIEDIT_SetString(MMIENG_COMMON_EDIT_CTRL11_ID, wchar_buffer, MMIAPICOM_Wstrlen(wchar_buffer));

	MMK_SendMsg(win_id, MSG_FULL_PAINT, PNULL);	
	
}


/********************************************************************************
 NAME:          EngFMNoiseScanShowWinHandleMsg
 DESCRIPTION:  display bt input para 
 PARAM IN:      win_id -  msg_id -  param - 
 PARAM OUT:     
 AUTHOR:        chao.chen
 DATE:          2015.11.30
********************************************************************************/
LOCAL MMI_RESULT_E EngFMTuneModeWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
	MMI_STRING_T text = {0};
	wchar wstr[TX_PARAM_LEN] = {0};
	char* str = PNULL;
	uint32 i = 0;
	MMI_STRING_T itemStr = {0};
	MMI_STRING_T        edit_1_str = {0};
	GUISETLIST_ITEM_INFO_T item_info  ={0};
	MMI_RESULT_E result = MMI_RESULT_TRUE;
	
	switch (msg_id) 
	{
	case MSG_OPEN_WINDOW:
			
		GUIFORM_SetType(MMIENG_FORM_CTRL_ID, GUIFORM_TYPE_TP);

		GUIFORM_SetStyle(MMIENG_COMMON_CTRL7_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_COMMON_CTRL8_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_COMMON_CTRL9_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_COMMON_CTRL10_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_COMMON_CTRL11_ID,GUIFORM_STYLE_UNIT);
		
		str = "rssi threshold";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL7_ID, &text, FALSE);

		str = "snr threshold";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL8_ID, &text, FALSE);

		str = "freq offset threshold";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL9_ID, &text, FALSE);

		
		str = "pilot power  threshold";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL10_ID, &text, FALSE);

		str = "noise power threshold";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL11_ID, &text, FALSE);
		
		MMK_SetAtvCtrl(win_id, MMIENG_COMMON_EDIT_CTRL7_ID);

		break;
		
	case MSG_FULL_PAINT:
		MMITHEME_UpdateRect();
		break;

		
#ifdef TOUCH_PANEL_SUPPORT 
	case MSG_CTL_PENOK:
#endif 
	case MSG_CTL_MIDSK:
	case MSG_APP_WEB:
		ENGFM_SetTuneModeParam(win_id);
		break;
	case MSG_CTL_OK:
		ENGFM_GetTuneModeParam();
		break;

	case MSG_CTL_CANCEL:    
	case MSG_APP_CANCEL:

		MMK_CloseWin(win_id);
		break;
		
	default:
		result = MMI_RESULT_FALSE;
		break;
    }

	return result;
}

/********************************************************************************
 NAME:          EngFMNoiseScanShowWinHandleMsg
 DESCRIPTION:  display bt input para 
 PARAM IN:      win_id -  msg_id -  param - 
 PARAM OUT:     
 AUTHOR:        chao.chen
 DATE:          2015.11.30
********************************************************************************/
LOCAL MMI_RESULT_E EngFMAudioModeWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
	MMI_STRING_T text = {0};
	wchar wstr[TX_PARAM_LEN] = {0};
	char* str = PNULL;
	uint32 i = 0;
	MMI_STRING_T itemStr = {0};
	MMI_STRING_T        edit_1_str = {0};
	GUISETLIST_ITEM_INFO_T item_info  ={0};
	MMI_RESULT_E result = MMI_RESULT_TRUE;
	switch (msg_id) 
	{
	case MSG_OPEN_WINDOW:


		GUIFORM_SetType(MMIENG_FORM_CTRL_ID, GUIFORM_TYPE_TP);

		GUIFORM_SetStyle(MMIENG_COMMON_CTRL7_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_COMMON_CTRL8_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_COMMON_CTRL9_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_COMMON_CTRL10_ID,GUIFORM_STYLE_UNIT);
		GUIFORM_SetStyle(MMIENG_COMMON_CTRL11_ID,GUIFORM_STYLE_UNIT);
		
		str = "softmute hbound";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL7_ID, &text, FALSE);

		str = "softmute lbound";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL8_ID, &text, FALSE);

		str = "power threshold";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL9_ID, &text, FALSE);

		
		str = "Retardation coefficient";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL10_ID, &text, FALSE);

		str = "snr threshold";
		text.wstr_len = strlen(str);
		text.wstr_ptr = wstr;
		MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
		GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL11_ID, &text, FALSE);
		
		MMK_SetAtvCtrl(win_id, MMIENG_COMMON_EDIT_CTRL7_ID);
		break;
		
	case MSG_FULL_PAINT:
		MMITHEME_UpdateRect();
		break;

		
#ifdef TOUCH_PANEL_SUPPORT 
	case MSG_CTL_PENOK:
#endif 
	case MSG_CTL_MIDSK:
	case MSG_APP_WEB:
		
		ENGFM_SetAudioModeParam(win_id);
		break;

	case MSG_CTL_OK:

		ENGFM_GetAudioModeParam();
		break;

	case MSG_CTL_CANCEL:    
	case MSG_APP_CANCEL:

		MMK_CloseWin(win_id);
		break;
		
	default:
		result = MMI_RESULT_FALSE;
		break;
    }

	return result;
}

//FM END
#endif




//Hardware

/********************************************************************************
 NAME:          EngHardWareOpenInfoWin   
 AUTHOR:        Leon.Wang
 DATE:          2012.11.14
********************************************************************************/
PUBLIC void EngHardWareOpenInfoWin(uint32 u_ID_ENG_HardW)
{
	switch(u_ID_ENG_HardW)
	{
		case ID_ENG_VIBRATE_TEST_INFO:
		    MMK_CreateWin((uint32*)MMIENG_HARDWARE_VIBRATE_WIN_TAB, PNULL);
		    break;
		case ID_ENG_CAMERA_LCD_INFO:
		    MMK_CreateWin((uint32*)MMIENG_HARDWARE_CAM_LCD_INFO_WIN_TAB, PNULL);
		    break;
		case ID_ENG_CAM_POW_TEST_MODE:
		    MMK_CreateWin((uint32*)MMIENG_HARDWARE_CAM_POW_TEST_MODE_WIN_TAB, PNULL);
		    break;
		default:
		   break;
	}
}

/********************************************************************************
 NAME:          EngHardWareVibTestWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      
 PARAM OUT:     
 AUTHOR:        James.Zhang
 DATE:      0   2007.11.28
********************************************************************************/
LOCAL MMI_RESULT_E EngHardWareVibTestWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{

    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_STRING_T text = {0};
    wchar wstr[100] = {0};
    char* str = "Use the left soft key to open Vibrate; use the right soft key to close Vibrate.";
    uint16 len = strlen( str );

	switch (msg_id) 
	{
		case MSG_OPEN_WINDOW:

			break;
			
		case MSG_FULL_PAINT:
			{
				GUI_LCD_DEV_INFO	lcd_dev_info = {GUI_MAIN_LCD_ID, GUI_BLOCK_MAIN};
				GUI_RECT_T			client_rect = MMITHEME_GetClientRectEx(win_id);
				GUIRES_DisplayImg(PNULL, &client_rect ,  &client_rect,	win_id,  IMAGE_COMMON_BG, &lcd_dev_info);
				//GUIWIN_SetSoftkeyTextId(win_id,  (MMI_TEXT_ID_T)TXT_NULL, (MMI_TEXT_ID_T)TXT_NULL, (MMI_TEXT_ID_T)TXT_NULL, TRUE);
                text.wstr_ptr = wstr;//"Use the left soft key to enter a menu; use the right soft key to leave a menu.";
                text.wstr_len = len;
                MMI_STRNTOWSTR( wstr, 100, (uint8*)str, len, len );
                GUITEXT_SetString(MMIENG_UITEST_TEXT_CTRL_ID, text.wstr_ptr, text.wstr_len, FALSE);
                MMK_SetAtvCtrl(MMIENG_WAITING_WIN_ID, MMIENG_UITEST_TEXT_CTRL_ID);
                GUIWIN_SetSoftkeyTextId(win_id,  (MMI_TEXT_ID_T)TXT_ENG_OK, (MMI_TEXT_ID_T)TXT_NULL, (MMI_TEXT_ID_T)STXT_RETURN, TRUE);
			}
			break;

#ifdef TOUCH_PANEL_SUPPORT 
		case MSG_CTL_PENOK:
#endif 
		case MSG_CTL_OK:
		case MSG_APP_OK:
		case MSG_CTL_MIDSK:
		case MSG_APP_WEB:
			MMIAPISET_SetVibrator(TRUE,MMISET_RING_TYPE_OTHER);
			break;
			
		case MSG_CTL_CANCEL:	
		case MSG_APP_CANCEL:
			MMIAPISET_SetVibrator(FALSE,MMISET_RING_TYPE_OTHER);
			MMK_CloseWin(win_id);
			break;
			
		default:
			result = MMI_RESULT_FALSE;
			break;
	}

	return result;

}
#ifdef PLATFORM_ANTISW3
extern PUBLIC uint32 DCAMERA_GetSensorStr(const uint8** sensor_str);
#endif
/********************************************************************************
 NAME:          EngHardWareCamLcdInfoWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      
 PARAM OUT:     
 AUTHOR:        James.Zhang
 DATE:      0   2007.11.28
********************************************************************************/
LOCAL MMI_RESULT_E EngHardWareCamLcdInfoWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{

	MMI_RESULT_E result = MMI_RESULT_TRUE;
    uint32 ret = 0;
	switch (msg_id) 
	{
		case MSG_OPEN_WINDOW:
			{
				wchar           unicode_cr = 0x0d;
				MMI_STRING_T    cr_s = {0};
				MMI_STRING_T    text_s = {0};
				uint16          uint16_str[MMIENG_3RDPARTYVER_TEXT_LEN + 1] = {0};
				uint16          uint16_str_len = 0;
				char*           temp_ptr = PNULL;
                char            temp_str[200]={0};
				uint16          temp_len = 0;

				cr_s.wstr_ptr = &unicode_cr;
				cr_s.wstr_len = 1;

				//Software V:
				temp_ptr = (char*)"Camera ID:";
				temp_len = SCI_STRLEN((char*)temp_ptr);
				MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)temp_ptr, temp_len);
				MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行
				#ifndef _WIN32
#ifdef PLATFORM_ANTISW3
                ret = DCAMERA_Open(DCAMERA_OP_NORMAL);
                if(ret == DCAMERA_OP_SUCCESS)
                {
                    ret = DCAMERA_GetSensorStr((uint8 const**)&(temp_ptr));
                    if(ret != DCAMERA_OP_SUCCESS)
                    {
                        temp_ptr = (char*)"Fail";
                        
                    }
                }
                else
                {
                    temp_ptr = (char*)"Fail";
                }
                temp_len = SCI_STRLEN((char*)temp_ptr);
                MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)temp_ptr, temp_len);
                MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行
                DCAMERA_Close();//close camera after copy string.
#endif
				#else
				temp_ptr = (char*)"Simulator";
                temp_len = SCI_STRLEN((char*)temp_ptr);
				MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)temp_ptr, temp_len);
				MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行

				#endif

				//Project V:
				temp_ptr = (char*)"LCD ID:";
				temp_len = SCI_STRLEN((char*)temp_ptr);
				MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)temp_ptr, temp_len);
				MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行

				#ifndef _WIN32
                {               
                    #ifndef LCD_FRAMEWORK_SPRD
                    extern uint32 g_lcd_cur_id_buf[10];
                    extern uint32 g_lcd_identify_id;
                    extern uint32 g_lcd_identify_index;
                    LCM_CFG_INFO_T_PTR lcm_info = PNULL;
                    uint32 count = 0;
                    lcm_info = LCM_GetCfgInfo(MAIN_LCD_ID, &count);
                    if(lcm_info != PNULL)
                    {
                        SCI_TRACE_LOW("[MMIENG][%s][%d] lcm_info size[%d], id at 0:[%x]", __FUNCTION__, __LINE__, count, lcm_info[0].dev_id);
                        _snprintf(temp_str, sizeof(temp_str),"0x%x,id=0x%x,index=%d", lcm_info[0].dev_id,g_lcd_identify_id,g_lcd_identify_index);
                        temp_len = SCI_STRLEN((char*)temp_str);
                        MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)temp_str, temp_len);
                        MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行
                    }
                    else
                    {
                        temp_ptr = (char*)"Fail";
                        temp_len = SCI_STRLEN((char*)temp_ptr);
                        MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)temp_ptr, temp_len);
                        MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行
                    }
                    {
                        SCI_MEMSET(temp_str,0,sizeof(temp_str));
                        _snprintf(temp_str, sizeof(temp_str),"Buf:0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x", g_lcd_cur_id_buf[0],g_lcd_cur_id_buf[1],g_lcd_cur_id_buf[2],g_lcd_cur_id_buf[3],g_lcd_cur_id_buf[4],g_lcd_cur_id_buf[5],g_lcd_cur_id_buf[6]);
                        temp_len = SCI_STRLEN((char*)temp_str);
                        MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)temp_str, temp_len);
                        MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行
                    }
                    
                    #endif
                }
				#else
				temp_ptr = (char*)"Simulator";
                temp_len = SCI_STRLEN((char*)temp_ptr);
				MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)temp_ptr, temp_len);
				MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行
				#endif

				text_s.wstr_ptr = uint16_str;
				text_s.wstr_len = uint16_str_len;
				GUITEXT_SetString(MMIENG_SHOW_VERSION_CTRL_ID, text_s.wstr_ptr,text_s.wstr_len, FALSE);
		        MMK_SetAtvCtrl(win_id, MMIENG_SHOW_VERSION_CTRL_ID);
			}
			break;
			
		case MSG_FULL_PAINT:

			break;

#ifdef TOUCH_PANEL_SUPPORT 
		case MSG_CTL_PENOK:
#endif 
		case MSG_CTL_MIDSK:
		case MSG_APP_WEB:
		case MSG_CTL_OK:
		case MSG_APP_OK:	
			MMK_CloseWin(win_id);
			break;
			
		case MSG_CTL_CANCEL:	
		case MSG_APP_CANCEL:
			
			MMK_CloseWin(win_id);
			break;
			
		default:
			result = MMI_RESULT_FALSE;
			break;
	}

	return result;

}
//#endif
BOOLEAN campowtest_flag = FALSE;// FALSE:OFF; TRUE: ON     
/********************************************************************************
 NAME:          EngHardWareCamLcdInfoWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      
 PARAM OUT:     
 AUTHOR:        James.Zhang
 DATE:      0   2007.11.28
********************************************************************************/
LOCAL MMI_RESULT_E EngHardWareCamPowTestWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
	int32 index = 0;
	MMI_RESULT_E result = MMI_RESULT_TRUE;
	int32 list_id = MMIENG_COMMON_CTRL1_ID ;

	switch (msg_id) 
	{
	case MSG_OPEN_WINDOW:
		{
			GUILIST_ITEM_T		item_t = {0};
			GUILIST_ITEM_DATA_T item_data = {0};	  
			
			GUILIST_SetMaxItem( list_id, 2, FALSE );
			GUILIST_SetOwnSofterKey(list_id,FALSE);
			
			item_t.item_style	 = GUIITEM_STYLE_1RADIO_ENG;
			item_t.item_data_ptr = &item_data;
			
			item_data.item_content[0].item_data_type	= GUIITEM_DATA_TEXT_ID; 	  
			
			item_data.item_content[0].item_data.text_id = TXT_OPEN_COMN;	
			GUILIST_AppendItem( list_id, &item_t );
			item_data.item_content[0].item_data.text_id = TXT_COMM_CLOSE;	 
			GUILIST_AppendItem( list_id, &item_t ); 					 
			
			//flag = ;
			if( TRUE ==  campowtest_flag)
			{
				index = 0;
			}
			else
			{
				index = 1;
			}
			GUILIST_SetSelectedItem( list_id,index, TRUE );
			GUILIST_SetCurItemIndex( list_id, index);		   
			MMK_SetAtvCtrl(win_id, list_id);
		}
		break;
		
	case MSG_FULL_PAINT:
		break;		
		
	case MSG_KEYDOWN_CANCEL:
	case MSG_CTL_CANCEL:
		MMK_CloseWin(win_id);
		break;
		
	case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
	case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
	case MSG_KEYDOWN_OK:
	case MSG_CTL_OK:
	case MSG_APP_WEB:
		index = GUILIST_GetCurItemIndex(list_id);			   
		if(0 == index)
		{  
			campowtest_flag = TRUE;
		}
		else if( 1	== index)
		{
			campowtest_flag = FALSE;
		}	
		
		MMK_CloseWin(win_id);
		break;
		
	default:
		result = MMI_RESULT_FALSE;
		break;
	}
	return (result);	
}

/********************************************************************************
 NAME:          MMIAPIENG_CreateChipTestWin
 DESCRIPTION:   
 PARAM IN:      
 PARAM OUT:     
 AUTHOR:        ryan.xu
 DATE:          2007.7.31
********************************************************************************/
PUBLIC BOOLEAN MMIAPIENG_CreateChipTestWin(void)
{
    return MMK_CreateWin((uint32*)MMIENG_CHIP_TEST_WIN_TAB, PNULL);
}

/******************************************************************************
**
 NAME:          MMIAPIENG_CreateCMMBTestWin
 DESCRIPTION:   
 PARAM IN:      
 PARAM OUT:     
 AUTHOR: xin.li
 DATE: 2009.07.23
*******************************************************************************
*/
#ifdef CMMB_SUPPORT
/********************************************************************************
 NAME:          MMIAPIENG_CreateCMMBChannelStatusWin
 DESCRIPTION:   
 PARAM IN:      
 PARAM OUT:     
 AUTHOR: xin.li
 DATE:2009.07.23
********************************************************************************/
BOOLEAN MMIAPIENG_CreateCMMBTestWin(void)
{
    return MMK_CreateWin((uint32*)MMIENG_CMMB_TEST_MAIN_WIN_TAB, PNULL);
}

/********************************************************************************
 NAME:          MMIAPIENG_CreateCMMBChannelStatusWin
 DESCRIPTION:   
 PARAM IN:      
 PARAM OUT:     
 AUTHOR: xin.li
 DATE:2009.07.23
********************************************************************************/
PUBLIC BOOLEAN MMIAPIENG_CreateCMMBChannelStatusWin(void)
{
    if(MMK_IsOpenWin(MMIENG_CMMB_DISPLAY_WIN_ID))
    {
        MMK_CloseWin(MMIENG_CMMB_DISPLAY_WIN_ID);
    }
    
    //SCI_TRACE_LOW:" MMIAPIENG_CreateCMMBChannelStatusWin"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_9964_112_2_18_2_18_1_176,(uint8*)"");
    return MMK_CreateWin((uint32*)MMIENG_CMMB_DISPLAY_WIN_TAB, PNULL);
}
#endif

/********************************************************************************
 NAME:			MMIAPIENG_CreateTFloadWin
 DESCRIPTION:	
 PARAM IN:		
 PARAM OUT:		
 AUTHOR: tao.feng
 DATE: 2010.12.16
********************************************************************************/
#ifdef TF_LOAD_SUPPORT
BOOLEAN MMIAPIENG_CreateTFloadWin(void)
{
    return MMK_CreateWin((uint32*)MMIENG_TFLOAD_WIN_TAB, PNULL);
}
#endif

/********************************************************************************
 NAME:          MMIAPIENG_CreateOTAWin
 DESCRIPTION:
 PARAM IN:
 PARAM OUT:
 AUTHOR: xiuyun.wang
 DATE: 2020.06.13
********************************************************************************/
BOOLEAN MMIAPIENG_CreateOTAWin(void)
{
    return MMK_CreateWin((uint32*)MMIENG_OTA_WIN_TAB, PNULL);
}

/*****************************************************************************/
//  Description : chip test mp3 play window
//  Global resource dependence : 
//  Author: ryan.xu
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleChipTestPlayMp3MP4WinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E    result = MMI_RESULT_TRUE;
    LOCAL uint8 flv_play_timer_id = 0;
    LOCAL uint8 h264_play_timer_id = 0;    
    const wchar flv_file_name[] = {'D', ':','\\', 'V', 'i', 'd', 'e', 'o', '\\', 't', 'e', 's', 't', '.', 'f', 'l', 'v', 0};
    const wchar flv_file_name1[] = {'E', ':','\\', 'V', 'i', 'd', 'e',  'o', '\\', 't', 'e', 's', 't', '.', 'f', 'l', 'v', 0};  
#ifdef H264_DEC_SUPPORT
    const wchar h264_file_name[] = {'D', ':','\\', 'V', 'i', 'd', 'e', 'o', '\\', 't', 'e', 's', 't', '.', 'm', 'p', '4', 0};
    const wchar h264_file_name1[] = {'E', ':','\\', 'V', 'i', 'd', 'e',  'o', '\\', 't', 'e', 's', 't', '.', 'm', 'p', '4', 0};  
#endif
    switch (msg_id)
    {
    case MSG_OPEN_WINDOW:             
#ifdef VIDEO_PLAYER_SUPPORT
#ifdef MMI_VIDEOPLAYER_MINI_FUNCTION
        MMIAPIVP_MiniFunction_ExitVideoPlayer();
#else
        MMIAPIVP_ExitVideoPlayer();   
#endif
        if(MMIAPIFMM_IsFileExist(flv_file_name, MMIAPICOM_Wstrlen(flv_file_name)))
        {
            if (flv_play_timer_id != 0)
            {
                MMK_StopTimer(flv_play_timer_id);
                flv_play_timer_id = 0;
            }
            flv_play_timer_id = MMK_CreateTimer(MMI_1SECONDS * 10, FALSE); 
#ifdef MMI_VIDEOPLAYER_MINI_FUNCTION
            MMIAPIVP_MiniFunction_PlayVideo(flv_file_name, MMIAPICOM_Wstrlen(flv_file_name));
#else
            MMIAPIVP_PlayVideoFromVideoPlayer(VP_ENTRY_FROM_FILE,flv_file_name, MMIAPICOM_Wstrlen(flv_file_name),PNULL);/*lint !e605*/
#endif
        }
        else if(MMIAPIFMM_IsFileExist(flv_file_name1, MMIAPICOM_Wstrlen(flv_file_name1)))
        {
            if (flv_play_timer_id != 0)
            {
                MMK_StopTimer(flv_play_timer_id);
                flv_play_timer_id = 0;
            }
            flv_play_timer_id = MMK_CreateTimer(MMI_1SECONDS * 10, FALSE); 
#ifdef MMI_VIDEOPLAYER_MINI_FUNCTION
            MMIAPIVP_MiniFunction_PlayVideo(flv_file_name1, MMIAPICOM_Wstrlen(flv_file_name1));
#else
            MMIAPIVP_PlayVideoFromVideoPlayer(VP_ENTRY_FROM_FILE,flv_file_name1, MMIAPICOM_Wstrlen(flv_file_name1),PNULL);/*lint !e605*/
#endif
        }
        else
        {
#ifdef H264_DEC_SUPPORT
            if(MMIAPIFMM_IsFileExist(h264_file_name, MMIAPICOM_Wstrlen(h264_file_name)))
            {
                if (h264_play_timer_id != 0)
                {
                    MMK_StopTimer(h264_play_timer_id);
                    h264_play_timer_id = 0;
                }
                h264_play_timer_id = MMK_CreateTimer(MMI_1SECONDS * 10, FALSE); 
#ifdef MMI_VIDEOPLAYER_MINI_FUNCTION
                MMIAPIVP_MiniFunction_PlayVideo(h264_file_name, MMIAPICOM_Wstrlen(h264_file_name));
#else
                MMIAPIVP_PlayVideoFromVideoPlayer(VP_ENTRY_FROM_FILE,h264_file_name, MMIAPICOM_Wstrlen(h264_file_name),PNULL);/*lint !e605*/
#endif
            }
            else if(MMIAPIFMM_IsFileExist(h264_file_name1, MMIAPICOM_Wstrlen(h264_file_name1)))
            {
                if (h264_play_timer_id != 0)
                {
                    MMK_StopTimer(h264_play_timer_id);
                    h264_play_timer_id = 0;
                }
                h264_play_timer_id = MMK_CreateTimer(MMI_1SECONDS * 10, FALSE); 
#ifdef MMI_VIDEOPLAYER_MINI_FUNCTION
                MMIAPIVP_MiniFunction_PlayVideo(h264_file_name1, MMIAPICOM_Wstrlen(h264_file_name1));
#else
                MMIAPIVP_PlayVideoFromVideoPlayer(VP_ENTRY_FROM_FILE,h264_file_name1, MMIAPICOM_Wstrlen(h264_file_name1),PNULL); /*lint !e605*/                     
#endif
            }
            else
            {
                MMI_STRING_T string = {0};
                char str[] = "Can't find test video file"; 
                int32 length = SCI_STRLEN(str) ;
                wchar wstr[128] = {0};
                MMI_STRNTOWSTR(wstr,  127, (uint8*)str,  length , length);
                string.wstr_ptr = wstr;
                string.wstr_len = length;
                MMIPUB_OpenAlertWinByTextPtr(PNULL, &string, PNULL, IMAGE_PUBWIN_FAIL,PNULL,PNULL,MMIPUB_SOFTKEY_ONE,PNULL);
                //    MMK_CloseWin(win_id);
            }
#else
            MMI_STRING_T string = {0};
            char str[] = "Can't find test video file"; 
            int32 length = SCI_STRLEN(str) ;
            wchar wstr[128] = {0};
            MMI_STRNTOWSTR(wstr,  127, (uint8*)str,  length , length);
            string.wstr_ptr = wstr;
            string.wstr_len = length;
            MMIPUB_OpenAlertWinByTextPtr(PNULL, &string, PNULL, IMAGE_PUBWIN_FAIL,PNULL,PNULL,MMIPUB_SOFTKEY_ONE,PNULL);
#endif
        }
#endif
        break;
        


        
    case MSG_LOSE_FOCUS:
        break;
        
    case MSG_FULL_PAINT:
    case MSG_GET_FOCUS:
        {
            GUI_RECT_T client_rect = MMITHEME_GetClientRect();
            GUI_RECT_T rect = MMITHEME_GetFullScreenRect();
            rect.top = client_rect.top ;
            LCD_FillRect(MMITHEME_GetDefaultLcdDev(), rect, MMI_BACKGROUND_COLOR);  
        }
        break;
        
    case MSG_TIMER: 
#ifdef VIDEO_PLAYER_SUPPORT
        if(flv_play_timer_id == *((uint8 *) param))
        {
            if(0 != flv_play_timer_id)
            {
                MMK_StopTimer(flv_play_timer_id);
                flv_play_timer_id = 0; 
#ifdef MMI_VIDEOPLAYER_MINI_FUNCTION
            MMIAPIVP_MiniFunction_ExitVideoPlayer();
#else
            MMIAPIVP_ExitVideoPlayer();   
#endif
#ifdef H264_DEC_SUPPORT
                if(MMIAPIFMM_IsFileExist(h264_file_name, MMIAPICOM_Wstrlen(h264_file_name)))
                {
                    if (h264_play_timer_id != 0)
                    {
                        MMK_StopTimer(h264_play_timer_id);
                        h264_play_timer_id = 0;
                    }
                    h264_play_timer_id = MMK_CreateTimer(MMI_1SECONDS * 10, FALSE); 
#ifdef MMI_VIDEOPLAYER_MINI_FUNCTION
                    MMIAPIVP_MiniFunction_PlayVideo(h264_file_name, MMIAPICOM_Wstrlen(h264_file_name));
#else
                    MMIAPIVP_PlayVideoFromVideoPlayer(VP_ENTRY_FROM_FILE,h264_file_name, MMIAPICOM_Wstrlen(h264_file_name),PNULL);/*lint !e605*/
#endif
                }
                else if(MMIAPIFMM_IsFileExist(h264_file_name1, MMIAPICOM_Wstrlen(h264_file_name1)))
                {
                    if (h264_play_timer_id != 0)
                    {
                        MMK_StopTimer(h264_play_timer_id);
                        h264_play_timer_id = 0;
                    }
                    h264_play_timer_id = MMK_CreateTimer(MMI_1SECONDS * 10, FALSE); 
#ifdef MMI_VIDEOPLAYER_MINI_FUNCTION
                    MMIAPIVP_MiniFunction_PlayVideo(h264_file_name1, MMIAPICOM_Wstrlen(h264_file_name1));
#else
                    MMIAPIVP_PlayVideoFromVideoPlayer(VP_ENTRY_FROM_FILE,h264_file_name1, MMIAPICOM_Wstrlen(h264_file_name1),PNULL); /*lint !e605*/                     
#endif
                }
                else
                {
                    MMI_STRING_T string = {0};
                    char str[] = "Can't find test video file"; 
                    int32 length = SCI_STRLEN(str) ;
                    wchar wstr[128] = {0};
                    MMI_STRNTOWSTR(wstr,  127, (uint8*)str,  length , length);
                    string.wstr_ptr = wstr;
                    string.wstr_len = length;
                    MMIPUB_OpenAlertWinByTextPtr(PNULL, &string, PNULL, IMAGE_PUBWIN_FAIL,PNULL,PNULL,MMIPUB_SOFTKEY_ONE,PNULL);
                    //    MMK_CloseWin(win_id);
                }
#endif     
            }
        }
        else if(h264_play_timer_id == *((uint8 *) param))
        {
            if(0 != h264_play_timer_id)
            {
                MMK_StopTimer(h264_play_timer_id);
                h264_play_timer_id = 0;   
#ifdef MMI_VIDEOPLAYER_MINI_FUNCTION
            MMIAPIVP_MiniFunction_ExitVideoPlayer();
#else                
                MMIAPIVP_ExitVideoPlayer();    
#endif
            }                    
        }    
#endif
        break;
        
    case MSG_CTL_CANCEL:
    case MSG_APP_CANCEL:
        break;
        
    case MSG_CTL_MIDSK:
    case MSG_KEYDOWN_UP:
    case MSG_KEYDOWN_OK:
    case MSG_APP_WEB:
#ifdef MMI_PDA_SUPPORT
    case MSG_APP_MENU:
#endif
#ifdef VIDEO_PLAYER_SUPPORT
#ifdef MMI_VIDEOPLAYER_MINI_FUNCTION
            MMIAPIVP_MiniFunction_ExitVideoPlayer();
#else
        MMIAPIVP_ExitVideoPlayer();
#endif
#endif
        MMK_CreateWin((uint32*)MMIENG_CHIP_TEST_DC_WIN_TAB, PNULL);    
        MMK_CloseWin(win_id);            
        break;
        
    case MSG_CLOSE_WINDOW:    
        break;
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    
    return (result);
}

/*****************************************************************************/
//  Description : chip test dc window
//  Global resource dependence : 
//  Author: ryan.xu
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleChipTestDCWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)  
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;

    switch(msg_id)
    {
    case MSG_OPEN_WINDOW:
        MMIAPIDC_OpenForChipTest();
        break;
     
    case MSG_FULL_PAINT: 
        break;

     case MSG_GET_FOCUS:
         {
             GUI_RECT_T client_rect = MMITHEME_GetClientRect();
             GUI_RECT_T rect = MMITHEME_GetFullScreenRect();
             rect.top =  client_rect.top ;
             LCD_FillRect(MMITHEME_GetDefaultLcdDev(), rect, MMI_BACKGROUND_COLOR);             
         }        
        break;
        
    case MSG_CTL_MIDSK:
    case MSG_KEYDOWN_UP:
    case MSG_KEYDOWN_OK:
    case MSG_APP_WEB:
#ifdef MMI_PDA_SUPPORT
    case MSG_APP_MENU:
#endif
        MMK_CreateWin((uint32*)MMIENG_CHIP_TEST_LOOPBACK_WIN_TAB, PNULL);
        MMK_CloseWin(win_id);
        break;  
        
    default:
        break;
    }      
    return result;
}

/********************************************************************************
NAME:           UITestLoopbackWinHandleMsg
DESCRIPTION:    
PARAM IN:       
PARAM OUT:      
AUTHOR:     allen
DATE:           2004.09.08
********************************************************************************/
LOCAL MMI_RESULT_E HandleChipTestLoopBackWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_STRING_T text = {0};
    MMI_RESULT_E result = MMI_RESULT_TRUE;
//     LOCAL AUDIO_DEVICE_MODE_TYPE_E old_aud_dev_mode = {AUDIO_DEVICE_MODE_HANDHOLD};
    GUI_RECT_T lab_rect = MMITHEME_GetClientRect();
    GUI_BOTH_RECT_T  lab_both_rect = MMITHEME_GetWinTitleBothRect(win_id);
    uint16          lcd_width = 0;
    uint16          lcd_height = 0;
    static  uint16  original_call_volume =  0;  
    const  uint16  test_call_volume = 9;   
    
    GUILCD_GetLogicWidthHeight(GUI_MAIN_LCD_ID,&lcd_width,&lcd_height);
    if(lcd_width > lcd_height)
    {
        lab_rect.top = lab_both_rect.h_rect.bottom;
    }
    else
    {
        lab_rect.top = lab_both_rect.v_rect.bottom;
    }

    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:              
        original_call_volume =  MMIAPISET_GetCallVolume();  
       
        GUILABEL_SetRect(MMIENG_UITEST_LABEL_CTRL_ID, &lab_rect, FALSE);         
        GUILABEL_SetBackgroundColor(MMIENG_UITEST_LABEL_CTRL_ID, mmi_uitest_display.bkgd_color);
        GUILABEL_SetText(MMIENG_UITEST_LABEL_CTRL_ID, &text, FALSE);
        GUIWIN_SetSoftkeyTextId(win_id,  TXT_NULL, STXT_UP, TXT_NULL, FALSE);  

        MMISRVAUD_EnableVoiceLB(TRUE, test_call_volume) ;
       
        break;

    case MSG_LCD_SWITCH:   
        break;
            
    case MSG_FULL_PAINT:
        break;
    case MSG_CTL_MIDSK:
    case MSG_KEYDOWN_UP:
    case MSG_KEYDOWN_OK:
    case MSG_APP_WEB:
#ifdef MMI_PDA_SUPPORT
    case MSG_APP_MENU:
#endif
//#ifdef MMI_ENG_GREENKEYTONEXT_ENABLE
//  case MSG_KEYDOWN_GREEN:
//#endif
    
        MMK_CloseWin(win_id);
        break;
                
    case MSG_KEYDOWN_CANCEL:
        break;  

    case MSG_CTL_CANCEL:
        break;
    

    case MSG_CTL_OK:
        break;
        
    case MSG_GET_FOCUS:
        MMISRVAUD_EnableVoiceLB(TRUE, test_call_volume) ;
        break;
        
    case MSG_LOSE_FOCUS:
    case MSG_CLOSE_WINDOW:
        //AUD_EnableVoiceLoopback(hVoiceRing, FALSE, 100);
        MMISRVAUD_EnableVoiceLB(FALSE, original_call_volume) ;         
        break;
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

/*****************************************************************************/
//  Description : start chip test
//  Global resource dependence : 
//  Author: ryan.xu
//  Note: 
/*****************************************************************************/
PUBLIC void MMIENGAPI_StartChipTest(void)
{   
#if defined TOUCH_PANEL_SUPPORT && !defined TOUCHPANEL_TYPE_MULTITP
            MMK_CreateWin((uint32*)MMIENG_CHIPTEST_TP_WIN_TAB, PNULL);   
#else
            MMK_CreateWin((uint32*)MMIENG_CHIP_TEST_PLAYMP3MP4_WIN_TAB, PNULL);         
#endif
    return ;
}

/*****************************************************************************/
//  Description : chip test menu
//  Global resource dependence : 
//  Author: ryan.xu
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleChipTestMenuWinMsg(
                                       MMI_WIN_ID_T     win_id,     
                                       MMI_MESSAGE_ID_E    msg_id, 
                                       DPARAM              param
                                       )
{
    MMI_RESULT_E    result = MMI_RESULT_TRUE;
    MMI_MENU_GROUP_ID_T group_id = 0;
    MMI_MENU_ID_T   menu_id = 0;

    //SCI_TRACE_LOW:"HandleChipTestMenuWinMsg(), msg_id = %x"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_10336_112_2_18_2_18_2_177,(uint8*)"d", msg_id);
    switch (msg_id)
    {
    case MSG_OPEN_WINDOW:
        GUIWIN_SetSoftkeyTextId(win_id,  TXT_COMMON_OK, TXT_NULL, STXT_RETURN, FALSE);
        MMK_SetAtvCtrl(MMIENG_CHIP_TEST_MENU_WIN_ID, MMIENG_CHIP_TEST_MENU_CTRL_ID);
        break;

#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_MIDSK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
    case MSG_APP_OK:

        GUIMENU_GetId(MMIENG_CHIP_TEST_MENU_CTRL_ID, (MMI_MENU_GROUP_ID_T *)(&group_id),(MMI_MENU_ID_T *) (&menu_id));

        switch ( menu_id )
        {
        case ID_ENG_CHIP_TEST:          
#if defined TOUCH_PANEL_SUPPORT && !defined TOUCHPANEL_TYPE_MULTITP
            MMK_CreateWin((uint32*)MMIENG_CHIPTEST_TP_WIN_TAB, PNULL);   
#else
            MMK_CreateWin((uint32*)MMIENG_CHIP_TEST_PLAYMP3MP4_WIN_TAB, PNULL);
            MMK_CloseWin(win_id);
#endif
            break;
        case ID_ENG_CHIP_TEST_SETTING:
            MMK_CreateWin((uint32*)MMIENG_CHIP_TEST_SETTING_WIN_TAB, PNULL);
            break;
        default:
            break;
        }

        break;

    case MSG_APP_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
        
    case MSG_CLOSE_WINDOW:
        break;

    default:
        result = MMI_RESULT_FALSE;
        break;
    }

    return (result);
}

#ifdef CMMB_SUPPORT
/*****************************************************************************/
//  Description : cmmb test main win
//  Global resource dependence : 
//  Author: xin.li
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleCMMBTestWaitWinMsg(MMI_WIN_ID_T win_id,
                                            MMI_MESSAGE_ID_E msg_id,
                                            DPARAM param
                                            )
{
    MBBMS_SERVICE_RESULT_E  play_result = MTVSERVICE_RST_RET_OK;
    MMI_RESULT_E    result = MMI_RESULT_TRUE;
    
    switch(msg_id)
    {
    case MSG_ENG_MTV_PLAY_CNF:
        //SCI_TRACE_LOW:"HandleCMMBTestWaitWinMsg msg MSG_ENG_MTV_PLAY_CNF"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_10403_112_2_18_2_18_2_178,(uint8*)"");
        MMK_CloseWin(MMIENG_CMMB_WAIT_WIN_ID);
        
        if(MTVSERVICE_RST_RET_OK != MMIAPIENG_GetPlayResult())
        {
            //play failed!
            MMIPUB_OpenAlertFailWin(TXT_MTV_PLAY_NETWORK_ERROR_NEED_RETRY);
        }
        else
        {
            //play ok, display channel info
            MMIAPIENG_CreateCMMBChannelStatusWin();
        }
        break;
        
    case MSG_ENG_MTV_SEARCH_CNF:
        //SCI_TRACE_LOW:"HandleCMMBTestWaitWinMsg msg MSG_ENG_MTV_SEARCH_CNF"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_10419_112_2_18_2_18_2_179,(uint8*)"");
        MMK_CloseWin(MMIENG_CMMB_WAIT_WIN_ID);
        
        //RF test, display rssi only
        MMIAPIENG_CreateCMMBChannelStatusWin();
        break;
        
    default:
        result = MMIPUB_HandleWaitWinMsg(win_id,msg_id,param);
        break;
    }

    return result;
}

/*****************************************************************************/
//  Description : cmmb test main win
//  Global resource dependence : 
//  Author: xin.li
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleCMMBTestMainMenuWinMsg(
                                                MMI_WIN_ID_T     win_id,    
                                                MMI_MESSAGE_ID_E    msg_id, 
                                                DPARAM              param
                                                )
{
    MMI_RESULT_E    result = MMI_RESULT_TRUE;
    MMI_MENU_GROUP_ID_T group_id = 0;
    MMI_MENU_ID_T   menu_id = 0;
    
    switch (msg_id)
    {
    case MSG_OPEN_WINDOW:
        MMIDEFAULT_TurnOnBackLight(); 
        MMIDEFAULT_AllowTurnOffBackLight(FALSE);
#ifdef UI_P3D_SUPPORT
        MMI_Disable3DEffect(MMI_3D_EFFECT_CMMB_ENGINE);
#endif 

        GUIWIN_SetSoftkeyTextId(win_id,  TXT_COMMON_OK, TXT_NULL, STXT_RETURN, FALSE);
        MMK_SetAtvCtrl(MMIENG_CMMB_TEST_MENU_WIN_ID, MMIENG_CMMB_TEST_MENU_CTRL_ID);
        MMITHEME_UpdateRect();

        //init CMMB
        if(!MMIAPIMTV_IsMTVOpen())
        {
            //当前已开启MTV的情况下，不需再做初始
            MMIAPIENG_InitMTV();
        }
        break;
        
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_MIDSK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
    case MSG_APP_OK:
        GUIMENU_GetId(MMIENG_CMMB_TEST_MENU_CTRL_ID, (MMI_MENU_GROUP_ID_T *)(&group_id),(MMI_MENU_ID_T *) (&menu_id));
        switch ( menu_id )
        {
        case ID_ENG_CMMB_FACTORY_TEST:
            //工厂测试
            MMK_CreateWin((uint32*)MMIENG_CMMB_FACTORY_TEST_WIN_TAB, PNULL);
            break;

        case ID_ENG_CMMB_RD_TEST:
            //研发调试
            MMK_CreateWin((uint32*)MMIENG_CMMB_RD_TEST_WIN_TAB, PNULL);
            break;

        default:
            break;
        }
        break;
        
    case MSG_APP_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
        
    case MSG_CLOSE_WINDOW:
        if(!MMIAPIMTV_IsMTVOpen())
        {
            MMIAPIENG_ReleaseMTV();
        }
        
        MMIDEFAULT_AllowTurnOffBackLight(TRUE);
#ifdef UI_P3D_SUPPORT
        MMI_Enable3DEffect(MMI_3D_EFFECT_CMMB_ENGINE);
#endif         
        break;
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    
    return (result);
}

/*****************************************************************************/
//  Description : cmmb RD test win
//  Global resource dependence : 
//  Author: xin.li
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleCMMBRDTestMenuWinMsg(
                                                MMI_WIN_ID_T     win_id,    
                                                MMI_MESSAGE_ID_E    msg_id, 
                                                DPARAM              param
                                                )
{
    MMI_RESULT_E    result = MMI_RESULT_TRUE;
    MMI_MENU_GROUP_ID_T group_id = 0;
    MMI_MENU_ID_T   menu_id = 0;
    
    switch (msg_id)
    {
    case MSG_OPEN_WINDOW:
        GUIWIN_SetSoftkeyTextId(win_id,  TXT_COMMON_OK, TXT_NULL, STXT_RETURN, FALSE);
        MMK_SetAtvCtrl(MMIENG_CMMB_RD_TEST_MENU_WIN_ID, MMIENG_CMMB_RD_TEST_MENU_CTRL_ID);
        break;
        
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_MIDSK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
    case MSG_APP_OK:
        GUIMENU_GetId(MMIENG_CMMB_RD_TEST_MENU_CTRL_ID, (MMI_MENU_GROUP_ID_T *)(&group_id),(MMI_MENU_ID_T *) (&menu_id));
        switch ( menu_id )
        {
        case ID_ENG_CMMB_DISPLAY:
            //Display
            MMIAPIENG_CreateCMMBChannelStatusWin();
            break;
#ifdef MBBMS_SUPPORT
           
        case ID_MBBMS_SMD_COUNTER:
            MMK_CreateWin(MMIENG_SMD_COUNTER_ENABLE_WIN_TAB,PNULL);
            break;
            
        case ID_MBBMS_AUDIO:
            MMK_CreateWin(MMIENG_AUDIO_SERVICE_ENABLE_WIN_TAB,PNULL);
            break;
#ifdef DEMOD_HW_SIANO
        case ID_MBBMS_LOG_CONTROL:
           MMK_CreateWin(MMIENG_LOG_CONTROL_ENABLE_WIN_TAB,PNULL);
#endif
           break;                    
#endif
        case ID_MBBMS_INTERFACE_TEST:
            MMK_CreateWin(MMIENG_INTERFACE_TEST_ENABLE_WIN_TAB,PNULL);
            break;  
          
        default:
            break;
        }
        break;
        
        case MSG_APP_CANCEL:
        case MSG_CTL_CANCEL:
            MMK_CloseWin(win_id);
            break;
            
        case MSG_CLOSE_WINDOW:
            break;
            
        default:
            result = MMI_RESULT_FALSE;
            break;
    }
    
    return (result);
}

/*****************************************************************************/
//  Description : cmmb Factory test win
//  Global resource dependence : 
//  Author: xin.li
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleCMMBFactoryTestMenuWinMsg(
                                                   MMI_WIN_ID_T     win_id,     
                                                   MMI_MESSAGE_ID_E    msg_id, 
                                                   DPARAM              param
                                                   )
{
    MMI_RESULT_E    result = MMI_RESULT_TRUE;
    MMI_MENU_GROUP_ID_T group_id = 0;
    MMI_MENU_ID_T   menu_id = 0;
    
    switch (msg_id)
    {
    case MSG_OPEN_WINDOW:
        GUIWIN_SetSoftkeyTextId(win_id,  TXT_COMMON_OK, TXT_NULL, STXT_RETURN, FALSE);
        MMK_SetAtvCtrl(MMIENG_CMMB_FACTORY_TEST_MENU_WIN_ID, MMIENG_CMMB_FACTORY_TEST_MENU_CTRL_ID);
        break;
        
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_MIDSK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
    case MSG_APP_OK:
        GUIMENU_GetId(MMIENG_CMMB_FACTORY_TEST_MENU_CTRL_ID, (MMI_MENU_GROUP_ID_T *)(&group_id),(MMI_MENU_ID_T *) (&menu_id));
        switch ( menu_id )
        {
        case ID_ENG_CMMB_FACTORY_HAVE_SIGNAL:
            //有信号测试
            MMK_CreateWin((uint32*)MMIENG_CMMB_OK_SIGNAL_WIN_TAB, PNULL);
            break;
            
        case ID_ENG_CMMB_FACTORY_NO_SIGNAL:
            //无信号测试
            MMK_CreateWin((uint32*)MMIENG_CMMB_NO_SIGNAL_WIN_TAB, PNULL);
            break;
            
        case ID_ENG_CMMB_SN:
            //CMMB serial number
            MMK_CreateWin((uint32*)MMIENG_CMMB_SN_WIN_TAB, PNULL);
            break;
            
        default:
            break;
        }
        break;
        
        case MSG_APP_CANCEL:
        case MSG_CTL_CANCEL:
            MMK_CloseWin(win_id);
            break;
            
        case MSG_CLOSE_WINDOW:
            break;
            
        default:
            result = MMI_RESULT_FALSE;
            break;
    }
    
    return (result);
}

/*****************************************************************************/
//  Description : CMMB serial number win
//  Global resource dependence : 
//  Author: xin.li
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleCMMBSerialNumberWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E            result = MMI_RESULT_TRUE;
    MBBMS_SERVICE_RET_E     err_code = 0;
    uint8                   str_info[MMIENG_CMMB_CHANNEL_INFO_MAX_LEN +1] = {0};
    wchar                   wstr_info[MMIENG_CMMB_CHANNEL_INFO_MAX_LEN +1] ={0};
    uint8                   str_len = 0;
    wchar                   wstr_len = 0;
    MBBMS_SERVICE_RET_E     ret_code = MBBMS_SERVICE_FUNC_OK;
    
    switch (msg_id)
    {
    case MSG_OPEN_WINDOW:
        //get cmmb sn
        ret_code = MTVSERVICE_GetCmmbSn(MMIENG_CMMB_CHANNEL_INFO_MAX_LEN, str_info);
        
        if(MBBMS_SERVICE_FUNC_OK == ret_code)
        {
            //SCI_TRACE_LOW:"MTVSERVICE_GetCmmbSn ok SN:%s"
            SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_10677_112_2_18_2_18_3_180,(uint8*)"s", str_info);
            MMIAPICOM_StrToWstr((char*)str_info, wstr_info);
        }
        else
        {
            sprintf((char*)str_info, "%s", "Error!");
            MMIAPICOM_StrToWstr((char*)str_info, wstr_info);
        }
        
        wstr_len = MMIAPICOM_Wstrlen(wstr_info);
        GUITEXT_SetString(MMIENG_CMMB_SN_TEXT_CTRL_ID, wstr_info, wstr_len, FALSE);
        break;
        
    case MSG_CTL_CANCEL:
    case MSG_APP_CANCEL:
        MMK_CloseWin(win_id);
        break;
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    
    return (result);
}

/*****************************************************************************/
//  Description : cmmb Factory test ok signal win
//  Global resource dependence : 
//  Author: xin.li
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleCMMBTestOKSignalMenuWinMsg(
                                                    MMI_WIN_ID_T     win_id,    
                                                    MMI_MESSAGE_ID_E    msg_id, 
                                                    DPARAM              param
                                                    )
{
    MMI_RESULT_E    result = MMI_RESULT_TRUE;
    MMI_STRING_T    wait_text = {0};
    MMI_MENU_GROUP_ID_T group_id = 0;
    MMI_MENU_ID_T   menu_id = 0;
    MMIENG_CMMB_INI_FILE_INFO_T ini_file_info ={0};
    
    switch (msg_id)
    {
    case MSG_OPEN_WINDOW:
        GUIWIN_SetSoftkeyTextId(win_id,  TXT_COMMON_OK, TXT_NULL, STXT_RETURN, FALSE);
        MMK_SetAtvCtrl(MMIENG_CMMB_HAVE_SIGNAL_MENU_WIN_ID, MMIENG_CMMB_FACTORY_HAVE_SIGNAL_MENU_CTRL_ID);
        break;
        
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_MIDSK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
    case MSG_APP_OK:
        GUIMENU_GetId(MMIENG_CMMB_FACTORY_HAVE_SIGNAL_MENU_CTRL_ID, (MMI_MENU_GROUP_ID_T *)(&group_id),(MMI_MENU_ID_T *) (&menu_id));
        switch ( menu_id )
        {
        case ID_ENG_CMMB_PLAY:
            //工厂测试 -> 播放
            SCI_MEMSET(&ini_file_info, 0, sizeof(ini_file_info));
            if(!MMIAPIMTV_IsMTVOpen())
            {
                //直播
                SCI_MEMSET(&ini_file_info, 0, sizeof(ini_file_info));
                if(CmmbTest_ParseIni(&ini_file_info))
                {
                    MMI_GetLabelTextByLang(TXT_COMMON_WAITING, &wait_text);
                    MMIPUB_OpenWaitWin(1,&wait_text,PNULL,PNULL,MMIENG_CMMB_WAIT_WIN_ID,IMAGE_NULL,
                        ANIM_PUBWIN_WAIT,WIN_ONE_LEVEL,MMIPUB_SOFTKEY_NONE,HandleCMMBTestWaitWinMsg);
                    
                    MMIAPIENG_PlayMTVService(ini_file_info.network_id, ini_file_info.service_id);
                }
                else
                {
                    //提示配置文件错误
                    MMIPUB_OpenAlertFailWin(TXT_ENG_CMMB_INI_FILE_ERROR);
                }
            }
            else
            {
                //mobiletv application is already opened, need stop first
                MMIPUB_OpenAlertFailWin(TXT_EXIT_MOBILETV);
            }
            break;
            
        default:
            break;
        }
        break;
        
        case MSG_APP_CANCEL:
        case MSG_CTL_CANCEL:
            MMK_CloseWin(win_id);
            break;
            
        case MSG_CLOSE_WINDOW:
            break;
            
        default:
            result = MMI_RESULT_FALSE;
            break;
    }
    
    return (result);
}

/*****************************************************************************/
//  Description : cmmb Factory test no signal win
//  Global resource dependence : 
//  Author: xin.li
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleCMMBTestNoSignalMenuWinMsg(
                                                    MMI_WIN_ID_T     win_id,    
                                                    MMI_MESSAGE_ID_E    msg_id, 
                                                    DPARAM              param
                                                    )
{
    MMI_RESULT_E    result = MMI_RESULT_TRUE;
    MMI_STRING_T    wait_text = {0};
    MMI_MENU_GROUP_ID_T group_id = 0;
    MMI_MENU_ID_T   menu_id = 0;
    MMIENG_CMMB_INI_FILE_INFO_T ini_file_info ={0};
    
    switch (msg_id)
    {
    case MSG_OPEN_WINDOW:
        GUIWIN_SetSoftkeyTextId(win_id,  TXT_COMMON_OK, TXT_NULL, STXT_RETURN, FALSE);
        MMK_SetAtvCtrl(MMIENG_CMMB_NO_SIGNAL_MENU_WIN_ID, MMIENG_CMMB_FACTORY_NO_SIGNAL_MENU_CTRL_ID);
        break;
        
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_MIDSK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
    case MSG_APP_OK:
        GUIMENU_GetId(MMIENG_CMMB_FACTORY_NO_SIGNAL_MENU_CTRL_ID, (MMI_MENU_GROUP_ID_T *)(&group_id),(MMI_MENU_ID_T *) (&menu_id));
        switch ( menu_id )
        {
        case ID_ENG_CMMB_RF_TEST:
            //RF测试
            if(!MMIAPIMTV_IsMTVOpen())
            {
                SCI_MEMSET(&ini_file_info, 0, sizeof(ini_file_info));
                if(CmmbTest_ParseIni(&ini_file_info))
                {
                    if(MMK_IsOpenWin(MAIN_WAIT_WIN_ID))
                    {
                        MMK_CloseWin(MAIN_WAIT_WIN_ID);
                    }
                    
                    MMI_GetLabelTextByLang(TXT_COMMON_WAITING, &wait_text);
                    MMIPUB_OpenWaitWin(1,&wait_text,PNULL,PNULL,MMIENG_CMMB_WAIT_WIN_ID,IMAGE_NULL,
                        ANIM_PUBWIN_WAIT,WIN_ONE_LEVEL,MMIPUB_SOFTKEY_NONE,HandleCMMBTestWaitWinMsg);
                    MMITHEME_UpdateRect();
                    
                    MMIAPIENG_MTVRFTest(ini_file_info.rf_test_freq);
                }
                else
                {
                    //提示配置文件错误
                    MMIPUB_OpenAlertFailWin(TXT_ENG_CMMB_INI_FILE_ERROR);
                }
            }
            else
            {
                //mobiletv application is already opened, need stop first
                MMIPUB_OpenAlertFailWin(TXT_EXIT_MOBILETV);
            }
            break;
            
        default:
            break;
        }
        break;
        
        case MSG_APP_CANCEL:
        case MSG_CTL_CANCEL:
            MMK_CloseWin(win_id);
            break;
            
        case MSG_CLOSE_WINDOW:
            break;
            
        default:
            result = MMI_RESULT_FALSE;
            break;
    }
    
    return (result);
}

/*****************************************************************************/
//  Description : display CMMB channel status info
//  Global resource dependence : 
//  Author: xin.li
//  Note:
/*****************************************************************************/
LOCAL void DisplayChannelStatusInfo(MTV_CHANNEL_STATUS_T* channel_info_ptr)
{
    MMI_WIN_ID_T    win_id = MMIENG_CMMB_DISPLAY_WIN_ID;
    MMI_CTRL_ID_T   ctrl_id = MMIENG_CMMB_TEXT_CTRL_ID;
    GUI_FONT_T      font = MMI_DEFAULT_NORMAL_FONT;
    char  buffer[MMIENG_CMMB_CHANNEL_INFO_MAX_LEN*7] = {0};
    wchar wstr_buffer[MMIENG_CMMB_CHANNEL_INFO_MAX_LEN*7] = {0};
    int32 length = 0;
    int32 offset = 0;
    uint8 str_info[MMIENG_CMMB_CHANNEL_INFO_MAX_LEN +1] = {0};
    wchar wstr_info[MMIENG_CMMB_CHANNEL_INFO_MAX_LEN +1] ={0};
    
    //SCI_TRACE_LOW:"[CMMB ENG]: CMMB Channel info Heartbeat:%d  Block count:%d  Error block count:%d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_10884_112_2_18_2_18_3_181,(uint8*)"ddd", channel_info_ptr->heartbeat, channel_info_ptr->block_count, channel_info_ptr->error_block_count);
    
    //SCI_TRACE_LOW:"[CMMB ENG]: CMMB Channel info Frequency offset:%d  RSSI:%d  Padding:%d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_10887_112_2_18_2_18_3_182,(uint8*)"ddd", channel_info_ptr->frequency_offset, channel_info_ptr->rssi, channel_info_ptr->padding);
    
    
    //正常播放显示全部的Channel信息
    if(MMIENG_MTV_CHANNEL_RF_TEST != MMIAPIENG_GetMTVChannelDisplayMode())
    {
        //heartbeat
        //sprintf((char*)str_info, "%s %d\n", "Heartbeat: ", channel_info_ptr->heartbeat);
        //length = SCI_STRLEN(str_info);
        //SCI_MEMCPY(buffer + offset, str_info, length);
        //offset += length ;
        
        //block_count
        //SCI_MEMSET(str_info, 0, sizeof(str_info));       
        //sprintf((char*)str_info, "%s %d\n", "Block count: ", channel_info_ptr->block_count);
        //length = SCI_STRLEN(str_info);
        //SCI_MEMCPY(buffer + offset, str_info, length);        
        //offset += length ;
        
        //error_block_count
        //SCI_MEMSET(str_info, 0, sizeof(str_info));     
        //sprintf((char*)str_info, "%s %d\n", "Error block count: ", channel_info_ptr->error_block_count);
        //length = SCI_STRLEN(str_info);
        //SCI_MEMCPY(buffer + offset, str_info, length);           
        //offset += length ;
        
        //frequency_offset
        //SCI_MEMSET(str_info, 0, sizeof(str_info));        
        sprintf((char*)str_info, "%s %d\n", "Frequency offset: ", channel_info_ptr->frequency_offset);
        length = SCI_STRLEN(str_info);
        SCI_MEMCPY(buffer + offset, str_info, length);    
        offset += length ;
        
        //rssi
        SCI_MEMSET(str_info, 0, sizeof(str_info));      
        sprintf((char*)str_info, "%s %d\n", "RSSI: ", channel_info_ptr->rssi);
        length = SCI_STRLEN(str_info);
        SCI_MEMCPY(buffer + offset, str_info, length);    
        offset += length ; 
        
        //padding
        //SCI_MEMSET(str_info, 0, sizeof(str_info));
        //sprintf((char*)str_info, "%s %d\n", "Padding: ", channel_info_ptr->padding);
        //length = SCI_STRLEN(str_info);
        //SCI_MEMCPY(buffer + offset, str_info, length);    
        //offset += length ;
        
        //sync_stat
        SCI_MEMSET(str_info, 0, sizeof(str_info));
        sprintf((char*)str_info, "%s %d\n", "sync_stat: ", channel_info_ptr->sync_stat);
        length = SCI_STRLEN(str_info);
        SCI_MEMCPY(buffer + offset, str_info, length);    
        offset += length ;
        
        //freqency
        SCI_MEMSET(str_info, 0, sizeof(str_info));
        sprintf((char*)str_info, "%s %d\n", "freqency: ", channel_info_ptr->freqency);
        length = SCI_STRLEN(str_info);
        SCI_MEMCPY(buffer + offset, str_info, length);    
        offset += length ;
        
        //BER
        SCI_MEMSET(str_info, 0, sizeof(str_info));
        sprintf((char*)str_info, "%s %d\n", "BER: ", channel_info_ptr->BER);
        length = SCI_STRLEN(str_info);
        SCI_MEMCPY(buffer + offset, str_info, length);    
        offset += length ;
        
        //SNR
        SCI_MEMSET(str_info, 0, sizeof(str_info));
        sprintf((char*)str_info, "%s %d\n", "SNR: ", channel_info_ptr->SNR);
        length = SCI_STRLEN(str_info);
        SCI_MEMCPY(buffer + offset, str_info, length);    
        offset += length ;
        
#if 0
        SCI_MEMSET(str_info, 0, sizeof(str_info));       
        
        /* 比较a/b 和c/d的大小，等同于比较a*d 和c * b的大小*/
        if (channel_info_ptr->rssi >= s_config_channel_info.rssi_min
            && channel_info_ptr->rssi <= s_config_channel_info.rssi_max
            && channel_info_ptr->error_block_count * s_config_channel_info.bler_num_blk < s_config_channel_info.bler_err_blk * channel_info_ptr->block_count)
        {
            sprintf(str_info, "%s", "pass!");
        }
        else
        {
            sprintf(str_info, "%s", "fail!");
        }        
        
        length = SCI_STRLEN(str_info);
        SCI_MEMCPY(buffer + offset, str_info, length);    
        offset += length ;
#endif
    }
    else
    {
        //RF测试仅显示RSSI信息
        //rssi
        SCI_MEMSET(str_info, 0, sizeof(str_info));       
        sprintf((char*)str_info, "%s %d", "RSSI:", channel_info_ptr->rssi);
        length = SCI_STRLEN(str_info);
        SCI_MEMCPY(buffer + offset, str_info, length);    
        offset += length ;     
    }
    
    MMI_STRNTOWSTR(wstr_buffer, (MMIENG_CMMB_CHANNEL_INFO_MAX_LEN*7), buffer,  offset, offset);
    GUITEXT_SetString(ctrl_id, wstr_buffer, offset, TRUE);
    GUITEXT_SetFont(ctrl_id, &font, PNULL);
    MMK_SetAtvCtrl(win_id, ctrl_id);
    return;
}

/*****************************************************************************/
//  Description : cmmb display win
//  Global resource dependence : 
//  Author: xin.li
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleCMMBDisplayWinMsg(
                                           MMI_WIN_ID_T win_id,
                                           MMI_MESSAGE_ID_E msg_id,
                                           DPARAM param)
{
    MMI_RESULT_E            result = MMI_RESULT_TRUE;
    MTV_CHANNEL_STATUS_T    channel_info = {0};
    MBBMS_SERVICE_RET_E     err_code = 0;
    
    switch (msg_id)
    {
    case MSG_OPEN_WINDOW:
        //SCI_TRACE_LOW:"[MMIMTV]: HandleCMMBDisplayWinMsg MSG_OPEN_WINDOW"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_11016_112_2_18_2_18_4_183,(uint8*)"");
        err_code = MTVSERVICE_GetChannelStatus(&channel_info);
        //SCI_TRACE_LOW:"[MMIMTV]: MTVSERVICE_GetChannelStatus, return = %d"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_11018_112_2_18_2_18_4_184,(uint8*)"d", err_code);
        DisplayChannelStatusInfo(&channel_info);
        
        //启动timer周期获取CHANNEL数据
        s_cmmb_timer = MMK_CreateWinTimer(win_id, 1000, FALSE);
        break;
        
    case MSG_TIMER:
        if(*(uint8*)param == s_cmmb_timer)
        {
            err_code = MTVSERVICE_GetChannelStatus(&channel_info);
            //SCI_TRACE_LOW:"[MMIMTV]: MTVSERVICE_GetChannelStatus, return = %d"
            SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_11029_112_2_18_2_18_4_185,(uint8*)"d", err_code);
            DisplayChannelStatusInfo(&channel_info);
            s_cmmb_timer = MMK_CreateWinTimer(win_id, 1000, FALSE);
        }
        break;
        
    case MSG_APP_CANCEL:
    case MSG_CTL_CANCEL:
        //SCI_TRACE_LOW:"[MMIMTV]: HandleCMMBDisplayWinMsg MSG_APP_CANCEL"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_11037_112_2_18_2_18_4_186,(uint8*)"");
        MMIAPIENG_StopMTVFlow();
        while(MMIMBBMS_FLOW_STATE_IDLE != MMIAPIENG_GetMTVFlowInfo()->flow_type)
        {
            SCI_Sleep(100);
        }
        MMK_CloseWin(win_id);
        break;
        
    case MSG_CLOSE_WINDOW:
        MMK_StopTimer(s_cmmb_timer);
        s_cmmb_timer = 0;
        break;
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }

    return (result);
}
#ifdef MBBMS_SUPPORT

#ifdef DEMOD_HW_SIANO
/*****************************************************************************/
//  Description : 
//  Global resource dependence : 
//  Author: xiaoxiang.huang
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleLOGControlEnableWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_LOG_ENABLE_CONTROL_CTRL_ID;
    uint16 cur_selection = 0;
   
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        GUILIST_SetMaxItem(ctrl_id,MMISET_OPEN_CLOSE_ITEM, FALSE );//max item 2
        GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
        MMIAPISET_AppendListItemByTextIdExt(TXT_OPEN_COMN,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
        MMIAPISET_AppendListItemByTextIdExt(TXT_COMM_CLOSE,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);     
        
        if (s_mbbms_log_control_enable)
        {
            cur_selection = 0;
        }
        else
        {
            cur_selection = 1;
        }   
        //set selected item
        GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
        
        //set current item
        GUILIST_SetCurItemIndex(ctrl_id,cur_selection);
        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;
        
    case MSG_FULL_PAINT:
        break;
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_KEYDOWN_OK:
        break;        
        
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
        
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_MIDSK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
        if (0 == cur_selection)
        {
            s_mbbms_log_control_enable = TRUE;
        }
        else
        {
            s_mbbms_log_control_enable = FALSE;
        }
        //set log control
        MTVSERVICE_SetLogOutput(s_mbbms_log_control_enable);            
        //设置NV项
       // MMIPUB_OpenAlertSuccessWin(TXT_SUCCESS);
        MMK_CloseWin(win_id);
        break;
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    
    return (result);
}
#endif

/*****************************************************************************/
//  Description : 
//  Global resource dependence : 
//  Author: xiaoxiang.huang
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleInterfaceTestEnableWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_GBA_AND_MSK_TEST_CTRL_ID;
    uint16 cur_selection = 0;
   
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        GUILIST_SetMaxItem(ctrl_id,MMISET_OPEN_CLOSE_ITEM, FALSE );//max item 2
        GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
        MMIAPISET_AppendListItemByTextIdExt(TXT_OPEN_COMN,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
        MMIAPISET_AppendListItemByTextIdExt(TXT_COMM_CLOSE,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);     
        
        if (s_mbbms_interface_test_enable)
        {
            cur_selection = 0;
        }
        else
        {
            cur_selection = 1;
        }   
        //set selected item
        GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
        
        //set current item
        GUILIST_SetCurItemIndex(ctrl_id,cur_selection);
        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;
        
    case MSG_FULL_PAINT:
        break;
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_KEYDOWN_OK:
        break;        
        
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
        
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_MIDSK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
        if (0 == cur_selection)
        {
            s_mbbms_interface_test_enable = TRUE;
        }
        else
        {
            s_mbbms_interface_test_enable = FALSE;
        }
        
        //设置NV项
        //MMIPUB_OpenAlertSuccessWin(TXT_SUCCESS);
        MMK_CloseWin(win_id);
        break;
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    
    return (result);
}
/*****************************************************************************/
//  Description : HandleSMDCounterEnableWinMsg
//  Global resource dependence : 
//  Author: zhaohui
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleSMDCounterEnableWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_SMD_COUNTER_ENABLE_CTRL_ID;
    uint16 cur_selection = 0;
   
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        GUILIST_SetMaxItem(ctrl_id,MMISET_OPEN_CLOSE_ITEM, FALSE );//max item 2
        GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
        MMIAPISET_AppendListItemByTextIdExt(TXT_OPEN_COMN,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
        MMIAPISET_AppendListItemByTextIdExt(TXT_COMM_CLOSE,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);     
        
        if (s_mbbms_smd_counter_enable)
        {
            cur_selection = 0;
        }
        else
        {
            cur_selection = 1;
        }
        
        //set selected item
        GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
        
        //set current item
        GUILIST_SetCurItemIndex(ctrl_id,cur_selection);
        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;
        
    case MSG_FULL_PAINT:
        break;
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_KEYDOWN_OK:
        break;        
        
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
        
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_MIDSK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
        if (0 == cur_selection)
        {
            s_mbbms_smd_counter_enable = TRUE;
        }
        else
        {
            s_mbbms_smd_counter_enable = FALSE;
        }
        
        //设置NV项
        //MMIPUB_OpenAlertSuccessWin(TXT_SUCCESS);
        MMK_CloseWin(win_id);
        break;
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    
    return (result);
}

/*****************************************************************************/
//  Description : is smd counter enable
//  Global resource dependence : 
//  Author: lisa.lin
//  Note: 
/*****************************************************************************/
PUBLIC BOOLEAN MMIAPIENG_IsSMDCounterEnable(void)
{
    return s_mbbms_smd_counter_enable;
}

/*****************************************************************************/
// 	Description : is interface testing eable
//	Global resource dependence : 
//  Author: xin.li
//	Note: 
/*****************************************************************************/
PUBLIC BOOLEAN MMIAPIENG_IsInterfaceTestingEnable(void)
{
    return s_mbbms_interface_test_enable;
}

#endif

/*****************************************************************************/
//  Description : HandleSMDCounterEnableWinMsg
//  Global resource dependence : 
//  Author: zhaohui
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleAudioServiceEnableWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_AUDIO_SERVICE_ENABLE_CTRL_ID;
    uint16 cur_selection = 0;
    MN_RETURN_RESULT_E return_value = MN_RETURN_FAILURE;
   
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        GUILIST_SetMaxItem(ctrl_id,MMISET_OPEN_CLOSE_ITEM, FALSE );//max item 2
        GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
        MMIAPISET_AppendListItemByTextIdExt(TXT_OPEN_COMN,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
        MMIAPISET_AppendListItemByTextIdExt(TXT_COMM_CLOSE,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);     
        
        //read nv
        MMINV_READ(MMIENG_NV_MBBMS_AUDIO_ID, &s_mbbms_audio_enable, return_value);
        if(MN_RETURN_SUCCESS != return_value)
        {
            s_mbbms_audio_enable = FALSE;
            MMINV_WRITE(MMIENG_NV_MBBMS_AUDIO_ID, &s_mbbms_audio_enable);
        }

        if (s_mbbms_audio_enable)
        {
            cur_selection = 0;
        }
        else
        {
            cur_selection = 1;
        }
        
        //set selected item
        GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
        
        //set current item
        GUILIST_SetCurItemIndex(ctrl_id,cur_selection);
        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;
        
    case MSG_FULL_PAINT:
        break;
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_KEYDOWN_OK:
        break;        
        
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
        
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_MIDSK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
        if (0 == cur_selection)
        {
            s_mbbms_audio_enable = TRUE;
        }
        else
        {
            s_mbbms_audio_enable = FALSE;
        }
        
        //设置NV项
        MMINV_WRITE(MMIENG_NV_MBBMS_AUDIO_ID, &s_mbbms_audio_enable);
        //MMIPUB_OpenAlertSuccessWin(TXT_SUCCESS);
        MMK_CloseWin(win_id);
        break;
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    
    return (result);
}

/*****************************************************************************/
//  Description : is smd counter enable
//  Global resource dependence : 
//  Author: lisa.lin
//  Note: 
/*****************************************************************************/
PUBLIC BOOLEAN MMIAPIENG_IsAudioServiceEnable(void)
{
    MN_RETURN_RESULT_E return_value = MN_RETURN_FAILURE;
    
    //read nv
    MMINV_READ(MMIENG_NV_MBBMS_AUDIO_ID, &s_mbbms_audio_enable, return_value);
    if(MN_RETURN_SUCCESS != return_value)
    {
        s_mbbms_audio_enable = FALSE;
        MMINV_WRITE(MMIENG_NV_MBBMS_AUDIO_ID, &s_mbbms_audio_enable);
    }
    
    return s_mbbms_audio_enable;
}

/********************************************************************************
 NAME:         EngMtvLOGSwitchWinHandleMsg
 DESCRIPTION:
 PARAM IN:     win_id - 
               msg_id - 
               param - 
 PARAM OUT:        
 AUTHOR:       Bill Ji
 DATE:         20104.04.09
********************************************************************************/
LOCAL MMI_RESULT_E EngMtvLOGSwitchWinHandleMsg(MMI_WIN_ID_T      win_id,
                                               MMI_MESSAGE_ID_E  msg_id,
                                               DPARAM            param)
{
    MMI_RESULT_E    result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T   ctrl_id = MMIENG_LISTBOX_CTRL_ID;
    BOOLEAN         is_on = FALSE;
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        GUILIST_SetMaxItem(ctrl_id,MMISET_OPEN_CLOSE_ITEM, FALSE );
        is_on = MTV_GetVLogFlag();
        GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
        MMIAPISET_AppendListItemByTextIdExt(TXT_COMM_CLOSE,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
        MMIAPISET_AppendListItemByTextIdExt(TXT_OPEN_COMN,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);         
        GUILIST_SetSelectedItem(ctrl_id, is_on, TRUE);
        GUILIST_SetCurItemIndex(ctrl_id,is_on);
        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;
    case MSG_FULL_PAINT:
        break;
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
        is_on = GUILIST_GetCurItemIndex(ctrl_id);       
        MTV_SetVLogFlag(is_on);
        //MMIPUB_OpenAlertSuccessWin(TXT_COMPLETE);       
        MMK_CloseWin(win_id);
        break;
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

/********************************************************************************
 NAME:         EngMtvLOGToBBSwitchWinHandleMsg
 DESCRIPTION:
 PARAM IN:     win_id - 
               msg_id - 
               param - 
 PARAM OUT:        
 AUTHOR:       Bill Ji
 DATE:         20104.04.09
********************************************************************************/
LOCAL MMI_RESULT_E EngMtvLOGToBBSwitchWinHandleMsg(MMI_WIN_ID_T      win_id,
                                                   MMI_MESSAGE_ID_E  msg_id,
                                                   DPARAM            param)
{
    MMI_RESULT_E    result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T   ctrl_id = MMIENG_LISTBOX_CTRL_ID;
    BOOLEAN         is_on = FALSE;
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        GUILIST_SetMaxItem(ctrl_id,MMISET_OPEN_CLOSE_ITEM, FALSE );
        is_on = MTV_GetVLogToBBFlag();
        GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
        MMIAPISET_AppendListItemByTextIdExt(TXT_COMM_CLOSE,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
        MMIAPISET_AppendListItemByTextIdExt(TXT_OPEN_COMN,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);         
        GUILIST_SetSelectedItem(ctrl_id, is_on, TRUE);
        GUILIST_SetCurItemIndex(ctrl_id,is_on);
        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;
    case MSG_FULL_PAINT:
        break;
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
        is_on = GUILIST_GetCurItemIndex(ctrl_id);       
        MTV_SetVLogToBBFlag(is_on);
       // MMIPUB_OpenAlertSuccessWin(TXT_COMPLETE);       
        MMK_CloseWin(win_id);
        break;
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

/********************************************************************************
 NAME:         EngMtvLOGStorageWinHandleMsg
 DESCRIPTION:
 PARAM IN:     win_id - 
               msg_id - 
               param - 
 PARAM OUT:        
 AUTHOR:       Bill Ji
 DATE:         20104.04.09
********************************************************************************/
LOCAL MMI_RESULT_E EngMtvLOGStorageWinHandleMsg(MMI_WIN_ID_T      win_id,
                                                MMI_MESSAGE_ID_E  msg_id,
                                                DPARAM            param)
{
    MMI_RESULT_E    result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T   ctrl_id = MMIENG_LISTBOX_CTRL_ID;
    BOOLEAN         is_on = FALSE;
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        GUILIST_SetMaxItem(ctrl_id,MMISET_OPEN_CLOSE_ITEM, FALSE );
        is_on = MTV_GetVLogStorage();
        GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
        MMIAPISET_AppendListItemByTextIdExt(TXT_ENG_MTV_LOG_STORAGE_U,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
        MMIAPISET_AppendListItemByTextIdExt(TXT_ENG_MTV_LOG_STORAGE_SD,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);         
        GUILIST_SetSelectedItem(ctrl_id, is_on, TRUE);
        GUILIST_SetCurItemIndex(ctrl_id,is_on);
        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;
    case MSG_FULL_PAINT:
        break;
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
        is_on = GUILIST_GetCurItemIndex(ctrl_id);
        MTV_SetVLogStorage(is_on);
        //MMIPUB_OpenAlertSuccessWin(TXT_COMPLETE);       
        MMK_CloseWin(win_id);
        break;
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

#endif

/*****************************************************************************/
//  Description : chip test setting
//  Global resource dependence : 
//  Author: ryan.xu
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleChipTestSettingWinMsg(
                                       MMI_WIN_ID_T     win_id,     
                                       MMI_MESSAGE_ID_E    msg_id, 
                                       DPARAM              param
                                       )
{
    MMI_RESULT_E    result = MMI_RESULT_TRUE;
    //MMI_MENU_GROUP_ID_T group_id = 0;
    uint16 index = 0;

    //SCI_TRACE_LOW:"HandleChipTestSettingWinMsg(), msg_id = %x"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_11577_112_2_18_2_18_5_187,(uint8*)"d", msg_id);
    switch (msg_id)
    {
    case MSG_OPEN_WINDOW:
        GUILIST_SetMaxItem(MMIENG_CHIP_TEST_SETTING_CTRL_ID, 2, FALSE );//max item 2
        GUILIST_SetOwnSofterKey(MMIENG_CHIP_TEST_SETTING_CTRL_ID,TRUE);
        MMIAPISET_AppendListItemByTextIdExt(TXT_OPEN_COMN,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,MMIENG_CHIP_TEST_SETTING_CTRL_ID,GUIITEM_STYLE_1RADIO_ENG);
        MMIAPISET_AppendListItemByTextIdExt(TXT_COMM_CLOSE,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,MMIENG_CHIP_TEST_SETTING_CTRL_ID,GUIITEM_STYLE_1RADIO_ENG);  

        if (MMIAPIENG_GetChipTestMode() == MMIENG_CHIP_TEST_SETTING_ON)
        {
            index = 0;
        }
        else
        {
            index = 1;
        }
        //set selected item
        GUILIST_SetSelectedItem(MMIENG_CHIP_TEST_SETTING_CTRL_ID, index, TRUE);
        //set current item
        GUILIST_SetCurItemIndex(MMIENG_CHIP_TEST_SETTING_CTRL_ID, index);   
        MMK_SetAtvCtrl(win_id, MMIENG_CHIP_TEST_SETTING_CTRL_ID);
        break;
    case MSG_CTL_MIDSK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
    case MSG_APP_OK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:  
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
        index = GUILIST_GetCurItemIndex(MMIENG_CHIP_TEST_SETTING_CTRL_ID);
        switch ( index )
        {
        case 0:
            MMIAPIENG_SetChipTestMode(MMIENG_CHIP_TEST_SETTING_ON);
           // MMIPUB_OpenAlertSuccessWin(TXT_SUCCESS);
            MMK_CloseWin(win_id);
            break;
        case 1:
            MMIAPIENG_SetChipTestMode(MMIENG_CHIP_TEST_SETTING_OFF);
            //MMIPUB_OpenAlertSuccessWin(TXT_SUCCESS);
            MMK_CloseWin(win_id);
            break;
            
        default:
            //SCI_TRACE_LOW:"MMIENG_WIN.C HandleChipTestSettingWinMsg index is %d"
            SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_11620_112_2_18_2_18_5_188,(uint8*)"d",index);
            break;
        }

        break;

    case MSG_APP_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
        
    case MSG_CLOSE_WINDOW:
        break;

    default:
        result = MMI_RESULT_FALSE;
        break;
    }

    return (result);
}

/*****************************************************************************/
//  Description : OTA window
//  Global resource dependence :
//  Author: xiuyun.wang
//  Note:
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleOTAWinMsg(
                                       MMI_WIN_ID_T     win_id,
                                       MMI_MESSAGE_ID_E    msg_id,
                                       DPARAM              param
                                       )
{
    MMI_STRING_T text1 = {0};
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_TEXT_ID_T content_id = TXT_ENG_OTA_UPDATE_NOTIFICATION;
    CHGMNG_STATE_INFO_T* p_chgmng_info = NULL;

    //SCI_TRACE_LOW:"MMIENG_WIN HandleTFLoadWinMsg: msg_id=0x%x"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_12022_112_2_18_2_18_6_194,(uint8*)"d", msg_id);
    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
            MMI_GetLabelTextByLang(content_id, &text1);
            GUITEXT_SetString(MMIENG_TEXTBOX1_CTRL_ID, text1.wstr_ptr, text1.wstr_len, FALSE);
            MMK_SetAtvCtrl(win_id, MMIENG_TEXTBOX1_CTRL_ID);
            break;
         case MSG_APP_OK:
         case MSG_CTL_OK:
         case MSG_APP_WEB:
            p_chgmng_info = CHGMNG_GetModuleState();
            if(PNULL != p_chgmng_info)
            {
                if((p_chgmng_info->bat_cur_vol < OTA_UPGRADING_VBAT_MIN) && !CHGMNG_IsChargeConnect())
                {
                    SCI_TRACE_LOW("OTA Upgrade,battery is too low");
                    MMI_GetLabelTextByLang(TXT_EN_OTA_UPDATE_WARNING_1, &text1);
                    GUITEXT_SetString(MMIENG_TEXTBOX1_CTRL_ID, text1.wstr_ptr, text1.wstr_len, TRUE);
                    MMK_SetAtvCtrl(win_id, MMIENG_TEXTBOX1_CTRL_ID);
                    break;
                }
            }
            if (!MMIAPIPHONE_GetSimExistedStatus(MN_DUAL_SYS_1))
            {
                SCI_TRACE_LOW("OTA Upgrade,no sim card exist");
                MMI_GetLabelTextByLang(TXT_EN_OTA_UPDATE_WARNING_2, &text1);
                GUITEXT_SetString(MMIENG_TEXTBOX1_CTRL_ID, text1.wstr_ptr, text1.wstr_len, TRUE);
                MMK_SetAtvCtrl(win_id, MMIENG_TEXTBOX1_CTRL_ID);
            }
            else
            {
                SCI_TRACE_LOW("OTA Upgrade, post message MSG_ENG_UPGRADING_ALLOW");
                MMK_PostMsg(win_id, MSG_ENG_UPGRADING_ALLOW, PNULL,0);
            }
            break;
         case MSG_ENG_UPGRADING_ALLOW:
            SCI_TRACE_LOW("OTA Upgrade,allow upgrading");
            // TODO: do OTA upgrading
            break;

         case MSG_APP_CANCEL:
         case MSG_CTL_CANCEL:
            //SCI_TRACE_LOW:"MMIENG_WIN HandleTFLoadWinMsg: MSG_KEYDOWN_CANCEL"
            SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_12125_112_2_18_2_18_6_197,(uint8*)"");
            MMK_CloseWin(win_id);
            break;

        default:
            result = MMI_RESULT_FALSE;
            break;
    }
    return (result);
}


#ifdef TF_LOAD_SUPPORT
/*****************************************************************************/
//  Description : 	find update file in TF CARD
//  Global resource dependence : 
//  Author: tao.feng
//  Note:
/*****************************************************************************/

LOCAL BOOLEAN MMIAPIENG_GetDeviceStatus(void)
{
	uint32 i = 0;
	for(i=0; i<2; i++)
	{
		if (MMIAPIFMM_GetDeviceStatus((wchar *)g_device_sdcard[i], MMIFILE_DEVICE_SDCARD_LEN))
		{
			slot_exist[i] = TRUE; 			
		}
	}

	if(slot_exist[0] || slot_exist[1])
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

LOCAL int tf_strncmp(char * str1, char * str2, int length)
{
   while (length--)
   {
      if (*str1 > *str2)
         return 1;
      if (*str1++ < *str2++)
         return -1;
   }
   return 0;
}

LOCAL char *tf_strstr(char * str1, char * str2, uint32 len)
{
   uint32 i = 0x0;

   while (i<len)
   {
      if (*str1 == *str2)  /* found first char of str2 in str1 */
      {
         if (tf_strncmp(str1, str2, strlen(str2)) == 0)
         {
            return str1;   /* found str2 at str1 */
         }
      }
      str1++;
      i++;
   }
   return (char*)0;
}

LOCAL MMIENG_TF_FILE_E MMIAPIENG_FindUpdateFile(void)
{
	uint16  full_path_name[MMIFILE_FULL_PATH_MAX_LEN+2] = {0};
	uint16  full_path_len = MMIFILE_FULL_PATH_MAX_LEN+2;
	uint32 i = 0;
	uint32  file_len = 0, nPacketSize = 0;	
	BIN_PACKET_HEADER_T bph;	
   	uint8   *data_ptr = PNULL, *tmp_ptr = PNULL;

	g_valid_sdcard = NULL;
	
	for(i=0; i<2; i++)
	{
		if(!slot_exist[i])
		{
			continue;
		}

		if (MMIAPIFMM_CombineFullPath((wchar *)g_device_sdcard[i],
		                        MMIFILE_DEVICE_SDCARD_LEN,
		                        TFLOAD_DEFAULT_DIR,
		                        TFLOAD_DEFAULT_DIR_DIR_LEN,
		                        NULL,
		                        0,
		                        full_path_name,
		                        &full_path_len))

		{
		    if(MMIAPIFMM_IsFolderExist(full_path_name, full_path_len))
		    {
		    	g_valid_sdcard = (wchar *)g_device_sdcard[i];
				break;
		    }
		}
	}

	if(!g_valid_sdcard)
	{
		return MMIENG_DIR_NO_EXITS;
	}

	SCI_MEMSET(full_path_name, 0, sizeof(full_path_name));
	full_path_len = MMIFILE_FULL_PATH_MAX_LEN+2;
	if (MMIAPIFMM_CombineFullPath(g_valid_sdcard,
	                        MMIFILE_DEVICE_SDCARD_LEN,
	                        TFLOAD_DEFAULT_DIR,
	                        TFLOAD_DEFAULT_DIR_DIR_LEN,
	                        TFLOAD_DEFAULT_FILENAME,
	                        TFLOAD_DEFAULT_FILELEN,
	                        full_path_name,
	                        &full_path_len))
	{

		if(!MMIAPIFMM_IsFileExist(full_path_name, full_path_len))
		{
			return MMIENG_PAC_NO_EXITS;
		}

		MMIAPIFMM_GetFileInfo(full_path_name,  full_path_len,  &file_len, NULL, NULL);
		//SCI_TRACE_LOW:"MMIAPIENG Read Pac file: file_len=0x%x"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_11759_112_2_18_2_18_5_189,(uint8*)"d", file_len);
		if(file_len == 0x0)
		{
		   return  MMIENG_PAC_ERROR;
		}

		nPacketSize = file_len;        
		//check packet size, it must large than the header struct
		if(nPacketSize < sizeof(BIN_PACKET_HEADER_T))
		{
			return MMIENG_PAC_ERROR;
		}
			
		if(MMIAPIFMM_ReadFilesDataSyn(full_path_name, full_path_len, (uint8 *)&bph, sizeof(BIN_PACKET_HEADER_T)))
		{
			// check packet product name we must swap the little endian to bigendian
			for(i = 0; i < 256; i++ )
			{
				bph.szPrdName[i] = TF_WORDSWAP(bph.szPrdName[i]);
			}

			if(TF_LoadWstrCMP(bph.szPrdName, TFLOAD_PRODUCT_NAME)!=0 )
			{
				return MMIENG_PAC_ERROR;
			}
		}
		else
		{
			return MMIENG_PAC_ERROR;
		}	   		
	}

	SCI_MEMSET(full_path_name, 0, sizeof(full_path_name));
	full_path_len = MMIFILE_FULL_PATH_MAX_LEN+2;
	if (MMIAPIFMM_CombineFullPath(g_valid_sdcard,
	                        MMIFILE_DEVICE_SDCARD_LEN,
	                        TFLOAD_DEFAULT_DIR,
	                        TFLOAD_DEFAULT_DIR_DIR_LEN,
	                        TFLOAD_DEFAULT_BOOTNAME,
	                        TFLOAD_DEFAULT_BOOTLEN,
	                        full_path_name,
	                        &full_path_len))
	{

		if(!MMIAPIFMM_IsFileExist(full_path_name, full_path_len))
		{
			return MMIENG_FILE_NO_EXITS;
		}

        MMIAPIFMM_GetFileInfo(full_path_name,  full_path_len,  &file_len, NULL, NULL);
		//SCI_TRACE_LOW:"MMIAPIENG Read Pac file: file_len=0x%x"
		SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_11809_112_2_18_2_18_5_190,(uint8*)"d", file_len);
		if(file_len == 0x0)
		{
		   return  MMIENG_FILE_ERROR;
		}

        data_ptr = (uint8*)SCI_ALLOCA(MMIFILE_PARSE_SIZE);
        if(!data_ptr)
        {
           return  MMIENG_FILE_ERROR;
        }
           
		if(MMIAPIFMM_ReadFilesDataSyn(full_path_name, full_path_len, data_ptr, MMIFILE_PARSE_SIZE))
		{
            tmp_ptr = (uint8 *)tf_strstr((char *)data_ptr, "Project Version:", MMIFILE_PARSE_SIZE);

            if(!tmp_ptr)
            {
                SCI_FREE(data_ptr);
                return  MMIENG_FILE_ERROR;
            }

            if(0 != strcmp((char *)tmp_ptr, s_version_info[PROJECT_VERSION]))
			{
			    SCI_FREE(data_ptr);
				return MMIENG_FILE_ERROR;
			}
                        
            SCI_FREE(data_ptr);
		}
		else
		{
		    SCI_FREE(data_ptr);
			return MMIENG_FILE_ERROR;
		}	
	}

	return MMIENG_ALL_EXIST;
}


/*****************************************************************************/
//  Description : 	read tf boot file 
//  Global resource dependence : 
//  Author: tao.feng
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN MMIAPIENG_ReadBootFile(void)
{
	uint16  full_path_name[MMIFILE_FULL_PATH_MAX_LEN+2] = {0};
	uint16  full_path_len = MMIFILE_FULL_PATH_MAX_LEN+2;
	uint32  file_len;
	uint8   *data_ptr =PNULL;

	SCI_MEMSET(full_path_name, 0, sizeof(full_path_name));
	full_path_len = MMIFILE_FULL_PATH_MAX_LEN+2;
	if (MMIAPIFMM_CombineFullPath(g_valid_sdcard,
	                        MMIFILE_DEVICE_SDCARD_LEN,
	                        TFLOAD_DEFAULT_DIR,
	                        TFLOAD_DEFAULT_DIR_DIR_LEN,
	                        TFLOAD_DEFAULT_BOOTNAME,
	                        TFLOAD_DEFAULT_BOOTLEN,
	                        full_path_name,
	                        &full_path_len))
	{
		   MMIAPIFMM_GetFileInfo(full_path_name,  full_path_len,  &file_len, NULL, NULL);
		   //SCI_TRACE_LOW:"MMIAPIENG_ReadBootFile: file_len=0x%x"
		   SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_11873_112_2_18_2_18_5_191,(uint8*)"d", file_len);
		   if(file_len == 0x0)
		   {
			    return  SCI_FALSE;
		   }
		   data_ptr = (uint8*)SCI_ALLOCA(file_len);
           if(!data_ptr)
           {
               return  SCI_FALSE;
           }

		   if(MMIAPIFMM_ReadFilesDataSyn(full_path_name, full_path_len, data_ptr, file_len))
		   {
		   		s_tf_load.file_addr = data_ptr;
				s_tf_load.file_len   = file_len;
				return  SCI_TRUE;
		   }
		   else
		   {
		   		SCI_FREE(data_ptr);
				return  SCI_FALSE;
		   }
	}

	return  SCI_FALSE;
}



/*****************************************************************************/
//  Description : 	copy boot  file to sram
//  Global resource dependence : 
//  Author: tao.feng
//  Note:
/*****************************************************************************/
LOCAL void MMIAPIENG_CopyBootFile(void)
{
        uint32 i,len;
	uint8 *srcaddr;
	uint8 *dscaddr;
	uint32  tf_exec_addr =TF_GetBootExecAddress();
	//SCI_TRACE_LOW:"MMIAPIENG_CopyBootFile: tf_exec_addr=0x%x"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_11912_112_2_18_2_18_5_192,(uint8*)"d", tf_exec_addr);
	//SCI_ASSERT((tf_exec_addr< s_tf_load.file_addr) || (tf_exec_addr>  (s_tf_load.file_addr + s_tf_load.file_len));
	//SCI_MEMCPY((uint8*)tf_exec_addr,  (uint8*)s_tf_load.file_addr,  s_tf_load.file_len);
	#if 1
	srcaddr =  s_tf_load.file_addr;
	dscaddr =  tf_exec_addr; /*lint !e64*/
	len = s_tf_load.file_len;
	for(i=0;i<len;i++)
	{
           *dscaddr= *srcaddr;
	     dscaddr++;	
	     srcaddr++;	
	}
	#endif
}


/*****************************************************************************/
//  Description : 	Handle low battery condition before TF upgrading
//  Global resource dependence : 
//  Author: Jassmine
//  Note:
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleTFUpWarnWindow(
                                         MMI_WIN_ID_T    win_id, 
                                         MMI_MESSAGE_ID_E   msg_id, 
                                         DPARAM             param   
                                         )
{
	LOCAL uint8 tf_timer_id = 0;
	MMI_RESULT_E recode = MMI_RESULT_TRUE;
    CHGMNG_STATE_INFO_T* p_chgmng_info;

	//SCI_TRACE_LOW:"HandleTFUpWarnWindow: msg_id=0x%x"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_11943_112_2_18_2_18_5_193,(uint8*)"d", msg_id);
	switch(msg_id)
	{
		case MSG_OPEN_WINDOW:
			recode = MMIPUB_HandleWaitWinMsg(win_id, msg_id, param);
			MMK_PostMsg(MMI_TF_UPGRADING_WARNING_ID, MSG_ENG_UPGRADING_WARN, PNULL,0);
			break;

	       case MSG_ENG_UPGRADING_WARN:
            p_chgmng_info = CHGMNG_GetModuleState();
		   	if(((p_chgmng_info->bat_cur_vol < TF_UPGRADING_VBAT_MIN) && !CHGMNG_IsChargeConnect())\
				|| !MMIAPIENG_GetDeviceStatus()\
					|| (MMIAPIENG_FindUpdateFile() != MMIENG_ALL_EXIST))
		   	{
					tf_timer_id = MMK_CreateTimer(MMI_1SECONDS * 5, TRUE); 
			}
			else
			{
				MMK_PostMsg(MMIENG_TFLOAD_WIN_ID, MSG_ENG_UPGRADING_ALLOW, PNULL,0);
				MMK_CloseWin(MMI_TF_UPGRADING_WARNING_ID); 
			}
			break;

		 case MSG_APP_RED:
		 case MSG_CTL_OK:
		 case MSG_APP_OK:
			break;

		 case MSG_TIMER:	
			if(tf_timer_id == *((uint8 *) param))
			{
				if(0 != tf_timer_id)
				{
					MMK_StopTimer(tf_timer_id);
					tf_timer_id = 0;
					MMK_CloseWin(MMI_TF_UPGRADING_WARNING_ID); 
				}
			}
			else
			{
			    recode = MMIPUB_HandleWaitWinMsg( win_id, msg_id, param );
			}
			break;
			
		case MSG_CTL_CANCEL:
		case MSG_APP_CANCEL:
			MMK_CloseWin(MMI_TF_UPGRADING_WARNING_ID); 
			break;

		case MSG_CLOSE_WINDOW:
			if(0 != tf_timer_id)
			{
				MMK_StopTimer(tf_timer_id);
				tf_timer_id = 0;
			}
			break;
		    
		default:
			recode = MMIPUB_HandleWaitWinMsg(win_id, msg_id, param);
			break;
	}

	return recode;  
}


/*****************************************************************************/
// 	Description : TF LOAD handler
//	Global resource dependence : 
//   Author: tao.feng
//	Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleTFLoadWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
	MMI_STRING_T text1 = {0}, text2 = {0};
	MMI_RESULT_E result = MMI_RESULT_TRUE;
	MMI_TEXT_ID_T content_id = TXT_ENG_TF_UPDATE_NOTIFICATION;
	BOOLEAN ret;
	MMIENG_TF_FILE_E TF_FILE_INFO = MMIENG_ALL_EXIST;
    CHGMNG_STATE_INFO_T* p_chgmng_info;

	//SCI_TRACE_LOW:"MMIENG_WIN HandleTFLoadWinMsg: msg_id=0x%x"
	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_12022_112_2_18_2_18_6_194,(uint8*)"d", msg_id);
	switch (msg_id) 
	{
		case MSG_OPEN_WINDOW:
	    	MMI_GetLabelTextByLang(content_id, &text1);
			GUITEXT_SetString(MMIENG_TEXTBOX1_CTRL_ID, text1.wstr_ptr, text1.wstr_len, FALSE);
			MMK_SetAtvCtrl(MMIENG_TFLOAD_WIN_ID, MMIENG_TEXTBOX1_CTRL_ID);
			break;
#ifdef MMI_PDA_SUPPORT
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
     case MSG_CTL_PENOK:
        if (PNULL != param)
        {
            uint32 src_id = ((MMI_NOTIFY_T*)param)->src_id;
        
            switch (src_id)
            {
            case MMICOMMON_BUTTON_SOFTKEY_LEFT_CTRL_ID:
                MMK_SendMsg(win_id, MSG_APP_OK, PNULL);
                break;
            case MMICOMMON_BUTTON_SOFTKEY_RIGHT_CTRL_ID:
                 MMK_SendMsg(win_id, MSG_APP_CANCEL, PNULL);
                break;           
            default:
                break;
            }
        }
        break;
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
#endif
	   	 case MSG_APP_OK:		
	   	 case MSG_CTL_OK:	
	   	 case MSG_APP_WEB:	
            p_chgmng_info = CHGMNG_GetModuleState();
			if((p_chgmng_info->bat_cur_vol < TF_UPGRADING_VBAT_MIN) && !CHGMNG_IsChargeConnect())
			{
				MMI_GetLabelTextByLang(TXT_EN_TF_UPDATE_WARNING_1, &text1);
				MMI_GetLabelTextByLang(TXT_EN_TF_UPDATE_WARNING_2, &text2);
				MMIPUB_OpenWaitWin(2,&text1, &text2, PNULL, MMI_TF_UPGRADING_WARNING_ID, ANIM_PUBWIN_WAIT,
				0, WIN_ONE_LEVEL,MMIPUB_SOFTKEY_NONE, HandleTFUpWarnWindow);
			}
			else if (!MMIAPIENG_GetDeviceStatus())
			{
				MMI_GetLabelTextByLang(TXT_EN_TF_UPDATE_WARNING_3, &text1);
				MMIPUB_OpenWaitWin(1,&text1, PNULL, PNULL, MMI_TF_UPGRADING_WARNING_ID, ANIM_PUBWIN_WAIT,
				0, WIN_ONE_LEVEL,MMIPUB_SOFTKEY_NONE, HandleTFUpWarnWindow);	
			}
			else if((TF_FILE_INFO =MMIAPIENG_FindUpdateFile()) != MMIENG_ALL_EXIST)
			{
				if(TF_FILE_INFO == MMIENG_PAC_ERROR)
				{
					MMI_GetLabelTextByLang(TXT_EN_TF_UPDATE_WARNING_5, &text1);
					MMIPUB_OpenWaitWin(1,&text1, PNULL, PNULL, MMI_TF_UPGRADING_WARNING_ID, ANIM_PUBWIN_WAIT,
					0, WIN_ONE_LEVEL,MMIPUB_SOFTKEY_NONE, HandleTFUpWarnWindow);	
				}

   				if(TF_FILE_INFO == MMIENG_FILE_ERROR)
				{
					MMI_GetLabelTextByLang(TXT_EN_TF_UPDATE_WARNING_6, &text1);
					MMIPUB_OpenWaitWin(1,&text1, PNULL, PNULL, MMI_TF_UPGRADING_WARNING_ID, ANIM_PUBWIN_WAIT,
					0, WIN_ONE_LEVEL,MMIPUB_SOFTKEY_NONE, HandleTFUpWarnWindow);	
				}                

				#ifdef TF_LOAD_PROTECT
				if(TF_FILE_INFO == MMIENG_FILE_NO_EXITS)
				{   
				    MMIAPISET_InitAudioDevice(0);   //set to silent
					GPIO_SetLcdBackLight(SCI_FALSE);
					TF_LoadInit();
					TF_EnterInit();
					//should never enter here
					while(1) {} /*lint !e716*/
				}
				#endif
				MMI_GetLabelTextByLang(TXT_EN_TF_UPDATE_WARNING_4, &text1);
				MMIPUB_OpenWaitWin(1,&text1, PNULL, PNULL, MMI_TF_UPGRADING_WARNING_ID, ANIM_PUBWIN_WAIT,
				0, WIN_ONE_LEVEL,MMIPUB_SOFTKEY_NONE, HandleTFUpWarnWindow);	
			}
			else
			{
				MMK_PostMsg(MMIENG_TFLOAD_WIN_ID, MSG_ENG_UPGRADING_ALLOW, PNULL,0);
			}
		 	break;
			
		 case MSG_ENG_UPGRADING_ALLOW:
		 	//SCI_TRACE_LOW:"file update file and jump to sram execute"
		 	SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_12105_112_2_18_2_18_6_195,(uint8*)"");
			ret = MMIAPIENG_ReadBootFile();
			if(ret)
			{
			    MMIAPISET_InitAudioDevice(0);   //set to silent
				GPIO_SetLcdBackLight(SCI_FALSE);
				TF_LoadInit();
				MMIAPIENG_CopyBootFile();
			//	SCI_TRACE_LOW("TF_LoadInit success");
				TF_Jump();
			       while(1) {} /*lint !e716*/
			}
			else
			{
				//SCI_TRACE_LOW:"read boot file  fail "
				SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_12119_112_2_18_2_18_6_196,(uint8*)"");
			}
		 	break;
			
		 case MSG_APP_CANCEL:	 
		 case MSG_CTL_CANCEL:
            //SCI_TRACE_LOW:"MMIENG_WIN HandleTFLoadWinMsg: MSG_KEYDOWN_CANCEL"
            SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_12125_112_2_18_2_18_6_197,(uint8*)"");
			MMK_CloseWin(win_id);
			break;


        case MSG_CLOSE_WINDOW:
            //SCI_TRACE_LOW:"MMIENG_WIN HandleTFLoadWinMsg: MSG_CLOSE_WINDOW"
            SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_12131_112_2_18_2_18_6_198,(uint8*)"");
            break;
		
		default:
			result = MMI_RESULT_FALSE;
			break;
	}
	return (result);
}
#endif

//extern BOOLEAN MMIAPIENG_GetIsCardLogOn(void);
extern void MMIAPIENG_SetIsCardLogOn(
                                     BOOLEAN is_cardlog_on
                                     );
extern void MMIAPIENG_SetIsBrowserLogOn(BOOLEAN is_browser_log_on);

/*****************************************************************************/
//  Description : open cardlog win
//  Global resource dependence : 
//  Author: bin.ji
//  Note: 
/*****************************************************************************/
PUBLIC void MMIAPIENG_OpenCardLogWin(void)
{
/*,@cr239352 renwei add begin*/
    if(MMIAPIUDISK_UdiskIsRun())
    {
        MMIPUB_OpenAlertFailWin( TXT_ENG_CARDLOG_OPEN_ERROR_UDISK);
    }
    else if(MMIAPIENG_IsUSBLOGON())
    {
        MMIPUB_OpenAlertFailWin( TXT_ENG_CARDLOG_OPEN_ERROR_USBLOG);
    }
#ifndef DPHONE_SUPPORT 
    else if (MMIAPISD_IsUsbLogOn())
    {
        //无法使用card log
        MMIPUB_OpenAlertFailWin( TXT_ENG_CARDLOG_OPEN_ERROR_SDUSBLOG);
    }
#endif 
    else
    {
        MMK_CreateWin((uint32*)MMIENG_CARDLOG_WIN_TAB, PNULL);
    }
/*,@cr239352 renwei add end*/
}

/********************************************************************************
 NAME:          EngCardLogWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        bin.ji
 DATE:          
********************************************************************************/
LOCAL MMI_RESULT_E EngCardLogWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_LISTBOX_CTRL_ID;
    uint16 cur_selection = 0;
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        GUILIST_SetMaxItem(ctrl_id,MMISET_OPEN_CLOSE_ITEM, FALSE );//max item 2
        //GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
        MMIAPISET_AppendListItemByTextIdExt(TXT_OPEN_COMN,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
        MMIAPISET_AppendListItemByTextIdExt(TXT_COMM_CLOSE,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);  
        
        if (MMIAPIENG_GetIsCardLogOn())
        {
            cur_selection = 0;
        }
        else
        {
            cur_selection = 1;
        }
        
        //set selected item
        GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
        
        //set current item
        GUILIST_SetCurItemIndex(ctrl_id,cur_selection);
        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;
        
    case MSG_FULL_PAINT:
        break;
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_KEYDOWN_OK:
        break;  
        
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
        if (MMIAPIUDISK_UdiskIsRun()) //U盘使用中
        {
            MMIPUB_OpenAlertWarningWin(TXT_COMMON_UDISK_USING);
            break;
        }
        if (0 == cur_selection) //开启
        {
            MMIPUB_OpenQueryWinByTextId(TXT_ENG_CARDLOG_FORMAT_CONTINUE,IMAGE_PUBWIN_QUERY,PNULL,PNULL);
        }
        else
        {
            MMIAPISET_SetByOpenCloseList(ctrl_id, MMIAPISET_GetActiveSim(),MMIAPIENG_SetIsCardLogOn);
            //success!
            
            MMK_CloseWin( win_id );
        }
        break;
        
    case MSG_PROMPTWIN_OK:
#ifdef MMI_AUDIO_PLAYER_SUPPORT            
        MMIAPIMP3_ResetAllMp3();
#endif
        //关闭询问窗口
        MMIPUB_CloseQuerytWin(PNULL);
        MMIAPISET_SetByOpenCloseList(ctrl_id, MMIAPISET_GetActiveSim(),MMIAPIENG_SetIsCardLogOn);
        //success!
        
        MMK_CloseWin( win_id );
        break;
        
    case MSG_PROMPTWIN_CANCEL:
        //关闭询问窗口
        MMIPUB_CloseQuerytWin(PNULL);
        MMK_CloseWin(win_id);
        break;
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

/********************************************************************************
 NAME:          EngAutoAnswerCallWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        bin.ji
 DATE:          
********************************************************************************/
LOCAL MMI_RESULT_E EngAutoAnswerCallWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_LISTBOX_CTRL_ID;
    uint16 cur_selection = 0;
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        GUILIST_SetMaxItem(ctrl_id,MMISET_OPEN_CLOSE_ITEM, FALSE );//max item 2
        //GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
        MMIAPISET_AppendListItemByTextIdExt(TXT_OPEN_COMN,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
        MMIAPISET_AppendListItemByTextIdExt(TXT_COMM_CLOSE,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);  
        
        if (MMIAPIENG_GetAutoAnswerCallSet())
        {
            cur_selection = 0;
        }
        else
        {
            cur_selection = 1;
        }
        
        //set selected item
        GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
        
        //set current item
        GUILIST_SetCurItemIndex(ctrl_id,cur_selection);
        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;
        
    case MSG_FULL_PAINT:
        break;
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_KEYDOWN_OK:
        break;  
        
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
        MMIAPISET_SetByOpenCloseList(ctrl_id, MMIAPISET_GetActiveSim(),MMIAPIENG_SetAutoAnswerCallSet);
        MMK_CloseWin( win_id );
        break;

    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

#ifdef MMI_SMS_RETRY_SUPPORT
/********************************************************************************
 NAME:          EngAutoAnswerCallWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        bin.ji
 DATE:          
********************************************************************************/
LOCAL MMI_RESULT_E EngSMSRetryWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_LISTBOX_CTRL_ID;
    uint16 cur_selection = 0;
    BOOLEAN RetryEnable=FALSE;
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        GUILIST_SetMaxItem(ctrl_id,MMISET_OPEN_CLOSE_ITEM, FALSE );//max item 2
        //GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
        MMIAPISET_AppendListItemByTextIdExt(TXT_OPEN_COMN,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
        MMIAPISET_AppendListItemByTextIdExt(TXT_COMM_CLOSE,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);  
        
        if (MMIAPISMS_GetResendCount())
        {
            cur_selection = 0;
        }
        else
        {
            cur_selection = 1;
        }
        
        //set selected item
        GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
        
        //set current item
        GUILIST_SetCurItemIndex(ctrl_id,cur_selection);
        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;
        
    case MSG_FULL_PAINT:
        break;
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_KEYDOWN_OK:
        break;  
        
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
     if (cur_selection)
        {
            RetryEnable = FALSE;
        }
        else
        {
            RetryEnable = TRUE;
        }
        MMIAPISMS_SetResendCount(RetryEnable);
        MMK_CloseWin( win_id );
        break;

    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}
#endif

/********************************************************************************
 NAME:          EngCallBarringWinHandleMsg
 DESCRIPTION:   MS00186848
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        fen.xie
 DATE:          
********************************************************************************/
LOCAL MMI_RESULT_E EngCallBarringWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_LISTBOX_CTRL_ID;
    uint16 cur_selection = 0;
    BOOLEAN IsEnableCallBarring = FALSE;
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        GUILIST_SetMaxItem(ctrl_id,MMISET_OPEN_CLOSE_ITEM, FALSE );//max item 2
        MMIAPISET_AppendListItemByTextIdExt(TXT_OPEN_COMN,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
        MMIAPISET_AppendListItemByTextIdExt(TXT_COMM_CLOSE,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);  
        
        if (MMIAPIENG_GetCallBarring())
        {
            cur_selection = 0;
        }
        else
        {
            cur_selection = 1;
        }
        
        //set selected item
        GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
        
        //set current item
        GUILIST_SetCurItemIndex(ctrl_id,cur_selection);
        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;
        
    case MSG_FULL_PAINT:
        break;
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_KEYDOWN_OK:
        break;  
        
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
        if (cur_selection)
        {
            IsEnableCallBarring = FALSE;
        }
        else
        {
            IsEnableCallBarring = TRUE;
        }
        MMIAPIENG_SetCallBarring(IsEnableCallBarring);
        MMK_CloseWin( win_id );
        break;

    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

/*****************************************************************************/
//  Description : handle set lcd logic angle window msg
//  Global resource dependence : 
//  Author: Jassmine
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E EngSetAngleWinHandleMsg(
                                           MMI_WIN_ID_T         win_id,
                                           MMI_MESSAGE_ID_E     msg_id,
                                           DPARAM               param
                                           )
{
    uint16              cur_selection = 0;
    MMI_RESULT_E        result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T       ctrl_id = MMIENG_LISTBOX_CTRL_ID;

    switch (msg_id)
    {
    case MSG_OPEN_WINDOW:
        GUILIST_SetMaxItem(ctrl_id,4,FALSE);
        MMIAPISET_AppendListItemByTextIdExt(TXT_ENG_ANGLE_0,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
        MMIAPISET_AppendListItemByTextIdExt(TXT_ENG_ANGLE_90,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
        MMIAPISET_AppendListItemByTextIdExt(TXT_ENG_ANGLE_180,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
        MMIAPISET_AppendListItemByTextIdExt(TXT_ENG_ANGLE_270,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
        
        //get logic angle
        cur_selection = (uint16)GUILCD_GetLogicAngle(GUI_MAIN_LCD_ID);
        
        //set selected item
        GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
        
        //set current item
        GUILIST_SetCurItemIndex(ctrl_id,cur_selection);
        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;

    case MSG_CTL_OK:
    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
        cur_selection = GUILIST_GetCurItemIndex(ctrl_id);

        //set logic angle
//        GUILCD_SetLogicAngle(GUI_MAIN_LCD_ID,(LCD_ANGLE_E)cur_selection);
        MMK_SetScreenAngle(( LCD_ANGLE_E)cur_selection );
        MMK_CloseWin( win_id );
        break;

    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;

    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    
    return (result);
}

/********************************************************************************
 NAME:          MMIENG_OpenIQModeWin
 DESCRIPTION:   
 PARAM IN:      
 PARAM OUT:     
 AUTHOR:        zhaohui
 DATE:      0   2009.03.03
********************************************************************************/
PUBLIC void MMIENG_OpenIQModeWin(void)
{
    MMK_CreateWin((uint32*)MMIENG_IQ_MODE_WIN_TAB, PNULL);
}

/*****************************************************************************/
//  Description : open IQ Mode win
//  Global resource dependence : 
//  Author: wancan.you
//  Note: 
/*****************************************************************************/
PUBLIC void MMIAPIENG_OpenIQModeOnOffWin(void)
{
    if (MMIAPIENG_GetIQDataStatus())
    {
        MMIPUB_OpenAlertWarningWin(TXT_ENG_IQ_DATA_STOP_IQ_DATA_WARNING);
    }
    else
    {
        MMK_CreateWin((uint32*)MMIENG_IQ_MODE_ONOFF_WIN_TAB, PNULL);
    }
}

/*****************************************************************************/
//  Description : EngIQModeWinHandleMsg
//  Global resource dependence : 
//  Author: zhaohui
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E EngIQModeWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_MENU_GROUP_ID_T group_id = 0;
    MMI_MENU_ID_T menu_id = 0;
    MMI_CTRL_ID_T ctrl_id = MMIENG_IQ_MODE_CTRL_ID;

    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
            CTRLMENU_SetSecMenuFontSize(MMIENG_IQ_MODE_CTRL_ID,MMIENG_MENU_ITEM_FONT,MMIENG_MENU_ITEM_FONT);
            CTRLMENU_SetSecMenuItemHeight(MMIENG_IQ_MODE_CTRL_ID,MMIENG_MENU_ITEM_HEIGHT,MMIENG_MENU_ITEM_HEIGHT);
            CTRLMENU_SetFontColor(MMIENG_IQ_MODE_CTRL_ID,MMI_WHITE_COLOR);

            if (MMIAPIENG_GetIQModeStatus())
            {
                GUIMENU_SetItemGrayed(MMIENG_IQ_MODE_CTRL_ID,MENU_IQ_MODE, ID_ENG_IQ_DATA, FALSE);
            }
            else
            {
                GUIMENU_SetItemGrayed(MMIENG_IQ_MODE_CTRL_ID,MENU_IQ_MODE, ID_ENG_IQ_DATA, TRUE);
            }
            MMK_SetAtvCtrl(win_id, ctrl_id);
            break;

        case MSG_GET_FOCUS:
            if (MMIAPIENG_GetIQModeStatus())
            {
                GUIMENU_SetItemGrayed(MMIENG_IQ_MODE_CTRL_ID,MENU_IQ_MODE, ID_ENG_IQ_DATA, FALSE);
            }
            else
            {
                GUIMENU_SetItemGrayed(MMIENG_IQ_MODE_CTRL_ID,MENU_IQ_MODE, ID_ENG_IQ_DATA, TRUE);
            }
            MMK_SetAtvCtrl(win_id, ctrl_id);
            break;
            
        case MSG_APP_OK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
        case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
        case MSG_CTL_MIDSK:
        case MSG_CTL_OK:
        case MSG_APP_WEB:
            GUIMENU_GetId(ctrl_id, (MMI_MENU_GROUP_ID_T *)(&group_id),(MMI_MENU_ID_T *)(&menu_id));
            switch (menu_id)
            {
                case ID_ENG_IQ_DATA_ONOFF:
                    MMIAPIENG_OpenIQModeOnOffWin();
                    break;

                case ID_ENG_IQ_DATA:
                    MMIAPIENG_OpenIQDataWin();
                    break;

                default:
                    break;
            }
            break;

        case MSG_APP_CANCEL:
        case MSG_CTL_CANCEL:
            MMK_CloseWin(win_id);
            break;

        case MSG_CLOSE_WINDOW:
            break;

        default:
            result = MMI_RESULT_FALSE;
            break;
    }

    return (result);
}

/*****************************************************************************/
//  Description : EngIQModeOnOffWinHandleMsg
//  Global resource dependence : 
//  Author: wancan.you
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E EngIQModeOnOffWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_LISTBOX_CTRL_ID;
    uint16 cur_selection = 0;
    MMIENG_IQ_MODE_T iq_mode_param = MMIAPIENG_GetIQMode();

    switch (msg_id) 
    {
        case MSG_OPEN_WINDOW:
            GUILIST_SetMaxItem(ctrl_id,MMISET_OPEN_CLOSE_ITEM, FALSE );//max item 2
            GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
            MMIAPISET_AppendListItemByTextIdExt(TXT_COMMON_OPEN,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
            MMIAPISET_AppendListItemByTextIdExt(TXT_COMMON_CLOSE,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);  

            if (MMIAPIENG_GetIQModeStatus())
            {
                cur_selection = 0;
            }
            else
            {
                cur_selection = 1;
            }
    
            //set selected item
            GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);

            //set current item
            GUILIST_SetCurItemIndex(ctrl_id,cur_selection);
            MMK_SetAtvCtrl(win_id,ctrl_id);
            break;

        case MSG_FULL_PAINT:
            break;
            
        case MSG_KEYDOWN_CANCEL:
        case MSG_KEYDOWN_OK:
            break;

        case MSG_CTL_CANCEL:
            MMK_CloseWin(win_id);
            break;
 
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
        case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
        case MSG_CTL_MIDSK:
        case MSG_CTL_OK:
        case MSG_APP_WEB:
            cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
            if (0 == cur_selection)
            {
                iq_mode_param.b_status = TRUE;
                                
                MMIAPISET_StopAllRing(TRUE);

                MMIDEFAULT_EnableKeyTpRing("ENG IQ MODE", FALSE);
            }
            else
            {
                iq_mode_param.b_status = FALSE;
                MMIDEFAULT_EnableKeyTpRing("ENG IQ MODE", TRUE);
            }

            MMIAPIENG_SetIQMode(&iq_mode_param);
            //MMIPUB_OpenAlertSuccessWin(TXT_SUCCESS);
            MMK_CloseWin(win_id);
            break;

        default:
            result = MMI_RESULT_FALSE;
            break;
    }

    return (result);
}

/*****************************************************************************/
//  Description : HandleIQDataWinMsg
//  Global resource dependence : 
//  Author: wancan.you
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleIQDataWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_MENU_GROUP_ID_T group_id = 0;
    MMI_MENU_ID_T menu_id = 0;
    MMI_CTRL_ID_T ctrl_id = MMIENG_IQ_DATA_CTRL_ID;
    MMIENG_IQ_MODE_T iq_mode_param = MMIAPIENG_GetIQMode();

    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
            CTRLMENU_SetSecMenuFontSize(MMIENG_IQ_DATA_CTRL_ID,MMIENG_MENU_ITEM_FONT,MMIENG_MENU_ITEM_FONT);
            CTRLMENU_SetSecMenuItemHeight(MMIENG_IQ_DATA_CTRL_ID,MMIENG_MENU_ITEM_HEIGHT,MMIENG_MENU_ITEM_HEIGHT);
            CTRLMENU_SetFontColor(MMIENG_IQ_DATA_CTRL_ID,MMI_WHITE_COLOR);

            GUIMENU_GetId(ctrl_id, (MMI_MENU_GROUP_ID_T *)(&group_id),(MMI_MENU_ID_T *)(&menu_id));
            if (MMIAPIENG_GetIQDataStatus())
            {
                GUIMENU_SetItemGrayed(MMIENG_IQ_DATA_CTRL_ID,group_id, ID_ENG_IQ_DATA_SETTINGS, TRUE);
            }
            else
            {
                GUIMENU_SetItemGrayed(MMIENG_IQ_DATA_CTRL_ID,group_id, ID_ENG_IQ_DATA_SETTINGS, FALSE);
            }
            GUIWIN_SetSoftkeyTextId(win_id,  TXT_COMMON_OK, TXT_NULL, STXT_RETURN, FALSE);
            MMK_SetAtvCtrl(win_id, ctrl_id);
            break;

        case MSG_APP_OK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
        case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
        case MSG_CTL_MIDSK:
        case MSG_CTL_OK:
        case MSG_APP_WEB:
            GUIMENU_GetId(ctrl_id, (MMI_MENU_GROUP_ID_T *)(&group_id),(MMI_MENU_ID_T *)(&menu_id));
            switch (menu_id)
            {
                case ID_ENG_IQ_DATA_ENABLE:
                    if (MMIAPIENG_StartIQData())
                    {
                        iq_mode_param.b_is_start = TRUE;
                        MMIAPIENG_SetIQMode(&iq_mode_param);
                        //MMIPUB_OpenAlertSuccessWin(TXT_SUCCESS);
                        MMK_CloseWin(win_id);
                    }
                    break;

                case ID_ENG_IQ_DATA_DISABLE:
                    MMIAPIENG_StopQData();
                    //MMIPUB_OpenAlertSuccessWin(TXT_SUCCESS);
                    MMK_CloseWin(win_id);
                    break;

                case ID_ENG_IQ_DATA_MODES_SETTINGS:
                    MMK_CreateWin((uint32*)MMIENG_IQ_DATA_MODE_SELECT_WIN_TAB, PNULL);
                    break;

                case ID_ENG_IQ_DATA_POWER_ON_START:
                    MMK_CreateWin((uint32*)MMIENG_IQ_DATA_POWER_ON_START_WIN_TAB, PNULL);
                    break;

                default:
                    break;
            }
            break;

        case MSG_APP_CANCEL:
        case MSG_CTL_CANCEL:
            MMK_CloseWin(win_id);
            break;

        case MSG_CLOSE_WINDOW:
            break;

        default:
            result = MMI_RESULT_FALSE;
            break;
    }

    return (result);
}

/*****************************************************************************/
//  Description : MMIAPIENG_OpenIQDataWin
//  Global resource dependence : 
//  Author: wancan.you
//  Note: 
/*****************************************************************************/
PUBLIC void MMIAPIENG_OpenIQDataWin(void)
{
    if (MMK_IsOpenWin(MMIENG_IQ_DATA_WIN_ID))
    {
        return;
    }

    if (MMIAPIENG_GetIQModeStatus())
    {
        if (MMIAPIENG_GetIQDataStatus())
        {
            MMK_CreateWin((uint32*)MMIENG_IQ_DATA_DISABLE_WIN_TAB, PNULL);
        }
        else
        {
            MMK_CreateWin((uint32*)MMIENG_IQ_DATA_ENABLE_WIN_TAB, PNULL);
        }
    }
    else
    {
        //SCI_TRACE_LOW:"MMIENG_WIN.C MMIAPIENG_OpenIQDataWin IQ Mode Is Disable!"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_12824_112_2_18_2_18_7_199,(uint8*)"");
    }
}

/*****************************************************************************/
//  Description : EngIQDataModeSelectWinHandleMsg
//  Global resource dependence : 
//  Author: wancan.you
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E EngIQDataModeSelectWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_IQ_DATA_MODE_SELECT_CTRL_ID;
    uint16 cur_selection = 0;
    MMIENG_IQ_MODE_T iq_mode_param = MMIAPIENG_GetIQMode();

    switch (msg_id) 
    {
        case MSG_OPEN_WINDOW:
            GUILIST_SetMaxItem(ctrl_id,MMIENG_IQ_MODE_MAX, FALSE );//max item 5
            GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
            MMIAPISET_AppendListItemByTextIdExt(TXT_ENG_IQ_DATA_MODE_A_SETTINGS,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
            MMIAPISET_AppendListItemByTextIdExt(TXT_ENG_IQ_DATA_MODE_B_SETTINGS,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG); 
            MMIAPISET_AppendListItemByTextIdExt(TXT_ENG_IQ_DATA_MODE_C_SETTINGS,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
            MMIAPISET_AppendListItemByTextIdExt(TXT_EXPORT_LOC_CUSTOM,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG); 

            cur_selection = iq_mode_param.cur_mode;

            //set current item
            GUILIST_SetCurItemIndex(ctrl_id,cur_selection);

            MMK_SetAtvCtrl(win_id,ctrl_id);
            break;

        case MSG_FULL_PAINT:
            cur_selection = iq_mode_param.cur_mode;

            //set selected item
            GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
            break;

        case MSG_APP_CANCEL:
        case MSG_CTL_CANCEL:
            MMK_CloseWin(win_id);
            break;

        case MSG_APP_OK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
        case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
        case MSG_CTL_MIDSK:
        case MSG_CTL_OK:
        case MSG_APP_WEB:
            MMK_CreateWin((uint32*)MMIENG_IQ_DATA_MODE_SETTING_WIN_TAB, PNULL);
            break;

        default:
            result = MMI_RESULT_FALSE;
            break;
    }

    return (result);
}

/*****************************************************************************/
//  Description : EngIQDataPowerOnStartWinHandleMsg
//  Global resource dependence : 
//  Author: wancan.you
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E EngIQDataPowerOnStartWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_LISTBOX_CTRL_ID;
    uint16 cur_selection = 0;
    MMIENG_IQ_MODE_T iq_mode_param = MMIAPIENG_GetIQMode();

    switch (msg_id) 
    {
        case MSG_OPEN_WINDOW:
            GUILIST_SetMaxItem(ctrl_id,MMISET_OPEN_CLOSE_ITEM, FALSE );//max item 2
    
            MMISET_AppendOpenCloseListItem(ctrl_id,MMIAPIENG_GetIQPowerOnStartStatus);      
            MMK_SetAtvCtrl(win_id,ctrl_id);
            break;

        case MSG_FULL_PAINT:
            break;

        case MSG_APP_CANCEL:
        case MSG_CTL_CANCEL:
            MMK_CloseWin(win_id);
            break;

        case MSG_APP_OK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
        case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
        case MSG_CTL_MIDSK:
        case MSG_CTL_OK:
        case MSG_APP_WEB:
            cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
            if (0 == cur_selection)
            {
                iq_mode_param.b_power_on_start = TRUE;
            }
            else
            {
                iq_mode_param.b_power_on_start = FALSE;
            }

            MMIAPIENG_SetIQMode(&iq_mode_param);
            //MMIPUB_OpenAlertSuccessWin(TXT_SUCCESS);
            MMK_CloseWin(win_id);
            break;

        default:
            result = MMI_RESULT_FALSE;
            break;
    }

    return (result);
}

/*****************************************************************************/
//  Description : HandleIQDataModeSettingWinMsg
//  Global resource dependence : 
//  Author: wancan.you
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleIQDataModeSettingWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_MENU_GROUP_ID_T group_id = 0;
    MMI_MENU_ID_T menu_id = 0;
    uint16 cur_selection = 0;
    MMI_CTRL_ID_T ctrl_id = MMIENG_IQ_DATA_MODE_SETTING_CTRL_ID;
    MMIENG_IQ_MODE_T iq_mode_param = MMIAPIENG_GetIQMode();

    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
            CTRLMENU_SetSecMenuFontSize(MMIENG_IQ_DATA_MODE_SETTING_CTRL_ID,MMIENG_MENU_ITEM_FONT,MMIENG_MENU_ITEM_FONT);
            CTRLMENU_SetSecMenuItemHeight(MMIENG_IQ_DATA_MODE_SETTING_CTRL_ID,MMIENG_MENU_ITEM_HEIGHT,MMIENG_MENU_ITEM_HEIGHT);
            CTRLMENU_SetFontColor(MMIENG_IQ_DATA_MODE_SETTING_CTRL_ID,MMI_WHITE_COLOR);

            GUIWIN_SetSoftkeyTextId(win_id,  TXT_COMMON_OK, TXT_NULL, STXT_RETURN, FALSE);
            MMK_SetAtvCtrl(win_id, ctrl_id);
            break;

        case MSG_APP_OK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
        case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
        case MSG_CTL_MIDSK:
        case MSG_CTL_OK:
        case MSG_APP_WEB:
            GUIMENU_GetId(ctrl_id, (MMI_MENU_GROUP_ID_T *)(&group_id),(MMI_MENU_ID_T *)(&menu_id));
            switch (menu_id)
            {
                case ID_ENG_IQ_DATA_MODE_SETTING_ENABLE:
                    cur_selection = GUILIST_GetCurItemIndex(MMIENG_IQ_DATA_MODE_SELECT_CTRL_ID);
                    iq_mode_param.cur_mode = cur_selection;

                    MMIAPIENG_SetIQMode(&iq_mode_param);
                    //MMIPUB_OpenAlertSuccessWin(TXT_SUCCESS);
                    MMK_CloseWin(win_id);
                    break;

                case ID_ENG_IQ_DATA_MODE_SETTING_FORMAT:
                    MMK_CreateWin((uint32*)MMIENG_IQ_DATA_MODE_SETTING_FORMAT_WIN_TAB, PNULL);
                    break;

                case ID_ENG_IQ_DATA_MODE_SETTING_CHANNEL:
                    MMK_CreateWin((uint32*)MMIENG_IQ_DATA_MODE_SETTING_CHANNEL_WIN_TAB, PNULL);
                    break;

                case ID_ENG_IQ_DATA_MODE_SETTING_TIME_LIMIT:
                    MMK_CreateWin((uint32*)MMIENG_IQ_DATA_MODE_SETTING_TIME_LIMIT_WIN_TAB, PNULL);
                    break;

                case ID_ENG_IQ_DATA_MODE_SETTING_FRAME_LENGTH:
                    MMK_CreateWin((uint32*)MMIENG_IQ_DATA_MODE_SETTING_FRAME_LENGTH_WIN_TAB, PNULL);
                    break;

                case ID_ENG_IQ_DATA_MODE_SETTING_BLOCK_COUNT:
                    MMK_CreateWin((uint32*)MMIENG_IQ_DATA_MODE_SETTING_BLOCK_COUNT_WIN_TAB, PNULL);
                    break;

/*[START] Jerry Liang for IQ MODE 2008/07/31*/        
           case ID_ENG_IQ_DATA_MODE_SETTING_ARFCN:
                    MMK_CreateWin((uint32*)MMIENG_IQ_DATA_MODE_SETTING_ARFCN_WIN_TAB, PNULL);
                    break;
/*[END] Jerry Liang for IQ MODE 2008/07/31*/                            

                default:                    
                    //SCI_TRACE_LOW:"MMIENG_WIN.C HandleIQDataModeSettingWinMsg menu_id=%d"
                    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_13003_112_2_18_2_18_8_200,(uint8*)"d", menu_id);
                    break;
            }
            break;

        case MSG_APP_CANCEL:
        case MSG_CTL_CANCEL:
            MMK_CloseWin(win_id);
            break;

        case MSG_CLOSE_WINDOW:
            break;

        default:
            result = MMI_RESULT_FALSE;
            break;
    }

    return (result);
}

/*****************************************************************************/
//  Description : HandleIQDataModeSettingFormatWinMsg
//  Global resource dependence : 
//  Author: wancan.you
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleIQDataModeSettingFormatWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    //GUI_RECT_T rect = MMITHEME_GetClientRect();
    MMI_RESULT_E result = MMI_RESULT_TRUE;
//     GUI_LCD_DEV_INFO    lcd_dev_info = {GUI_MAIN_LCD_ID, GUI_BLOCK_MAIN};
    MMI_CTRL_ID_T   ctrl_id = MMIENG_IQ_DATA_MODE_SETTING_FORMAT_CTRL_ID;
    uint16 cur_selection = 0;
    uint8 format_buf[10] = {0};
    wchar wstr[10] = {0};
    uint16 len = 0;
    MMIENG_IQ_MODE_T iq_mode_param = MMIAPIENG_GetIQMode();
    MMI_STRING_T  edit_string = {0};
     

    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        {
            //GUIEDIT_SetRect(MMIENG_IQ_DATA_MODE_SETTING_FORMAT_CTRL_ID,&edit_rect);
            GUI_BOTH_RECT_T  edit_rect = MMITHEME_GetWinClientBothRect(MMK_ConvertIdToHandle(win_id));   
             GUIAPICTRL_SetBothRect(MMK_ConvertIdToHandle(ctrl_id), &edit_rect);
        }
        cur_selection = GUILIST_GetCurItemIndex(MMIENG_IQ_DATA_MODE_SELECT_CTRL_ID);

        SCI_MEMSET(format_buf, 0, sizeof(format_buf));
        sprintf((char *)format_buf, "%d", iq_mode_param.record_param[cur_selection].format);

        len = strlen((char *)format_buf);
        MMI_STRNTOWSTR( wstr, 10, format_buf, len, len );
        
        GUIEDIT_SetString(
            ctrl_id,
            wstr,
            len
            );

        GUIEDIT_SetStyle(ctrl_id, GUIEDIT_STYLE_SINGLE);
        
        //LCD_FillRect(&lcd_dev_info, rect, mmi_eng_display.bkgd_color);

        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;

    case MSG_FULL_PAINT:
       // LCD_FillRect(&lcd_dev_info, rect, mmi_eng_display.bkgd_color);
        break;

    case MSG_APP_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
    case MSG_APP_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
        cur_selection = GUILIST_GetCurItemIndex(MMIENG_IQ_DATA_MODE_SELECT_CTRL_ID);
        GUIEDIT_GetString(ctrl_id, &edit_string);

        if (0 != edit_string.wstr_len)
        {
            SCI_MEMSET(format_buf, 0x00, sizeof(format_buf));
            MMI_WSTRNTOSTR(format_buf, 10, edit_string.wstr_ptr, edit_string.wstr_len, edit_string.wstr_len );

            iq_mode_param.record_param[cur_selection].format = atoi((char *)(format_buf));/*lint !e64*/

            if (AUD_REC_DSP_DATA_MIN <= iq_mode_param.record_param[cur_selection].format && AUD_REC_DSP_DATA_MAX >= iq_mode_param.record_param[cur_selection].format)
            {
                MMIAPIENG_SetIQMode(&iq_mode_param);

                MMK_CloseWin(win_id);
                
              //  MMIPUB_OpenAlertSuccessWin(TXT_SUCCESS);
            }
            else
            {
                MMIPUB_OpenAlertFailWin(TXT_INPUT_ERROR);
            }
        }
        else
        {
            MMIPUB_OpenAlertFailWin(TXT_INPUT_ERROR);
        }
        MMK_CloseWin(win_id);
        break;

    default:
        result = MMI_RESULT_FALSE;
        break;
    }

    return (result);
}

/*****************************************************************************/
//  Description : HandleIQDataModeSettingTimeLimitWinMsg
//  Global resource dependence : 
//  Author: wancan.you
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleIQDataModeSettingTimeLimitWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    //GUI_RECT_T rect = MMITHEME_GetClientRect();
    MMI_RESULT_E result = MMI_RESULT_TRUE;
   // GUI_LCD_DEV_INFO  lcd_dev_info = {GUI_MAIN_LCD_ID, GUI_BLOCK_MAIN};
    MMI_CTRL_ID_T   ctrl_id = MMIENG_IQ_DATA_MODE_SETTING_TIME_LIMIT_CTRL_ID;
    uint16 cur_selection = 0;
    uint8 time_buf[10] = {0};
    wchar wstr[10] = {0};
    uint16 len = 0;
    MMIENG_IQ_MODE_T iq_mode_param = MMIAPIENG_GetIQMode();
    MMI_STRING_T  edit_string = {0};
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
         {
            //GUIEDIT_SetRect(MMIENG_IQ_DATA_MODE_SETTING_FORMAT_CTRL_ID,&edit_rect);
            GUI_BOTH_RECT_T  edit_rect = MMITHEME_GetWinClientBothRect(MMK_ConvertIdToHandle(win_id));   
             GUIAPICTRL_SetBothRect(MMK_ConvertIdToHandle(ctrl_id), &edit_rect);
        }       

        cur_selection = GUILIST_GetCurItemIndex(MMIENG_IQ_DATA_MODE_SELECT_CTRL_ID);

        SCI_MEMSET(time_buf, 0, sizeof(time_buf));
        sprintf((char *)time_buf, "%ld", (int32)iq_mode_param.record_param[cur_selection].time_limit);

        len = strlen((char *)time_buf);
        MMI_STRNTOWSTR( wstr, 10, time_buf, len, len );
        
        GUIEDIT_SetString(
            ctrl_id,
            wstr,
            len
            );
        GUIEDIT_SetStyle(ctrl_id, GUIEDIT_STYLE_SINGLE);

        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;
        

        /*
    case MSG_FULL_PAINT:
        LCD_FillRect(&lcd_dev_info, rect, mmi_eng_display.bkgd_color);
        break;
*/
    case MSG_APP_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
    case MSG_APP_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
        cur_selection = GUILIST_GetCurItemIndex(MMIENG_IQ_DATA_MODE_SELECT_CTRL_ID);
        GUIEDIT_GetString(ctrl_id, &edit_string);

        if (0 != edit_string.wstr_len)
        {
            SCI_MEMSET(time_buf, 0x00, sizeof(time_buf));
            MMI_WSTRNTOSTR(time_buf, 10, edit_string.wstr_ptr, edit_string.wstr_len, edit_string.wstr_len );

            iq_mode_param.record_param[cur_selection].time_limit = atoi((char *)(time_buf));

            MMIAPIENG_SetIQMode(&iq_mode_param);

          //  MMIPUB_OpenAlertSuccessWin(TXT_SUCCESS);
        }
        else
        {
            MMIPUB_OpenAlertFailWin(TXT_INPUT_ERROR);
        }
        MMK_CloseWin(win_id);
        break;

    default:
       result = MMI_RESULT_FALSE;

        break;
    }

    return (result);
}

/*****************************************************************************/
//  Description : HandleIQDataModeSettingFrameLengthWinMsg
//  Global resource dependence : 
//  Author: wancan.you
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleIQDataModeSettingFrameLengthWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
//     GUI_LCD_DEV_INFO    lcd_dev_info = {GUI_MAIN_LCD_ID, GUI_BLOCK_MAIN};
    MMI_CTRL_ID_T   ctrl_id = MMIENG_IQ_DATA_MODE_SETTING_FRAME_LENGTH_CTRL_ID;
    uint16 cur_selection = 0;
    uint8 frame_buf[10] = {0};
    wchar wstr[10] = {0};
    uint16 len = 0;
    MMIENG_IQ_MODE_T iq_mode_param = MMIAPIENG_GetIQMode();
    MMI_STRING_T  edit_string = {0};
 
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        {
             GUI_BOTH_RECT_T  edit_rect = MMITHEME_GetWinClientBothRect(MMK_ConvertIdToHandle(win_id));   
             GUIAPICTRL_SetBothRect(MMK_ConvertIdToHandle(ctrl_id), &edit_rect);
        }       
        
        cur_selection = GUILIST_GetCurItemIndex(MMIENG_IQ_DATA_MODE_SELECT_CTRL_ID);

        SCI_MEMSET(frame_buf, 0, sizeof(frame_buf));
        sprintf((char *)frame_buf, "%ld", (int32)iq_mode_param.record_param[cur_selection].frame_length);
        
        len = strlen((char *)frame_buf);
        MMI_STRNTOWSTR( wstr, 10, frame_buf, len, len );
        
        GUIEDIT_SetString(
            ctrl_id,
            wstr,
            len
            );
        GUIEDIT_SetStyle(ctrl_id, GUIEDIT_STYLE_SINGLE);

        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;
/*
    case MSG_FULL_PAINT:
        LCD_FillRect(&lcd_dev_info, rect, mmi_eng_display.bkgd_color);
        break;
*/
    case MSG_APP_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
    case MSG_APP_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
        cur_selection = GUILIST_GetCurItemIndex(MMIENG_IQ_DATA_MODE_SELECT_CTRL_ID);
        GUIEDIT_GetString(ctrl_id, &edit_string);

        if (0 != edit_string.wstr_len)
        {
            SCI_MEMSET(frame_buf, 0x00, sizeof(frame_buf));
            MMI_WSTRNTOSTR( frame_buf, 10, edit_string.wstr_ptr, edit_string.wstr_len, edit_string.wstr_len );

            iq_mode_param.record_param[cur_selection].frame_length = atoi((char *)(frame_buf));

            MMIAPIENG_SetIQMode(&iq_mode_param);

           // MMIPUB_OpenAlertSuccessWin(TXT_SUCCESS);
        }
        else
        {
            MMIPUB_OpenAlertFailWin(TXT_INPUT_ERROR);
        }
        MMK_CloseWin(win_id);
        break;

    default:
        result = MMI_RESULT_FALSE;
        break;
    }

    return (result);
}

/*****************************************************************************/
//  Description : HandleIQDataModeSettingBlockCountWinMsg
//  Global resource dependence : 
//  Author: wancan.you
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleIQDataModeSettingBlockCountWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
//     GUI_LCD_DEV_INFO    lcd_dev_info = {GUI_MAIN_LCD_ID, GUI_BLOCK_MAIN};
    MMI_CTRL_ID_T   ctrl_id = MMIENG_IQ_DATA_MODE_SETTING_BLOCK_COUNT_CTRL_ID;
    uint16 cur_selection = 0;
    uint8 block_buf[10] = {0};
    wchar wstr[10] = {0};
    uint16 len = 0;
    MMIENG_IQ_MODE_T iq_mode_param = MMIAPIENG_GetIQMode();
    MMI_STRING_T  edit_string = {0};
  
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
         {
            //GUIEDIT_SetRect(MMIENG_IQ_DATA_MODE_SETTING_FORMAT_CTRL_ID,&edit_rect);
            GUI_BOTH_RECT_T  edit_rect = MMITHEME_GetWinClientBothRect(MMK_ConvertIdToHandle(win_id));   
            GUIAPICTRL_SetBothRect(MMK_ConvertIdToHandle(ctrl_id), &edit_rect);
        }
       
        cur_selection = GUILIST_GetCurItemIndex(MMIENG_IQ_DATA_MODE_SELECT_CTRL_ID);

        SCI_MEMSET(block_buf, 0, sizeof(block_buf));
        sprintf((char *)block_buf, "%d", iq_mode_param.record_param[cur_selection].block_count);

        len = strlen((char *)block_buf);
        MMI_STRNTOWSTR( wstr, 10, block_buf, len, len );

        GUIEDIT_SetString(
            ctrl_id,
            wstr,
            len
            );
        GUIEDIT_SetStyle(ctrl_id, GUIEDIT_STYLE_SINGLE);

        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;
/*
    case MSG_FULL_PAINT:
        LCD_FillRect(&lcd_dev_info, rect, mmi_eng_display.bkgd_color);
        break;
*/
    case MSG_APP_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
    case MSG_APP_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
        cur_selection = GUILIST_GetCurItemIndex(MMIENG_IQ_DATA_MODE_SELECT_CTRL_ID);
        GUIEDIT_GetString(ctrl_id, &edit_string);

        if (0 != edit_string.wstr_len)
        {
            SCI_MEMSET(block_buf, 0x00, sizeof(block_buf));
            MMI_WSTRNTOSTR( block_buf, 10, edit_string.wstr_ptr, edit_string.wstr_len, edit_string.wstr_len );

            iq_mode_param.record_param[cur_selection].block_count = atoi((char *)(block_buf));

            MMIAPIENG_SetIQMode(&iq_mode_param);

          //  MMIPUB_OpenAlertSuccessWin(TXT_SUCCESS);
        }
        else
        {
            MMIPUB_OpenAlertFailWin(TXT_INPUT_ERROR);
        }
        MMK_CloseWin(win_id);
        break;

    default:
        result = MMI_RESULT_FALSE;
        break;
    }

    return (result);
}


/********************************************************************************
 NAME:          HandleIQDataModeSettingARFCNWinMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        Jerry Liang
 DATE:          2008.07.31
********************************************************************************/
LOCAL MMI_RESULT_E HandleIQDataModeSettingARFCNWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{   
    MMI_RESULT_E result = MMI_RESULT_TRUE;
//     GUI_LCD_DEV_INFO    lcd_dev_info = {GUI_MAIN_LCD_ID, GUI_BLOCK_MAIN};
    MMI_CTRL_ID_T   ctrl_id = MMIENG_IQ_DATA_MODE_SETTING_ARFCN_CTRL_ID;
    uint16 cur_selection = 0;
    uint8 arfcn_buf[10] = {0};
    wchar wstr[10] = {0};
    uint16 len = 0;
    MMIENG_IQ_MODE_T iq_mode_param = MMIAPIENG_GetIQMode();
    MMI_STRING_T  edit_string = {0};
 
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
          {
             GUI_BOTH_RECT_T  edit_rect = MMITHEME_GetWinClientBothRect(MMK_ConvertIdToHandle(win_id));   
             GUIAPICTRL_SetBothRect(MMK_ConvertIdToHandle(ctrl_id), &edit_rect);
        }
       
        cur_selection = GUILIST_GetCurItemIndex(MMIENG_IQ_DATA_MODE_SELECT_CTRL_ID);

        SCI_MEMSET(arfcn_buf, 0, sizeof(arfcn_buf));
        sprintf((char *)arfcn_buf, "%d", iq_mode_param.record_param[cur_selection].arfcn);

        len = strlen((char *)arfcn_buf);
        MMI_STRNTOWSTR( wstr, 10, arfcn_buf, len, len );

        GUIEDIT_SetString(
            ctrl_id,
            wstr,
            len
            );
        GUIEDIT_SetStyle(ctrl_id, GUIEDIT_STYLE_SINGLE);

        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;
/*
    case MSG_FULL_PAINT:
        LCD_FillRect(&lcd_dev_info, rect, mmi_eng_display.bkgd_color);
        break;
*/
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
        cur_selection = GUILIST_GetCurItemIndex(MMIENG_IQ_DATA_MODE_SELECT_CTRL_ID);
        GUIEDIT_GetString(ctrl_id, &edit_string);

        if (0 != edit_string.wstr_len)
        {
            SCI_MEMSET(arfcn_buf, 0x00, sizeof(arfcn_buf));
            MMI_WSTRNTOSTR(arfcn_buf, 10, edit_string.wstr_ptr, edit_string.wstr_len, edit_string.wstr_len);

            iq_mode_param.record_param[cur_selection].arfcn = atoi((char *)(arfcn_buf));

            MMIAPIENG_SetIQMode(&iq_mode_param);

           // MMIPUB_OpenAlertSuccessWin(TXT_SUCCESS);
        }
        else
        {
            MMIPUB_OpenAlertFailWin(TXT_INPUT_ERROR);
        }
        MMK_CloseWin(win_id);
        break;

    default:
        result = MMI_RESULT_FALSE;
        break;
    }

    return (result);
}


/*****************************************************************************/
//  Description : HandleIQDataModeSettingChannelWinMsg
//  Global resource dependence : 
//  Author: wancan.you
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleIQDataModeSettingChannelWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_IQ_DATA_MODE_SETTING_CHANNEL_CTRL_ID;
    uint16 cur_selection = 0;
    uint16 index = 0;
    MMIENG_IQ_MODE_T iq_mode_param = MMIAPIENG_GetIQMode();

    switch (msg_id) 
    {
        case MSG_OPEN_WINDOW:
            GUILIST_SetMaxItem(ctrl_id, RECORD_OUTPUT_MAX, FALSE);//max item 2
            GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
            //add items to listbox
            MMIAPISET_AppendListItemByTextIdExt(TXT_ENG_IQ_DATA_CHANNEL_FILE,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
            MMIAPISET_AppendListItemByTextIdExt(TXT_ENG_IQ_DATA_CHANNEL_ARM_LOG,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG); 

            GUILIST_SetItemGray(ctrl_id, RECORD_OUTPUT_ARM_LOG, TRUE);

            index = GUILIST_GetCurItemIndex(MMIENG_IQ_DATA_MODE_SELECT_CTRL_ID);
            cur_selection = iq_mode_param.record_param[index].output_channel;

            //set selected item
            GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
            
            //set current item
            GUILIST_SetCurItemIndex(ctrl_id, cur_selection);
            MMK_SetAtvCtrl(win_id, ctrl_id);
            break;

        case MSG_FULL_PAINT:
            break;

        case MSG_APP_CANCEL:
        case MSG_CTL_CANCEL:
            MMK_CloseWin(win_id);
            break;

        case MSG_APP_OK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
        case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
        case MSG_CTL_MIDSK:
        case MSG_CTL_OK:
        case MSG_APP_WEB:
            if (!GUILIST_IsCurrItemInvalid(ctrl_id))
            {
                index = GUILIST_GetCurItemIndex(MMIENG_IQ_DATA_MODE_SELECT_CTRL_ID);
                cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
                if (0 == cur_selection)
                {
                    iq_mode_param.record_param[index].output_channel = RECORD_OUTPUT_SAVE_TO_FILE;
                }
                else
                {
                    iq_mode_param.record_param[index].output_channel = RECORD_OUTPUT_ARM_LOG;
                }

                MMIAPIENG_SetIQMode(&iq_mode_param);
              //  MMIPUB_OpenAlertSuccessWin(TXT_SUCCESS);
                MMK_CloseWin(win_id);
            }
            break;

        default:
            result = MMI_RESULT_FALSE;
            break;
    }

    return (result);
}

/*****************************************************************************/
//  Description : MMIAPIENG_AlertIQMode
//  Global resource dependence : 
//  Author: wancan.you
//  Note: 
/*****************************************************************************/
PUBLIC void MMIAPIENG_AlertIQMode(void)
{
    //提示IQ模式下不能录音
    MMIPUB_OpenAlertWarningWin(TXT_ENG_IQ_MODE_WARNING);
}

/*****************************************************************************/
//  Description : HandleIQDataQueryWin
//  Global resource dependence :                                
//      Author: wancan.you
//  Note:
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleIQDataQueryWin(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E    result = MMI_RESULT_TRUE;
    static BOOLEAN is_succeed = FALSE;
    static BOOLEAN is_need_add_to_fs = FALSE;
    MMIENG_IQ_MODE_T iq_mode_param = MMIAPIENG_GetIQMode();

    switch(msg_id)
    {
        case MSG_OPEN_WINDOW:
            is_need_add_to_fs = TRUE;
            result = MMIPUB_HandleAlertWinMsg(win_id,msg_id,param);
            break;

        case MSG_ENG_IQ_RESULT_CNF:
            is_succeed = *(BOOLEAN *)param;
            break;

        case MSG_UDISK_FORMAT_CNF:
            //MMIPUB_CloseQuerytWin(PNULL);
            MMIPUB_CloseAlertWin();
            MMIAPIUdisk_HandleFormatCnf(*(BOOLEAN *)param);
            MMIAPIENG_StartIQData();
            MMK_CloseWin(win_id);
            break;

        case MSG_APP_OK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
        case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
        case MSG_CTL_MIDSK:
        case MSG_CTL_OK:
        case MSG_APP_WEB:
            is_need_add_to_fs = FALSE;
#ifdef MMI_RECORD_SUPPORT
            MMIPUB_OpenAlertWaitingWin(TXT_COMMON_WAITING);
            
            MMIAPIFMM_FormatDeviceAsyn((wchar *)MMIAPIFMM_GetDevicePath(MMIAPIRECORD_GetRecordStorage()), 
                                      MMIAPIFMM_GetDevicePathLen(MMIAPIRECORD_GetRecordStorage()), 
                                      MMIFILE_FORMAT_FAT16,
                                      win_id,
                                      MSG_UDISK_FORMAT_CNF
                                     );   

            MMK_CloseWin(win_id);
#endif            
            break;

        case MSG_APP_CANCEL:
        case MSG_CTL_CANCEL:
            is_need_add_to_fs = FALSE;
            MMIPUB_CloseQuerytWin(PNULL);
#ifdef MMI_RECORD_SUPPORT     
			MMIENG_DeletRecordFile();
			if (!is_succeed)
			{		
				MMIPUB_OpenAlertFailWin(TXT_ERROR);    
			}
#endif            
            iq_mode_param.b_is_start = FALSE;
            MMIAPIENG_SetIQMode(&iq_mode_param);
            MMK_CloseWin(win_id);
            break;

        case MSG_CLOSE_WINDOW:
                        
            if (is_need_add_to_fs)
            {
                is_need_add_to_fs = FALSE;
#ifdef MMI_RECORD_SUPPORT 
				MMIENG_DeletRecordFile();
				if (!is_succeed)
				{			
					MMIPUB_OpenAlertFailWin(TXT_ERROR);      
				}
#endif                
                iq_mode_param.b_is_start = FALSE;
                MMIAPIENG_SetIQMode(&iq_mode_param);
            }
            result = MMIPUB_HandleAlertWinMsg(win_id,msg_id,param);
            break;

        default:
            result = MMIPUB_HandleAlertWinMsg(win_id,msg_id,param);
            break;
    }

    return result;
}

/*****************************************************************************/
//  Description : Open IQ Data Query Win
//  Global resource dependence :                                
//      Author: wancan.you
//  Note:
/*****************************************************************************/
PUBLIC BOOLEAN MMIAPIENG_OpenHandleIQDataQueryWin(BOOLEAN is_succeed)
{
    MMI_WIN_ID_T query_win_id = MMIENG_IQ_DATA_HANDLE_QUERY_WIN_ID;
    MMIPUB_CloseQuerytWin(PNULL);
    MMIPUB_OpenQueryWinByTextId(TXT_ENG_IQ_DATA_RECORD_AGAIN, IMAGE_PUBWIN_QUERY, &query_win_id, HandleIQDataQueryWin);
    MMK_PostMsg(query_win_id, MSG_ENG_IQ_RESULT_CNF, &is_succeed, sizeof(BOOLEAN));

    return TRUE;
    //return MMK_CreateWin((uint32 *)MMIENG_HANDLE_QUERY_WIN_TAB, (ADD_DATA) is_suc_ptr);
}

/*****************************************************************************/
//  Description : is arm log on when power on
//  Global resource dependence :                                
//      Author: wancan.you
//  Note:
/*****************************************************************************/
PUBLIC BOOLEAN MMIAPIENG_IsUSBLOGON(void)
{
    BOOLEAN is_on = FALSE;
    MN_RETURN_RESULT_E  return_value = MN_RETURN_FAILURE;
     MMINV_READ(MMINV_ENG_USBLOG,&is_on,return_value);        
    if(MN_RETURN_SUCCESS!=return_value)
    {
        is_on = FALSE;      
        MMINV_WRITE(MMINV_ENG_USBLOG,&is_on);
    }    
    SCI_TRACE_LOW("MMIAPIENG_IsUSBLOGON is_on = %d", is_on);// @cr239352 renwei add
    return is_on;
}

#ifdef PCLINK_SUPPORT
/*****************************************************************************/
//  Description : HandlePClinkEnableWinMsg
//  Global resource dependence : 
//  Author: zhaohui
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandlePClinkEnableWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_PCLINK_ENABLE_CTRL_ID;
    uint16 cur_selection = 0;
    //    MMIENG_IQ_MODE_T iq_mode_param = MMIAPIENG_GetIQMode();
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
#ifndef WIN32
        MNGPRS_GetPclinkCfg(&s_pclink_config_info);
#endif
        GUILIST_SetMaxItem(ctrl_id,MMISET_OPEN_CLOSE_ITEM, FALSE );//max item 2
        GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
        MMIAPISET_AppendListItemByTextIdExt(TXT_OPEN_COMN,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
        MMIAPISET_AppendListItemByTextIdExt(TXT_COMM_CLOSE,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);     
        
        if (s_pclink_config_info.is_pclink_open)
        {
            cur_selection = 0;
        }
        else
        {
            cur_selection = 1;
        }
        
        //set selected item
        GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
        
        //set current item
        GUILIST_SetCurItemIndex(ctrl_id,cur_selection);
        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;
        
    case MSG_FULL_PAINT:
        break;
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_KEYDOWN_OK:
        break;        
        
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
        
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_MIDSK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
        if (0 == cur_selection)
        {
            s_pclink_config_info.is_pclink_open = TRUE;
        }
        else
        {
            s_pclink_config_info.is_pclink_open = FALSE;
        }
        
        //设置NV项
#ifndef WIN32
        MNGPRS_SetPclinkCfg(&s_pclink_config_info);
#endif
        MMIPUB_OpenAlertSuccessWin(TXT_ENG_SUCCESS_NEED_RESET);
        MMK_CloseWin(win_id);
        break;
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    
    return (result);
}

/*****************************************************************************/
//  Description : HandlePClinkInputDNSWinMsg
//  Global resource dependence : none
//  Author: zhaohui
//  Note:
/*****************************************************************************/
LOCAL MMI_RESULT_E HandlePClinkInputIPAddrWinMsg(
                                                 MMI_WIN_ID_T   win_id, 
                                                 MMI_MESSAGE_ID_E   msg_id, 
                                                 DPARAM             param
                                                 )
{
    MMI_RESULT_E    recode = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_PCLINK_INPUT_IPADDR_CTRL_ID;
    
    switch(msg_id)
    {
    case MSG_OPEN_WINDOW:
#ifndef WIN32
        MNGPRS_GetPclinkCfg(&s_pclink_config_info);
#endif
        GUIEDIT_SetIP (ctrl_id,s_pclink_config_info.ipaddr);
        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;
#ifdef MMI_PDA_SUPPORT
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
        if (PNULL != param)
        {
            uint32 src_id = ((MMI_NOTIFY_T*)param)->src_id;
            
            switch (src_id)
            {
            case MMICOMMON_BUTTON_SOFTKEY_LEFT_CTRL_ID:
                MMK_SendMsg(win_id,MSG_APP_OK, PNULL);

                break;
            case MMICOMMON_BUTTON_SOFTKEY_MIDDLE_CTRL_ID:
                break;
            case MMICOMMON_BUTTON_SOFTKEY_RIGHT_CTRL_ID:
                MMK_SendMsg(win_id,MSG_APP_CANCEL, PNULL);
                break;           
            default:
                break;
            }
        }
        break;
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527        
#else        
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
#endif
    case MSG_CTL_MIDSK:
    case MSG_APP_WEB:
    case MSG_APP_OK:
    case MSG_CTL_OK:
        s_pclink_config_info.ipaddr = GUIEDIT_GetIP(ctrl_id);
        //设置NV项
#ifndef WIN32
        MNGPRS_SetPclinkCfg(&s_pclink_config_info);
#endif      
        MMK_CloseWin(win_id);
        break;
        
    case MSG_CTL_CANCEL:
    case MSG_APP_CANCEL:
        MMK_CloseWin(win_id);//返回上一级
        break;
        
    default:    
        recode = MMI_RESULT_FALSE;
        break;
    }
    return recode;
    
}

/*****************************************************************************/
//  Description : HandlePClinkInputSNMaskWinMsg
//  Global resource dependence : none
//  Author: zhaohui
//  Note:
/*****************************************************************************/
LOCAL MMI_RESULT_E HandlePClinkInputSNMaskWinMsg(
                                            MMI_WIN_ID_T    win_id, 
                                            MMI_MESSAGE_ID_E    msg_id, 
                                            DPARAM              param
                                            )
{
    MMI_RESULT_E    recode = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_PCLINK_INPUT_SNMASK_CTRL_ID;
    
    switch(msg_id)
    {
    case MSG_OPEN_WINDOW:
#ifndef WIN32
        MNGPRS_GetPclinkCfg(&s_pclink_config_info);
#endif
        GUIEDIT_SetIP (ctrl_id,s_pclink_config_info.snmask);
        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;
        
#ifdef MMI_PDA_SUPPORT
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
        if (PNULL != param)
        {
            uint32 src_id = ((MMI_NOTIFY_T*)param)->src_id;
            
            switch (src_id)
            {
            case MMICOMMON_BUTTON_SOFTKEY_LEFT_CTRL_ID:
                MMK_SendMsg(win_id,MSG_APP_OK, PNULL);

                break;
            case MMICOMMON_BUTTON_SOFTKEY_MIDDLE_CTRL_ID:
                break;
            case MMICOMMON_BUTTON_SOFTKEY_RIGHT_CTRL_ID:
                MMK_SendMsg(win_id,MSG_APP_CANCEL, PNULL);
                break;           
            default:
                break;
            }
        }
        break;
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527        
#else        
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
#endif
    case MSG_CTL_MIDSK:
    case MSG_APP_WEB:
    case MSG_APP_OK:
    case MSG_CTL_OK:
        s_pclink_config_info.snmask = GUIEDIT_GetIP(ctrl_id);
        //设置NV项
#ifndef WIN32
        MNGPRS_SetPclinkCfg(&s_pclink_config_info);
#endif
        MMK_CloseWin(win_id);       
        break;
        
    case MSG_CTL_CANCEL:
    case MSG_APP_CANCEL:
        MMK_CloseWin(win_id);//返回上一级
        break;
        
    default:    
        recode = MMI_RESULT_FALSE;
        break;
    }
    return recode;
    
}

/*****************************************************************************/
//  Description : HandlePClinkInputDefGWWinMsg
//  Global resource dependence : none
//  Author: zhaohui
//  Note:
/*****************************************************************************/
LOCAL MMI_RESULT_E HandlePClinkInputDefGWWinMsg(
                                            MMI_WIN_ID_T    win_id, 
                                            MMI_MESSAGE_ID_E    msg_id, 
                                            DPARAM              param
                                            )
{
    MMI_RESULT_E    recode = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_PCLINK_INPUT_DEFGW_CTRL_ID;

    switch(msg_id)
    {
    case MSG_OPEN_WINDOW:
#ifndef WIN32
      MNGPRS_GetPclinkCfg(&s_pclink_config_info);
#endif
        GUIEDIT_SetIP (ctrl_id,s_pclink_config_info.defgw);
        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;
        
#ifdef MMI_PDA_SUPPORT
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
        if (PNULL != param)
        {
            uint32 src_id = ((MMI_NOTIFY_T*)param)->src_id;
            
            switch (src_id)
            {
            case MMICOMMON_BUTTON_SOFTKEY_LEFT_CTRL_ID:
                MMK_SendMsg(win_id,MSG_APP_OK, PNULL);

                break;
            case MMICOMMON_BUTTON_SOFTKEY_MIDDLE_CTRL_ID:
                break;
            case MMICOMMON_BUTTON_SOFTKEY_RIGHT_CTRL_ID:
                MMK_SendMsg(win_id,MSG_APP_CANCEL, PNULL);
                break;           
            default:
                break;
            }
        }
        break;
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527        
#else        
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
#endif
    case MSG_CTL_MIDSK:
    case MSG_APP_WEB:
    case MSG_APP_OK:
    case MSG_CTL_OK:
        s_pclink_config_info.defgw = GUIEDIT_GetIP(ctrl_id);
        //设置NV项
#ifndef WIN32
        MNGPRS_SetPclinkCfg(&s_pclink_config_info);
#endif
        MMK_CloseWin(win_id);       
        break;
        
    case MSG_CTL_CANCEL:
    case MSG_APP_CANCEL:
        MMK_CloseWin(win_id);//返回上一级
        break;
        
    default:    
        recode = MMI_RESULT_FALSE;
        break;
    }
    return recode;
    
}

/*****************************************************************************/
//  Description : HandlePClinkInputDNSWinMsg
//  Global resource dependence : none
//  Author: zhaohui
//  Note:
/*****************************************************************************/
LOCAL MMI_RESULT_E HandlePClinkInputDNSWinMsg(
                                              MMI_WIN_ID_T  win_id, 
                                              MMI_MESSAGE_ID_E  msg_id, 
                                              DPARAM                param
                                              )
{
    MMI_RESULT_E    recode = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_PCLINK_INPUT_DNS_CTRL_ID;
    
    switch(msg_id)
    {
    case MSG_OPEN_WINDOW:
#ifndef WIN32
        MNGPRS_GetPclinkCfg(&s_pclink_config_info);
#endif
        GUIEDIT_SetIP (ctrl_id,s_pclink_config_info.dns);
        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;
        
#ifdef MMI_PDA_SUPPORT
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
        if (PNULL != param)
        {
            uint32 src_id = ((MMI_NOTIFY_T*)param)->src_id;
            
            switch (src_id)
            {
            case MMICOMMON_BUTTON_SOFTKEY_LEFT_CTRL_ID:
                MMK_SendMsg(win_id,MSG_APP_OK, PNULL);

                break;
            case MMICOMMON_BUTTON_SOFTKEY_MIDDLE_CTRL_ID:
                break;
            case MMICOMMON_BUTTON_SOFTKEY_RIGHT_CTRL_ID:
                MMK_SendMsg(win_id,MSG_APP_CANCEL, PNULL);
                break;           
            default:
                break;
            }
        }
        break;
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527        
#else        
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
#endif
    case MSG_CTL_MIDSK:
    case MSG_APP_WEB:
    case MSG_APP_OK:
    case MSG_CTL_OK:
        s_pclink_config_info.dns = GUIEDIT_GetIP(ctrl_id);
        //设置NV项
#ifndef WIN32
        MNGPRS_SetPclinkCfg(&s_pclink_config_info);
#endif      
        MMK_CloseWin(win_id);
        break;
        
    case MSG_CTL_CANCEL:
    case MSG_APP_CANCEL:
        MMK_CloseWin(win_id);//返回上一级
        break;
        
    default:    
        recode = MMI_RESULT_FALSE;
        break;
    }
    return recode;
    
}

/*****************************************************************************/
//  Description : handle message of input test address window of pc link
//  Global resource dependence : none
//  Author: zhaohui
//  Note:
/*****************************************************************************/
LOCAL MMI_RESULT_E HandlePCLinkInputTestAdfressWinMsg(
                                             MMI_WIN_ID_T   win_id, 
                                             MMI_MESSAGE_ID_E   msg_id, 
                                             DPARAM             param
                                             )
{
    MMI_RESULT_E    recode = MMI_RESULT_TRUE;
//     MMI_STRING_T string_info = {0};
    MMI_CTRL_ID_T   ctrl_id = MMIENG_PCLINK_INPUT_TEST_ADDRESS_CTRL_ID;
    uint32 pclink_test_addr = 0;
    MN_RETURN_RESULT_E nv_result =MN_RETURN_SUCCESS;
    
    switch(msg_id)
    {
    case MSG_OPEN_WINDOW:
        //从NV中读出来
        MMINV_READ(MMIENG_NV_PCLINK_TEST_ADDR_ID, &pclink_test_addr, nv_result);
        if (MN_RETURN_SUCCESS != nv_result)
        {
            SCI_MEMSET(&pclink_test_addr,0,sizeof(uint32));
            MMINV_WRITE(MMIENG_NV_PCLINK_TEST_ADDR_ID, &pclink_test_addr);
        }
        
        if (0 == pclink_test_addr)//若test address为空，则直接设置默认的gateway地址
        {
            GUIEDIT_SetIP (ctrl_id,s_pclink_config_info.defgw);
            
        }
        else
        {
            GUIEDIT_SetIP (ctrl_id,pclink_test_addr);
        }
        
        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;
        
#ifdef MMI_PDA_SUPPORT
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
        if (PNULL != param)
        {
            uint32 src_id = ((MMI_NOTIFY_T*)param)->src_id;
            
            switch (src_id)
            {
            case MMICOMMON_BUTTON_SOFTKEY_LEFT_CTRL_ID:
                MMK_SendMsg(win_id,MSG_APP_OK, PNULL);

                break;
            case MMICOMMON_BUTTON_SOFTKEY_MIDDLE_CTRL_ID:
                break;
            case MMICOMMON_BUTTON_SOFTKEY_RIGHT_CTRL_ID:
                MMK_SendMsg(win_id,MSG_APP_CANCEL, PNULL);
                break;           
            default:
                break;
            }
        }
        break;
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527        
#else        
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
#endif
    case MSG_CTL_MIDSK:
    case MSG_APP_WEB:
    case MSG_APP_OK:
    case MSG_CTL_OK:
        pclink_test_addr = GUIEDIT_GetIP(ctrl_id);      
        //存入NV
        MMINV_WRITE(MMIENG_NV_PCLINK_TEST_ADDR_ID, &pclink_test_addr);
        MMK_CloseWin(win_id);
        break;
        
    case MSG_CTL_CANCEL:
    case MSG_APP_CANCEL:
        MMK_CloseWin(win_id);//返回上一级
        break;
        
    default:        
        recode = MMI_RESULT_FALSE;
        break;
    }
    return recode;
    
}

/*****************************************************************************/
//  Description : start pingtest for pc link
//  Global resource dependence : none
//  Author: zhaohui
//  Note:
/*****************************************************************************/
PUBLIC void MMIENG_StartPingTest(void)
{
    MMI_STRING_T    ping_test_text = {0};
    // 显示“Ping test start ...”对话框
    MMI_GetLabelTextByLang(TXT_ENG_PCLINK_PING_TEST_START, &ping_test_text);
    MMIPUB_OpenWaitWin(1,&ping_test_text,PNULL,PNULL,MMIENG_PCLINK_PING_TEST_WAIT_WIN_ID,IMAGE_NULL,
        ANIM_PUBWIN_WAIT,WIN_ONE_LEVEL,MMIPUB_SOFTKEY_ONE,HandlePCLinkPingTestWaitWinMsg);
}

/* ping request handle */
TCPIP_PING_HANDLE    g_pclink_ping_handle = TCPIP_PING_HANDLE_NULL;
TCPIP_PING_RESULT_E  g_pclink_ping_res = PINGRES_SUCCESS;

/*****************************************************************************/
//  Description : start pingtest for pc link
//  Global resource dependence : none
//  Author: zhaohui
//  Note:
/*****************************************************************************/
LOCAL MMI_RESULT_E HandlePCLinkPingTestWaitWinMsg(
                                                 MMI_WIN_ID_T    win_id,    // 窗口的ID
                                                 MMI_MESSAGE_ID_E   msg_id,     // 窗口的内部消息ID
                                                 DPARAM             param       // 相应消息的参数
                                                 )
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    uint8 addr[MMIENG_PCLINK_MAX_IP_LEN + 1] = {0};
    uint32 pclink_test_addr = 0;
    MN_RETURN_RESULT_E nv_result = MN_RETURN_SUCCESS;
    
    switch (msg_id)
    {   
    case MSG_OPEN_WINDOW:
        //从NV中读出来
        MMINV_READ(MMIENG_NV_PCLINK_TEST_ADDR_ID, &pclink_test_addr, nv_result);
        if (MN_RETURN_SUCCESS != nv_result)
        {
            SCI_MEMSET(&pclink_test_addr,0,sizeof(uint32));
            MMINV_WRITE(MMIENG_NV_PCLINK_TEST_ADDR_ID, &pclink_test_addr);
        }
#ifndef WIN32
        TCPIPPCLINK_SetNetInterface();   // 设置PCLINK网络接口
#endif
        MMIAPICONNECTION_IpNumToStr(pclink_test_addr, &addr);/*lint !e64*/

        // send ping request
        g_pclink_ping_handle = sci_async_ping((char*)addr, 0, 0, SCI_IdentifyThread(), 0);
        if( TCPIP_PING_HANDLE_NULL == g_pclink_ping_handle )
        {
            MMK_CloseWin(win_id);
            MMIPUB_OpenAlertWinByTextId(
                NULL,TXT_ENG_PCLINK_PING_TEST_ERROR,TXT_NULL,IMAGE_PUBWIN_FAIL,PNULL,PNULL,MMIPUB_SOFTKEY_ONE,PNULL);

        }
        result = MMIPUB_HandleWaitWinMsg(win_id, msg_id, param);
        break;

    case MSG_APP_CANCEL://取消ping test的处理
    case MSG_APP_RED:
        MMK_CloseWin(win_id);
        sci_ping_cancel(g_pclink_ping_handle);
        // 弹出“Ping test canceled!”对话框    
        MMIPUB_OpenAlertWinByTextId(NULL,TXT_ENG_PCLINK_PING_TEST_CANCELED,TXT_NULL,IMAGE_PUBWIN_WARNING,PNULL,PNULL,MMIPUB_SOFTKEY_ONE,PNULL);
        break;

#ifdef FLIP_PHONE_SUPPORT  //close flip ring codes, just open for flip phone.
    case MSG_APP_FLIP:
        MMIDEFAULT_HandleFlipKey(FALSE);
        break;
#endif

    case MSG_ENG_PCLINK_PING_SUC:
        {  
            MMK_CloseWin(win_id);
            // 弹出“Ping test OK!”对话框
            MMIPUB_OpenAlertWinByTextId(NULL,TXT_ENG_PCLINK_PING_TEST_OK,TXT_NULL,IMAGE_PUBWIN_SUCCESS,PNULL,PNULL,MMIPUB_SOFTKEY_ONE,PNULL);
        }       
        break;

    case MSG_ENG_PCLINK_PING_FAIL:
        {
            MMK_CloseWin(win_id);        
            // 显示“Ping test error!”对话框
            switch(g_pclink_ping_res)
            {
            case PINGRES_ICMP_TIMEOUT:
            case PINGRES_DNS_TIMEOUT:
                MMIPUB_OpenAlertWinByTextId(
                    NULL,TXT_ENG_PCLINK_PING_TEST_TIMEOUT,TXT_NULL,IMAGE_PUBWIN_WARNING,PNULL,PNULL,MMIPUB_SOFTKEY_ONE,PNULL);
                break;

            case PINGRES_DNS_ERROR:
            case PINGRES_ICMP_ERROR:
            default:
                MMIPUB_OpenAlertWinByTextId(
                    NULL,TXT_ENG_PCLINK_PING_TEST_ERROR,TXT_NULL,IMAGE_PUBWIN_FAIL,PNULL,PNULL,MMIPUB_SOFTKEY_ONE,PNULL);
                break;
            }
         }
        break;

    case MSG_CLOSE_WINDOW:
#ifndef WIN32
        TCPIPPCLINK_ResetNetInterface();   // 清除PCLINK网络接口
#endif
        result = MMIPUB_HandleWaitWinMsg(win_id, msg_id, param);
        break;

    default:
        result = MMIPUB_HandleWaitWinMsg(win_id, msg_id, param);        
        break;      
    }
    return result;
}
#endif

#ifdef  CAMERA_SUPPORT

/********************************************************************************
 NAME:          HandleDCParamScreenSizeWinMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        zhaohui
 DATE:          2008.12.30
********************************************************************************/
LOCAL MMI_RESULT_E HandleDCParamScreenSizeWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    uint16                  index = 0;
    MMI_RESULT_E            result = MMI_RESULT_TRUE;
    MMI_TEXT_ID_T           text_id_tab[] = {TXT_ENG_DC_176_220, TXT_ENG_DC_240_320, TXT_ENG_DC_220_400};
    int16                   item_total_num = ARR_SIZE(text_id_tab);
    MMI_CTRL_ID_T           list_id = MMIENG_LISTBOX_CTRL_ID;
    CAMERA_ENG_LCD_SIZE_MODE_E  mode = CAMERA_ENG_LCD_176X220;
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        GUILIST_SetMaxItem(list_id, item_total_num, FALSE );//max item 3
        GUILIST_SetOwnSofterKey(list_id,TRUE);
        AppendListItem(
            list_id, 
            text_id_tab, 
            item_total_num
            );
        // #ifndef WIN32        
        mode = MMIAPIDC_GetLCDSizeMode();
        // #endif        
        //SCI_TRACE_LOW:"MMIENG_MAIN.C HandleDCParamScreenSizeWinMsg mode is %d,item_total_num is %d"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_14287_112_2_18_2_18_10_201,(uint8*)"dd",mode,item_total_num);
        if((int16)mode >=  item_total_num)
        {
            break;
        }
        GUILIST_SetSelectedItem(list_id, (uint16)mode, TRUE);
        GUILIST_SetCurItemIndex(list_id, (int16)mode);
        MMK_SetAtvCtrl(win_id, list_id);
        break;
        
    case MSG_FULL_PAINT:
        break;
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        index = GUILIST_GetCurItemIndex(list_id);
        //SCI_TRACE_LOW:"MMIENG_MAIN.C HandleDCParamScreenSizeWinMsg mode is %d,item_total_num is %d"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_14310_112_2_18_2_18_10_202,(uint8*)"dd",index,item_total_num);
        if((int16)index >=  item_total_num)
        {
            break;
        }
        
        MMIAPIDC_SetLCDSizeMode((CAMERA_ENG_LCD_SIZE_MODE_E)index);
        MMIAPIDC_TurnOnEngTestMode();
        //success!
       // MMIPUB_OpenAlertSuccessWin(TXT_COMPLETE);
        MMK_CloseWin(win_id);
        break;
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    
    return (result);
}

/*****************************************************************************/
//  Description : HandleDCParamScreenSwitchWinMsg
//  Global resource dependence : 
//  Author: zhaohui
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleDCParamScreenSwitchWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_LISTBOX_CTRL_ID;
    uint16 cur_selection = 0;
    MMI_TEXT_ID_T           text_id_tab[] = {TXT_ENG_DC_ACROSS_SCREEN, TXT_ENG_DC_UPRIGHT_SCREEN};
    int16                   item_total_num = ARR_SIZE(text_id_tab);
    CAMERA_ENG_PREVIEW_MODE_E mode = CAMERA_ENG_PREVIEW_HOR_MODE;
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        GUILIST_SetMaxItem(ctrl_id, item_total_num, FALSE );//max item 3
        GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
        AppendListItem(
            ctrl_id, 
            text_id_tab, 
            item_total_num
            );
        
//#ifndef WIN32
        mode = MMIAPIDC_GetPreviewMode();
        if (CAMERA_ENG_PREVIEW_HOR_MODE == mode)
        {
            cur_selection = 0;
        }   
        else
        {
            cur_selection = 1;
        }
//#endif    
        
        //set selected item
        GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
        //set current item
        GUILIST_SetCurItemIndex(ctrl_id,cur_selection);

        if(DCAMERA_IMG_SENSOR_TYPE_3P4 == MMIAPIDC_GetDCModulSensorTypeById(SETTING_SENSOR_REAR)
            || DCAMERA_IMG_SENSOR_TYPE_3P4 == MMIAPIDC_GetDCModulSensorTypeById(SETTING_SENSOR_FRONT)
            )
        {
            GUILIST_SetItemGray(ctrl_id, 0, TRUE);
            GUILIST_SetItemGray(ctrl_id, 1, TRUE);
        }
            
        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;
        
    case MSG_FULL_PAINT:
        break;
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_KEYDOWN_OK:
        break;      
        
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
        
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_MIDSK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
//#ifndef WIN32
        if (0 == cur_selection)
        {
            mode = CAMERA_ENG_PREVIEW_HOR_MODE;
        }
        else
        {
            mode = CAMERA_ENG_PREVIEW_VER_MODE;
        }
        if (CheckIfDCScreenSwitchPrevSetSupported(mode,MMIAPIDC_GetVisualMode()))/*lint !e64*/
        {
            MMIAPIDC_SetPreviewMode(mode);
//#endif
            MMIAPIDC_TurnOnEngTestMode();
          //  MMIPUB_OpenAlertSuccessWin(TXT_COMPLETE);
            MMK_CloseWin(win_id);
        }
        else
        {
            MMIPUB_OpenAlertFailWin(TXT_FACILITY_NOT_SUPPORTED);
        }
        break;
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    
    return (result);
}

/*****************************************************************************/
//  Description : HandleDCParamScreenPrevSetWinMsg
//  Global resource dependence : 
//  Author: zhaohui
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleDCParamScreenPrevSetWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_LISTBOX_CTRL_ID;
    uint16 cur_selection = 0;
    MMI_TEXT_ID_T           text_id_tab[] = { TXT_ENG_DC_FULL_VIEW,TXT_ENG_DC_FULL_SCREEN };
    int16                   item_total_num = ARR_SIZE(text_id_tab);
    CAMERA_ENG_VISUAL_MODE_E mode = CAMERA_ENG_FULL_VISUAL_ANGLE;
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        GUILIST_SetMaxItem(ctrl_id, item_total_num, FALSE );//max item 3
        GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
        AppendListItem(
            ctrl_id, 
            text_id_tab, 
            item_total_num
            );
        
//#ifndef WIN32
        mode = MMIAPIDC_GetVisualMode();
        if (CAMERA_ENG_FULL_VISUAL_ANGLE == mode)//全视角
        {
            cur_selection = 0;
        }
        else//全屏幕
        {
            cur_selection = 1;
        }
//#endif    
        
        //set selected item
        GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
        //set current item
        GUILIST_SetCurItemIndex(ctrl_id,cur_selection);
        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;
        
    case MSG_FULL_PAINT:
        break;
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_KEYDOWN_OK:
        break;
                
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
        
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_MIDSK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
//#ifndef WIN32
        if (0 == cur_selection)
        {
            mode = CAMERA_ENG_FULL_VISUAL_ANGLE;
        }
        else
        {
            mode = CAMERA_ENG_FULL_SCREEN;
        }
        if (CheckIfDCScreenSwitchPrevSetSupported(MMIAPIDC_GetPreviewMode(),mode))/*lint !e64*/
        {
            MMIAPIDC_SetVisualMode(mode);
//#endif
            MMIAPIDC_TurnOnEngTestMode();
           // MMIPUB_OpenAlertSuccessWin(TXT_COMPLETE);
            MMK_CloseWin(win_id);
        }
        else
        {
            MMIPUB_OpenAlertFailWin(TXT_FACILITY_NOT_SUPPORTED);
        }       
        break;
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    
    return (result);
}

/*****************************************************************************/
//  Description : Handle DCParam Sensor Angle Win Msg
//  Global resource dependence : 
//  Author: robert.wang
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleDCParamSensorAngleWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_LISTBOX_CTRL_ID;
    uint16 cur_selection = 0;
    MMI_TEXT_ID_T           text_id_tab[] =
    { TXT_SENSOR_0,TXT_SENSOR_90,TXT_SENSOR_180,TXT_SENSOR_270,
        TXT_SENSOR_MIRROR,TXT_SENSOR_FLIP
    };
    int16                   item_total_num = ARR_SIZE(text_id_tab);
    DCAMERA_ROTATION_MODE_E     angle = 0;
    static SETTING_SENSOR_ID_E s_dc_sensor_id = 0;
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        s_dc_sensor_id = (uint32)MMK_GetWinAddDataPtr(win_id);/*lint !e64*/

        //SCI_TRACE_LOW:"mmieng HandleDCParamSensorAngleWinMsg s_dc_sensor_id=%d"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_14534_112_2_18_2_18_11_203,(uint8*)"d",s_dc_sensor_id);
        
        GUILIST_SetMaxItem(ctrl_id, item_total_num, FALSE );//max item 3
        GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
        AppendListItem(
            ctrl_id, 
            text_id_tab, 
            item_total_num
            );
            
        angle = MMIAPIDC_GetDCModuleSensorAngle(s_dc_sensor_id);
        switch(angle)
        {
        case DCAMERA_ROTATION_0:
            cur_selection = 0;
            break;
        case DCAMERA_ROTATION_90:
            cur_selection = 1;
            break;
        case DCAMERA_ROTATION_180:
            cur_selection = 2;
            break;
        case DCAMERA_ROTATION_270:
            cur_selection = 3;
            break;
        case DCAMERA_ROTATION_MIRROR:
            cur_selection = 4;
            break;
        case DCAMERA_ROTATION_FLIP:
            cur_selection = 5;
            break;
        default:
            cur_selection = 0;
            break;
        }
        
        //set selected item
        GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
        //set current item
        GUILIST_SetCurItemIndex(ctrl_id,cur_selection);
        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;
        
    case MSG_FULL_PAINT:
        break;
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_KEYDOWN_OK:
        break;
                
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
        
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_MIDSK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
        switch(cur_selection)
        {
        case 0:
            angle = DCAMERA_ROTATION_0;
            break;
        case 1:
            angle = DCAMERA_ROTATION_90;
            break;
        case 2:
            angle = DCAMERA_ROTATION_180;
            break;
        case 3:
            angle = DCAMERA_ROTATION_270;
            break;        
        case 4:
            angle = DCAMERA_ROTATION_MIRROR;
            break;
        case 5:
            angle = DCAMERA_ROTATION_FLIP;
            break;
        default:
            angle = DCAMERA_ROTATION_0;
            break;
        }

        MMIAPIDC_SetDCModuleSensorAngle(angle, s_dc_sensor_id);
        MMIAPIDC_TurnOnEngTestMode();
       // MMIPUB_OpenAlertSuccessWin(TXT_COMPLETE);
        MMK_CloseWin(win_id);
        break;
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    
    return (result);
}

/*****************************************************************************/
//  Description : Handle DCParam Sensor ID Win Msg
//  Global resource dependence : 
//  Author: robert.wang
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleDCParamSensorIDWinMsg(MMI_WIN_ID_T win_id,
                                                          MMI_MESSAGE_ID_E msg_id,
                                                          DPARAM param
                                                          )
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_LISTBOX_CTRL_ID;
    uint16 cur_selection = 0;
    DCAMERA_IMG_SENSOR_TYPE_E sensor_type = 0;
    int32 sensor_number = 0;
    MMI_TEXT_ID_T  text_id_tab[] =
    {
        TXT_POSTPOSITIVE_SENSOR,
        TXT_PREPOSITIVE_SENSOR
    };
    int16 item_total_num = ARR_SIZE(text_id_tab);
    
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        GUILIST_SetMaxItem(ctrl_id, item_total_num, FALSE );//max item 3
        GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
        AppendListItem(
            ctrl_id, 
            text_id_tab, 
            item_total_num
            );
            
        //set selected item
        GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
        //set current item
        GUILIST_SetCurItemIndex(ctrl_id,cur_selection);

        sensor_number = MMIAPIDC_GetDCModuleSensorNumber();
        if (sensor_number == MAX_MMI_SENSOR_NUM)
        {
            sensor_type = MMIAPIDC_GetDCModulSensorTypeById(SETTING_SENSOR_REAR);
            if (DCAMERA_IMG_SENSOR_TYPE_3P4 == sensor_type)
            {
                GUILIST_SetItemGray(ctrl_id, 0, TRUE);
            }
            sensor_type = MMIAPIDC_GetDCModulSensorTypeById(SETTING_SENSOR_FRONT);
            if (DCAMERA_IMG_SENSOR_TYPE_3P4 == sensor_type)
            {
                GUILIST_SetItemGray(ctrl_id, 1, TRUE);
            }
        } 
        else
        {
            sensor_type = MMIAPIDC_GetDCModulSensorTypeById(SETTING_SENSOR_REAR);
            if (DCAMERA_IMG_SENSOR_TYPE_3P4 == sensor_type)
            {
                GUILIST_SetItemGray(ctrl_id, 0, TRUE);
            }
            GUILIST_SetItemGray(ctrl_id, 1, TRUE);
        }
            
        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;
        
    case MSG_FULL_PAINT:
        break;
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_KEYDOWN_OK:
        break;
                
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
        
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_MIDSK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
        MMK_CreateWin((uint32*)MMIENG_DC_PARAM_SENSOR_ANGLE_WIN_TAB, (ADD_DATA)cur_selection);
        MMK_CloseWin(win_id);
        break;
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    
    return (result);
}

#endif

/*****************************************************************************/
//  Description : CheckIfDCScreenSwitchPrevSupported
//  Global resource dependence : 
//  Author: zhaohui
//  Note: 
/*****************************************************************************/
PUBLIC void MMIAPIENG_SaveLastTime(void)
{ 
     SCI_DATE_T  cur_date={0};
     SCI_TIME_T   cur_time={0};
     
     TM_GetSysDate(&cur_date);
     TM_GetSysTime(&cur_time);

     MMINV_WRITE(MMIENG_NV_LAST_DATA_ID, &cur_date);    
     MMINV_WRITE(MMIENG_NV_LAST_TIME_ID, &cur_time);    
}

#ifdef  CAMERA_SUPPORT
/*****************************************************************************/
//  Description : CheckIfDCScreenSwitchPrevSupported
//  Global resource dependence : 
//  Author: zhaohui
//  Note: 
/*****************************************************************************/
LOCAL BOOLEAN CheckIfDCScreenSwitchPrevSetSupported(
                                                CAMERA_ENG_VISUAL_MODE_E switch_mode,
                                                CAMERA_ENG_PREVIEW_MODE_E prev_mode
                                                )
{
    BOOLEAN     result = TRUE;

#ifdef MAINLCD_SIZE_240X400
    #if defined (PLATFORM_SC6600L) || defined (PLATFORM_SC6600R)
        if ((CAMERA_ENG_PREVIEW_HOR_MODE ==prev_mode)
            && (CAMERA_ENG_FULL_VISUAL_ANGLE == switch_mode))//wqvga版本,6600R,6600L不支持横屏全视角 
        {
            result = FALSE;
        }   
    #endif
#else
    #ifdef PLATFORM_SC6600R
        if ((CAMERA_ENG_PREVIEW_VER_MODE ==prev_mode)
            && (CAMERA_ENG_FULL_VISUAL_ANGLE == switch_mode))//6600R不支持竖屏全视角 
        {
            result = FALSE;
        }
    #endif
#endif

    return result;
}
#endif
/*****************************************************************************/
//  Description : MMIAPIENG_OpenUserAgentWin
//  Global resource dependence : 
//  Author: li.li
//  Note: 
/*****************************************************************************/
PUBLIC void MMIAPIENG_OpenUserAgentWin(void)
{
    MMK_CreateWin((uint32*)MMIENG_UA_AGENT_WIN_TAB, PNULL);
}
/*****************************************************************************/
//  Description : MMIAPIENG_OpenUaProfileWin
//  Global resource dependence : 
//  Author: li.li
//  Note: 
/*****************************************************************************/
PUBLIC void MMIAPIENG_OpenUaProfileWin(void)
{
    MMK_CreateWin((uint32*)MMIENG_UA_PROFILE_WIN_TAB, PNULL);
}
/*****************************************************************************/
//  Description : EngUaAgentOnOffWinHandleMsg
//  Global resource dependence : 
//  Author: fen.xie
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E EngUaAgentOnOffWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{    
    int32 index = 0;
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    int32 list_id = MMIENG_LISTBOX_CTRL_ID ;
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        {
            GUILIST_ITEM_T      item_t = {0};
            GUILIST_ITEM_DATA_T item_data = {0};    
            
            GUIWIN_SetTitleTextId(win_id, TXT_ENG_UA_AGENT, FALSE);
            GUILIST_SetMaxItem( list_id, 2, FALSE );
            GUILIST_SetOwnSofterKey(list_id,FALSE);
            
            item_t.item_style    = GUIITEM_STYLE_1RADIO_ENG;
            item_t.item_data_ptr = &item_data;
            
            item_data.item_content[0].item_data_type    = GUIITEM_DATA_TEXT_ID;    
            
            item_data.item_content[0].item_data.text_id = TXT_OPEN_COMN;    
            GUILIST_AppendItem( list_id, &item_t );
            item_data.item_content[0].item_data.text_id = TXT_COMM_CLOSE;    
            GUILIST_AppendItem( list_id, &item_t );                      

            index = (MMIENG_GetUserAgentIsUse())? 0: 1;
            GUILIST_SetSelectedItem( list_id,index, TRUE );
            GUILIST_SetCurItemIndex( list_id, index);          
            MMK_SetAtvCtrl(win_id, list_id);
        }
        break;

    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
        
    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        index = GUILIST_GetCurItemIndex(list_id);    
        MMIENG_SetUserAgentIsUse((0 == index)? TRUE: FALSE);
        MMK_CloseWin(win_id);
        break;
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);    
}

/*****************************************************************************/
//  Description : HandleUaAgentWinMsg
//  Global resource dependence : 
//  Author: fen.xie
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleUaAgentWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    uint32 group_id = 0;
    uint32 menu_id = 0;
    MMI_CTRL_ID_T ctrl_id = MMIENG_UA_SUB_MENU_CTRL_ID;
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
    {
        MMI_STRING_T title_string = {0};
        CTRLMENU_SetSecMenuFontSize(MMIENG_UA_SUB_MENU_CTRL_ID,MMIENG_MENU_ITEM_FONT,MMIENG_MENU_ITEM_FONT);
        CTRLMENU_SetSecMenuItemHeight(MMIENG_UA_SUB_MENU_CTRL_ID,MMIENG_MENU_ITEM_HEIGHT,MMIENG_MENU_ITEM_HEIGHT);
        CTRLMENU_SetFontColor(MMIENG_UA_SUB_MENU_CTRL_ID,MMI_WHITE_COLOR);

        GUIWIN_SetSoftkeyTextId(win_id,  TXT_ENG_OK, TXT_NULL, TXT_ENG_RETURN, FALSE);
        MMI_GetLabelTextByLang(TXT_ENG_UA_AGENT, &title_string);
        GUIMENU_SetMenuTitle(&title_string, ctrl_id);
        MMK_SetAtvCtrl(win_id, ctrl_id);
    }
        break;
			
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;

#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_MIDSK:
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB: 
        GUIMENU_GetId(MMIENG_UA_SUB_MENU_CTRL_ID, &group_id, &menu_id);
        switch (menu_id)
        {
        case ID_ENG_UA_SET_ONOFF:
#ifdef ENG_SUPPORT
            MMIENG_OpenListSelectWin((uint32)EngUaAgentOnOffWinHandleMsg);
#endif
            break;
            
        case ID_ENG_UA_SET:
            MMK_CreateWin((uint32*)MMIENG_UA_AGENT_SET_WIN_TAB, PNULL);
            break;
            
        case ID_ENG_UA_SET_SHOW:
            MMK_CreateWin((uint32*)MMIENG_UA_AGENT_SHOW_WIN_TAB, PNULL);
            break;
            
        default:
            break;
        }
        break;

    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}
/*****************************************************************************/
//  Description : HandleUaAgentWinMsg
//  Global resource dependence : 
//  Author: fen.xie
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleUaAgentSetWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_UA_SELECT_LISTBOX_CTRL_ID;
    uint16 cur_selection = 0;
    BOOLEAN is_use_list = FALSE;

    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
    {
        MMI_TEXT_ID_T   text_id_tab[] = {TXT_ENG_UA_LIST,TXT_ENG_UA_EDIT };
        uint16  item_total_num = ARR_SIZE(text_id_tab);
        
        GUILIST_SetMaxItem(ctrl_id, item_total_num, FALSE );//max item 3
        GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
        AppendListItem(ctrl_id, text_id_tab, item_total_num);
        is_use_list = MMIENG_GetUserAgentIsUseList();
        cur_selection = (is_use_list)? 0: 1;
        GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
        GUILIST_SetCurItemIndex(ctrl_id,cur_selection);
        MMK_SetAtvCtrl(win_id,ctrl_id);
    }
        break;
        
    case MSG_FULL_PAINT:
        break;
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_KEYDOWN_OK:
        break;
                
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
        
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_MIDSK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
        if (0 == cur_selection)
        {
            is_use_list = TRUE;
            MMK_CreateWin((uint32*)MMIENG_UA_AGENT_LIST_WIN_TAB, PNULL);
        }
        else
        {
            is_use_list = FALSE;
            MMK_CreateWin((uint32*)MMIENG_UA_AGENT_EDIT_WIN_TAB, PNULL);
        }
        MMIENG_SetUserAgentIsUseList(is_use_list);
        MMK_CloseWin(win_id);
        break;
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    
    return (result);
}

/*****************************************************************************/
//  Description : HandleUaAgentListWinMsg
//  Global resource dependence : 
//  Author: fen.xie
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleUaAgentListWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_UA_SELECT_LIST_NUM_CTRL_ID;
    uint32                 list_num = 0;

    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
    {
        MMI_TEXT_ID_T   text_id_tab[] = 
                {
                TXT_ENG_UA_NONE ,
                TXT_ENG_UA_DORADO,
                TXT_ENG_UA_MTK,
                TXT_ENG_UA_09A,
                TXT_ENG_UA_NOKIA,
                TXT_ENG_UA_NF
                };
        uint16  item_total_num = ARR_SIZE(text_id_tab);
    
        GUILIST_SetMaxItem(ctrl_id, item_total_num, FALSE );//max item 3
        GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
        AppendListItem(ctrl_id, text_id_tab, item_total_num);
        list_num = MMIENG_GetUserAgentListNum();
        GUILIST_SetSelectedItem(ctrl_id, list_num, TRUE);
        GUILIST_SetCurItemIndex(ctrl_id,list_num);
        MMK_SetAtvCtrl(win_id,ctrl_id);
    }
        break;
        
    case MSG_FULL_PAINT:
        break;
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_KEYDOWN_OK:
        break;
                
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
        
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_MIDSK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
    {
        MMIENG_UA_T     ua_set={0};

        list_num = GUILIST_GetCurItemIndex(ctrl_id);
        MMIENG_SetUserAgentListNum(list_num);
        SCI_MEMSET(&ua_set,0,sizeof(MMIENG_UA_T));
        MMIENG_GetUa(&ua_set);
        SCI_MEMSET(ua_set.user_agent,0,MMIENG_MAX_URL_LEN);
        switch(list_num) 
        {
        case 1:
            strncpy((char *)ua_set.user_agent,MMIENG_USER_AGENT_DORADO,MIN(MMIENG_MAX_URL_LEN,strlen(MMIENG_USER_AGENT_DORADO)));   /*lint !e666*/
            break;
        case 2:
            strncpy((char *)ua_set.user_agent,MMIENG_USER_AGENT_MTK,MIN(MMIENG_MAX_URL_LEN,strlen(MMIENG_USER_AGENT_MTK)));         /*lint !e666*/
            break;
        case 3:
            strncpy((char *)ua_set.user_agent,MMIENG_USER_AGENT_09A,MIN(MMIENG_MAX_URL_LEN,strlen(MMIENG_USER_AGENT_09A)));         /*lint !e666*/
            break;
        case 4:
            strncpy((char *)ua_set.user_agent,MMIENG_USER_AGENT_NOKIA,MIN(MMIENG_MAX_URL_LEN,strlen(MMIENG_USER_AGENT_NOKIA)));     /*lint !e666*/
            break;
        case 5:
            strncpy((char *)ua_set.user_agent,MMIENG_USER_AGENT_NF,MIN(MMIENG_MAX_URL_LEN,strlen(MMIENG_USER_AGENT_NF)));           /*lint !e666*/
            break;
        default:
            break;
        }
        MMIENG_SetUa(&ua_set);
        MMK_CloseWin(win_id);
    }
        break;
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    
    return (result);
}
/*****************************************************************************/
//  Description : HandleUaAgentShowWinMsg
//  Global resource dependence : 
//  Author: fen.xie
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleUaAgentShowWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;  
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:   
    {
        wchar wstr[1024] = {0};
        MMIENG_UA_T     ua_set={0};
        uint32 length = 0; 
        char    *ua_user_agent_ptr = PNULL;

        MMIENG_GetUa(&ua_set);
        length = SCI_STRLEN((char *)ua_set.user_agent);
        if (MMIENG_GetUserAgentIsUse() && (length > 0))//use the eng's user_agent
        {
            ua_user_agent_ptr = (char *)ua_set.user_agent;
        }
        else//use the default
        {
            ua_user_agent_ptr = MMIAPICOM_GetUserAgent();
            length = SCI_STRLEN(ua_user_agent_ptr);
        }
        
        if (length > 0)
        {
            MMI_STRNTOWSTR(wstr, 1023, 
                (uint8*)ua_user_agent_ptr, length, 
                MIN(length, 1023));
                
            GUITEXT_SetString(MMIENG_TEXTBOX1_CTRL_ID, wstr, length, FALSE);           
        }

        MMK_SetAtvCtrl(win_id,MMIENG_TEXTBOX1_CTRL_ID);
    }
        break;
        
    case MSG_CTL_MIDSK:     
    case MSG_CTL_OK:
    case MSG_CTL_CANCEL:    
    case MSG_KEYDOWN_OK:        
    case MSG_KEYDOWN_CANCEL:
    case MSG_APP_WEB:
        MMK_CloseWin(win_id);
        break;
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}
/*****************************************************************************/
//  Description : EngUaProfileOnOffWinHandleMsg
//  Global resource dependence : 
//  Author: fen.xie
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E EngUaProfileOnOffWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{    
    int32 index = 0;
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    int32 list_id = MMIENG_LISTBOX_CTRL_ID ;
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        {
            GUILIST_ITEM_T      item_t = {0};
            GUILIST_ITEM_DATA_T item_data = {0};    
            
            GUIWIN_SetTitleTextId(win_id, TXT_ENG_UA_PROFILE, FALSE);
            GUILIST_SetMaxItem( list_id, 2, FALSE );
            GUILIST_SetOwnSofterKey(list_id,FALSE);
            
            item_t.item_style    = GUIITEM_STYLE_1RADIO_ENG;
            item_t.item_data_ptr = &item_data;
            
            item_data.item_content[0].item_data_type    = GUIITEM_DATA_TEXT_ID;    
            
            item_data.item_content[0].item_data.text_id = TXT_OPEN_COMN;    
            GUILIST_AppendItem( list_id, &item_t );
            item_data.item_content[0].item_data.text_id = TXT_COMM_CLOSE;    
            GUILIST_AppendItem( list_id, &item_t );                      

            index = (MMIENG_GetUaProfileIsUse())? 0: 1;
            GUILIST_SetSelectedItem( list_id,index, TRUE );
            GUILIST_SetCurItemIndex( list_id, index);          
            MMK_SetAtvCtrl(win_id, list_id);
        }
        break;

    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
        
    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        index = GUILIST_GetCurItemIndex(list_id);    
        MMIENG_SetUaProfileIsUse((0 == index)? TRUE: FALSE);
        MMK_CloseWin(win_id);
        break;
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);    
}

/*****************************************************************************/
//  Description : HandleUaProfileShowWinMsg
//  Global resource dependence : 
//  Author: fen.xie
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleUaProfileShowWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;  
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:   
    {
        wchar wstr[1024] = {0};
        MMIENG_UA_T     ua_set={0};
        uint32 length = 0; 
        char    *ua_profile_ptr = PNULL;

        MMIENG_GetUa(&ua_set);
        length = SCI_STRLEN((char *)ua_set.uaprofile);
        if (MMIENG_GetUaProfileIsUse() && (length > 0))//use the eng's ua profile
        {
            ua_profile_ptr = (char *)ua_set.uaprofile;
        }
        else//use the default
        {
            ua_profile_ptr = MMIAPICOM_GetUserAgentProfile();
            length = SCI_STRLEN(ua_profile_ptr);
        }
        
        if (length > 0)
        {
            MMI_STRNTOWSTR(wstr, 1023, 
                (uint8*)ua_profile_ptr, length, 
                MIN(length, 1023));
                
            GUITEXT_SetString(MMIENG_TEXTBOX1_CTRL_ID, wstr, length, FALSE);           
        }

        MMK_SetAtvCtrl(win_id,MMIENG_TEXTBOX1_CTRL_ID);
    }
        break;
        
    case MSG_CTL_MIDSK:     
    case MSG_CTL_OK:
    case MSG_CTL_CANCEL:    
    case MSG_KEYDOWN_OK:        
    case MSG_KEYDOWN_CANCEL:
    case MSG_APP_WEB:
        MMK_CloseWin(win_id);
        break;
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}


/*****************************************************************************/
//  Description : HandleUaProfileWinMsg
//  Global resource dependence : 
//  Author: fen.xie
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleUaProfileWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    uint32 group_id = 0;
    uint32 menu_id = 0;
    MMI_CTRL_ID_T ctrl_id = MMIENG_UA_SUB_MENU_CTRL_ID;
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
    {
        MMI_STRING_T title_string = {0};
        CTRLMENU_SetSecMenuFontSize(MMIENG_UA_SUB_MENU_CTRL_ID,MMIENG_MENU_ITEM_FONT,MMIENG_MENU_ITEM_FONT);
        CTRLMENU_SetSecMenuItemHeight(MMIENG_UA_SUB_MENU_CTRL_ID,MMIENG_MENU_ITEM_HEIGHT,MMIENG_MENU_ITEM_HEIGHT);
        CTRLMENU_SetFontColor(MMIENG_UA_SUB_MENU_CTRL_ID,MMI_WHITE_COLOR);

        GUIWIN_SetSoftkeyTextId(win_id,  TXT_ENG_OK, TXT_NULL, TXT_ENG_RETURN, FALSE);
        MMI_GetLabelTextByLang(TXT_ENG_UA_PROFILE, &title_string);
        GUIMENU_SetMenuTitle(&title_string, ctrl_id);
        MMK_SetAtvCtrl(win_id, ctrl_id);
    }
        break;
			
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;

#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_MIDSK:
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB: 
        GUIMENU_GetId(MMIENG_UA_SUB_MENU_CTRL_ID, &group_id, &menu_id);
        switch (menu_id)
        {
        case ID_ENG_UA_SET_ONOFF:
#ifdef ENG_SUPPORT
            MMIENG_OpenListSelectWin((uint32)EngUaProfileOnOffWinHandleMsg);
#endif
            break;
            
        case ID_ENG_UA_SET:
            MMK_CreateWin((uint32*)MMIENG_UA_PROFILE_SET_WIN_TAB, PNULL);
            break;
            
        case ID_ENG_UA_SET_SHOW:
            MMK_CreateWin((uint32*)MMIENG_UA_PROFILE_SHOW_WIN_TAB, PNULL);
            break;
            
        default:
            break;
        }
        break;

    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

/*****************************************************************************/
//  Description : HandleUaProfileSetWinMsg
//  Global resource dependence : 
//  Author: fen.xie
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleUaProfileSetWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_PROFILE_SELECT_LISTBOX_CTRL_ID;
    uint16 cur_selection = 0;
    BOOLEAN is_use_list = FALSE;

    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
    {
        MMI_TEXT_ID_T           text_id_tab[] = { TXT_ENG_UA_LIST,TXT_ENG_UA_EDIT };
        uint16  item_total_num = ARR_SIZE(text_id_tab);
        
        GUILIST_SetMaxItem(ctrl_id, item_total_num, FALSE );//max item 3
        GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
        AppendListItem(ctrl_id, text_id_tab, item_total_num);
        is_use_list = MMIENG_GetUaProfileIsUseList();
        cur_selection = (is_use_list)? 0: 1;
        GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
        GUILIST_SetCurItemIndex(ctrl_id,cur_selection);
        MMK_SetAtvCtrl(win_id,ctrl_id);
    }
        break;
        
    case MSG_FULL_PAINT:
        break;
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_KEYDOWN_OK:
        break;
                
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
        
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_MIDSK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
        if (0 == cur_selection)
        {
            is_use_list = TRUE;
            MMK_CreateWin((uint32*)MMIENG_UA_PROFILE_LIST_WIN_TAB, PNULL);
        }
        else
        {
            is_use_list = FALSE;
            MMK_CreateWin((uint32*)MMIENG_UA_PROFILE_EDIT_WIN_TAB, PNULL);
        }
        MMIENG_SetUaProfileIsUseList(is_use_list);
        MMK_CloseWin(win_id);
        break;
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    
    return (result);
}


/*****************************************************************************/
//  Description : HandleUaProfileListWinMsg
//  Global resource dependence : 
//  Author: fen.xie
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleUaProfileListWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_PROFILE_SELECT_LIST_NUM_CTRL_ID;
    uint32                 list_num = 0;

    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
    {
        MMI_TEXT_ID_T   text_id_tab[] = {TXT_ENG_UA_NONE, TXT_ENG_PROFILE_SONYERICSSON,TXT_ENG_PROFILE_NOKIA};
        uint16  item_total_num = ARR_SIZE(text_id_tab);
        
        GUILIST_SetMaxItem(ctrl_id, item_total_num, FALSE );//max item 3
        GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
        AppendListItem(ctrl_id, text_id_tab, item_total_num);
        
        list_num = MMIENG_GetUaProfileListNum();
        GUILIST_SetSelectedItem(ctrl_id, list_num, TRUE);
        GUILIST_SetCurItemIndex(ctrl_id,list_num);
        MMK_SetAtvCtrl(win_id,ctrl_id);
    }
        break;
        
    case MSG_FULL_PAINT:
        break;
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_KEYDOWN_OK:
        break;
                
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
        
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_MIDSK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
    {
        MMIENG_UA_T     ua_set={0};
        
        list_num = GUILIST_GetCurItemIndex(ctrl_id);
        MMIENG_SetUaProfileListNum(list_num);
        SCI_MEMSET(&ua_set,0,sizeof(MMIENG_UA_T));
        MMIENG_GetUa(&ua_set);
        SCI_MEMSET(ua_set.uaprofile,0,MMIENG_MAX_URL_LEN);
        switch(list_num) 
        {
        case 1:
            strncpy((char *)ua_set.uaprofile,MMIENG_UA_PROFILE_SONYERICSSION,MIN(MMIENG_MAX_URL_LEN,strlen(MMIENG_UA_PROFILE_SONYERICSSION)));/*lint !e666*/
            break;
            
        case 2:
            strncpy((char *)ua_set.uaprofile,MMIENG_UA_PROFILE_NOKIA,MIN(MMIENG_MAX_URL_LEN,strlen(MMIENG_UA_PROFILE_NOKIA)));/*lint !e666*/
            break;
            
        default:
            break;
        }
              
        MMIENG_SetUa(&ua_set);
        MMK_CloseWin(win_id);
    }
        break;
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    
    return (result);
}
/*****************************************************************************/
//  Description : HandleUaAgentEditWinMsg
//  Global resource dependence : 
//  Author: fen.xie
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleUaAgentEditWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_CTRL_ID_T       editbox_ctrl_id = MMIENG_UAAGENT_CTRL_ID;
    MMI_RESULT_E        result = MMI_RESULT_TRUE;

    switch (msg_id)
    {
    case MSG_OPEN_WINDOW:
     {
        wchar wstr[MMIENG_MAX_URL_LEN + 1] = {0};
        uint16  ua_len = 0;
        MMIENG_UA_T ua = {0};

       //set im
        GUIEDIT_SetIm(editbox_ctrl_id, GUIIM_TYPE_ENGLISH|GUIIM_TYPE_ABC|GUIIM_TYPE_DIGITAL, GUIIM_TYPE_ENGLISH);/*lint !e655*/
        SCI_MEMSET(&ua,0,sizeof(MMIENG_UA_T));
        MMIENG_GetUa(&ua);
        ua_len=strlen((char *)(ua.user_agent));
        if (ua_len > 0)
        {
            MMI_STRNTOWSTR( wstr, MMIENG_MAX_URL_LEN, ua.user_agent, ua_len, ua_len );
            GUIEDIT_SetString(editbox_ctrl_id,wstr,ua_len);
        }
        MMK_SetAtvCtrl(win_id,editbox_ctrl_id);
    }
        break;
#ifdef MMI_PDA_SUPPORT
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
     case MSG_CTL_PENOK:
        if (PNULL != param)
        {
            uint32 src_id = ((MMI_NOTIFY_T*)param)->src_id;
        
            switch (src_id)
            {
            case MMICOMMON_BUTTON_SOFTKEY_LEFT_CTRL_ID:
                MMK_SendMsg(win_id, MSG_APP_OK, PNULL);
                break;
            case MMICOMMON_BUTTON_SOFTKEY_RIGHT_CTRL_ID:
                MMK_SendMsg(win_id, MSG_APP_CANCEL, PNULL);
                break;
            default:
                break;
            }
        }
        break;
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
#endif
    case MSG_APP_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
        
    case MSG_CTL_MIDSK:
    case MSG_APP_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
    {
        MMI_STRING_T string_info = {0};
        MMIENG_UA_T ua = {0};
        //save to nv
        SCI_MEMSET(&string_info,0,sizeof(MMI_STRING_T));
        GUIEDIT_GetString(editbox_ctrl_id,&string_info);
        SCI_MEMSET(ua.user_agent,0,MMIENG_MAX_URL_LEN);
        MMI_WSTRNTOSTR(ua.user_agent, MMIENG_MAX_URL_LEN, string_info.wstr_ptr, string_info.wstr_len, string_info.wstr_len );

        MMIENG_SetUa(&ua);
        MMK_CloseWin(win_id);
    }
        break;

    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

/*****************************************************************************/
//  Description : HandleUaProfileEditWinMsg
//  Global resource dependence : 
//  Author: fen.xie
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleUaProfileEditWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_CTRL_ID_T       editbox_ctrl_id = MMIENG_UAPROFILE_CTRL_ID;
    MMI_RESULT_E        result = MMI_RESULT_TRUE;

    switch (msg_id)
    {
    case MSG_OPEN_WINDOW:
    {
        wchar wstr[MMIENG_MAX_URL_LEN + 1] = {0};
        uint16  ua_len = 0;
        MMIENG_UA_T ua = {0};
        
        //set im
        GUIEDIT_SetIm(editbox_ctrl_id,GUIIM_TYPE_ENGLISH|GUIIM_TYPE_ABC|GUIIM_TYPE_DIGITAL, GUIIM_TYPE_ENGLISH);/*lint !e655*/
        SCI_MEMSET(&ua,0,sizeof(MMIENG_UA_T));
        MMIENG_GetUa(&ua);
        ua_len = strlen((char *)(ua.uaprofile));
        if (ua_len > 0)
        {
            MMI_STRNTOWSTR( wstr, MMIENG_MAX_URL_LEN, ua.uaprofile, ua_len, ua_len );
            GUIEDIT_SetString(editbox_ctrl_id,wstr,ua_len);
        }
        MMK_SetAtvCtrl(win_id,editbox_ctrl_id);
    }
        break;
#ifdef MMI_PDA_SUPPORT
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
     case MSG_CTL_PENOK:
        if (PNULL != param)
        {
            uint32 src_id = ((MMI_NOTIFY_T*)param)->src_id;
        
            switch (src_id)
            {
            case MMICOMMON_BUTTON_SOFTKEY_LEFT_CTRL_ID:
                MMK_SendMsg(win_id, MSG_APP_OK, PNULL);
                break;
            case MMICOMMON_BUTTON_SOFTKEY_RIGHT_CTRL_ID:
                MMK_SendMsg(win_id, MSG_APP_CANCEL, PNULL);
                break;
            default:
                break;
            }
        }
        break;
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
#endif
    case MSG_APP_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
        
    case MSG_CTL_MIDSK:
    case MSG_APP_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
    {
        MMI_STRING_T string_info = {0};
        MMIENG_UA_T ua = {0};
        
        //save to nv
        SCI_MEMSET(&string_info,0,sizeof(MMI_STRING_T));
        GUIEDIT_GetString(editbox_ctrl_id,&string_info);
        SCI_MEMSET(ua.uaprofile,0,MMIENG_MAX_URL_LEN);
        MMI_WSTRNTOSTR( ua.uaprofile, MMIENG_MAX_URL_LEN, string_info.wstr_ptr, string_info.wstr_len, string_info.wstr_len );
              
        MMIENG_SetUa(&ua);
        MMK_CloseWin(win_id);
    }
        break;

    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}
#ifdef ENGTD_SUPPORT
/********************************************************************************
 NAME:          GetNCNetInfoStr
 DESCRIPTION:   
 PARAM IN:      net_buf - 
                buf_len - 
 PARAM OUT:     net info string len
 AUTHOR:        allen
 DATE:          2004.09.08
********************************************************************************/
LOCAL int GetTDNCNetInfoStr(uint8* net_buf, uint16 buf_len)
{
    LAYER1_TD_NCELL_ARR_T    ncell = {0};

    uint8 digit_buf1[19] = {0};
    uint8 digit_buf2[19] = {0};
    uint8 digit_buf3[19] = {0};
    int i = 0;
    int len1 = 0, len2 = 0,len3=0;
    int offset = 0;
    
    if(PNULL == net_buf)
    {
        //SCI_TRACE_LOW:"mmieng_win.c GetTDNCNetInfoStr net_buf == null"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_15604_112_2_18_2_18_13_204,(uint8*)"");
        return -1;
    }    
    //SCI_TRACE_LOW:"mmieng_win.c GetTDNCNetInfoStr buf_len is %d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_15607_112_2_18_2_18_13_205,(uint8*)"d",buf_len);
    if(2 > buf_len)
    {
        return -2;
    }

    
#ifndef _WIN32  
    ncell=LAYER1_GetLayer1TDNcellList();
#endif
    for (i = 0; i < MAX_TD_NCELL_REPORT_NUM; i++)
    {
        // order
        MMIAPICOM_Int2Str(i + 1, digit_buf1, 18);       //( i + 1)   is the No. of NCELL
        len1 = SCI_STRLEN((char*)digit_buf1);
        if(buf_len - offset <  18)
        {
            return offset;
        } 
        MMI_MEMCPY(net_buf + offset, buf_len - offset, digit_buf1, 18, len1);
        offset += len1;
        
        if(buf_len - offset <  2)
        {
            return offset;
        } 
        MMI_MEMCPY(net_buf + offset, buf_len - offset, ". ", 2, 2);
        offset += 2;
        MMIAPICOM_Int2Str((uint32)ncell.td_ncell[i].arfcn, digit_buf1, 18);
        MMIAPICOM_Int2Str((uint32)ncell.td_ncell[i].cell_id, digit_buf2, 18);
        MMIENG_Int2Str((int16)ncell.td_ncell[i].rscp, digit_buf3, 18);
        
        len1 = SCI_STRLEN((char*)digit_buf1);
        if(buf_len - offset <  len1)
        {
            return offset;
        } 
        MMI_MEMCPY(net_buf + offset, buf_len - offset, digit_buf1, 18, len1);
        offset += len1;
        len2 = SCI_STRLEN((char*)digit_buf2);
        if (len1 + len2 + 1 <= ENG_WIN_MAX_CHAR)
        {
            if(buf_len - offset <  1)
            {
                return offset;
            } 
            MMI_MEMCPY(net_buf + offset, buf_len - offset,  ",", 1, 1);
            offset += 1;
            
            if(buf_len - offset <  len2 )
            {
                return offset;
            } 
            MMI_MEMCPY(net_buf + offset, buf_len - offset, digit_buf2, 18, len2);
            offset += len2;
        }
        len3 = SCI_STRLEN((char*)digit_buf3);
        if (len1 + len2+len3 + 1 <= ENG_WIN_MAX_CHAR)
        {
            if(buf_len - offset <  1 )
            {
                return offset;
            } 
            MMI_MEMCPY(net_buf + offset, buf_len - offset,  ",", 1, 1);
            offset += 1;
            
            if(buf_len - offset <  len3 )
            {
                return offset;
            } 
            MMI_MEMCPY(net_buf + offset, buf_len - offset, digit_buf3, 18, len3);
            offset += len3;
        }
        
        if(buf_len - offset < 1)
        {
            return offset;
        }        
        net_buf[offset] = CR_CHAR;
        offset += 1;
    }
    
    
    return (offset);
}
#endif

/********************************************************************************
 NAME:          Int2Str
 DESCRIPTION:   
 PARAM IN:      value - 
                buf - 
                buf_len - 
 PARAM OUT:     None
 AUTHOR:        allen
 DATE:          2004.09.14
********************************************************************************/
PUBLIC void MMIENG_Int2Str(int16 value, uint8* buf, uint16 buf_len)
{
    int32 i = 0, j = 0;
    int32 semi_len = 0;
    int32 offset = 0;
    uint8 tmp_chr = 0x00;
    BOOLEAN is_abs=FALSE;
 
    if(PNULL == buf)
    {
        //SCI_TRACE_LOW:"mmieng_win.c MMIENG_Int2Str buf == null"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_15713_112_2_18_2_18_13_206,(uint8*)"");
        return ;
    }    
    //SCI_TRACE_LOW:"mmieng_win.c MMIENG_Int2Str buf_len is %d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_15716_112_2_18_2_18_13_207,(uint8*)"d",buf_len);
    if(2 > buf_len)
    {
        return ;
    }
    
    if (value == 0)
    {
        buf[i] = (uint8)(0 + '0');
        buf[i + 1] = 0;
        return;
    }
    if(value&0x8000)
    {
        is_abs=TRUE;
        value=(int16)(~((uint16)value-1));  /*lint !e502*/
        
    }
    while (value != 0)
    {
        buf[i] = (uint8)((value % 10) + '0');   /*lint !e502*/
        value /= 10;
        i++;
        if (i >= buf_len)
            break;
    }
    if(is_abs)
    {
        buf[i++]='-';
    }
    if (i < buf_len)
        buf[i] = 0;
    semi_len = i / 2;
    offset = i % 2 - 1;
    for (j = 0; j < semi_len; j++)
    {
        tmp_chr = buf[j];
        buf[j] = buf[2 * semi_len + offset - j];
        buf[2 * semi_len + offset - j] = tmp_chr;
    }
}
/********************************************************************************
 NAME:          MMIENGWIN_OpenAudioSetWin
 DESCRIPTION:   
 PARAM IN:      
 PARAM OUT:     None
 AUTHOR:        ying.xu
 DATE:          2010.06.21
********************************************************************************/

PUBLIC BOOLEAN MMIENGWIN_OpenAudioSetWin(uint32 menuid)
{
    MMK_CreateWin((uint32*)MMIENG_AUDIOSET_WIN_TAB,(ADD_DATA)menuid);
    return TRUE;
}   
/********************************************************************************
 NAME:          MMIENGWIN_SetMMITestBit
 DESCRIPTION:   
 PARAM IN:      
 PARAM OUT:     None
 AUTHOR:        ying.xu
 DATE:          2010.08.17
********************************************************************************/
PUBLIC uint32  MMIENGWIN_SetMMITestBit(uint32 result)
{

    uint32 adc_reserved_info = 0;
        //从NV中读取adc_reserved[7]的信息
#ifdef WIN32    
    adc_reserved_info = 0xc3fe0155;/*lint !e64*/
#else
    adc_reserved_info = REFPARAM_GetCaliMarkerValue();
    //SCI_TRACE_LOW:"GetAdcCalibrateInfoStr %x"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_15786_112_2_18_2_18_13_208,(uint8*)"d",adc_reserved_info);
#endif

    adc_reserved_info &= ~ (0x00000001 << 27) ;
    adc_reserved_info |=  (result&0x01) << 27;
    return REFPARAM_SetCaliMarkerValue(adc_reserved_info) ; 
}   

#ifdef MMI_AUTOTEST_SUPPORT
/*****************************************************************************/
//  Description : HandleAutoTestSetWinMsg
//  Global resource dependence : 
//  Author: 
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleAutoTestSetWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_LISTBOX_CTRL_ID;
    uint16 cur_selection = 0;
    uint8  *at_set_ptr = (uint8*)MMK_GetWinAddDataPtr(win_id);
    uint32 at_string[] = {TXT_ENG_AT_ALL_SET,TXT_ENG_AT_IMAGE_ID,TXT_ENG_AT_TEXT,TXT_ENG_AT_WIN_MSG, TXT_ENG_AT_TP, TXT_ENG_AT_KEY,TXT_ENG_AT_MSG,
                          TXT_ENG_AT_SOFTKEY,TXT_ENG_AT_TITLE,TXT_ENG_AT_POINTER_STATE,TXT_ENG_AT_BACKLIGHT};// @CR247145 renwei modify
  
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        GUILIST_SetMaxItem(ctrl_id,MMISET_OPEN_CLOSE_ITEM, FALSE );//max item 2
        //GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
        MMIAPISET_AppendListItemByTextIdExt(TXT_OPEN_COMN,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
        MMIAPISET_AppendListItemByTextIdExt(TXT_COMM_CLOSE,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);  
        
        if (MMI_GetAtSetValue(*at_set_ptr))
        {
            cur_selection = 0;
        }
        else
        {
            cur_selection = 1;
        }
        
        //set selected item
        GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
        
        //set current item
        GUILIST_SetCurItemIndex(ctrl_id,cur_selection);
        MMK_SetAtvCtrl(win_id,ctrl_id);

        GUIWIN_SetTitleTextId(win_id, at_string[*at_set_ptr], FALSE);        
        break; 
        
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
        
    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        {
            /*, @CR247145 renwei modify begin*/ 
            cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
            
            if(MMI_AUTO_TEST_ALL_SET == *at_set_ptr)
            {
                if (1 == cur_selection) //close
                {
                    MMI_SetAllAtValue(FALSE);
                }
                else
                {
                    MMI_SetAllAtValue(TRUE);
                }
            }
            else
            {
                
                if (1 == cur_selection) //close
                {
                    MMI_SetAtValue(*at_set_ptr, FALSE);
                }
                else
                {
                    MMI_SetAtValue(*at_set_ptr, TRUE);        
                }
            }
            
            /*, @CR247145 renwei modify end*/ 
            MMK_CloseWin(win_id);
            break;
        }
                
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}
#endif

#ifdef MMI_WIFI_SUPPORT
LOCAL MMI_RESULT_E HandleWlanPerformanceModeWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_LISTBOX_CTRL_ID;
    uint16 cur_selection = 0;
  
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        GUILIST_SetMaxItem(ctrl_id, MMISET_OPEN_CLOSE_ITEM, FALSE);//max item 2
        MMIAPISET_AppendListItemByTextIdExt(TXT_OPEN_COMN,  TXT_ENG_OK, TXT_NULL, TXT_ENG_RETURN, ctrl_id, GUIITEM_STYLE_1RADIO_ENG);
        MMIAPISET_AppendListItemByTextIdExt(TXT_COMM_CLOSE, TXT_ENG_OK, TXT_NULL, TXT_ENG_RETURN, ctrl_id, GUIITEM_STYLE_1RADIO_ENG);  
        
        if (WIFISUPP_LOG_ON == WIFISUPP_GetLogSwitch())
        {
            cur_selection = 1;
        }
        else
        {
            cur_selection = 0;
        }
        
        //set selected item
        GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
        GUILIST_SetCurItemIndex(ctrl_id, cur_selection);
        
        MMK_SetAtvCtrl(win_id, ctrl_id);
        break; 
        
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
        
    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
        if (1 == cur_selection) //close
        {
            WIFISUPP_SetLogSwitch(WIFISUPP_LOG_ON);
            TCPIP_SetGlobalSendWin(0); //default
            SCI_SetArmLogFlag(TRUE);
            TCPIPDEBUG_EnableCap(TRUE);
        }
        else
        {
            WIFISUPP_SetLogSwitch(WIFISUPP_LOG_OFF);
            TCPIP_SetGlobalSendWin(32 * 1024);
            SCI_SetArmLogFlag(FALSE);
            TCPIPDEBUG_EnableCap(FALSE);
        }
        MMK_CloseWin(win_id);
        break;        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

#define IPERF_IP_MAX_LEN     (20)
#define IPERF_PORT_MAX_LEN   (20)
#define IPERF_TIME_MAX_LEN   (20)
#define IPERF_UPLOAD         (0)
#define IPERF_DOWNLOAD       (1)
#define IPERF_TCP            (0)
#define IPERF_UDP            (1)

#define STR_MAX_LEN          (20)

#define IPERF_DROPDOWN_MAX_NUM         (2)
#define IPERF_DROPDOWN_TYPE_MAX_NUM    (2)
LOCAL MMI_TEXT_ID_T type_id[IPERF_DROPDOWN_TYPE_MAX_NUM] = {TXT_ENG_IPERF_TCP,TXT_ENG_IPERF_UDP};
LOCAL MMI_TEXT_ID_T up_id[IPERF_DROPDOWN_MAX_NUM] = {TXT_ENG_IPERF_UP,TXT_ENG_IPERF_DOWN};
LOCAL MMI_TEXT_ID_T net_id[IPERF_DROPDOWN_MAX_NUM] = {TXT_WIFI,TXT_GPRS};
LOCAL uint32 gprs_net_id = 0;

typedef struct
{
    uint32  net_id;
    uint8   ip[STR_MAX_LEN];
    uint8   port[STR_MAX_LEN];
    uint8   time[STR_MAX_LEN];
    uint8   datasize[STR_MAX_LEN];
    uint8   bw[STR_MAX_LEN];
}MMIENG_IPERF_T;


/*****************************************************************************/
//  Description : InitIperfParam
//  Global resource dependence :
//  Author: chunjuan.liang
//  Note:
/*****************************************************************************/

LOCAL void InitIperfParam(uint32 win_id)
{
    MMI_HANDLE_T form_ctrl                  = MMK_GetCtrlHandleByWin(win_id, MMIENG_FORM_CTRL_ID);

    MMI_HANDLE_T form1                      = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_IPERF_TYPE_FORM_CTRL_ID);
    MMI_HANDLE_T form2                      = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_IPERF_UP_FORM_CTRL_ID);
    MMI_HANDLE_T form3                      = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_IPERF_IP_FORM_CTRL_ID);
    MMI_HANDLE_T form4                      = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_IPERF_PORT_FORM_CTRL_ID);
    MMI_HANDLE_T form5                      = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_IPERF_TIME_FORM_CTRL_ID);
    MMI_HANDLE_T form6                      = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_IPERF_RESULT_FORM_CTRL_ID);
    MMI_HANDLE_T form7                      = MMK_GetCtrlHandleByWin(win_id, MMIENG_FORM1_CTRL_ID);

    MMI_HANDLE_T drop_list_net_ctrl     = MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_EDIT_CTRL7_ID);
    MMI_HANDLE_T drop_list_type_ctrl    = MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_EDIT_CTRL1_ID);
    MMI_HANDLE_T drop_list_up_ctrl      = MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_EDIT_CTRL2_ID);

    GUIFORM_CHILD_HEIGHT_T height_info = {0};
    GUI_BG_T               display_bg  = {0};
    GUIFORM_CHILD_HEIGHT_T form_height = {0};
    GUI_BORDER_T           droplist_border = {0};
    GUIFORM_CHILD_WIDTH_T  form_width  = {0};

    uint8 *str               = PNULL;
    wchar wstr[STR_MAX_LEN]  = {0};
    uint8 i                  = 0;
    MMI_STRING_T text        = {0};

    display_bg.bg_type = GUI_BG_COLOR;
    display_bg.color   = MMI_WHITE_COLOR;

    //form
    GUIFORM_SetType(MMIENG_FORM_CTRL_ID, GUIFORM_TYPE_TP);
    GUIFORM_SetDividingLine(form_ctrl,1,MMI_BLACK_COLOR);
    GUIFORM_SetBg(MMIENG_FORM_CTRL_ID,&display_bg);
    GUIFORM_PermitChildFont(form_ctrl,FALSE);
    GUIFORM_PermitChildBorder(form_ctrl,FALSE);

    //set unit
    GUIFORM_SetStyle(MMIENG_WIFI_IPERF_TYPE_FORM_CTRL_ID,GUIFORM_STYLE_UNIT);
    GUIFORM_SetStyle(MMIENG_WIFI_IPERF_UP_FORM_CTRL_ID,GUIFORM_STYLE_UNIT);
    GUIFORM_SetStyle(MMIENG_WIFI_IPERF_IP_FORM_CTRL_ID,GUIFORM_STYLE_UNIT);
    GUIFORM_SetStyle(MMIENG_WIFI_IPERF_PORT_FORM_CTRL_ID,GUIFORM_STYLE_UNIT);
    GUIFORM_SetStyle(MMIENG_WIFI_IPERF_TIME_FORM_CTRL_ID,GUIFORM_STYLE_UNIT);
    GUIFORM_SetStyle(MMIENG_WIFI_IPERF_RESULT_FORM_CTRL_ID,GUIFORM_STYLE_UNIT);
    GUIFORM_SetStyle(MMIENG_FORM1_CTRL_ID,GUIFORM_STYLE_UNIT);

    height_info.type     = GUIFORM_CHILD_HEIGHT_FIXED;
    height_info.add_data = MMIENG_MENU_ITEM_HEIGHT;
    form_height.type     = GUIFORM_CHILD_HEIGHT_PERCENT;
    form_height.add_data = 100;
    form_width.type      = GUIFORM_CHILD_WIDTH_PERCENT;
    form_width.add_data  = 40;

    droplist_border.color = MMI_BLACK_COLOR;
    droplist_border.width = 1;
    droplist_border.type = GUI_BORDER_ROUNDED;

    //network:gprs/wifi
    GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID,MMIENG_FORM1_CTRL_ID,&height_info);
    GUIFORM_SetChildHeight(MMIENG_FORM1_CTRL_ID,MMIENG_COMMON_LABEL_CTRL7_ID,&form_height);
    GUIFORM_SetChildHeight(MMIENG_FORM1_CTRL_ID,MMIENG_COMMON_EDIT_CTRL7_ID,&form_height);
    GUIEDIT_SetBorder(MMIENG_COMMON_EDIT_CTRL7_ID,&droplist_border);
    GUIFORM_SetChildWidth(form7,MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_LABEL_CTRL7_ID),&form_width);
    //tcp/udp
    GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID,MMIENG_WIFI_IPERF_TYPE_FORM_CTRL_ID,&height_info);
    GUIFORM_SetChildHeight(MMIENG_WIFI_IPERF_TYPE_FORM_CTRL_ID,MMIENG_COMMON_LABEL_CTRL1_ID,&form_height);
    GUIFORM_SetChildHeight(MMIENG_WIFI_IPERF_TYPE_FORM_CTRL_ID,MMIENG_COMMON_EDIT_CTRL1_ID,&form_height);
    GUIEDIT_SetBorder(MMIENG_COMMON_EDIT_CTRL1_ID,&droplist_border);
    GUIFORM_SetChildWidth(form1,MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_LABEL_CTRL1_ID),&form_width);
    //up/down
    GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID,MMIENG_WIFI_IPERF_UP_FORM_CTRL_ID,&height_info);
    GUIFORM_SetChildHeight(MMIENG_WIFI_IPERF_UP_FORM_CTRL_ID,MMIENG_COMMON_LABEL_CTRL2_ID,&form_height);
    GUIFORM_SetChildHeight(MMIENG_WIFI_IPERF_UP_FORM_CTRL_ID,MMIENG_COMMON_EDIT_CTRL2_ID,&form_height);
    CTRLFORM_SetChildWidth(form2,MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_LABEL_CTRL2_ID),&form_width);
    //ip
    GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID,MMIENG_WIFI_IPERF_IP_FORM_CTRL_ID,&height_info);
    GUIFORM_SetChildHeight(MMIENG_WIFI_IPERF_IP_FORM_CTRL_ID,MMIENG_COMMON_LABEL_CTRL3_ID,&form_height);
    GUIFORM_SetChildHeight(MMIENG_WIFI_IPERF_IP_FORM_CTRL_ID,MMIENG_COMMON_EDIT_CTRL3_ID,&form_height);
    GUIFORM_SetChildWidth(form3,MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_LABEL_CTRL3_ID),&form_width);
    GUIEDIT_SetBorder(MMIENG_COMMON_EDIT_CTRL3_ID,&droplist_border);
    GUIEDIT_SetStyle(MMIENG_COMMON_EDIT_CTRL3_ID,GUIEDIT_STYLE_SINGLE);
    GUIEDIT_SetAlign(MMIENG_COMMON_EDIT_CTRL3_ID,ALIGN_LVMIDDLE);
    //port
    GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID,MMIENG_WIFI_IPERF_PORT_FORM_CTRL_ID,&height_info);
    GUIFORM_SetChildHeight(MMIENG_WIFI_IPERF_PORT_FORM_CTRL_ID,MMIENG_COMMON_LABEL_CTRL4_ID,&form_height);
    GUIFORM_SetChildHeight(MMIENG_WIFI_IPERF_PORT_FORM_CTRL_ID,MMIENG_COMMON_EDIT_CTRL4_ID,&form_height);
    GUIFORM_SetChildWidth(form4,MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_LABEL_CTRL4_ID),&form_width);
    GUIEDIT_SetBorder(MMIENG_COMMON_EDIT_CTRL4_ID,&droplist_border);
    GUIEDIT_SetStyle(MMIENG_COMMON_EDIT_CTRL4_ID,GUIEDIT_STYLE_SINGLE);
    GUIEDIT_SetAlign(MMIENG_COMMON_EDIT_CTRL4_ID,ALIGN_LVMIDDLE);
    //time
    GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID,MMIENG_WIFI_IPERF_TIME_FORM_CTRL_ID,&height_info);
    GUIFORM_SetChildHeight(MMIENG_WIFI_IPERF_TIME_FORM_CTRL_ID,MMIENG_COMMON_LABEL_CTRL5_ID,&form_height);
    GUIFORM_SetChildHeight(MMIENG_WIFI_IPERF_TIME_FORM_CTRL_ID,MMIENG_COMMON_EDIT_CTRL5_ID,&form_height);
    GUIFORM_SetChildWidth(form5,MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_LABEL_CTRL5_ID),&form_width);
    GUIEDIT_SetBorder(MMIENG_COMMON_EDIT_CTRL5_ID,&droplist_border);
    GUIEDIT_SetStyle(MMIENG_COMMON_EDIT_CTRL5_ID,GUIEDIT_STYLE_SINGLE);
    GUIEDIT_SetAlign(MMIENG_COMMON_EDIT_CTRL5_ID,ALIGN_LVMIDDLE);
    //result
    GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID,MMIENG_WIFI_IPERF_RESULT_FORM_CTRL_ID,&height_info);
    GUIFORM_SetChildHeight(MMIENG_WIFI_IPERF_RESULT_FORM_CTRL_ID,MMIENG_COMMON_LABEL_CTRL6_ID,&form_height);
    GUIFORM_SetChildHeight(MMIENG_WIFI_IPERF_RESULT_FORM_CTRL_ID,MMIENG_COMMON_EDIT_CTRL6_ID,&form_height);
    GUIFORM_SetChildWidth(form6,MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_LABEL_CTRL6_ID),&form_width);
    GUITEXT_SetBorder(&droplist_border,MMIENG_COMMON_EDIT_CTRL6_ID);
    GUITEXT_SetAlign(MMIENG_COMMON_LABEL_CTRL6_ID,ALIGN_LVMIDDLE);

    //NETWORK
    str = "Network";
    text.wstr_len = strlen(str);
    text.wstr_ptr = wstr;
    MMI_STRNTOWSTR( wstr, STR_MAX_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
    GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL7_ID, &text, TRUE);

    height_info.type = GUIFORM_CHILD_HEIGHT_AUTO;
    GUIFORM_SetChildHeight(form7, drop_list_net_ctrl, &height_info);
    GUIDROPDOWNLIST_SetBorder(drop_list_net_ctrl,&droplist_border);
    GUIDROPDOWNLIST_SetVisible(drop_list_net_ctrl,TRUE,TRUE);
    GUIDROPDOWNLIST_SetMaxItem(drop_list_net_ctrl,IPERF_DROPDOWN_TYPE_MAX_NUM);

    for(i=0;i<ARR_SIZE(net_id);i++)
    {
        GUIDROPDOWNLIST_AppendItemById(MMIENG_COMMON_EDIT_CTRL7_ID,net_id[i]);
    }
    GUIDROPDOWNLIST_SetCurItemIndex(MMIENG_COMMON_EDIT_CTRL7_ID,0);

    //TYPE
    str = "Type";
    text.wstr_len = strlen(str);
    text.wstr_ptr = wstr;
    MMI_STRNTOWSTR( wstr, STR_MAX_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
    GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL1_ID, &text, TRUE);

    height_info.type = GUIFORM_CHILD_HEIGHT_AUTO;
    GUIFORM_SetChildHeight(form1, drop_list_type_ctrl, &height_info);
    GUIDROPDOWNLIST_SetBorder(drop_list_type_ctrl,&droplist_border);
    GUIDROPDOWNLIST_SetVisible(drop_list_type_ctrl,TRUE,TRUE);
    GUIDROPDOWNLIST_SetMaxItem(drop_list_type_ctrl,IPERF_DROPDOWN_TYPE_MAX_NUM);

    for(i=0;i<ARR_SIZE(type_id);i++)
    {
        GUIDROPDOWNLIST_AppendItemById(MMIENG_COMMON_EDIT_CTRL1_ID,type_id[i]);
    }
    GUIDROPDOWNLIST_SetCurItemIndex(MMIENG_COMMON_EDIT_CTRL1_ID,0);

    //UP/DOWN
    str = "Direction";
    text.wstr_len = strlen(str);
    text.wstr_ptr = wstr;
    MMI_STRNTOWSTR( wstr, STR_MAX_LEN, (uint8*)str, strlen(str), strlen(str) );
    GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL2_ID,&text, FALSE);

    height_info.type = GUIFORM_CHILD_HEIGHT_AUTO;
    GUIFORM_SetChildHeight(form2, drop_list_up_ctrl, &height_info);
    GUIDROPDOWNLIST_SetBorder(drop_list_up_ctrl,&droplist_border);
    GUIDROPDOWNLIST_SetVisible(drop_list_up_ctrl,TRUE,TRUE);
    GUIDROPDOWNLIST_SetMaxItem(drop_list_up_ctrl,IPERF_DROPDOWN_MAX_NUM);

    for(i=0;i<ARR_SIZE(up_id);i++)
    {
        GUIDROPDOWNLIST_AppendItemById(MMIENG_COMMON_EDIT_CTRL2_ID,up_id[i]);
    }
    GUIDROPDOWNLIST_SetCurItemIndex(MMIENG_COMMON_EDIT_CTRL2_ID,0);

    //IP
    str = "IP";
    text.wstr_len = strlen(str);
    text.wstr_ptr = wstr;
    MMI_STRNTOWSTR( wstr, STR_MAX_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
    GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL3_ID, &text, FALSE);
    str = "192.168.43.70";
    SCI_MEMSET(wstr,0,sizeof(wchar)*STR_MAX_LEN);
    MMI_STRNTOWSTR( wstr, STR_MAX_LEN, (uint8*)str, strlen(str), strlen(str));
    GUIEDIT_SetString(MMIENG_COMMON_EDIT_CTRL3_ID,wstr,MMIAPICOM_Wstrlen(wstr));

    //PORT
    str = "Port";
    text.wstr_len = strlen(str);
    text.wstr_ptr = wstr;
    MMI_STRNTOWSTR( wstr, STR_MAX_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
    GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL4_ID, &text, FALSE);
    str = "5001";
    SCI_MEMSET(wstr,0,sizeof(wchar)*STR_MAX_LEN);
    MMI_STRNTOWSTR( wstr, STR_MAX_LEN, (uint8*)str, strlen(str), strlen(str));
    GUIEDIT_SetString(MMIENG_COMMON_EDIT_CTRL4_ID,wstr,MMIAPICOM_Wstrlen(wstr));

    //TIME
    str = "Time";
    text.wstr_len = strlen(str);
    text.wstr_ptr = wstr;
    MMI_STRNTOWSTR( wstr, STR_MAX_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
    GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL5_ID, &text, FALSE);
    str = "1";
    SCI_MEMSET(wstr,0,sizeof(wchar)*STR_MAX_LEN);
    MMI_STRNTOWSTR( wstr, STR_MAX_LEN, (uint8*)str, strlen(str), strlen(str));
    GUIEDIT_SetString(MMIENG_COMMON_EDIT_CTRL5_ID,wstr,MMIAPICOM_Wstrlen(wstr));

    //RESULT
    str = "Result";
    text.wstr_len = strlen(str);
    text.wstr_ptr = wstr;
    MMI_STRNTOWSTR( wstr, STR_MAX_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
    GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL6_ID, &text, FALSE);

}
LOCAL IPERF_RESULT_T g_iperf_result = {0};

PUBLIC void Iperfresult_callback (IPERF_RESULT_T* result)
{
    if (PNULL != result)
    {
        uint32 len =0;
        TRACE_APP_ENGINEERMODE("Title is %s", result->report_title);
        TRACE_APP_ENGINEERMODE("total len is  %s", result->total_len);
        TRACE_APP_ENGINEERMODE("speed is      %s ", result->result);
        len = strlen(result->result);
        len = MIN(IPERF_MAX_BUFFER_LEN, len);
        SCI_MEMCPY(g_iperf_result.result,result->result, len);
        MMK_SendMsg(MMIENG_WIFI_IPERF_WIN_ID,MSG_FULL_PAINT,PNULL);
    }
    else
    {
        TRACE_APP_ENGINEERMODE("error");
    }
 }

LOCAL BOOLEAN GetIperfIpAddr(char *ip_ptr,uint32 addr,uint32 buf_len)
{
    {
        typedef union
        {
            uint32 whole;
            struct
            {
                uint32 byte0 : 8;
                uint32 byte1 : 8;
                uint32 byte2 : 8;
                uint32 byte3 : 8;
            }all_part;
        }DEPART_T;

        DEPART_T depart = {0};
        depart.whole = addr;

        _snprintf(
            ip_ptr,
            buf_len,
            "%d.%d.%d.%d",
            depart.all_part.byte0,
            depart.all_part.byte1,
            depart.all_part.byte2,
            depart.all_part.byte3
            );
    }
    return TRUE;
}

/*****************************************************************************/
//  Description : StartIperfTestParam
//  Global resource dependence : 
//  Author: chunjuan.liang
//  Note: TCPUP:	AT+WIFI= IPERF,UP,TCP,IP=xxx,PORT=xxx,TIME=xxx
//	      UDPUP:	AT+WIFI= IPERF,UP,UDP,IP=xxx,PORT=xxx,TIME=xxx,BW=xxx
//	      DL:    AT+WIFI=IPERF,DOWN,TCP/UDP,PORT=xxx
//if up means:client
//if down mens:server
/*****************************************************************************/

PUBLIC IPERF_ERROR_E Iperf_test(MMIENG_IPERF_T *iperf_param,uint16 tcpidx,uint16 upidx,BOOLEAN is_wifi)
{
    IPERF_CONFIG_T* iperf_config = PNULL;
    uint8           *str = "10M";
    uint32          ip_addr = 0;
    uint32 len =0;
    IPERF_CONFIG_T  iperf_config_temp = {0};

    TRACE_APP_ENGINEERMODE("iperf  begin");

    if(PNULL == iperf_param)
    {
        TRACE_APP_ENGINEERMODE("[iperf_config is null");
        return IPERF_ERROR;
    }

    iperf_config = SCI_ALLOC_APPZ(sizeof(IPERF_CONFIG_T));
    if (PNULL == iperf_config)
    {
        TRACE_APP_ENGINEERMODE("[iperf_config is null");
        return IPERF_NO_MEMORY;
    }

    memset(iperf_config, 0x0, sizeof(IPERF_CONFIG_T));

    daps_iperf_init();

    TRACE_APP_ENGINEERMODE("wifi on=%d",MMIAPIWIFI_GetIsWlanOn());

    if(TRUE == is_wifi)
    {
        daps_iperf_WIFI_Set_netid(&iperf_config_temp);
        //ip_addr = sci_gethostaddress();

        iperf_config->net_id = iperf_config_temp.net_id;

        TRACE_APP_ENGINEERMODE("net id =%x",iperf_config_temp.net_id);
    }else
    {
        iperf_config->net_id = gprs_net_id;

        ip_addr = sci_gethostaddress_ext(gprs_net_id);
        GetIperfIpAddr(iperf_param->ip,ip_addr,20);
    }

    TRACE_APP_ENGINEERMODE("net id =%d,ip_addr =%d",iperf_config->net_id,ip_addr);

    TRACE_APP_ENGINEERMODE("IP=%s",iperf_param->ip);
    TRACE_APP_ENGINEERMODE("upidx =%d,tcpidx=%d",upidx,tcpidx);
    TRACE_APP_ENGINEERMODE("ip=%s,port=%s,time=%s",iperf_param->ip,iperf_param->port,iperf_param->time);

    switch(upidx)
    {
        case IPERF_DOWNLOAD:
        {
            if(0 == tcpidx)
            {
                TRACE_APP_ENGINEERMODE("TCP  Server: net_id =%x,port=%s",iperf_config->net_id,iperf_param->port);
                daps_iperf_set_TCP_Server(iperf_config,iperf_param->port ,Iperfresult_callback);
            }else
            {
                TRACE_APP_ENGINEERMODE("UDP  Server: net_id =%x,port=%s",iperf_config->net_id,iperf_param->port);
                daps_iperf_set_UDP_Server(iperf_config, iperf_param->port,Iperfresult_callback);
            }
        }
            break;
        case IPERF_UPLOAD:
        {
            if(0 == tcpidx)
            {
                TRACE_APP_ENGINEERMODE("TCP  Client:net_id =%x,ip=%s,port=%s,time=%s",iperf_config->net_id,iperf_param->ip,iperf_param->port,iperf_param->time);
                daps_iperf_set_TCP_Client(iperf_config,iperf_param->ip,iperf_param->port,iperf_param->time,PNULL,Iperfresult_callback);
            }else
            {
                TRACE_APP_ENGINEERMODE("UDP  Client:net_id =%x,ip=%s,port=%s,time=%s,bw=%s",iperf_config->net_id,iperf_param->ip,iperf_param->port,iperf_param->time,iperf_param->bw);
                len = strlen(str);
                len = MIN(IPERF_MAX_BUFFER_LEN, len);
                SCI_MEMCPY(iperf_param->bw,str,len);
                daps_iperf_set_UDP_Client(iperf_config, iperf_param->ip,iperf_param->port,iperf_param->time,PNULL,iperf_param->bw,Iperfresult_callback);
            }
        }
            break;
        default:
            TRACE_APP_ENGINEERMODE("error");
            break;
    }

    daps_iperf_run(iperf_config);

    if(PNULL != iperf_config)
    {
        SCI_FREE(iperf_config);
        iperf_config = PNULL;
    }

    TRACE_APP_ENGINEERMODE("iperf end");
    return IPERF_SUCCESS;
 }

/*****************************************************************************/
//  Description : StartIperfTestParam
//  Global resource dependence :
//  Author: chunjuan.liang
//  Note: TCPUP:	AT+WIFI= IPERF,UP,TCP,IP=xxx,PORT=xxx,TIME=xxx
//	      UDPUP:	AT+WIFI= IPERF,UP,UDP,IP=xxx,PORT=xxx,TIME=xxx,BW=xxx
//	      DL:    AT+WIFI=IPERF,DOWN,TCP/UDP,PORT=xxx
//if up means:client
//if down mens:server
/*****************************************************************************/

LOCAL void StartIperfTestParam(uint16 tcpidx,uint16 upidx,BOOLEAN is_wifi)
{
    uint8 ip[IPERF_IP_MAX_LEN]     = {0};
    uint8 port[IPERF_PORT_MAX_LEN] = {0};
    uint8 time[IPERF_TIME_MAX_LEN] = {0};
    MMI_STRING_T       txt_temp    = {0};

    MMIENG_IPERF_T      iperf_param = {0};
    uint32 len =0;
    //IP
    GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL3_ID,&txt_temp);
    if(0 < txt_temp.wstr_len)
    {
        MMI_WSTRNTOSTR(ip,IPERF_IP_MAX_LEN,txt_temp.wstr_ptr,IPERF_IP_MAX_LEN,txt_temp.wstr_len);
        len = strlen(ip);
        len = MIN(STR_MAX_LEN, len);
        len = MIN(IPERF_IP_MAX_LEN, len);
        SCI_MEMCPY(iperf_param.ip,ip,len);
    }else
    {
        TRACE_APP_ENGINEERMODE("IP IS NULL");
    }
    //PORT
    SCI_MEMSET(&txt_temp,0,sizeof(MMI_STRING_T));
    GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL4_ID,&txt_temp);
    if(0 < txt_temp.wstr_len)
    {
        MMI_WSTRNTOSTR(port,IPERF_PORT_MAX_LEN,txt_temp.wstr_ptr,IPERF_PORT_MAX_LEN,txt_temp.wstr_len);
        len = strlen(port);
        len = MIN(STR_MAX_LEN, len);
        len = MIN(len, IPERF_PORT_MAX_LEN);
        SCI_MEMCPY(iperf_param.port,port,len);
    }else
    {
        TRACE_APP_ENGINEERMODE("PORT IS NULL");
    }
    //TIME
    SCI_MEMSET(&txt_temp,0,sizeof(MMI_STRING_T));
    GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL5_ID,&txt_temp);
    if(0 < txt_temp.wstr_len)
    {
        MMI_WSTRNTOSTR(time,IPERF_TIME_MAX_LEN,txt_temp.wstr_ptr,IPERF_TIME_MAX_LEN,txt_temp.wstr_len);
        len = strlen(time);
        len = MIN(IPERF_TIME_MAX_LEN, len);
        len = MIN(STR_MAX_LEN, len);
        SCI_MEMCPY(iperf_param.time,time,len);
    }else
    {
        TRACE_APP_ENGINEERMODE("TIME IS NULL");
    }

    Iperf_test(&iperf_param,tcpidx,upidx, is_wifi);
}

LOCAL void HandleIperfTest_PdpMsg(MMIPDP_CNF_INFO_T *msg_ptr)
{
    uint16 tcp_idx = 0;
    uint16 up_idx = 0;
    if(PNULL == msg_ptr)
    {
        TRACE_APP_ENGINEERMODE("msg_ptr is null");
        return;
    }

    TRACE_APP_ENGINEERMODE("HandleGprsTes_PdpMsg(), msg_ptr->msg_id = %d.", msg_ptr->msg_id);
    switch(msg_ptr->msg_id)
    {
        case MMIPDP_ACTIVE_CNF:
        {
            TRACE_APP_ENGINEERMODE("HandleGprsTes_PdpMsg(), MMIPDP_ACTIVE_CNF.msg_ptr->result = %d", msg_ptr->result);

            if(MMIPDP_RESULT_SUCC == msg_ptr->result)
            {
                gprs_net_id = msg_ptr->nsapi;
                TRACE_APP_ENGINEERMODE("gprs_net_id=%d", gprs_net_id);
                tcp_idx = GUIDROPDOWNLIST_GetCurItemIndex(MMIENG_COMMON_EDIT_CTRL1_ID);
                up_idx  = GUIDROPDOWNLIST_GetCurItemIndex(MMIENG_COMMON_EDIT_CTRL2_ID);
                StartIperfTestParam(tcp_idx,up_idx,FALSE);
            }
#if defined(MMI_GPRS_SUPPORT)
            else
            {
                MMIAPIPDP_Deactive(MMI_MODULE_IPERF_TEST);
            }
#endif
        }
            break;
        case MMIPDP_DEACTIVE_CNF:
            gprs_net_id = 0;
            break;

        case MMIPDP_DEACTIVE_IND:
            gprs_net_id = 0;
#if defined(MMI_GPRS_SUPPORT)
            MMIAPIPDP_Deactive(MMI_MODULE_IPERF_TEST);
#endif
            break;
        default:
            break;
    }
}
/*****************************************************************************/
//  Description : IperfTest_PdpActive
//  Global resource dependence : 
//  Author: chunjuan.liang
//  Note: 
/*****************************************************************************/
LOCAL BOOLEAN IperfTest_PdpActive(void)
{
    MMIPDP_ACTIVE_INFO_T            active_info     = {0};
    BOOLEAN                         return_val      = FALSE;
    MMICONNECTION_LINKSETTING_DETAIL_T* linksetting = PNULL;

    TRACE_APP_ENGINEERMODE("Enter");

    {
        int i = 0;
        int j = 0;
        MN_DUAL_SYS_E sim_sys = MN_DUAL_SYS_1;
        uint8 linkNum = 0;

        linkNum = MMIAPICONNECTION_GetLinkSettingNum(sim_sys);
        TRACE_APP_ENGINEERMODE("linkNum = %d.", linkNum);

        for (i = 0; i < linkNum; i++)
        {
            linksetting = PNULL;
            linksetting = MMIAPICONNECTION_GetLinkSettingItemByIndex(sim_sys, i);
            TRACE_APP_ENGINEERMODE("linksetting = %x", linksetting);

            // print apn information and plmn
            if(PNULL != linksetting && 0 != linksetting->apn_len)
            {
                SCI_TRACE_LOW("%d", linksetting->apn_len);
                for (j = 0; j < linksetting->apn_len; j++)
                {
                    TRACE_APP_ENGINEERMODE("[%d]--%x", j, linksetting->apn[j]);
                }
                TRACE_APP_ENGINEERMODE("hplmn = %d, [%d, %d, %d]", linksetting->hplmn, linksetting->plmn.mcc, linksetting->plmn.mnc, linksetting->plmn.mnc_digit_num);

                // set apn, username and psw
                active_info.apn_ptr       = linksetting->apn;
                active_info.user_name_ptr = linksetting->username;
                active_info.psw_ptr       = linksetting->password;
                break;
            }
        }
        active_info.app_handler         = MMI_MODULE_IPERF_TEST;
        active_info.dual_sys            = sim_sys;
        active_info.priority            = 3;
        active_info.ps_service_rat      = MN_UNSPECIFIED;
        active_info.ps_interface        = MMIPDP_INTERFACE_GPRS;
        active_info.handle_msg_callback = HandleIperfTest_PdpMsg;
        active_info.ps_service_type = BROWSER_E;
        active_info.storage = MN_GPRS_STORAGE_ALL;
#ifdef IPVERSION_SUPPORT_V4_V6
        active_info.ip_type = MMICONNECTION_IP_V4;
#endif

        TRACE_APP_ENGINEERMODE("call MMIAPIPDP_Active ");
#if defined(MMI_GPRS_SUPPORT)
        if(MMIAPIPDP_Active(&active_info))
        {
            return_val = TRUE;
        }
#endif
    }

    TRACE_APP_ENGINEERMODE("return_val = %d", return_val);
    return return_val;
}
LOCAL void IperfServerIpDisplay(void)
{
    uint32 ip_addr = 0;
    uint8   str_ip[20] = {0};
    wchar   wstr_ip[20] = {0};
    uint16  ip_len = 20;

    if(TRUE == MMIAPIWIFI_GetIsWlanOn())//wlan&serer&wifi is on
    {
        ip_addr = sci_gethostaddress();
        TRACE_APP_ENGINEERMODE("IPADDR=%x",ip_addr);
        GetIperfIpAddr(str_ip,ip_addr,ip_len);
        MMI_STRNTOWSTR(wstr_ip,20,str_ip,20,20);
        GUIEDIT_SetString(MMIENG_COMMON_EDIT_CTRL3_ID,wstr_ip,strlen(str_ip));
        MMK_SendMsg(MMIENG_WIFI_IPERF_WIN_ID,MSG_FULL_PAINT,PNULL);
    }
}

/*****************************************************************************/
//  Description : HandleWifiIperfWinMsg
//  Global resource dependence : 
//  Author: chunjuan.liang
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleWifiIperfWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;

    MMICONNECTION_SETTING_GPRS_SWITCH_E  gprs_staus = MMICONNECTION_SETTING_GPRS_SWITCH_MAX;

    wchar     iperf_result[20] = {0};

    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        {
            MMIDEFAULT_AllowTurnOffBackLight(FALSE);
            if(TRUE == MMIAPIWIFI_GetIsWlanOn())
            {
                TRACE_APP_ENGINEERMODE("WIFI ON");
                //MMIAPIWIFI_Off();
            }
            if(MMICONNECTION_SETTING_GPRS_SWITCH_ON == gprs_staus)
            {
                TRACE_APP_ENGINEERMODE("gprs_staus on");
                MMIAPICONNECTION_SetGPRSSwitchStatus(MMICONNECTION_SETTING_GPRS_SWITCH_OFF);
            }
            InitIperfParam(win_id);
            MMK_SetAtvCtrl(win_id,MMIENG_COMMON_EDIT_CTRL1_ID);
        }
        break;
    case MSG_FULL_PAINT:
    {
        MMI_STRNTOWSTR(iperf_result,20,g_iperf_result.result,20,strlen(g_iperf_result.result));
        GUITEXT_SetString(MMIENG_COMMON_EDIT_CTRL6_ID,iperf_result,strlen(g_iperf_result.result),FALSE);
    }
            break;
    case MSG_APP_CANCEL:
    case MSG_CTL_CANCEL:
    {
#ifndef WIN32
            TRACE_APP_ENGINEERMODE("stop");
            // TODO: stop test
            daps_iperf_stop();
#if defined(MMI_GPRS_SUPPORT)
            MMIAPIPDP_Deactive(MMI_MODULE_IPERF_TEST);
#endif
#endif
        //MMK_CloseWin(win_id);
    }
        break;
    case MSG_NOTIFY_DROPDOWNLIST_SELECTED:
    {
            uint16  down_idx = GUIDROPDOWNLIST_GetCurItemIndex(MMIENG_COMMON_EDIT_CTRL2_ID);;

            if(IPERF_DOWNLOAD == down_idx)
            {
                TRACE_APP_ENGINEERMODE("DOWNLOAD  To display ip");
                IperfServerIpDisplay();
            }
    }
        break;
    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT
    case MSG_CTL_PENOK:
#endif
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        {
            //if gprs,pdp active
            //if wifi,set net id
            uint16 tcp_idx = 0;
            uint16 up_idx  = 0;
            uint16 net_idx = 0;
            BOOLEAN is_wifi = TRUE;


            MMI_CTRL_ID_T act_ctrl_id = MMIENG_COMMON_EDIT_CTRL3_ID;

            MMI_STRING_T txt_tip = {0};
            WATCH_SOFTKEY_TEXT_ID_T softkey = {TXT_NULL,TXT_NULL,TXT_NULL};

            net_idx = GUIDROPDOWNLIST_GetCurItemIndex(MMIENG_COMMON_EDIT_CTRL7_ID);
            tcp_idx = GUIDROPDOWNLIST_GetCurItemIndex(MMIENG_COMMON_EDIT_CTRL1_ID);
            up_idx  = GUIDROPDOWNLIST_GetCurItemIndex(MMIENG_COMMON_EDIT_CTRL2_ID);

            TRACE_APP_ENGINEERMODE("net_idx=%d",net_idx);

            TRACE_APP_ENGINEERMODE("daps running=%d",daps_iperf_is_running());

            if(0 < daps_iperf_is_running())
            {
                MMI_GetLabelTextByLang(TXT_ERROR, &txt_tip);
                WatchCOM_NoteWin_1Line_Enter(MMIENG_LOG_NOTE_WIN_ID, &txt_tip,0,softkey,PNULL);
                return result;
            }


            if(1 == net_idx)//GPRS
            {
                gprs_staus = MMIAPICONNECTION_GetGPRSSwitchStatus();
                TRACE_APP_ENGINEERMODE("MMIAPICONNECTION_GetGPRSSwitchStatus=%d",gprs_staus);

                if(MMICONNECTION_SETTING_GPRS_SWITCH_ON == gprs_staus)
                {
                    TRACE_APP_ENGINEERMODE("GPRS ON");
                }
                else if(MMICONNECTION_SETTING_GPRS_SWITCH_OFF == gprs_staus)
                {
                    TRACE_APP_ENGINEERMODE("GPRS OFF,To Switch ON GPRS");
                    MNPHONE_SetServiceTypeEx(MN_DUAL_SYS_1, MN_PHONE_USER_SELECT_GSM_GPRS_BOTH);
                    MNPHONE_GprsAttachEx(MN_DUAL_SYS_1, MN_PHONE_GPRS_ATTACH);
                    MMIAPICONNECTION_SetGPRSSwitchStatus(MMICONNECTION_SETTING_GPRS_SWITCH_ON);
                }

                //active pdp
                IperfTest_PdpActive();
                is_wifi = FALSE;

            }else if(0 == net_idx)//WIFI
            {
                if(FALSE == MMIAPIWIFI_GetIsWlanOn())
                {
                    MMIAPIWIFI_On(FALSE);
                }
                StartIperfTestParam(tcp_idx,up_idx,TRUE);
            }
        }
        break;
    case MSG_CLOSE_WINDOW:
        MMIDEFAULT_AllowTurnOffBackLight(TRUE);
        break;
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}
#if 0
/*****************************************************************************/
//  Description : HandleWifiIperfWinMsg
//  Global resource dependence : 
//  Author: YING.XU
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleWifiIperfWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T editbox_id = MMIENG_EDITBOX1_CTRL_ID;

    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        {
            char *input_str = "Input";
            char *result_str = "Result";
            char *command_str = "-c 192.168.1.3";
            MMI_STRING_T text = {0};
            wchar wstr[32] = {0} ;

            text.wstr_ptr = wstr;
            
            text.wstr_len = strlen(input_str);
            MMI_STRNTOWSTR( wstr, 31, (uint8*)input_str, text.wstr_len, text.wstr_len );
            GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &text, FALSE);
            
            text.wstr_len = strlen(result_str);
            MMI_STRNTOWSTR( wstr, 31, (uint8*)result_str, text.wstr_len, text.wstr_len );
            GUILABEL_SetText(MMIENG_LABEL2_CTRL_ID, &text, FALSE);

            text.wstr_len = strlen(command_str);
            MMI_STRNTOWSTR(wstr, 31, (uint8*)command_str, text.wstr_len, text.wstr_len);
            GUIEDIT_SetString(editbox_id, text.wstr_ptr, text.wstr_len);
            
            GUIEDIT_SetIm(editbox_id,  GUIIM_TYPE_ENGLISH|GUIIM_TYPE_ABC|GUIIM_TYPE_DIGITAL, GUIIM_TYPE_ENGLISH); /*lint !e655*/
            MMK_SetAtvCtrl(win_id,editbox_id);
        }
        break; 
    case MSG_APP_CANCEL:
    case MSG_CTL_CANCEL:
#ifndef WIN32
            iperf_test_stop();
#endif
        MMK_CloseWin(win_id);
        break;
        
    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        {
            MMI_STRING_T edit_text = {0};
            char str[256] = {0} ;

#if defined(MMI_PDA_SUPPORT)
            if (MSG_CTL_PENOK == msg_id)
            {
                if (MMICOMMON_BUTTON_SOFTKEY_LEFT_CTRL_ID == ((MMI_NOTIFY_T*) param)->src_id)
                {
                    MMK_PostMsg(win_id, MSG_APP_OK, PNULL, 0);

                    return MMI_RESULT_TRUE;
                }
                else if (MMICOMMON_BUTTON_SOFTKEY_RIGHT_CTRL_ID == ((MMI_NOTIFY_T*) param)->src_id)
                {
                    MMK_PostMsg(win_id, MSG_APP_CANCEL, PNULL, 0);

                    return MMI_RESULT_TRUE;
                }
            }
#endif

            GUIEDIT_GetString(editbox_id,  &edit_text);
            MMI_WSTRNTOSTR((uint8*)str, 255, edit_text.wstr_ptr, edit_text.wstr_len, edit_text.wstr_len );
#ifndef WIN32
#if 1  //deflete  for MARLIN2
            iperf_test_start(str);
            iperf_test_start_ex(str);
#endif
#endif
            MMK_CloseWin(win_id);
        }
        break;        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}
#endif
/*****************************************************************************/
//  Description : HandleWifiIperfWinMsg
//  Global resource dependence : 
//  Author: George.Liu
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleWlanRfSetWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E            recode      =   MMI_RESULT_TRUE;
    WIFISUPP_COMMAND_INFO_T command_info ={0};

    
    switch(msg_id)
    {
    case MSG_OPEN_WINDOW:
        //set power save param
        GUIFORM_SetStyle(MMIENG_WLAN_POWER_SAVE_FORM_CTRL_ID, GUIFORM_STYLE_UNIT);
        GUILABEL_SetTextById(MMIENG_WLAN_POWER_SAVE_LABEL_CTRL_ID, TXT_ENG_WLAN_POWER_SAVE, FALSE);
        GUISETLIST_AddItemById(MMIENG_WLAN_POWER_SAVE_SETLIST_CTRL_ID, TXT_COMM_OFF);
        GUISETLIST_AddItemById(MMIENG_WLAN_POWER_SAVE_SETLIST_CTRL_ID, TXT_COMM_ON);
        GUISETLIST_SetCtrlState(MMIENG_WLAN_POWER_SAVE_SETLIST_CTRL_ID, GUISETLIST_STATE_LEFTSK_SWITCH, TRUE);
        GUISETLIST_SetCurIndex(MMIENG_WLAN_POWER_SAVE_SETLIST_CTRL_ID, 1);
        GUISETLIST_SetTitleTextId(MMIENG_WLAN_POWER_SAVE_SETLIST_CTRL_ID, TXT_ENG_WLAN_POWER_SAVE);    

        //set roaming param
        GUIFORM_SetStyle(MMIENG_WLAN_ROAMING_FORM_CTRL_ID, GUIFORM_STYLE_UNIT);
        GUILABEL_SetTextById(MMIENG_WLAN_ROAMING_LABEL_CTRL_ID, TXT_ENG_WLAN_ROAMING, FALSE);
        GUISETLIST_AddItemById(MMIENG_WLAN_ROAMING_SETLIST_CTRL_ID, TXT_COMM_OFF);
        GUISETLIST_AddItemById(MMIENG_WLAN_ROAMING_SETLIST_CTRL_ID, TXT_COMM_ON);
        GUISETLIST_SetCtrlState(MMIENG_WLAN_ROAMING_SETLIST_CTRL_ID, GUISETLIST_STATE_LEFTSK_SWITCH, TRUE);
        GUISETLIST_SetCurIndex(MMIENG_WLAN_ROAMING_SETLIST_CTRL_ID, 1);
        GUISETLIST_SetTitleTextId(MMIENG_WLAN_ROAMING_SETLIST_CTRL_ID, TXT_ENG_WLAN_ROAMING);    

        MMK_SetAtvCtrl(win_id, MMIENG_RADIO_FREQUENCY_FORM_CTRL_ID);
        break;
        
    
    case MSG_CTL_CANCEL:
    case MSG_APP_CANCEL:
        //handle power save setting
        command_info.command_id = WIFIDRV_COMMAND_POWER_SAVE;
        command_info.para1 = GUISETLIST_GetCurIndex(MMIENG_WLAN_POWER_SAVE_SETLIST_CTRL_ID);
        //SCI_TRACE_LOW:"WIFI:info:MMI: HandleWlanRfSetWinMsg WIFISUPP_Command cmd=0x%x, para1=%d"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_16069_112_2_18_2_18_14_209,(uint8*)"dd", command_info.command_id, command_info.para1);
        WIFISUPP_Command(&command_info);

        //handle roaming setting
        command_info.command_id = WIFIDRV_COMMAND_SET_ROAMING_MODE;
        command_info.para1 = GUISETLIST_GetCurIndex(MMIENG_WLAN_ROAMING_SETLIST_CTRL_ID);
        //SCI_TRACE_LOW:"WIFI:info:MMI: HandleWlanRfSetWinMsg WIFISUPP_Command cmd=0x%x, para1=%d"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_16075_112_2_18_2_18_14_210,(uint8*)"dd", command_info.command_id, command_info.para1);
        WIFISUPP_Command(&command_info);
        
        MMK_CloseWin(win_id);
        break;

            
    default:
        recode = MMI_RESULT_FALSE;
        break;
    }
    
    return recode;
}


#endif

/*****************************************************************************/
//  Description : change url win
//  Global resource dependence : 
//  Author: 
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleBrowserChangeURLWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_LISTBOX_CTRL_ID;
    uint16 cur_selection = 0;
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        GUILIST_SetMaxItem(ctrl_id, MMISET_OPEN_CLOSE_ITEM, FALSE );//max item 2
        //GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
        MMIAPISET_AppendListItemByTextIdExt(TXT_OPEN_COMN, TXT_ENG_OK, TXT_NULL, TXT_ENG_RETURN, ctrl_id, GUIITEM_STYLE_1RADIO_ENG);
        MMIAPISET_AppendListItemByTextIdExt(TXT_COMM_CLOSE, TXT_ENG_OK, TXT_NULL, TXT_ENG_RETURN, ctrl_id, GUIITEM_STYLE_1RADIO_ENG);  
        
        if (MMIAPIENG_GetIsBrowserChangeURL())
        {
            cur_selection = 0;
        }
        else
        {
            cur_selection = 1;
        }
        
        //set selected item
        GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
        
        //set current item
        GUILIST_SetCurItemIndex(ctrl_id,cur_selection);
        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;    
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
        if (0 == cur_selection) //open
        {
            MMIAPIENG_SetIsBrowserChangeURL(TRUE);
        }
        else
        {
            MMIAPIENG_SetIsBrowserChangeURL(FALSE);            
        }
        MMK_CloseWin(win_id);
        break;        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

/*****************************************************************************/
//  Description : HandleBrowserLogWinMsg
//  Global resource dependence : 
//  Author: sally.he
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleBrowserLogWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_LISTBOX_CTRL_ID;
    uint16 cur_selection = 0;
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        GUILIST_SetMaxItem(ctrl_id,MMISET_OPEN_CLOSE_ITEM, FALSE );//max item 2
        //GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
        MMIAPISET_AppendListItemByTextIdExt(TXT_OPEN_COMN,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
        MMIAPISET_AppendListItemByTextIdExt(TXT_COMM_CLOSE,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);  
        
        if (MMIAPIENG_GetIsBrowserLogOn())
        {
            cur_selection = 0;
        }
        else
        {
            cur_selection = 1;
        }
        
        //set selected item
        GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
        
        //set current item
        GUILIST_SetCurItemIndex(ctrl_id,cur_selection);
        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;    
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
        if (0 == cur_selection) //open
        {
            MMIAPIENG_SetIsBrowserLogOn(TRUE);
        }
        else
        {
            MMIAPIENG_SetIsBrowserLogOn(FALSE);            
        }
        MMK_CloseWin(win_id);
        break;        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

/*****************************************************************************/
//  Description : open cardlog win
//  Global resource dependence : 
//  Author: bin.ji
//  Note: 
/*****************************************************************************/
PUBLIC void MMIAPIENG_OpenBrowserLogWin(void)
{
    MMK_CreateWin((uint32*)MMIENG_BROWSER_LOG_WIN_TAB, PNULL);
}

/*****************************************************************************/
//  Description : browser change url by wre
//  Global resource dependence : 
//  Author: 
//  Note: 
/*****************************************************************************/
PUBLIC void MMIAPIENG_OpenBrowserChangeURLWin(void)
{
    MMK_CreateWin((uint32*)MMIENG_BROWSER_CHANGE_URL_WIN_TAB, PNULL);
}

/*****************************************************************************/
//  Description : HandleScreenLogWinMsg
//  Global resource dependence : 
//  Author: James.Zhang
//  Note: 
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleScreenLogWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_LISTBOX_CTRL_ID;
    uint16 cur_selection = 0;
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        {
            wchar* off_wstr = L"OFF";
            wchar* debug_string_wstr = L"DEBUG STRING";
            wchar* debug_rect_wstr = L"DEBUG RECT";

            GUILIST_SetMaxItem(ctrl_id,MMIENG_SCREEN_DEBUG_MAX, FALSE );//max item 2
            //GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
            MMIAPISET_AppendListItemByTextBuffer(off_wstr, MMIAPICOM_Wstrlen( off_wstr ), 
                0,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG); 

            MMIAPISET_AppendListItemByTextBuffer(debug_string_wstr, MMIAPICOM_Wstrlen( debug_string_wstr ), 
                0,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
            
            MMIAPISET_AppendListItemByTextBuffer(debug_rect_wstr, MMIAPICOM_Wstrlen( debug_rect_wstr ), 
                0,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
            
            cur_selection = (uint16)MMIAPIENG_GetIsScreenLogOn();
            
            //set selected item
            GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
            
            //set current item
            GUILIST_SetCurItemIndex(ctrl_id,cur_selection);
            MMK_SetAtvCtrl(win_id,ctrl_id);
        }

        break;    
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        cur_selection = GUILIST_GetCurItemIndex(ctrl_id);

        MMIAPIENG_SetIsScreenLogOn( cur_selection );

        MMK_CloseWin(win_id);
        break;        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}
#ifdef MMISRV_AUDIO_TEST_SUPPORT
/*****************************************************************************/
// 	Description : Audio self test, play audio.
//	Global resource dependence : none
//  Author: Yintang.Ren
//	Note:
/*****************************************************************************/
LOCAL MMI_RESULT_E EngAudioSelfTestPlayHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
        //int32 index = 0;
        MMI_RESULT_E result = MMI_RESULT_TRUE;
        //int32 list_id = MMIENG_LISTBOX_CTRL_ID ;
        
        switch (msg_id) 
        {
        case MSG_OPEN_WINDOW:
            break;
            
        case MSG_FULL_PAINT:
            MMISRVAUD_TestDrawBg();
            break;      
            
        case MSG_KEYDOWN_CANCEL:
        case MSG_CTL_CANCEL:
            MMK_CloseWin(win_id);
            break;
            
        case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
        case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
        case MSG_KEYDOWN_OK:
        case MSG_CTL_OK:
        case MSG_APP_WEB:
            break;
        default:
            result = MMISRVAUD_TestHandleKey(win_id, msg_id, param);
            break;
        }
        return (result);     
}

/*****************************************************************************/
// 	Description : Audio self test, display audio info.
//	Global resource dependence : none
//  Author: Yintang.Ren
//	Note:
/*****************************************************************************/
LOCAL MMI_RESULT_E EngAudioSelfTestDisplayInfoHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
        int32 index = 0;
        MMI_RESULT_E result = MMI_RESULT_TRUE;
        int32 list_id = MMIENG_LISTBOX_CTRL_ID ;
        
        switch (msg_id) 
        {
        case MSG_OPEN_WINDOW:
            {
                GUILIST_ITEM_T      item_t = {0};
                GUILIST_ITEM_DATA_T item_data = {0};       
#ifdef PRINTSCREEN_SUPPORT
                GUIWIN_SetTitleTextId(win_id, TXT_ENG_AUDIO_DISPLAY_INFO, FALSE);
#endif
                GUILIST_SetMaxItem( list_id, 3, FALSE );
                GUILIST_SetOwnSofterKey(list_id,FALSE);
                
                item_t.item_style    = GUIITEM_STYLE_1RADIO_ENG;
                item_t.item_data_ptr = &item_data;
                
                item_data.item_content[0].item_data_type    = GUIITEM_DATA_TEXT_ID;    
                
                item_data.item_content[0].item_data.text_id = TXT_COMM_ON;    
                GUILIST_AppendItem( list_id, &item_t );
                
                item_data.item_content[0].item_data.text_id = TXT_COMM_OFF;    
                GUILIST_AppendItem( list_id, &item_t );
               
                GUILIST_SetSelectedItem( list_id, index, TRUE );
                GUILIST_SetCurItemIndex( list_id, index);          
                MMK_SetAtvCtrl(win_id, list_id);
            }
            break;
            
        case MSG_FULL_PAINT:
            break;      
            
        case MSG_KEYDOWN_CANCEL:
        case MSG_CTL_CANCEL:
            MMK_CloseWin(win_id);
            break;
            
        case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
        case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
        case MSG_KEYDOWN_OK:
        case MSG_CTL_OK:
        case MSG_APP_WEB:
            index = GUILIST_GetCurItemIndex(list_id);   
            switch(index)
            {
            case 0:
                MMISRVAUD_TestSetEnable(TRUE);
                MMK_CloseWin(win_id);
                break;
            case 1:
                MMISRVAUD_TestSetEnable(FALSE);
                MMK_CloseWin(win_id);
                break;
            default:
                break;
            }
            break;
            
        default:
            result = MMI_RESULT_FALSE;
            break;
        }
        return (result); 
}

/*****************************************************************************/
// 	Description : Audio self test.
//	Global resource dependence : none
//  Author: Yintang.Ren
//	Note:
/*****************************************************************************/
LOCAL MMI_RESULT_E EngAudioSelfTestHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
        int32 index = 0;
        MMI_RESULT_E result = MMI_RESULT_TRUE;
        int32 list_id = MMIENG_LISTBOX_CTRL_ID ;
        
        switch (msg_id) 
        {
        case MSG_OPEN_WINDOW:
            {
                GUILIST_ITEM_T      item_t = {0};
                GUILIST_ITEM_DATA_T item_data = {0};       

                GUIWIN_SetTitleTextId(win_id, TXT_ENG_AUDIO_SELF_TEST, FALSE);
                
                GUILIST_SetMaxItem( list_id, 2, FALSE );
                GUILIST_SetOwnSofterKey(list_id,FALSE);
                
                item_t.item_style    = GUIITEM_STYLE_1RADIO_ENG;
                item_t.item_data_ptr = &item_data;
                
                item_data.item_content[0].item_data_type    = GUIITEM_DATA_TEXT_ID; 
                item_data.item_content[0].item_data.text_id = TXT_ENG_AUDIO_PLAY;    
                GUILIST_AppendItem( list_id, &item_t );
                
            #ifdef PRINTSCREEN_SUPPORT
                item_data.item_content[0].item_data.image_id = IMAGE_NUMBER_2;
                item_data.item_content[1].item_data.text_id = TXT_ENG_AUDIO_DISPLAY_INFO;    
                GUILIST_AppendItem( list_id, &item_t );
            #endif
               
                GUILIST_SetSelectedItem( list_id, index, TRUE );
                GUILIST_SetCurItemIndex( list_id, index);          
                MMK_SetAtvCtrl(win_id, list_id);
            }
            break;
            
        case MSG_FULL_PAINT:
            break;      
            
        case MSG_KEYDOWN_CANCEL:
        case MSG_CTL_CANCEL:
            MMK_CloseWin(win_id);
            break;
            
        case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
        case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
        case MSG_KEYDOWN_OK:
        case MSG_CTL_OK:
        case MSG_APP_WEB:
            index = GUILIST_GetCurItemIndex(list_id);   
            switch(index)
            {
            case 0:
                MMK_CreateWin((uint32*)MMIENG_AUDIO_SELF_TEST_PLAY_TAB, PNULL);
                
                break;
        #ifdef PRINTSCREEN_SUPPORT        
            case 1:
#ifdef ENG_SUPPORT
                MMIENG_OpenListSelectWin((uint32)EngAudioSelfTestDisplayInfoHandleMsg);
#endif
                break;
        #endif
            default:
                break;
            }
            break;
            
        default:
            result = MMI_RESULT_FALSE;
            break;
        }
        return (result); 
}    

#endif


/*****************************************************************************/
//  Description : open screenlog win
//  Global resource dependence : 
//  Author: James.Zhang
//  Note: 
/*****************************************************************************/
PUBLIC void MMIAPIENG_OpenScreenLogWin(void)
{
    MMK_CreateWin((uint32*)MMIENG_SCREEN_LOG_WIN_TAB, PNULL);
}

#ifdef MMI_AUTOTEST_SUPPORT
/*****************************************************************************/
//  Description : open auto test set win
//  Global resource dependence : 
//  Author: hongbo.lan
//  Note: 
/*****************************************************************************/
PUBLIC void MMIAPIENG_OpenAutoTestSetWin(uint8 set_id)
{
    uint8* type_id_ptr = PNULL;
    
    if (set_id >=  MMI_AUTO_TEST_MAX)
    {
        return;
    }

    type_id_ptr = (uint8*)SCI_ALLOCA(sizeof(uint8));

    *type_id_ptr = set_id;
    MMK_CreateWin((uint32*)MMIENG_AUTOTEST_SET_WIN_TAB, (ADD_DATA)type_id_ptr);
}
#endif

/********************************************************************************
 NAME:			GetProductionInfoStr
 DESCRIPTION:	
 PARAM IN:		pd_buf - 
				buf_len - 
 PARAM OUT:		production info string len
 AUTHOR:		allen
 DATE:			2004.10.04
 modified by ying.xu,20100609
********************************************************************************/
LOCAL int32 GetProductionInfoStr(char* pd_buf, int32 buf_len)
{	
    int32 i = 0;
    int32 len1 = 0;
    int32 offset = 0;
    char num[8] = {0};    
    uint16 item_num = 0;
    int32 station_num = 0;
//     uint16 phase_length = sizeof(SP09_PHASE_CHECK_T);
    char *isTested[2] = {"Tested!", "Not Tested!"};
    char *isPassed[2] ={"Passed!", "Failed!"} ;
    
    uint8 temp_buffer[1025] = {0};
    int32 temp_buffer_lenght = 1024 ;
    
    int32 test_length[2] ={0};	
    int32 pass_length[2] = {0};

#ifndef WIN32
    SP09_PHASE_CHECK_T  s_mmieng_product = {0};    
#else
    SP09_PHASE_CHECK_T  s_mmieng_product  = {SP09_SPPH_MAGIC_NUMBER,
        "12345678901234567890123",
        "12345678901234567890123",
        15,
    {"123456789","234567891","345678912","456789123","567891234",
    "678912345","789123456","891234567","912345678","123456789",
    "234567891","345678912","456789123","567891234","678912345"},
    {0}, 0x01, {0},	0xf00f,0x0ff0 };
#endif
    
    test_length[0] = SCI_STRLEN(isTested[0]) ;
    test_length[1] = SCI_STRLEN(isTested[1]) ;
    pass_length[0] = SCI_STRLEN(isPassed[0]) ;
    pass_length[1] = SCI_STRLEN(isPassed[1]) ;        
    
    //read data from flash
#ifndef WIN32       
    if(0 == EFS_ReadPhaseCheck(temp_buffer,temp_buffer_lenght))
    {
        return 0;
    } 
    SCI_MEMCPY(&s_mmieng_product, temp_buffer, SP09_MAX_PHASE_BUFF_SIZE);   
#endif

#if defined(__BIG_ENDIAN) || defined(__BigEndian)	
    if(SP09_SPPH_MAGIC_NUMBER != CHANGE_ENDIAN_SEQUENCE_32(s_mmieng_product.Magic))
#else   
    if(SP09_SPPH_MAGIC_NUMBER != s_mmieng_product.Magic) 
#endif    
    {
        SCI_TRACE_LOW("MMIENG_WIN GetProductionInfoStr magic num = %x", s_mmieng_product.Magic); 
        
        len1 = sprintf((char*)temp_buffer,"error! magic num = %x\n",s_mmieng_product.Magic);
        offset += len1;
        SCI_MEMCPY(pd_buf, temp_buffer, len1);
        //return 0;
    }
        ////////////////
        //  S/N
        ////////////////
        MMI_MEMCPY(pd_buf + offset, buf_len - offset, "<S/N1>", 6, 6);
        offset += 6;
        pd_buf[offset] = CR_CHAR;
        offset += 1;
        len1 = MIN(SP09_MAX_SN_LEN,SCI_STRLEN(s_mmieng_product.SN1));/*lint !e666*/
        MMI_MEMCPY(pd_buf + offset, buf_len - offset, 
            s_mmieng_product.SN1, SP09_MAX_SN_LEN , len1);
        offset += len1;
        pd_buf[offset] = CR_CHAR;
        offset += 1;

//Michael: 这部分暂时处理成如下的方式，也是09A的处理方式
//逻辑分析上是应该有SN2/SN3/SN4等多卡信息的处理的
//但是，目前底层提供的只有SN1/SN2,因此，这部分还需要再讨论!!!
//待底层有SN3/SN4 的信息，再考虑优化这个多卡处理流程....
#ifndef MMI_MULTI_SIM_SYS_SINGLE
        MMI_MEMCPY(pd_buf + offset, buf_len - offset, "<S/N2>", 6, 6);
        offset += 6;
        pd_buf[offset] = CR_CHAR;
        offset += 1;
        len1 = MIN(SP09_MAX_SN_LEN,SCI_STRLEN(s_mmieng_product.SN2));/*lint !e666*/
        MMI_MEMCPY(pd_buf + offset, buf_len - offset, 
            s_mmieng_product.SN2, SP09_MAX_SN_LEN , len1);
        offset += len1;
        pd_buf[offset] = CR_CHAR;
        offset += 1;
#endif	
        
        
        ////////////////////////////
        //  station test result
        ////////////////////////////
        MMI_MEMCPY(pd_buf + offset, buf_len - offset, "<Station Result>", 16, 16);
        offset += 16;
        
 #if defined(__BIG_ENDIAN) || defined(__BigEndian)
        station_num = CHANGE_ENDIAN_SEQUENCE_32(s_mmieng_product.StationNum);
#else
        station_num = s_mmieng_product.StationNum;
#endif       
        for (i = 0; i <  station_num; i++)
        {
            pd_buf[offset] = CR_CHAR;
            offset += 1;
            
            //num		        
            SCI_MEMSET(num, 0 ,8);
            sprintf(num,"<%d> ",i+1);
            len1  = SCI_STRLEN(num);
            if(buf_len - offset < len1)
            {
                return offset;
            }
            MMI_MEMCPY(pd_buf + offset, buf_len - offset, num, 7, len1);		
            offset += len1;	
            
            //name          
            len1 = MIN(SP09_MAX_STATION_NAME_LEN, SCI_STRLEN(s_mmieng_product.StationName[i]));/*lint !e666*/
            if(buf_len - offset < len1)
            {
                return offset;
            }
            MMI_MEMCPY(pd_buf + offset, buf_len - offset, 
                s_mmieng_product.StationName[i], SP09_MAX_STATION_NAME_LEN, len1);
            offset += len1;

            if(buf_len - offset < 2)
            {
                return offset;
            }
            MMI_MEMCPY(pd_buf + offset, buf_len - offset, ": ", 2, 2);	
            offset += 2;

            // if tested
#if defined(__BIG_ENDIAN) || defined(__BigEndian)	
            item_num = (CHANGE_ENDIAN_SEQUENCE_16(s_mmieng_product.iTestSign) >> i) & (uint16)0x0001;
#else    
            item_num = (s_mmieng_product.iTestSign >> i) & (uint16)0x0001; 
#endif   
              if(s_mmieng_product.SignFlag == 0x00)
            {
                item_num = (~item_num)&(uint16)0x0001;
            }
            
            if(buf_len - offset < test_length[item_num])
            {
                return offset;
            }
            MMI_MEMCPY(pd_buf + offset, buf_len - offset, isTested[item_num],
                test_length[item_num], test_length[item_num]);
            
            offset += test_length[item_num];
            
            //if passed  
            if(item_num == 0)
            {
                MMI_MEMCPY(pd_buf + offset, buf_len - offset, ": ", 2, 2);		
                offset += 2;
#if defined(__BIG_ENDIAN) || defined(__BigEndian)	
                item_num = (CHANGE_ENDIAN_SEQUENCE_16(s_mmieng_product.iItem) >> i) & (uint16)0x0001;
#else     
                item_num = (s_mmieng_product.iItem >> i)&(uint16)0x0001;
#endif               
                if(s_mmieng_product.SignFlag == 0x00)
                {
                    item_num = (~item_num)&(uint16)0x0001;
                }
                
                if(buf_len - offset < pass_length[item_num])
                {
                    return offset;
                }
                MMI_MEMCPY(pd_buf + offset, buf_len - offset, isPassed[item_num],
                    pass_length[item_num],pass_length[item_num]);
                offset += pass_length[item_num];
            }
            
        }		// end of 	for (i = 0; i <  SP09_MAX_STATION_NUM; i++)
        
        return offset;
    //return 0;
}

LOCAL MMI_RESULT_E  HandleChiptestTpWinMsg (MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
     MMI_RESULT_E result = MMI_RESULT_TRUE;

    switch(msg_id)
    {
    case MSG_OPEN_WINDOW:      
        {
             GUI_RECT_T rect = MMITHEME_GetFullScreenRect();
             LCD_FillRect(MMITHEME_GetDefaultLcdDev(), rect, MMI_BACKGROUND_COLOR);    
         }
             MMIAPITP_COORDINATE_OpenWin(FALSE);
         
        break;
   
    case MSG_GET_FOCUS:
        MMK_CreateWin((uint32*)MMIENG_CHIP_TEST_PLAYMP3MP4_WIN_TAB, PNULL);
        MMK_CloseWin(win_id);
        break;  
        
    default:
        break;
    }      
    return result;
}

#ifdef MMI_WIFI_SUPPORT
/*****************************************************************************/
//  Description : 
//  Global resource dependence : 
//  Author: George.Liu
//  Note: 
/*****************************************************************************/
PUBLIC void MMIAPIENG_OpenWlanPerformanceModeWin(void)
{
    MMK_CreateWin((uint32*)MMIENG_WLAN_PERFORMANCE_MODE_WIN_TAB, 0);
}

/*****************************************************************************/
//  Description : open WIFI iperf  win
//  Global resource dependence : 
//  Author: YING.XU
//  Note: 
/*****************************************************************************/
PUBLIC void MMIAPIENG_OpenWifiIperfWin(void)
{
    MMK_CreateWin((uint32*)MMIENG_WIFI_IPERF_WIN_TAB, 0);
}

/*****************************************************************************/
//  Description : 
//  Global resource dependence : 
//  Author: George.Liu
//  Note: 
/*****************************************************************************/
PUBLIC void MMIAPIENG_OpenWlanRadioFrequencyWin(void)
{
    MMK_CreateWin((uint32*)MMIENG_WLAN_RADIO_FREQUENCY_WIN_TAB, 0);
}
#endif

// SUPPORT_STANDBY_RECORD
PUBLIC void MMIENG_OpenStandbyInfoWin(void)
{    
    MMK_CreateWin((uint32*)MMIENG_STANDBY_TIME_INFO_TAB,PNULL);
}

/*******************************************************************************/
// NAME:			StandbyTimeInfoWinHandleMsg
//DESCRIPTION:	
// PARAM IN:		win_id - 
//				msg_id - 
//				param - 
// PARAM OUT:		
//AUTHOR:	Rex.Yang	
// DATE:	
/*******************************************************************************/
LOCAL MMI_RESULT_E StandbyTimeInfoWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E  result = MMI_RESULT_TRUE;
    MMI_STRING_T  standbyTimeInfoStr={0};
    MMI_CTRL_ID_T ctrl_id=MMIENG_TEXTBOX1_CTRL_ID;
    uint32 standby_startTime,standby_time;
    uint16 s_day,s_hour,s_minute,s_second,t_minute;
    uint32 t_hour;
    STANDBY_RECORD_T standbyInfo={0};
    uint32 nv_id = MMIENG_NV_POWERON_TIME_ID;
    uint8 char_str[128]={0};
    wchar char_wstr[128]={0};
    const uint32 buffer_length = 127;

#define MMIENG_SIXTY_RADIX          60
#define MMIENG_HOUR_PER_DAY      24
    
    switch(msg_id)
    {
    case MSG_OPEN_WINDOW:
      MMI_ReadNVItem(nv_id , &standbyInfo);
            standby_startTime=standbyInfo.standbyStartTime;
            standby_time=standbyInfo.standbytime;
            s_day=standbyInfo.startDay;
        //SCI_TRACE_LOW:"standby_start:%lu standby_time:%lu\n"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_16729_112_2_18_2_18_15_211,(uint8*)"uu",standby_startTime,standby_time);
        
        s_second=(uint16)(standby_startTime%MMIENG_SIXTY_RADIX);
        standby_startTime=standby_startTime/MMIENG_SIXTY_RADIX;
        s_minute=(uint16)(standby_startTime%MMIENG_SIXTY_RADIX);
        standby_startTime=standby_startTime/MMIENG_SIXTY_RADIX;
        s_hour=(uint16)(standby_startTime%MMIENG_HOUR_PER_DAY);
        standby_startTime=standby_startTime/MMIENG_HOUR_PER_DAY;

		MMI_ReadNVItem(MMIENG_NV_STANDBY_TIME_ID , &standby_time);
        standby_time=standby_time/MMIENG_SIXTY_RADIX;
        t_minute=(uint16)(standby_time%MMIENG_SIXTY_RADIX);
        t_hour=standby_time/MMIENG_SIXTY_RADIX;
        
        //SCI_TRACE_LOW:"s_d:%u s_h:%u s_m:%u s_s:%u t_h:%lu t_m:%un"
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_16742_112_2_18_2_18_15_212,(uint8*)"uuuuuu",s_day,s_hour,s_minute,s_second,t_hour,t_minute);
        sprintf((char *)char_str,"start(DHMS):%u:%u:%u:%u\nstandby(HM):%lu:%u",s_day,
            s_hour,s_minute,s_second,t_hour,t_minute);
        standbyTimeInfoStr.wstr_ptr=char_wstr;
        standbyTimeInfoStr.wstr_len=/*min*/(strlen((char *)char_str) < buffer_length ? strlen((char *)char_str) : buffer_length);
        MMI_STRNTOWSTR(standbyTimeInfoStr.wstr_ptr,buffer_length,\
            char_str,buffer_length,(uint32)standbyTimeInfoStr.wstr_len);
        GUITEXT_SetString(ctrl_id,standbyTimeInfoStr.wstr_ptr,standbyTimeInfoStr.wstr_len,FALSE);
        
        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;
    case MSG_FULL_PAINT:
        break;
    case MSG_APP_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB: 
    case MSG_CTL_MIDSK:
    case MSG_CTL_CANCEL:
    case MSG_APP_CANCEL:
        MMK_CloseWin(win_id);
        break;
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    
    return result;
}

/**********************************************************************************/
//  Description : record standby time file init
//  Global resource dependence : 
//  Author: ying.xu
//  Note:
/**********************************************************************************/
PUBLIC void MMIENG_RecordStandbyInit(void)
{
    STANDBY_RECORD_T standby = {0};
    SCI_DATE_T startDay;
    uint32 nv_id = MMIENG_NV_POWERON_TIME_ID;
    MN_RETURN_RESULT_E error= 0;
    
    error = MMI_ReadNVItem(nv_id, &standby);    
    //SCI_TRACE_LOW:"MMIENG_WIN.C MMIENG_RecordStandbyInit MMI_ReadNVItem = %d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_16783_112_2_18_2_18_15_213,(uint8*)"d",error);
    //SCI_TRACE_LOW:"MMIENG_WIN.C MMIENG_RecordStandbyInit ENALBE = %d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_16784_112_2_18_2_18_15_214,(uint8*)"d",standby.standbyEn);
    
    if(1 == standby.standbyEn)
    {
        TM_GetSysDate(&startDay);
        standby.standbyStartTime = TM_GetTotalSeconds();
        standby.startDay = startDay.mday;
        MMI_WriteNVItem( nv_id,  &standby );      
        Power_RegFunCalculateStandby(MMI_CalculateStandbyTime2File);
    }				
    return;
}

/**********************************************************************************/
//  Description : MMI_CalculateStandbyTime2File
//  Global resource dependence : 
//  Author: ying.xu
//  Note:
/**********************************************************************************/
LOCAL void MMI_CalculateStandbyTime2File(void)
{
    STANDBY_RECORD_T standby = {0};
    uint32 standbyEndTime=0;
    uint32 nv_id = MMIENG_NV_POWERON_TIME_ID;
    MN_RETURN_RESULT_E error = 0;
    error = MMI_ReadNVItem(nv_id, &standby);    
    //SCI_TRACE_LOW:"MMIENG_WIN.C MMI_CalculateStandbyTime2File MMI_ReadNVItem = %d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_16808_112_2_18_2_18_15_215,(uint8*)"d",error);
    standbyEndTime=TM_GetTotalSeconds();
    if(((standbyEndTime>standby.standbyStartTime)&&(0==standby.standbytime))&&\
        ((0!=standby.standbyStartTime)&&(1==standby.standbyEn)))
    {
        standby.standbytime=standbyEndTime-standby.standbyStartTime;
        MMI_WriteNVItem(nv_id , &standby);
    }
    return;
}

/**********************************************************************************/
//  Description : MMI_EnableAndResetStanbyRecord
//  Global resource dependence : 
//  Author: ying.xu
//  Note:
/**********************************************************************************/
PUBLIC void MMIENG_EnableAndResetStanbyRecord(uint32 enable)
{
    STANDBY_RECORD_T standby = {0};
    uint32 nv_id = MMIENG_NV_POWERON_TIME_ID;
    standby.standbyEn = enable;
    if(1 != enable)
    {
        Power_RegFunCalculateStandby(SCI_NULL);
    }
    MMI_WriteNVItem(nv_id , &standby);
}

/**********************************************************************************/
//  Description : MMIENG_GetStanbyRecordEnableState
//  Global resource dependence : 
//  Author: ying.xu
//  Note:
/**********************************************************************************/
PUBLIC uint32 MMIENG_GetStanbyRecordEnableState(void)
{
    STANDBY_RECORD_T standby = {0};
    uint32 nv_id = MMIENG_NV_POWERON_TIME_ID;	
    MMI_ReadNVItem(nv_id , &standby);
    return standby.standbyEn;
}


//end SUPPORT_STANDBY_RECORD


/********************************************************************************
 NAME:			MMIENG_OpenGetFlashInfoWin
 DESCRIPTION:	
 PARAM IN:		win_id - 
				msg_id - 
				param - 
 PARAM OUT:		
 AUTHOR:		ying.xu
 DATE:			
********************************************************************************/
PUBLIC void MMIENG_OpenGetFlashInfoWin(void)
{
	MMK_CreateWin((uint32*)MMIENG_GET_FLASH_INFO_WIN_TAB, PNULL);
}

/********************************************************************************
 NAME:			EngGetFlashInfoWinHandleMsg
 DESCRIPTION:	
 PARAM IN:		win_id - 
				msg_id - 
				param - 
 PARAM OUT:		
 AUTHOR:		ying.xu
 DATE:			
********************************************************************************/
LOCAL MMI_RESULT_E EngGetFlashInfoWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E 			result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T   		textbox_id = MMIENG_TEXTBOX1_CTRL_ID;
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:   
		{
			uint32 manufactor_id = 0;
			uint32 device_id = 0;
			uint32 extend_id = 0;
			char   str[128] = {0};
			wchar  wstr[128] = {0};
			uint32 buf_length = 127;	
			uint32 str_length = 0;
			uint32 offset = 0;
			MMI_STRING_T text = {0};
#ifndef WIN32
			PROD_GetFlashID(&manufactor_id, &device_id, &extend_id);
#endif			
			str_length = sprintf(&str[offset],"Manufacture ID:%x\n", manufactor_id);
			offset += str_length;
			str_length = sprintf(&str[offset],"Device ID:%x\n", device_id);
			offset += str_length;
			str_length = sprintf(&str[offset],"Extend ID:%x", extend_id);
			offset += str_length;
			MMI_STRNTOWSTR(wstr, buf_length, (uint8*)str,  offset, offset);
			text.wstr_ptr = wstr;
			text.wstr_len = offset; 
			GUITEXT_SetString(textbox_id , text.wstr_ptr, text.wstr_len, FALSE );
			}
        MMK_SetAtvCtrl(win_id, textbox_id);
        break;
        
    case MSG_FULL_PAINT:
        break;
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:	
        MMK_CloseWin(win_id);
        break;
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    
    return (result);
}

/********************************************************************************
NAME:			MMIENG_OpenuUpdateIMEIWin
DESCRIPTION:	
PARAM IN:		
PARAM OUT:		
AUTHOR:		ying.xu
********************************************************************************/
PUBLIC void MMIENG_OpenuUpdateIMEIWin(void)
{
    MMK_CreateWin((uint32*)MMIENG_UPDATE_IMEI_WIN_TAB, PNULL);
}

LOCAL NV_ITEM_ID_E GetImeiId(
                            MN_DUAL_SYS_E     dual_sys       //IN:
                            )
{
    NV_ITEM_ID_E    nv_id = NV_IMEI;
    switch (dual_sys)
    {
    case MN_DUAL_SYS_1:
        nv_id = NV_IMEI;
        break;
#if defined MULTI_SIM_SYS_DUAL || defined MULTI_SIM_SYS_TRI || defined MULTI_SIM_SYS_QUAD
    case MN_DUAL_SYS_2:
        nv_id = NV_IMEI1;
        break;
#endif
        
#if defined MULTI_SIM_SYS_TRI || defined MULTI_SIM_SYS_QUAD
    case MN_DUAL_SYS_3:
        nv_id = NV_IMEI2;
        break;
#endif
#if defined MMI_DUAL_SIM_SYS_QUAD
    case MN_DUAL_SYS_4:
        nv_id = NV_IMEI3;
        break;
#endif

    default:
        break;
    }
    return (nv_id);
}

/********************************************************************************
NAME:			EngGetFlashInfoWinHandleMsg
DESCRIPTION:	
PARAM IN:		win_id - 
msg_id - 
param - 
PARAM OUT:		
AUTHOR:		ying.xu
DATE:			
********************************************************************************/
LOCAL BOOLEAN ReadIMEINum(MN_DUAL_SYS_E dual_sys, uint8 *pbuf, uint32 buffer_length)
{
    uint16  nv_id = NV_IMEI;
    int32 error = 0;
    
    nv_id =  GetImeiId(dual_sys);
    //SCI_ASSERT(buffer_length >= MN_MAX_IMEI_LENGTH);/*assert verified*/		
    if(buffer_length < MN_MAX_IMEI_LENGTH)
    {
        return  FALSE;
    }
    error = EFS_NvitemRead(nv_id, MN_MAX_IMEI_LENGTH, pbuf);	
    
    //SCI_TRACE_LOW:"MMIENG_WIN ReadIMEINum EFS_NvitemRead error = %d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_16992_112_2_18_2_18_16_216,(uint8*)"d", error);
    return error == 0 ?TRUE:FALSE;	
}

LOCAL BOOLEAN WriteIMEINum(MN_DUAL_SYS_E dual_sys, uint8 *pbuf, uint32 buffer_length)
{
    NV_ITEM_ID_E    nv_id = NV_IMEI;
    int32 error = 0;    
    nv_id =  GetImeiId(dual_sys);
    error = EFS_NvitemWrite(nv_id, MN_MAX_IMEI_LENGTH, pbuf, FALSE);	
    //SCI_TRACE_LOW:"MMIENG_WIN ReadIMEINum EFS_NvitemRead error = %d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIENG_WIN_17002_112_2_18_2_18_16_217,(uint8*)"d", error);
    return error == 0 ?TRUE:FALSE;	
}

LOCAL BOOLEAN ConvertIMEICode2Num(char *dst,  uint32 dst_length, uint8 *src, uint32 src_length)
{
    int32 i = 0;
    char tmp_buf1[MN_MAX_IMEI_LENGTH*2 + 1] = {0};
    for (i = 0; i < MN_MAX_IMEI_LENGTH; i++) 
    {
        tmp_buf1[2 * i] = (src[i]) & 0x0F;
        tmp_buf1[2 * i + 1] = src[i] >> 4;
    }
    sprintf(    dst,
        "%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x",
        tmp_buf1[0],tmp_buf1[1], tmp_buf1[2], tmp_buf1[3],
        tmp_buf1[4], tmp_buf1[5], tmp_buf1[6], tmp_buf1[7],
        tmp_buf1[8], tmp_buf1[9], tmp_buf1[10], tmp_buf1[11],
        tmp_buf1[12], tmp_buf1[13], tmp_buf1[14], tmp_buf1[15]
        );
    return TRUE;
}

LOCAL BOOLEAN ConvertNum2IMEICode(uint8 *dst,  uint32 dst_length, char *src, uint32 src_length)
{
    int32 i = 0;
    uint8 tmp_buf1[MN_MAX_IMEI_LENGTH*2 + 1] = {0};
    tmp_buf1[0] = 0xA;
    for (i = 0; i < src_length; i++) /*lint !e574 !e737*/
    {
        tmp_buf1[i+1] = (uint8) ( (src[i]>= 'A') ? src[i] - 'A' + 10 : src[i] - '0');
    }
    for (i = 0; i < MN_MAX_IMEI_LENGTH; i++) 
    {
        dst[i] = (tmp_buf1[2 * i] & 0x0f) | ((tmp_buf1[2 * i + 1] << 4) & 0Xf0);
    }
    return TRUE;
}

/********************************************************************************
NAME:			EngGetFlashInfoWinHandleMsg
DESCRIPTION:	
PARAM IN:		win_id - 
msg_id - 
param - 
PARAM OUT:		
AUTHOR:		ying.xu
DATE:			
********************************************************************************/
LOCAL BOOLEAN UpateIMEIListData(MMI_WIN_ID_T win_id, MMI_CTRL_ID_T  list_id)
{
    int32 i = 0;
    GUILIST_ITEM_T      item_t = {0};
    GUILIST_ITEM_DATA_T item_data = {0};
    uint8 imei_buffer[MN_MAX_IMEI_LENGTH + 1] = {0};    
    char num_buffer[MN_MAX_IMEI_LENGTH*2 + 1] = {0};
    wchar wbuffer[MN_MAX_IMEI_LENGTH*2 + 1] = {0};
    uint16  length = 0;
    
    GUILIST_SetMaxItem(list_id, MMI_DUAL_SYS_MAX, FALSE );//max item 3
    GUILIST_RemoveAllItems(list_id );
    item_t.item_style    = GUIITEM_STYLE_ONE_LINE_TEXT;
    item_t.item_data_ptr = &item_data;
    
    for(i = 0; i < MMI_DUAL_SYS_MAX; i++)
    {
        SCI_MEMSET(imei_buffer, 0, MN_MAX_IMEI_LENGTH);
        SCI_MEMSET(num_buffer, 0, MN_MAX_IMEI_LENGTH*2);
        SCI_MEMSET(wbuffer, 0, MN_MAX_IMEI_LENGTH*2);
        ReadIMEINum(MN_DUAL_SYS_1  + i, imei_buffer, MN_MAX_IMEI_LENGTH);
        
        ConvertIMEICode2Num(num_buffer, MN_MAX_IMEI_LENGTH*2,imei_buffer, MN_MAX_IMEI_LENGTH);
        item_data.item_content[0].item_data_type = GUIITEM_DATA_TEXT_BUFFER;  
        length =  strlen((char*)num_buffer)-1;
        item_data.item_content[0].item_data.text_buffer.wstr_len= length;
        item_data.item_content[0].item_data.text_buffer.wstr_ptr = wbuffer;
        
        MMI_STRNTOWSTR(wbuffer, MN_MAX_IMEI_LENGTH*2, (const uint8*)&num_buffer[1], MN_MAX_IMEI_LENGTH*2-1,length);
        
        GUILIST_AppendItem( list_id, &item_t );    
    }
    return TRUE;
}


/********************************************************************************
NAME:			EngGetFlashInfoWinHandleMsg
DESCRIPTION:	
PARAM IN:		win_id - 
msg_id - 
param - 
PARAM OUT:		
AUTHOR:		ying.xu
DATE:			
********************************************************************************/
LOCAL MMI_RESULT_E EngUpdateIMEIWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E            result = MMI_RESULT_TRUE;    
    uint16                  index = 0;
    MMI_CTRL_ID_T           list_id = MMIENG_LISTBOX_CTRL_ID;
    //MMI_STRING_T            str = {0};
    //uint16                  str_length = 0;
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        UpateIMEIListData(win_id, list_id);
        MMK_SetAtvCtrl(win_id, list_id);
        break;
        
    case MSG_GET_FOCUS:
        UpateIMEIListData(win_id, list_id);
        break;
    case MSG_FULL_PAINT:
        break;
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
        
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_MIDSK:
    case MSG_APP_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        index = GUILIST_GetCurItemIndex(list_id);
        MMK_CreateWin((uint32*)MMIENG_UPDATE_IMEI_EDIT_WIN_TAB, (ADD_DATA)index);
        break;
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    
    return (result);
}

#if 0
//yangyu add begin // MMI_IMEI_EDIT_FUNC 
LOCAL BOOLEAN ConvertNum2IMEICode_Y(uint8 *dst,  uint32 dst_length, char *src, uint32 src_length)
{
    int32 i = 0;
    uint8 tmp_buf1[MN_MAX_IMEI_LENGTH*2 + 1] = {0};
    uint8 moveIndex = 1;
    
    for (i = 0; i < src_length; i++) /*lint !e574 !e737*/
    {
        //tmp_buf1[1 + i] = atoi(&src[i]);
        tmp_buf1[i] = src[i] - '0';
    }
    for (i = 0; i < MN_MAX_IMEI_LENGTH; i++) 
    {
        //dst[i] = (tmp_buf1[2 * i] & 0x0f) | ((tmp_buf1[2 * i + 1] << 4) & 0Xf0);
        //SCI_TRACE_LOW("MMIENG_UpdateNewImei = %x", dst[i]);
        if(i == 0 )
        {
            dst[i] =  ((tmp_buf1[2 * i] << 4) & 0Xf0);
        }
        else
        {
            dst[i] = (tmp_buf1[2 * i-1] & 0x0f) | ((tmp_buf1[2 * i] << 4) & 0Xf0);
        }
    }
    return TRUE;
}

PUBLIC BOOLEAN MMIENG_UpdateNewImei(uint8 *imeiStr)
{
    BOOLEAN ret = FALSE;
    uint8 imei_buffer[MN_MAX_IMEI_LENGTH + 1] = {0};
    char num_buffer[2*MN_MAX_IMEI_LENGTH + 1] = {0}; 
    SCI_TRACE_LOW("MMIENG_UpdateNewImei = %s", imeiStr);
    if(imeiStr == NULL || strlen(imeiStr) != 15)
    
{
        SCI_TRACE_LOW("MMIENG_UpdateNewImei error");
        return ret;
    }
    
    SCI_MEMCPY(num_buffer, imeiStr, 15);//have bug
    //SCI_MEMCPY(num_buffer+1, imeiStr, 15);
    ConvertNum2IMEICode_Y(imei_buffer,  MN_MAX_IMEI_LENGTH, num_buffer, strlen(imeiStr));
    if(WriteIMEINum(0 , imei_buffer,  MN_MAX_IMEI_LENGTH))
    {
        ret = TRUE;
    }
    
    SCI_TRACE_LOW("MMIENG_UpdateNewImei ret = %d", ret);
    return ret;

}
//yangyu end
#endif


/********************************************************************************
NAME:			EngGetFlashInfoWinHandleMsg
DESCRIPTION:	
PARAM IN:		win_id - 
msg_id - 
param - 
PARAM OUT:		
AUTHOR:		ying.xu
DATE:			
********************************************************************************/
LOCAL MMI_RESULT_E EngUpdateIMEIEditWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E            result = MMI_RESULT_TRUE;    
    uint32                  index = MMK_GetWinAddDataPtr(win_id );/*lint !e64*/    
    MMI_CTRL_ID_T           ctrl_id = MMIENG_EDITBOX1_CTRL_ID;
    MMI_STRING_T            str = {0};
    //uint16                  str_length = 0;
    uint8 imei_buffer[MN_MAX_IMEI_LENGTH + 1] = {0};
    char num_buffer[2*MN_MAX_IMEI_LENGTH + 1] = {0};    
    wchar wbuffer[MN_MAX_IMEI_LENGTH*2 + 1] = {0};
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        {
            ReadIMEINum(index , imei_buffer,  MN_MAX_IMEI_LENGTH);      
            ConvertIMEICode2Num(num_buffer,  MN_MAX_IMEI_LENGTH*2, imei_buffer, MN_MAX_IMEI_LENGTH);
            str.wstr_len= strlen((char*)num_buffer)-1;
            MMI_STRNTOWSTR(wbuffer, MN_MAX_IMEI_LENGTH*2, (const uint8*)&num_buffer[1], MN_MAX_IMEI_LENGTH*2-1,str.wstr_len);
            str.wstr_ptr = wbuffer;
            GUIEDIT_SetString(ctrl_id,  str.wstr_ptr, str.wstr_len);
            /*add for bug110091:*/
            //GUIEDIT_SetIm(ctrl_id, GUIIM_TYPE_ABC|GUIIM_TYPE_DIGITAL, GUIIM_TYPE_ABC);/*lint !e655*/   
            GUIEDIT_SetIm(ctrl_id, GUIIM_TYPE_DIGITAL, GUIIM_TYPE_DIGITAL);
            /*end bug110091*/
            MMK_SetAtvCtrl(win_id, ctrl_id);
        }
        break;
        
    case MSG_FULL_PAINT:
        break;
        
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
       //// MMK_CloseWin(win_id); // wuxx del
       //// break;
        
    case MSG_APP_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:    
    case MSG_CTL_MIDSK:
        GUIEDIT_GetString(ctrl_id, &str);
        MMI_WSTRNTOSTR((uint8*)num_buffer, MN_MAX_IMEI_LENGTH*2, str.wstr_ptr, str.wstr_len,str.wstr_len); 
        ConvertNum2IMEICode(imei_buffer,  MN_MAX_IMEI_LENGTH, num_buffer, str.wstr_len);
        if(WriteIMEINum(index , imei_buffer,  MN_MAX_IMEI_LENGTH))
        {
            MMK_CloseWin(win_id);
        }
        else       
        {
            MMIPUB_OpenAlertWinByTextId(PNULL,TXT_ERROR,
                TXT_NULL,IMAGE_PUBWIN_FAIL,PNULL,PNULL,MMIPUB_SOFTKEY_ONE,PNULL);
        }
        break;
        
#ifdef MMI_PDA_SUPPORT
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
        if (PNULL != param)
        {
            uint32 src_id = ((MMI_NOTIFY_T*)param)->src_id;
            
            switch (src_id)
            {
            case MMICOMMON_BUTTON_SOFTKEY_LEFT_CTRL_ID:
                MMK_SendMsg(win_id, MSG_APP_OK, PNULL);
                break;
            case MMICOMMON_BUTTON_SOFTKEY_RIGHT_CTRL_ID:
                MMK_SendMsg(win_id, MSG_APP_CANCEL, PNULL);
                break;
            default:
                break;
            }
        }
        break;
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
#endif
        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    
    return (result);
}

#else   //if define ENG_SUPPORT

static MMI_STRING_T s_mmieng_show3result_text1 = {0};
static MMI_STRING_T s_mmieng_show3result_text2 = {0};
static MMI_STRING_T s_mmieng_show3result_text3 = {0};

/********************************************************************************
 NAME:          MMIAPIENG_BandSelectCnf
 DESCRIPTION:   
 PARAM IN:      None 
 PARAM OUT:     None
 AUTHOR:        songbin.zeng
 DATE:          2006.11.16
********************************************************************************/
PUBLIC void MMIAPIENG_BandSelectCnf(DPARAM  param)
{

}

/*****************************************************************************/
//  Description : start chip test
//  Global resource dependence : 
//  Author: ryan.xu
//  Note: 
/*****************************************************************************/
PUBLIC void MMIENGAPI_StartChipTest(void)
{

}

/*****************************************************************************/
//  Description : MMIAPIENG_OpenIQDataWin
//  Global resource dependence : 
//  Author: wancan.you
//  Note: 
/*****************************************************************************/
PUBLIC void MMIAPIENG_OpenIQDataWin(void)
{

}

/*****************************************************************************/
//  Description : MMIAPIENG_AlertIQMode
//  Global resource dependence : 
//  Author: wancan.you
//  Note: 
/*****************************************************************************/
PUBLIC void MMIAPIENG_AlertIQMode(void)
{
}

/*****************************************************************************/
//  Description : Open IQ Data Query Win
//  Global resource dependence :                                
//      Author: wancan.you
//  Note:
/*****************************************************************************/
PUBLIC BOOLEAN MMIAPIENG_OpenHandleIQDataQueryWin(BOOLEAN is_succeed)
{
    return FALSE;
}

/*****************************************************************************/
//  Description : is arm log on when power on
//  Global resource dependence :                                
//      Author: wancan.you
//  Note:
/*****************************************************************************/
PUBLIC BOOLEAN MMIAPIENG_IsUSBLOGON(void)
{
    return FALSE;
}

/*****************************************************************************/
//  Description : is eng band select cmd
//  Global resource dependence : 
//  Author: jian.ma
//  Note: 
/*****************************************************************************/
PUBLIC BOOLEAN MMIAPIENG_IsBandSelectWinOpen(void)
{
    return FALSE;
}


/********************************************************************************
 NAME:          MMIEng_SetResultWinText
 DESCRIPTION:   
 PARAM IN:      txt1 - 
                txt2 - 
                txt3 - 
 PARAM OUT:     None
 AUTHOR:        allen
 DATE:          2004.09.10
********************************************************************************/
PUBLIC void MMIEng_SetResultWinText(MMI_STRING_T txt1, MMI_STRING_T txt2, MMI_STRING_T txt3)
{
}
#endif//ENG_SUPPORT

/********************************************************************************
 NAME:          MMIENGWIN_OpenNVCountingWin
 DESCRIPTION:   
 PARAM IN:      
 PARAM OUT:     
 AUTHOR:        ying.xu
 DATE:      0   2010.08.17
********************************************************************************/
PUBLIC BOOLEAN MMIENGWIN_OpenNVCountingWin(void)
{
#ifdef ENG_SUPPORT
     MMK_CreateWin((uint32*)MMIENG_NV_COUNTING_WIN_TAB, PNULL);
#endif
#ifdef MMI_SAVE_RUNING_NV_INFO
     MMI_GetAllModuleSumNvSize();
#endif
     return TRUE;
}

#ifdef ENG_SUPPORT
/*****************************************************************************/
//  Description : start HandleRunningNVCountingWinMsg for pc link
//  Global resource dependence : none
//  Author: ying.xu
//  Note:   2010.08.17
/*****************************************************************************/
LOCAL uint32 GetRunningNVCountingInfo(char *buffer, uint32 buffer_lengh)
{
    char tmp_buf[128] = {0};
    uint32 tmp_buf_length = 127;    
    uint32 offset = 0;

    uint32 str_length = 0;
    uint32 i = 0;
    
    i = MMI_GetAllNVSize();
    SCI_MEMSET(tmp_buf, 0 ,tmp_buf_length + 1) ;
    sprintf(tmp_buf, "All running NV size: %d KB\n", i);    
    str_length = SCI_STRLEN(tmp_buf) ;
    if( offset + str_length > buffer_lengh )
    {
        return offset ;
    }
    SCI_MEMCPY(buffer + offset , tmp_buf,  str_length );
    offset += str_length;
    
    i = MMI_GetAllModuleSumNvSize() ;
    SCI_MEMSET(tmp_buf, 0 ,tmp_buf_length + 1) ;
    sprintf(tmp_buf, "MMI running NV size: %d KB\n", i);    
    str_length = SCI_STRLEN(tmp_buf) ;
    if( offset + str_length > buffer_lengh )
    {
        return offset ;
    }
    SCI_MEMCPY(buffer + offset , tmp_buf,  str_length );
    offset += str_length;
    
    i = MMI_GetAllMMINVItem();
    SCI_MEMSET(tmp_buf, 0 ,tmp_buf_length + 1) ;
    sprintf(tmp_buf, "MMI running NV item num: %d \n", i);
    str_length = SCI_STRLEN(tmp_buf) ;
    if( offset + str_length > buffer_lengh )
    {
        return offset ;
    }
    SCI_MEMCPY(buffer + offset , tmp_buf,  str_length );
    offset += str_length;
#if 0   
    i= MMI_GetFlashSecterSize() ;
    SCI_MEMSET(tmp_buf, 0 ,tmp_buf_length + 1) ;
    sprintf(tmp_buf, "Flash sector size: %d KB\n", i);
    str_length = SCI_STRLEN(tmp_buf) ;
    if( offset + str_length > buffer_lengh )
    {
        return offset ;
    }
    SCI_MEMCPY(buffer + offset , tmp_buf,  str_length );
    offset += str_length;
    
    i = MMI_GetMinimumNVConfig();
    SCI_MEMSET(tmp_buf, 0 ,tmp_buf_length + 1) ;
    sprintf(tmp_buf, "Minimum requried sector num: %d \n", i);
    str_length = SCI_STRLEN(tmp_buf) ;
    if( offset + str_length > buffer_lengh )
    {
        return offset ;
    }
    SCI_MEMCPY(buffer + offset , tmp_buf,  str_length );
    offset += str_length;
    
    i = MMI_GetOptimumNVConfig() ;
    SCI_MEMSET(tmp_buf, 0 ,tmp_buf_length + 1) ;
    sprintf(tmp_buf, "Optimum requried sector num: %d ", i);
    str_length = SCI_STRLEN(tmp_buf) ;
    if( offset + str_length > buffer_lengh )
    {
        return offset ;
    }
    SCI_MEMCPY(buffer + offset , tmp_buf,  str_length );
    offset += str_length;
#endif
    return offset  ;
}

/*****************************************************************************/
//  Description : start HandleRunningNVCountingWinMsg for pc link
//  Global resource dependence : none
//  Author: ying.xu
//  Note:   2010.08.17
/*****************************************************************************/
LOCAL MMI_RESULT_E HandleRunningNVCountingWinMsg(
                                                 MMI_WIN_ID_T    win_id,    // 窗口的ID
                                                 MMI_MESSAGE_ID_E   msg_id,     // 窗口的内部消息ID
                                                 DPARAM             param       // 相应消息的参数
                                                 )
{
    
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        {           
            wchar wstr[1024] = {0};
            char str[1024] = {0};
            uint32 buffer_length = 1023;
            uint32 str_length = 0;
            str_length = GetRunningNVCountingInfo(str, buffer_length) ;
    
            MMI_STRNTOWSTR( wstr, buffer_length, (uint8*)str, str_length, str_length );         
    
        GUITEXT_SetString(MMIENG_NV_COUNTING_TEXTBOX_CTRL_ID,  wstr,  str_length, FALSE);
        MMK_SetAtvCtrl(win_id,  MMIENG_NV_COUNTING_TEXTBOX_CTRL_ID);
        }
        break;
        
    case MSG_FULL_PAINT:
        break;
        
    case MSG_APP_WEB:       
    case MSG_KEYDOWN_OK:
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_MIDSK:
    case MSG_CTL_OK:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}
#endif

#ifdef WRE_SUPPORT
/*****************************************************************************/
//  Description : EngShowWREVersionWinHandleMsg
//  Global resource dependence : none
//  Author: juan.wu
//  Note:   
/*****************************************************************************/
LOCAL MMI_RESULT_E EngShowWREVersionWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    char   * str_ptr    = PNULL;
    uint16          str_len = 0;
    uint16           uint16_str[MMIENG_WRE_VER_MAX_LEN +1] = {0};
    uint16          uint16_str_len = 0;

    switch(msg_id)
    {
    case MSG_OPEN_WINDOW:
        MMK_SetAtvCtrl(win_id, MMIENG_SHOW_WRE_VERSION_CTRL_ID);
        str_ptr = MMIWRE_GetVersionInfo();
        str_len = SCI_STRLEN((char*)str_ptr);
        str_len = MIN(str_len,MMIENG_WRE_VER_MAX_LEN);
        MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)str_ptr, str_len );
        GUITEXT_SetString(MMIENG_SHOW_WRE_VERSION_CTRL_ID, uint16_str, uint16_str_len, FALSE);
        break;

#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#if defined MMI_PDA_SUPPORT
        {
            MMI_CTRL_ID_T ctrl_id = ((MMI_NOTIFY_T*) param)->src_id;
            if( MMICOMMON_BUTTON_SOFTKEY_LEFT_CTRL_ID == ctrl_id)
            {
                MMK_SendMsg(win_id, MSG_APP_OK, PNULL);
            }
            else if( MMICOMMON_BUTTON_SOFTKEY_RIGHT_CTRL_ID == ctrl_id)
            {
                MMK_SendMsg(win_id, MSG_APP_CANCEL, PNULL);
            }
        }
#endif   
        break;
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
        
    case MSG_APP_MENU:
    case MSG_APP_CANCEL:
    case MSG_CTL_CANCEL:
    case MSG_APP_OK:
    case MSG_CTL_OK:
        MMK_CloseWin(win_id);
        break;
        
    default:
        result = MMI_RESULT_FALSE;
        break;        
    }
    return result;
}
#endif


//Telephony

LOCAL MMI_RESULT_E MMIENG_OpenOperatorSIMSelectWin(uint32 dual_sys, BOOLEAN isReturnOK, DPARAM param)
{
    if (isReturnOK)
    {
        return MMK_CreateWin((uint32 *) s_mmieng_sim_select_table_ptr, (ADD_DATA)dual_sys); 
    }
    else
    {
        return MMI_RESULT_FALSE;
    }
}

PUBLIC uint8 MMIAPIENG_SelectSimWIN(uint32* win_table_ptr,MMIAPIPHONE_SELECTSIM_FUNC  MMICLSelectSIMWinCallback)
{
	uint16  sim_ok = 0;
	uint32  sim_num = 0;

	sim_num = MMIAPIPHONE_GetSimAvailableNum(&sim_ok, 1);

	if (0 == sim_num)
	{
		MMIAPIPHONE_AlertSimNorOKStatus();
		return 0;
	}
	else if (1 == sim_num)
	{
		MMK_CreateWin((uint32 *) win_table_ptr, (ADD_DATA)sim_ok);
		return 1;   
	}
	else
	{
		MMI_WIN_ID_T    selectSimWinID = MMIENG_SIM_SELECT_WIN_ID;
		MMIPHONE_SELECT_SIM_DATA_T  caller_data={0};

		caller_data.append_type = (uint32)MMISET_APPEND_SYS_OK;
		caller_data.callback_func = MMICLSelectSIMWinCallback ;
		caller_data.select_type= MMIPHONE_SELECTION_SIM_ONLY;
		caller_data.publist_id = MMIENG_LISTBOX_CTRL_ID;
		caller_data.win_id_ptr = &selectSimWinID;
		caller_data.user_data  = PNULL;
		caller_data.extra_data = PNULL;

		return MMIAPIPHONE_OpenSelectSimWin(&caller_data);
	}
}

/********************************************************************************
 NAME:          BandSelectCallBack
 DESCRIPTION:
 PARAM IN:      is_ok
 PARAM OUT:     None
 AUTHOR:        fangfang.yao
********************************************************************************/
LOCAL void BandSelectCallBack(MN_DUAL_SYS_E dual_sys,BOOLEAN is_ok)
{
    MMI_STRING_T text_str = {0};
    uint8        str_buf[100] = {0};
    wchar     w_str_buf[100] = {0};

    if (TRUE == is_ok)
    {
        //success!
        sprintf((char*)str_buf,"SIM%d set done",(dual_sys+1));
        MMI_STRNTOWSTR(w_str_buf,100, str_buf,strlen((char*)str_buf),strlen((char*)str_buf));
        text_str.wstr_ptr = w_str_buf;
        text_str.wstr_len = strlen((char*)str_buf);
        MMIPUB_OpenAlertWinByTextPtr(PNULL,&text_str,PNULL,IMAGE_PUBWIN_SUCCESS,PNULL,PNULL,MMIPUB_SOFTKEY_ONE,PNULL);
    }
    else
    {
        sprintf((char*)str_buf,"SIM%d set fail",(dual_sys+1));
        MMI_STRNTOWSTR(w_str_buf,100, str_buf,strlen((char*)str_buf),strlen((char*)str_buf));
        text_str.wstr_ptr = w_str_buf;
        text_str.wstr_len = strlen((char*)str_buf);
        MMIPUB_OpenAlertWinByTextPtr(PNULL,&text_str,PNULL,IMAGE_PUBWIN_FAIL,PNULL,PNULL,MMIPUB_SOFTKEY_ONE,PNULL);
    }
}

LOCAL MMI_RESULT_E  EngTeleBANDSelectWinHandleMsg(
                                MMI_WIN_ID_T    win_id,
                                MMI_MESSAGE_ID_E   msg_id,
                                DPARAM             param
)
{
        enum {ENG_TDD, ENG_FDD, ENG_GSM, ENG_WCDMA};
        MMI_RESULT_E    recode      = MMI_RESULT_TRUE;
        uint16          cur_index   = 0;
        uint16          top_index   = 0;
        MMI_CTRL_ID_T       ctrl_id = MMIENG_COMMON_EDIT_CTRL2_ID;
        uint16   sim_num = (int32)MMK_GetWinAddDataPtr(win_id);

        switch( msg_id ) {
                case MSG_OPEN_WINDOW:
                {
                        MMI_TEXT_ID_T  band_text_id[] = {TXT_ENG_TEL_BAND_TDD,
                                                         TXT_ENG_TEL_BAND_FDD,
                                                         TXT_ENG_TEL_BAND_GSM,
                                                         TXT_ENG_TEL_BAND_WCDMA
                                                         };
                        uint32  num = ARR_SIZE(band_text_id);
                        uint8   i = 0;
                        GUILIST_SetMaxItem(ctrl_id, num, FALSE );//max item 4
                        GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
                        for(i=0;i<num;i++)
                        {
                            MMIAPISET_AppendListItemByTextIdExt(band_text_id[i],TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1CHECK_ENG);
                        }

                        GUILIST_SetTopItemIndex( ctrl_id, top_index );
                        GUILIST_SetCurItemIndex( ctrl_id, cur_index );

                        CTRLLIST_SetItemStateById( ctrl_id, 0, GUIITEM_STATE_SELECTED, FALSE );
                        CTRLLIST_SetItemStateById( ctrl_id, 1, GUIITEM_STATE_SELECTED, TRUE );

                        MMK_SetAtvCtrl( win_id, ctrl_id );

                }
                break;

                case MSG_FULL_PAINT:
                        cur_index = GUILIST_GetCurItemIndex( ctrl_id );
                        GUILIST_SetCurItemIndex( ctrl_id, cur_index );
                        MMITHEME_UpdateRect();
                        break;
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
                case MSG_CTL_PENOK:
#endif
                case MSG_APP_OK:
                case MSG_APP_WEB:
                case MSG_CTL_MIDSK: 
                {
                    cur_index = GUILIST_GetCurItemIndex( ctrl_id );
                    switch( cur_index )
                    {
                        case ENG_TDD:
                            MMK_CreateWin( ( uint32 * )MMIENG_TELE_BAND_TDD_WIN_TAB,  (ADD_DATA)sim_num );
                            break;
                        case ENG_FDD:
                            MMK_CreateWin( ( uint32 * )MMIENG_TELE_BAND_FDD_WIN_TAB,  (ADD_DATA)sim_num );
                            break;
                        case ENG_GSM:
                            MMK_CreateWin( ( uint32 * )MMIENG_TELE_BAND_GSM_WIN_TAB,  (ADD_DATA)sim_num );
                            break;
                        case ENG_WCDMA:
                            MMK_CreateWin( ( uint32 * )MMIENG_TELE_BAND_WCDMA_WIN_TAB,  (ADD_DATA)sim_num );
                            break;
                    }
                }
                break;
                case MSG_CTL_OK:
                case MSG_CTL_CANCEL:
                case MSG_APP_CANCEL:
                        MMK_CloseWin( win_id );
                        break;
                case MSG_CLOSE_WINDOW:
                        break;
                default:
                        recode = MMI_RESULT_FALSE;
                        break;
        }

        return recode;
}
LOCAL MMI_RESULT_E  EngTeleBANDTDDWinHandleMsg(
                                MMI_WIN_ID_T    win_id,
                                MMI_MESSAGE_ID_E   msg_id,
                                DPARAM             param
)
{
        enum {TDD_BAND38 = 38, TDD_BAND39 = 39, TDD_BAND40 = 40, TDD_BAND41 = 41};
        MMI_RESULT_E    recode      =   MMI_RESULT_TRUE;
        uint16          cur_index   =   0;
        uint16                      top_index       =       0;
        MMI_CTRL_ID_T       ctrl_id = MMIENG_COMMON_EDIT_CTRL2_ID;
        uint32 locked_band_tdd_33_64 = 0;
        uint32 locked_band_fdd_1_32 = 0;
        uint32 locked_band_fdd_65_80 = 0;
        uint8 locked_band_tdd_33_64_ary[] = {TDD_BAND38, TDD_BAND39, TDD_BAND40, TDD_BAND41};
        uint8 locked_band_tdd_33_64_ary_num = sizeof(locked_band_tdd_33_64_ary)/sizeof(uint8);
        uint8           locked_band_tdd[32] = {0};
        uint8           locked_band_fdd[32] = {0};
        uint8 i = 0;

        switch( msg_id ) {
                case MSG_OPEN_WINDOW: {

                        GUILIST_ITEM_T      item_t = {0};
                        GUILIST_ITEM_DATA_T item_data = {0};
                        wchar wstr[30] = {0};
                        char str[30] = {0};

                        CTRLLIST_ChangeCheckListSoftkeyIndex( ctrl_id, 1 );
                        GUIWIN_SeSoftkeytButtonIconId( win_id, ( MMI_TEXT_ID_T )TXT_ENG_OK, 0, TRUE );
#ifdef PLATFORM_ANTISW3

#ifndef WIN32
                        em_al_get_locked_lte_multiband( &locked_band_tdd_33_64, &locked_band_fdd_1_32, &locked_band_fdd_65_80 );
#endif
#endif
                        // MMIENG_AppendListItem( ctrl_id, idle_text_id, num );
                        GUILIST_SetMaxItem( ctrl_id, 32, FALSE );
                        GUILIST_SetOwnSofterKey( ctrl_id, TRUE );

                        item_t.item_style    = GUIITEM_STYLE_1CHECK_ENG;
                        item_t.item_data_ptr = &item_data;

                        item_data.item_content[0].item_data_type = GUIITEM_DATA_TEXT_BUFFER;
                        item_data.softkey_id[0] = TXT_ENG_OK;
                        item_data.softkey_id[1] = TXT_NULL;
                        item_data.softkey_id[2] = TXT_ENG_RETURN;

                        for( i = 0; i < locked_band_tdd_33_64_ary_num; i++ ) {
                                SCI_MEMSET( wstr, 0, 30 );
                                sprintf( str, "TDD_BAND%d", locked_band_tdd_33_64_ary[i] );

                                item_data.item_content[0].item_data.text_buffer.wstr_len =  strlen( ( char * )str );
                                item_data.item_content[0].item_data.text_buffer.wstr_ptr = wstr;

                                MMI_STRNTOWSTR( wstr, GUILIST_STRING_MAX_NUM, ( uint8 * )str,  strlen( ( char * )str ),  strlen( ( char * )str ) );

                                GUILIST_AppendItem( ctrl_id, &item_t );

                                if( ( locked_band_tdd_33_64 >> (locked_band_tdd_33_64_ary[i] - 33) ) & 0x1 ) {
                                        CTRLLIST_SetItemStateById( ctrl_id, i, GUIITEM_STATE_SELECTED, TRUE );
                                } else {
                                        CTRLLIST_SetItemStateById( ctrl_id, i, GUIITEM_STATE_SELECTED, FALSE );
                                }
                        }

                        GUILIST_SetTopItemIndex( ctrl_id, top_index );
                        GUILIST_SetCurItemIndex( ctrl_id, cur_index );
                        MMK_SetAtvCtrl( win_id, ctrl_id );
                }
                break;
                case MSG_FULL_PAINT:
                        cur_index = GUILIST_GetCurItemIndex( ctrl_id );
                        GUILIST_SetCurItemIndex( ctrl_id, cur_index );
                        MMITHEME_UpdateRect();
                        break;
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
                case MSG_CTL_PENOK:
#endif
                case MSG_APP_WEB:
                case MSG_CTL_MIDSK:
                        cur_index = GUILIST_GetCurItemIndex( ctrl_id );
                        if( GUILIST_GetItemState( GUILIST_GetItemPtrByIndex( ctrl_id, cur_index ), GUIITEM_STATE_SELECTED ) )
                        { //selected
                            CTRLLIST_SetItemStateById( ctrl_id, cur_index, GUIITEM_STATE_SELECTED, FALSE );
                        }
                        else
                        {
                            CTRLLIST_SetItemStateById( ctrl_id, cur_index, GUIITEM_STATE_SELECTED, TRUE );
                        }
                        MMK_SendMsg( win_id, MSG_FULL_PAINT, PNULL );
                        break;
                case MSG_APP_OK:
                case MSG_CTL_OK:
                    {
                        BOOLEAN result = FALSE;
                        uint8 numof_locked_band_tdd = 0;
                        uint8 numof_locked_band_fdd = 0;

                        for( i = 0; i < locked_band_tdd_33_64_ary_num; i++ )
                        {
                            if( GUILIST_GetItemState( GUILIST_GetItemPtrByIndex( ctrl_id, i ), GUIITEM_STATE_SELECTED ) )
                            {
                                locked_band_tdd[numof_locked_band_tdd] = locked_band_tdd_33_64_ary[i];
                                //SCI_TraceLow( "[MMIENG] %s %d locktddband[%d]", __FUNCTION__, __LINE__, locked_band_tdd_33_64_ary[i]);
                                SCI_TraceLow( "[MMIENG] locktddband[%d]",locked_band_tdd_33_64_ary[i]);
                                numof_locked_band_tdd++;
                            }
                        }
#ifdef PLATFORM_ANTISW3
#ifndef WIN32
                        result = em_al_get_locked_lte_multiband( &locked_band_tdd_33_64, &locked_band_fdd_1_32, &locked_band_fdd_65_80 );
                        if(FALSE == result)
                        {
                            BandSelectCallBack(g_dual_sys,result);//Bug 1958881
                            MMK_CloseWin( win_id );
                            break;
                        }
                        for( i = 0; i < 32; i++ )
                        {
                            if( ( locked_band_fdd_1_32 >> i ) & 0x01 )
                            {
                                locked_band_fdd[numof_locked_band_fdd] = 1 + i;
                                SCI_TraceLow( "[MMIENG] %s %d lockfddband[%d]", __FUNCTION__, __LINE__, i+1 );
                                numof_locked_band_fdd++;
                            }
                        }
                        result = em_al_lock_lte_multiband( locked_band_tdd, numof_locked_band_tdd, locked_band_fdd, numof_locked_band_fdd );
                        BandSelectCallBack(g_dual_sys,result);//Bug 1958881
#endif
#endif
                }
                MMK_CloseWin( win_id );
                break;
                case MSG_CTL_CANCEL:
                case MSG_APP_CANCEL:
                    MMK_CloseWin( win_id );
                    break;
                case MSG_CLOSE_WINDOW:
                    break;
                default:
                    recode = MMI_RESULT_FALSE;
                    break;
        }

        return recode;
}
LOCAL MMI_RESULT_E  EngTeleBANDFDDWinHandleMsg(
                                MMI_WIN_ID_T    win_id,
                                MMI_MESSAGE_ID_E   msg_id,
                                DPARAM             param
)
{
        enum {FDD_BAND1 = 1, FDD_BAND3 = 3, FDD_BAND5 = 5, FDD_BAND7 = 7, FDD_BAND8 = 8, FDD_BAND20 = 20};
        MMI_RESULT_E    recode      =   MMI_RESULT_TRUE;
        uint16          cur_index   =   0;
        uint16          top_index   =   0;
        MMI_CTRL_ID_T       ctrl_id = MMIENG_COMMON_EDIT_CTRL2_ID;
        uint32 locked_band_tdd_33_64= 0;
        uint32 locked_band_fdd_1_32 = 0;
        uint32 locked_band_fdd_65_80= 0;
        uint8 locked_band_fdd_1_32_ary[] = {FDD_BAND1, FDD_BAND3, FDD_BAND5, FDD_BAND7, FDD_BAND8};
        uint8 locked_band_fdd_1_32_ary_num = sizeof(locked_band_fdd_1_32_ary)/sizeof(locked_band_fdd_1_32_ary[1]);
        uint8 i = 0;

        switch( msg_id )
        {
            case MSG_OPEN_WINDOW:
            {

                GUILIST_ITEM_T      item_t = {0};
                GUILIST_ITEM_DATA_T item_data = {0};
                wchar wstr[30] = {0};
                char str[30] = {0};

                CTRLLIST_ChangeCheckListSoftkeyIndex( ctrl_id, 1 );
                GUIWIN_SeSoftkeytButtonIconId( win_id, ( MMI_TEXT_ID_T )TXT_ENG_OK, 0, TRUE );
#ifdef PLATFORM_ANTISW3
#ifndef WIN32
                em_al_get_locked_lte_multiband( &locked_band_tdd_33_64, &locked_band_fdd_1_32, &locked_band_fdd_65_80 );
#endif
#endif
                GUILIST_SetMaxItem( ctrl_id, 32, FALSE );
                GUILIST_SetOwnSofterKey( ctrl_id, TRUE );

                item_t.item_style    = GUIITEM_STYLE_1CHECK_ENG;
                item_t.item_data_ptr = &item_data;

                item_data.item_content[0].item_data_type = GUIITEM_DATA_TEXT_BUFFER;
                item_data.softkey_id[0] = TXT_ENG_OK;
                item_data.softkey_id[1] = TXT_NULL;
                item_data.softkey_id[2] = TXT_ENG_RETURN;

                for( i = 0; i < locked_band_fdd_1_32_ary_num; i++ ) {
                        SCI_MEMSET( wstr, 0, 30 );
                        sprintf( str, "FDD_BAND%d", locked_band_fdd_1_32_ary[i] );

                        item_data.item_content[0].item_data.text_buffer.wstr_len =  strlen( ( char * )str );
                        item_data.item_content[0].item_data.text_buffer.wstr_ptr = wstr;

                        MMI_STRNTOWSTR( wstr, GUILIST_STRING_MAX_NUM, ( uint8 * )str,  strlen( ( char * )str ),  strlen( ( char * )str ) );

                        GUILIST_AppendItem( ctrl_id, &item_t );

                        if( ( locked_band_fdd_1_32 >> (locked_band_fdd_1_32_ary[i] -1) ) & 0x1 ) {
                            CTRLLIST_SetItemStateById( ctrl_id, i, GUIITEM_STATE_SELECTED, TRUE );
                        } else {
                            CTRLLIST_SetItemStateById( ctrl_id, i, GUIITEM_STATE_SELECTED, FALSE );
                        }
                }

                GUILIST_SetTopItemIndex( ctrl_id, top_index );
                GUILIST_SetCurItemIndex( ctrl_id, cur_index );

                MMK_SetAtvCtrl( win_id, ctrl_id );
        }
            break;

            case MSG_FULL_PAINT:
                    cur_index = GUILIST_GetCurItemIndex( ctrl_id );
                    GUILIST_SetCurItemIndex( ctrl_id, cur_index );
                    MMITHEME_UpdateRect();
                    break;
#ifdef TOUCH_PANEL_SUPPORT
            case MSG_CTL_PENOK:
#endif
            case MSG_APP_WEB:
            case MSG_CTL_MIDSK:

                    cur_index = GUILIST_GetCurItemIndex( ctrl_id );
                    if( GUILIST_GetItemState( GUILIST_GetItemPtrByIndex( ctrl_id, cur_index ), GUIITEM_STATE_SELECTED ) )
                    { //selected
                        CTRLLIST_SetItemStateById( ctrl_id, cur_index, GUIITEM_STATE_SELECTED, FALSE );
                    }
                    else
                    {
                        CTRLLIST_SetItemStateById( ctrl_id, cur_index, GUIITEM_STATE_SELECTED, TRUE );
                    }

                    MMK_SendMsg( win_id, MSG_FULL_PAINT, PNULL );
                    break;
            case MSG_APP_OK:
            case MSG_CTL_OK:
                {
                    BOOLEAN         result = FALSE;
                    uint8           locked_band_tdd[32] = {0};
                    uint8           locked_band_fdd[32] = {0};
                    uint8           numof_locked_band_tdd = 0;
                    uint8           numof_locked_band_fdd = 0;

                    for( i = 0; i < locked_band_fdd_1_32_ary_num; i++ )
                    {
                        if( GUILIST_GetItemState( GUILIST_GetItemPtrByIndex( ctrl_id, i ), GUIITEM_STATE_SELECTED ) )
                        {
                            locked_band_fdd[numof_locked_band_fdd] = locked_band_fdd_1_32_ary[i];
                            //SCI_TraceLow( "[MMIENG] %s %d lockfddband[%d]", __FUNCTION__, __LINE__, locked_band_fdd_1_32_ary[i] );
                            SCI_TraceLow( "[MMIENG]lockfddband[%d]", locked_band_fdd_1_32_ary[i] );
                            numof_locked_band_fdd++;
                        }
                    }
#ifdef PLATFORM_ANTISW3

#ifndef WIN32
                    result = em_al_get_locked_lte_multiband( &locked_band_tdd_33_64, &locked_band_fdd_1_32, &locked_band_fdd_65_80 );
                    if(FALSE == result)
                    {
                        BandSelectCallBack(g_dual_sys,result);//Bug 1958881
                        MMK_CloseWin( win_id );
                        break;
                    }

                    for( i = 0; i < 32; i++ )
                    {
                        if( ( locked_band_tdd_33_64 >> i ) & 0x01 )
                        {
                            locked_band_tdd[numof_locked_band_tdd] = 33 + i;
                            //SCI_TraceLow( "[MMIENG] %s %d locktddband[%d]", __FUNCTION__, __LINE__, i+33 );
                            SCI_TraceLow( "[MMIENG]locktddband[%d]", i+33 );
                            numof_locked_band_tdd++;
                        }
                    }
                    result = em_al_lock_lte_multiband( locked_band_tdd, numof_locked_band_tdd, locked_band_fdd, numof_locked_band_fdd );
                    BandSelectCallBack(g_dual_sys,result);//Bug 1958881
#endif
#endif
                    MMK_CloseWin( win_id );
                    break;
            }
            case MSG_CTL_CANCEL:
            case MSG_APP_CANCEL:
                    MMK_CloseWin( win_id );
                    break;

            case MSG_CLOSE_WINDOW:

                    break;

            default:
                    recode = MMI_RESULT_FALSE;
                    break;
    }

        return recode;
}

LOCAL MMI_RESULT_E  EngTeleBANDGSMWinHandleMsg(
                                MMI_WIN_ID_T    win_id,
                                MMI_MESSAGE_ID_E   msg_id,
                                DPARAM             param
)
{
        enum {ENG_TDD, ENG_FDD, ENG_GSM, ENG_WCDMA};
        MMI_RESULT_E    recode      =   MMI_RESULT_TRUE;
        uint16          cur_index   =   0;
        uint16          top_index   =   0;
        MMI_CTRL_ID_T       ctrl_id = MMIENG_COMMON_EDIT_CTRL2_ID;
        uint32 GSM900_BIT = 0x01;
        uint32 DCS1800_BIT = 0x02;
        uint32 PCS1900_BIT = 0x04;
        uint32 GSM850_BIT = 0x08;
        uint8 gsmBandMAp[] = {
                0x01,//0 - 0000 0001           MN_PHONE_BAND_GSM
                0x02,//1 - 0000 0010           MN_PHONE_BAND_DCS
                0x03,//2 - 0000 0011           MN_PHONE_BAND_GSM_DCS
                0x04,//3 - 0000 0100           MN_PHONE_BAND_PCS
                0x08,//4 - 0000 1000           MN_PHONE_BAND_GSM850
                0x05,//5 - 0000 0101           MN_PHONE_BAND_GSM_PCS
                0x0A,//6 - 0000 1010           MN_PHONE_BAND_GSM850_DCS
                0x0C,//7 - 0000 1100           MN_PHONE_BAND_GSM850_PCS
                0x09,//8 - 0000 1001           MN_PHONE_BAND_GSM850_GSM
                0x0D,//9 - 0000 1101           MN_PHONE_BAND_GSM850_GSM_PCS
                0x0B,//10 - 0000 1011          MN_PHONE_BAND_GSM850_GSM_DCS
                0x07,//11 - 0000 0111          MN_PHONE_BAND_GSM_DCS_PCS
                0x0f,//12 - 0000 1111          MN_PHONE_BAND_GSM850_GSM_DCS_PCS
                0x06,//13 - 0000 0110          MN_PHONE_BAND_DCS_PCS
                0x0E,//14 - 0000 1110          MN_PHONE_BAND_GSM850_DCS_PCS
        };
        uint16   sim_num = (int32)MMK_GetWinAddDataPtr( win_id);
        uint8  u8_bandValue = 0;
        switch( msg_id )
        {
            case MSG_OPEN_WINDOW:
            {
                const MMI_TEXT_ID_T  idle_text_id[] = {
                                                        TXT_ENG_TEL_BAND_GSM1,
                                                        TXT_ENG_TEL_BAND_GSM2,
                                                        TXT_ENG_TEL_BAND_GSM3,
                                                        TXT_ENG_TEL_BAND_GSM4,
                                                        };
                uint32  num = ARR_SIZE(idle_text_id );
                uint8   i = 0;
                CTRLLIST_ChangeCheckListSoftkeyIndex(ctrl_id,1);
                GUIWIN_SeSoftkeytButtonIconId(win_id, ( MMI_TEXT_ID_T )TXT_ENG_OK, 0, TRUE);

                GUILIST_SetMaxItem(ctrl_id, num, FALSE );//max item 4
                GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
                for(i=0;i<num;i++)
                {
                    MMIAPISET_AppendListItemByTextIdExt(idle_text_id[i],TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1CHECK_ENG);
                }

                GUILIST_SetTopItemIndex( ctrl_id, top_index );
                GUILIST_SetCurItemIndex( ctrl_id, cur_index );

                u8_bandValue =   MNPHONE_GetBandEx(sim_num);
                //SCI_TraceLow("[MMIENG] %s %d band[%x]",__FUNCTION__,__LINE__,u8_bandValue);
                SCI_TRACE_LOW("[MMIENG] band[%x]",u8_bandValue);
                CTRLLIST_SetItemStateById( ctrl_id, 0, GUIITEM_STATE_SELECTED, gsmBandMAp[u8_bandValue] & GSM900_BIT );
                CTRLLIST_SetItemStateById( ctrl_id, 1, GUIITEM_STATE_SELECTED, gsmBandMAp[u8_bandValue] & DCS1800_BIT );
                CTRLLIST_SetItemStateById( ctrl_id, 2, GUIITEM_STATE_SELECTED, gsmBandMAp[u8_bandValue] & PCS1900_BIT );
                CTRLLIST_SetItemStateById( ctrl_id, 3, GUIITEM_STATE_SELECTED, gsmBandMAp[u8_bandValue] & GSM850_BIT );

                MMK_SetAtvCtrl( win_id, ctrl_id );
        }
                break;
            case MSG_FULL_PAINT:
            {
                cur_index = GUILIST_GetCurItemIndex(ctrl_id);
                GUILIST_SetCurItemIndex(ctrl_id, cur_index);
                MMITHEME_UpdateRect();
            }
                break;
#ifdef TOUCH_PANEL_SUPPORT
            case MSG_CTL_PENOK:
#endif
            case MSG_APP_WEB:
            case MSG_CTL_MIDSK:
                {
                    cur_index = GUILIST_GetCurItemIndex(ctrl_id);
                    if (GUILIST_GetItemState(GUILIST_GetItemPtrByIndex(ctrl_id, cur_index), GUIITEM_STATE_SELECTED))//selected  
                    {
                        CTRLLIST_SetItemStateById(ctrl_id,cur_index,GUIITEM_STATE_SELECTED,FALSE);
                        //func to remove the item
                    }
                    else
                    {
                        CTRLLIST_SetItemStateById(ctrl_id,cur_index,GUIITEM_STATE_SELECTED,TRUE);
                          //func to add item
                    }
                MMK_SendMsg(win_id,MSG_FULL_PAINT,PNULL);
                }
                break;
            case MSG_APP_OK:
            case MSG_CTL_OK:
                {
                    uint32 i = 0;
                    u8_bandValue = 0;
                    for(i = 0;i<4;i++)
                    {
                        if(GUILIST_GetItemState(GUILIST_GetItemPtrByIndex(ctrl_id, i), GUIITEM_STATE_SELECTED))
                        {
                            u8_bandValue |= (1<<i);
                        }
                    }
                    for(i=0;i<sizeof(gsmBandMAp);i++)
                    {
                        if(u8_bandValue == gsmBandMAp[i] )
                        {
                           //SCI_TraceLow("[MMIENG] %s %d band[%x] i=[%d]",__FUNCTION__,__LINE__,u8_bandValue,i);
                           MNPHONE_SelectBandEx(sim_num,i);
                        }
                    }
                }
                 break;

            case MSG_CTL_CANCEL:
            case MSG_APP_CANCEL:
                    MMK_CloseWin( win_id );
                    break;
            case MSG_CLOSE_WINDOW:
                    break;
            default:
                    recode = MMI_RESULT_FALSE;
                    break;
        }

        return recode;
}

LOCAL MMI_RESULT_E  EngTeleBANDWCDMAWinHandleMsg(
                                MMI_WIN_ID_T    win_id,
                                MMI_MESSAGE_ID_E   msg_id,
                                DPARAM             param
)
{
        enum {BAND1=1, BAND2=2, BAND5=5, BAND8=8};
        MMI_RESULT_E    recode      =   MMI_RESULT_TRUE;
        uint16          cur_index   =   0;
        uint16          top_index   =   0;
        MMI_CTRL_ID_T       ctrl_id = MMIENG_COMMON_EDIT_CTRL2_ID;
        uint8 fddbandmap[]={BAND1,BAND2,BAND5,BAND8};
        uint8 i =0;
        switch( msg_id )
        {
            case MSG_OPEN_WINDOW:
            {
                const MMI_TEXT_ID_T   idle_text_id[] = {
                                                        TXT_ENG_TEL_BAND_WCDMA1,
                                                        TXT_ENG_TEL_BAND_WCDMA2,
                                                        TXT_ENG_TEL_BAND_WCDMA5,
                                                        TXT_ENG_TEL_BAND_WCDMA8,
                                                };
                uint8 bandvalue = 0;
                uint16 cur_selection  = 0;
                uint32 num = ARR_SIZE(idle_text_id);
                uint8  i   = 0;
                CTRLLIST_ChangeCheckListSoftkeyIndex(ctrl_id,1);
                GUIWIN_SeSoftkeytButtonIconId(win_id, ( MMI_TEXT_ID_T )TXT_ENG_OK, 0, TRUE);

                GUILIST_SetMaxItem(ctrl_id, num, FALSE );//max item 4
                GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
                for(i=0;i<num;i++)
                {
                    MMIAPISET_AppendListItemByTextIdExt(idle_text_id[i],TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1CHECK_ENG);
                }

                GUILIST_SetTopItemIndex( ctrl_id, top_index );
                GUILIST_SetCurItemIndex( ctrl_id, cur_index );

                for(i=0;i<sizeof(fddbandmap);i++)
                {
#ifdef PLATFORM_ANTISW3
                #ifndef WIN32
                    em_get_fdd_rf_band(fddbandmap[i], &bandvalue);
                #endif
#endif
                    CTRLLIST_SetItemStateById( ctrl_id, i, GUIITEM_STATE_SELECTED, bandvalue);
                }
                MMK_SetAtvCtrl( win_id, ctrl_id );
            }
            break;

            case MSG_FULL_PAINT:
                cur_index = GUILIST_GetCurItemIndex(ctrl_id);
                GUILIST_SetCurItemIndex(ctrl_id, cur_index);
                MMITHEME_UpdateRect();
                break;
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
            case MSG_CTL_PENOK:
#endif
            case MSG_APP_WEB:
            case MSG_CTL_MIDSK:
                    cur_index = GUILIST_GetCurItemIndex(ctrl_id);
                    if (GUILIST_GetItemState(GUILIST_GetItemPtrByIndex(ctrl_id, cur_index), GUIITEM_STATE_SELECTED))  //selected 
                    {
                        CTRLLIST_SetItemStateById(ctrl_id,cur_index,GUIITEM_STATE_SELECTED,FALSE);
                    }
                    else
                    {
                        CTRLLIST_SetItemStateById(ctrl_id,cur_index,GUIITEM_STATE_SELECTED,TRUE);
                    }
                    MMK_SendMsg(win_id,MSG_FULL_PAINT,PNULL);    
                break;
            case MSG_APP_OK:
            case MSG_CTL_OK:
                {
                    BOOLEAN result = FALSE;
                    for(i = 0;i<4;i++)
                    {
#ifdef PLATFORM_ANTISW3
                        if(GUILIST_GetItemState(GUILIST_GetItemPtrByIndex(ctrl_id, i), GUIITEM_STATE_SELECTED))
                        {
                            #ifndef WIN32
                            SCI_TraceLow("[MMIENG] %s %d band[%d] TRUE",__FUNCTION__,__LINE__,fddbandmap[i]);
                            result = em_set_fdd_rf_band( fddbandmap[i],TRUE);
                            #endif
                        }
                        else
                        {
                            #ifndef WIN32
                            SCI_TraceLow("[MMIENG] %s %d band[%d] FASLE",__FUNCTION__,__LINE__,fddbandmap[i]);
                            result = em_set_fdd_rf_band( fddbandmap[i],FALSE);
                            #endif
                        }
#endif
                    }
                    BandSelectCallBack(g_dual_sys,result);//Bug 1958881
                    MMK_CloseWin( win_id );
                }
                break;
            case MSG_CTL_CANCEL:
            case MSG_APP_CANCEL:
                    MMK_CloseWin( win_id );
                    break;

            case MSG_CLOSE_WINDOW:

                    break;
            default:
                    recode = MMI_RESULT_FALSE;
                    break;
    }

        return recode;
}
LOCAL MMI_RESULT_E EngTeleSIMTraceWinHandleMsg( MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param )
{
    int32 index = 0;
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    int32 list_id = MMIENG_COMMON_CTRL1_ID ;

    switch( msg_id )
    {
        case MSG_OPEN_WINDOW:
        {
            GUILIST_ITEM_T  item_t = {0};
            GUILIST_ITEM_DATA_T item_data = {0};

            GUILIST_SetMaxItem( list_id, 2, FALSE );
            GUILIST_SetOwnSofterKey( list_id, FALSE );

            item_t.item_style    = GUIITEM_STYLE_1RADIO_ENG;
            item_t.item_data_ptr = &item_data;

            item_data.item_content[0].item_data_type  = GUIITEM_DATA_TEXT_ID;


            item_data.item_content[0].item_data.text_id = TXT_COMM_CLOSE;
            GUILIST_AppendItem( list_id, &item_t );
            item_data.item_content[0].item_data.text_id = TXT_OPEN_COMN;
            GUILIST_AppendItem( list_id, &item_t );
#ifdef PLATFORM_ANTISW3
            #ifndef WIN32
            //Todo get USIM log flag
            index = DMNV_GetUsimDrvLogFlag();
            #endif
#endif
            GUILIST_SetSelectedItem( list_id, index, TRUE );
            GUILIST_SetCurItemIndex( list_id, index );
            MMK_SetAtvCtrl( win_id, list_id );
        }
        break;

        case MSG_FULL_PAINT:
                break;

        case MSG_KEYDOWN_CANCEL:
        case MSG_CTL_CANCEL:
                MMK_CloseWin( win_id );
                break;

        case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT
        case MSG_CTL_PENOK:
#endif
        case MSG_KEYDOWN_OK:
        case MSG_CTL_OK:
        case MSG_APP_WEB:
        {
            index = GUILIST_GetCurItemIndex( list_id );
#ifdef PLATFORM_ANTISW3
#ifndef WIN32
            //Todo set USIM log flag
            DMNV_SetUsimDrvLogFlag( ( BOOLEAN )index );
#endif
#endif
            MMK_CloseWin( win_id );
        }
        break;
        default:
            result = MMI_RESULT_FALSE;
            break;
}
    return ( result );
}


LOCAL uint32 MMIENG_GetSelectIndexByNetworkType( uint32 value, BOOLEAN is_index )
{
        enum {
                ENG_PHONE_POWER_SVLTE = 0,//sv lte
                ENG_PHONE_POWER_TD_LTE_ONLY = 1, //TD_LTE ONLY
                ENG_PHONE_POWER_LTE_FDD_ONLY = 2, //LTE_FDD ONLY
                ENG_PHONE_POWER_TD_LTE_AND_LTE_FDD = 3, //LTE_FDD +TD_LTE
                ENG_PHONE_POWER_LTE_FDD_FOUR_MODE_ONE_ACTIVE = 4, //LTE FDD/W/GSM CSFB ONE ACTIVE
                ENG_PHONE_POWER_TD_LTE_FOUR_MODE_ONE_ACTIVE = 5, //TD-LTE/W/GSM CSFB ONE ACTIVE
                ENG_PHONE_POWER_TD_LTE_FIVE_MODE_ONE_ACTIVE = 6, //TD-LTE/LTE FDD/W/GSM CSFB
                ENG_PHONE_POWER_TD_FOUR_MODE_ONE_ACTIVE = 7, //TD-LTE/ TD/GSM CSFB
                ENG_PHONE_POWER_TD_FIVE_MODE_ONE_ACTIVE = 8, //TD-LTE/LTE FDD/ TD/GSM CSFB
                ENG_PHONE_POWER_FIVE_MODE_ONE_ACTIVE = 9, //TD-LTE/LTE FDD/ TD/GSM WCDMA
                ENG_PHONE_POWER_GSM_ONLY = 10, // GSM ONLY
                ENG_PHONE_POWER_WCDMA_ONLY = 11, //W ONLY
                ENG_PHONE_POWER_TD_ONLY = 12, //TD ONLY
                ENG_PHONE_POWER_TD_AND_GSM = 13,
                ENG_PHONE_POWER_WCDMA_AND_GSM = 14,
                ENG_PHONE_POWER_GSM_ONLY_MASTER_CARD = 15,
                ENG_PHONE_POWER_GSM_PREFER = 16, /* Bug503447 M GSM Prefer in WG Dual Mode*/
                ENG_PHONE_POWER_TD_AND_WCDMA = 17, /*bug554176 WCDMA or TD only*/
                ENG_PHONE_POWER_WCDMA_ONLY_MASTER_CARD = 18,
                ENG_PHONE_POWER_TD_ONLY_MASTER_CARD = 19,
                ENG_PHONE_POWER_TG_AND_WG_MASTER_CARD = 20,
                ENG_PHONE_POWER_TD_LTE_FDD_LTE_AND_GSM = 21,
                ENG_PHONE_POWER_WCDMA_AND_GSM_MASTER_CARD = 22, //bug615651
                ENG_PHONE_POWER_TD_AND_WCDMA_MASTER_CARD = 23,
                ENG_PHONE_POWER_TD_LTE_FDD_LTE_AND_WCDMA = 24, /*bug644753*/ //TD-LTE/LTE FDD/WCDMA
                ENG_PHONE_POWER_CDMA_ONLY = 64,
                ENG_PHONE_POWER_FIVE_MOD_CDMA_ONE_ACTIVE = 73,
                ENG_PHONE_POWER_TD_AND_GSM_OR_WCDMA_AND_GSM = 255, //T/G or W/G
                ENG_PHONE_POWER_TEST_MODE_INVALID = 254
        };
        uint32 uiIndexAndTypeMap[] = {ENG_PHONE_POWER_TD_LTE_FIVE_MODE_ONE_ACTIVE,
                                      ENG_PHONE_POWER_TD_LTE_AND_LTE_FDD,
                                      ENG_PHONE_POWER_WCDMA_AND_GSM,
                                      ENG_PHONE_POWER_WCDMA_ONLY,
                                      ENG_PHONE_POWER_GSM_ONLY
                                     };
        uint32 uiIndexAndTypeMapNum = sizeof(uiIndexAndTypeMap)/sizeof(uint32);
        if(is_index)
        {
            return (value < uiIndexAndTypeMapNum ) ? uiIndexAndTypeMap[value]:ENG_PHONE_POWER_TEST_MODE_INVALID;
        }
        else
        {
            int i=0;
            for(i=0;i<uiIndexAndTypeMapNum;i++)
            {
                if(value == uiIndexAndTypeMap[i])
                {
                    return i;
                }
            }
            return 0xffff;
        }
}


LOCAL MMI_RESULT_E EngTeleNetWorkModeWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E    recode      =   MMI_RESULT_TRUE;
#if defined (PLATFORM_ANTISW3)
    uint16          cur_index   =   0;
    uint16			top_index	=	0;
    MMI_CTRL_ID_T       ctrl_id =   MMIENG_COMMON_CTRL1_ID;
    MN_DUAL_SYS_E sim_num = (int32)MMK_GetWinAddDataPtr( win_id);
    //HandleNetworkTypeWindow
    uint8 testmode[4] =
    {
        MN_PHONE_POWER_TEST_MODE_INVALID,
        MN_PHONE_POWER_TEST_MODE_INVALID,
        MN_PHONE_POWER_TEST_MODE_INVALID,
        MN_PHONE_POWER_TEST_MODE_INVALID
    };

    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            const MMI_TEXT_ID_T  idle_text_id[] = {TXT_ENG_TEL_NETWORK_MODE_MULTI1,//TD_LTE/LTE FDD/W/GSM CSFB Multi-mode
                                                   TXT_ENG_TEL_NETWORK_MODE_DUALMODE,//TD-LTE/LTE FDD Dual-mode
                                                   TXT_ENG_TEL_NETWORK_MODE_WG_DUALMODE,//WG Dual-mode
                                                   TXT_ENG_TEL_NETWORK_MODE_W_SIGNELMODE,//W Single-mode
                                                   TXT_ENG_TEL_NETWORK_MODE_GSM_SINGLEMODE,//GSM Single-mode
                                                  };
            uint32 num = ARR_SIZE(idle_text_id);
            uint8  i = 0;

            GUILIST_SetMaxItem(ctrl_id, num, FALSE );//max item 5
            GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
            for(i=0;i<num;i++)
            {
                MMIAPISET_AppendListItemByTextIdExt(idle_text_id[i],TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1CHECK_ENG);
            }
#ifndef WIN32
            MNPHONE_GetTestModeEx(testmode);
#endif /* WIN32 */
            //SCI_TraceLow( "[MMIENG] fun[%s] file[%d] type[%d]", __FUNCTION__, __LINE__, testmode[sim_num] );
            cur_index = MMIENG_GetSelectIndexByNetworkType(testmode[sim_num],FALSE);

            GUILIST_SetSelectedItem(ctrl_id, cur_index, TRUE);
            MMK_SetAtvCtrl(win_id,ctrl_id);
        }
        break;

        case MSG_FULL_PAINT:
        {
            cur_index = GUILIST_GetCurItemIndex(ctrl_id);
            GUILIST_SetCurItemIndex(ctrl_id, cur_index);
            MMITHEME_UpdateRect();
        }
            break;
#ifdef TOUCH_PANEL_SUPPORT 
		case MSG_CTL_PENOK:
#endif
        case MSG_APP_OK:
        case MSG_APP_WEB:
        case MSG_CTL_MIDSK:
        {
            cur_index = GUILIST_GetCurItemIndex(ctrl_id);
            //SCI_TraceLow( "[MMIENG] fun[%s] file[%d] cur_index[%d]", __FUNCTION__, __LINE__, cur_index );
            #ifdef MMI_DUALMODE_ENABLE
            MMIAPISET_SetTestModeEx(sim_num, MMIENG_GetSelectIndexByNetworkType(cur_index,TRUE));
            #endif
            MMK_CloseWin( win_id );
        }
        break;
        case MSG_CTL_OK:
        case MSG_CTL_CANCEL:
        case MSG_APP_CANCEL:
            MMK_CloseWin( win_id );
            break;
        case MSG_CLOSE_WINDOW:
            break;
        default:
            recode = MMI_RESULT_FALSE;
            break;
    }
#endif
    return recode;
}


//net info start

#define ENG_NETINFO_TEMP
#ifdef ENG_NETINFO_TEMP
#define ENG_NETINFO_UPDATE_TIMEOUT   5000 //5s update 
#if defined (PLATFORM_ANTISW3)
typedef struct {
    uint16         success;  //success times
    uint16         fail;   //failure times
    uint16         passRatio;  //success rate
    uint32         delay;   //delay time,unit:ms
} mn_statistic_t;


typedef struct {
    uint16         dropOn2g;  //drop times on gsm
    uint16         dropOn4g;   //drop times on lte
} mn_dropTimes_t;


typedef struct {
    uint32         timeOn2g;   //time on gsm registered
    uint32         timeOn4g;    //time on lte registered
    uint32         timeOnVolte;  //time on volte registered
    uint32         timeOnUnknow;   //time on no RAT or drop
    uint32         allTheTime;    //total time from power on
} mn_attachTime_t;

typedef struct {
    mn_statistic_t          handoverStatistic[8];  //0:GToGHO,1:GToGCCO,2:GToLCCO,3:LToGCCO,4:GToLHO,5:LToLHO,6:LToGHO,7:SRVCC
} mn_handoverInfo_t;

typedef struct {
    mn_statistic_t          reselStatistic[4];  //0:GToLResel,1:GToLResel,2:LToLResel,3:LToGResel
} mn_reselectInfo_t;

typedef struct {
    uint8    lteCipherFlag;   //default value 1
    uint8    bsrvccFlag;     //default value 1
    uint8    emfbiFlag;    //default value 1
    uint8    ipv6Flag;     //default value 1
    uint8    asrvccFlag;   //default value 1
    uint8    esrvccFlag;   //default value 1
} mn_capInfoLte_t;

typedef struct {
    uint32     arfcn;
    uint16     bsic;   //if not decode BSIC,apply 0xffff
    uint16     rxlev;
} mn_gsmNcell_t;

typedef struct {
    uint32     frequency;
    uint16     pcid;   //if not decode BSIC,apply 0xffff
    int16     rsrp;
    int16     rsrq;
} mn_lteNcell_t;

typedef struct {
    uint8      plmn[3];
    uint8      imsi[16];    //imsi[0]:length of IMSI
    uint8      roamingFlag;  //1:roaming,0:non roaming
    uint16     bandInfo;    //band1-band256
    uint32     dlEarfcn;    //0-262143, invalid value 0xffffffff
    uint16     pcid;
    int16      rsrp;
    int16      rsrq;
    uint16     tsMode;       //default value 0xffff
    uint16     bandwidth;    //default value 0xffff
    uint16     SA;      //default value 0xffff
    uint16     SSP;     //default value 0xffff
    uint16     SINR;
    uint32     ulMcs;   //default value 0xffff
    uint32     dlMcs;   //default value 0xffff
    uint8      ulBler;
    uint8      dlBler;
    uint32     enodeBID;  //first 20 bits of SIB1 cell identity
    uint16     cellId;    //default value 0xff
} mn_lteScell_t;

typedef struct {
    mn_lteScell_t   lteScell;
    uint16          lteNcellNum;
    mn_lteNcell_t   lteNcell[5];
    uint16          gsmNcellNum;
    mn_gsmNcell_t   gsmNcell[5];
    mn_capInfoLte_t capInfoLte;
} mn_nwCapLte_t;


typedef struct {
    uint32   vamos;
    uint32   diversityGsm;
    uint8    Plmn[3];
    BOOLEAN  Roaming;
    uint8    CellId[2];
    uint16   Arfcn;
    uint8    Bsic;
    uint8    Rla;
} mn_ueCapGsm_t;

typedef struct {
    mn_ueCapGsm_t   ueCapabilityGsm;
    mn_nwCapLte_t   nwCapabilityLte;
} MN_NET_INFO_T;

typedef struct {
    mn_reselectInfo_t   reselectInfo;
    mn_handoverInfo_t   handoverInfo;
    mn_attachTime_t     attachTime;
    mn_dropTimes_t      dropTimes;
} MN_NET_INFO_STATISTIC_T;
#endif
typedef enum {
    ENG_STRING_STRING,
    ENG_STRING_NUM,
    ENG_STRING_NUM_DBM,
    ENG_STRING_SUPPOT,
    ENG_STRING_PERCENT
} MMIENG_NETINFO_SHOW_TYPE_E;

typedef enum
{
    MMIENG_PACKET_CHECK_ON,
    MMIENG_PACKET_CHECK_OFF,
    MMIENG_PACKET_CHECK_MAX
}MMIENG_PACKET_CHECK_E;

typedef struct {
    char **item;
    MMIENG_NETINFO_SHOW_TYPE_E *item_type;
    uint32 *data;
    uint32 arrow;
    uint32 colunm;
    uint32 ncellnum;
} netinfoshow_t;

LOCAL uint16 MMIENGARRAY_StrcatFromStrToUCS2( netinfoshow_t netinfo, uint16  *uint16_str, uint16  *uint16_str_len )
{
    wchar           unicode_cr = 0x0d;
    MMI_STRING_T    cr_s = {0};
    char            temp_ptr[100] = {0};
    uint16          temp_len = 0;
    uint16          i = 0;
    uint32          arrow_colunm = netinfo.colunm * netinfo.arrow;

    cr_s.wstr_ptr = &unicode_cr;
    cr_s.wstr_len = 1;
    SCI_MEMSET( temp_ptr, 0, 100 );

    for( i = 0; i < netinfo.colunm; i++ )
    {
        TRACE_APP_ENGINEERMODE( " netinfo.item[%d] = %s", i, netinfo.item[i] );
        TRACE_APP_ENGINEERMODE( " netinfo.item_type[%d] = %d", i, netinfo.item_type[i] );
        TRACE_APP_ENGINEERMODE( " netinfo.data[%d] = %d", arrow_colunm + i, netinfo.data[arrow_colunm + i] );

        switch( netinfo.item_type[i] )
        {
            case ENG_STRING_NUM:
                sprintf( temp_ptr, "%s: %d ", netinfo.item[i], netinfo.data[arrow_colunm + i] );
                break;
            case ENG_STRING_NUM_DBM:
                sprintf( temp_ptr, "%s: %ddBm ", netinfo.item[i], netinfo.data[arrow_colunm + i] );
                break;
            case ENG_STRING_SUPPOT:
                if( netinfo.data[arrow_colunm + i])
                {
                    sprintf( temp_ptr, "%s: Support ", netinfo.item[i] );
                } else
                {
                    sprintf( temp_ptr, "%s: not Support", netinfo.item[i] );
                }
                break;
            case ENG_STRING_PERCENT:
                sprintf( temp_ptr, "%s: %d%% ", netinfo.item[i], netinfo.data[arrow_colunm + i] );
                break;
        }

        temp_len = SCI_STRLEN( ( char * )temp_ptr );
        MMIAPICOM_StrcatFromStrToUCS2( uint16_str, uint16_str_len, ( uint8 * )temp_ptr, temp_len );
        MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, uint16_str_len, &cr_s ); //换行
        TRACE_APP_ENGINEERMODE(" %s", temp_ptr );
        TRACE_APP_ENGINEERMODE(" uint16_str_len = %d", *uint16_str_len );
    }

    return *uint16_str_len;
}

LOCAL uint32 MMIEng_GetNetInfo( void *pNetInfo, MN_DUAL_SYS_E dual_sys )
{
    // TODO: GetNetinfo data from PS
    return 0;
}

LOCAL uint32 MMIEng_GetNetInfoStatistic( void *pNetinfoStatistic, MN_DUAL_SYS_E dual_sys )
{
    // TODO: Get NetInfoStatistic data from PS
    return 0;
}

#endif

LOCAL MMI_RESULT_E ENGNetinfoShowWinHandleMsg( MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param )
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    uint32 group_id = 0;
    uint32 menu_id = 0;
    //uint32  dual_sys = ( uint32 )MMK_GetWinAddDataPtr( win_id );

    switch( msg_id )
    {
        case MSG_OPEN_WINDOW:
            CTRLMENU_SetSecMenuFontSize(MMIENG_NET_INFO_SHOW_CTRL_ID,MMIENG_MENU_ITEM_FONT,MMIENG_MENU_ITEM_FONT);
            CTRLMENU_SetSecMenuItemHeight(MMIENG_NET_INFO_SHOW_CTRL_ID,MMIENG_MENU_ITEM_HEIGHT,MMIENG_MENU_ITEM_HEIGHT);

            CTRLMENU_SetFontColor(MMIENG_NET_INFO_SHOW_CTRL_ID,MMI_WHITE_COLOR);
            g_dual_sys = MN_DUAL_SYS_1;
            GUIWIN_SetSoftkeyTextId( win_id,  TXT_ENG_OK, TXT_NULL, TXT_ENG_RETURN, FALSE );
            MMK_SetAtvCtrl( win_id, MMIENG_NET_INFO_SHOW_CTRL_ID );
            break;

        case MSG_FULL_PAINT:
            break;

        case MSG_KEYDOWN_CANCEL:
        case MSG_CTL_CANCEL:
            MMK_CloseWin( win_id );
            break;

#ifdef TOUCH_PANEL_SUPPORT
        case MSG_CTL_PENOK:
#endif
        case MSG_CTL_MIDSK:
        case MSG_KEYDOWN_OK:
        case MSG_CTL_OK:
        case MSG_APP_WEB:
            GUIMENU_GetId( MMIENG_NET_INFO_SHOW_CTRL_ID, &group_id, &menu_id );
            TRACE_APP_ENGINEERMODE(" menuid = %d", menu_id );
            switch(menu_id)
            {
                case ID_ENG_BETWEEN_ADJACENTCELL_2G:
                    MMK_CreateWin( ( uint32 * )MMIENG_NET_INFO_BETWEEN_CELL_WIN_TAB,PNULL);
                    break;
                default:
                    MMK_CreateWin(( uint32 * )MMIENG_NW_CAP_SHOW_WIN_TAB, ( ADD_DATA )menu_id );
                    break;
            }
            break;
        default:
            result = MMI_RESULT_FALSE;
            break;
    }
    return ( result );
}

LOCAL void ShowServingUECapInfo(mn_ueCapGsm_t ueCapabilityGsm, BOOLEAN need_update)
{
    wchar           unicode_cr = 0x0d;
    MMI_STRING_T    cr_s = {0};
    MMI_STRING_T    text_s = {0};
    MMI_STRING_T    plmn_name = {0};
    uint16          uint16_str[400] = {0};
    uint16          uint16_str_len = 0;
    uint16          temp_len = 0;
    uint8 i = 0;
    char temp_ptr[100] = {0};
    uint16 mnc = 0;


    MN_IMSI_T tmp_imsi = MNSIM_GetImsiEx( g_dual_sys );
    SCI_MEMSET( temp_ptr, 0, 100 );

    cr_s.wstr_ptr = &unicode_cr;
    cr_s.wstr_len = 1;

    SCI_TraceLow( "ENG Plmn [%2x] [%2x] [%2x]", ueCapabilityGsm.Plmn[0], ueCapabilityGsm.Plmn[1], ueCapabilityGsm.Plmn[2] );

    sprintf( temp_ptr, "PLMN: %d%d%d ", ueCapabilityGsm.Plmn[0] & 0x0F, ( ueCapabilityGsm.Plmn[0] & 0xF0 ) >> 4, ueCapabilityGsm.Plmn[1] & 0x0F );
    temp_len = SCI_STRLEN( ( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );

    if( 0xF == ( ( ueCapabilityGsm.Plmn[1] & 0xF0 ) >> 4 ) )
    {
        mnc = ( ueCapabilityGsm.Plmn[2] & 0x0F ) * 10 + ( ( ueCapabilityGsm.Plmn[2] & 0xF0 ) >> 4 );
        sprintf( temp_ptr, " %d%d ", mnc / 10, mnc % 10 );
    } else {
        mnc = ( ueCapabilityGsm.Plmn[2] & 0x0F ) * 100 + ( ( ueCapabilityGsm.Plmn[2] & 0xF0 ) >> 4 ) * 10 + ( ( ueCapabilityGsm.Plmn[1] & 0xF0 ) >> 4 );
        sprintf( temp_ptr, " %d ", mnc );
    }

    temp_len = SCI_STRLEN( ( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len);
    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行

    if( tmp_imsi.imsi_len != 0 )
    {
        sprintf( temp_ptr, "IMSI: ");
        temp_len = SCI_STRLEN(( char * )temp_ptr);
        MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
        SCI_MEMSET( temp_ptr, 0, 100 );
        MMIAPICOM_BcdToStr( PACKED_LSB_FIRST, ( uint8 * )tmp_imsi.imsi_val, MN_MAX_IMSI_ARR_LEN << 1, temp_ptr );
        SCI_TraceLow( "ENG imsi_val[%s]", temp_ptr + 1 );
        temp_len = SCI_STRLEN( ( char * )temp_ptr ) - 1;
        MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )( temp_ptr + 1 ), temp_len );
        MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行
    } else
    {
        sprintf( temp_ptr, "IMSI: None " );
        temp_len = SCI_STRLEN( ( char * )temp_ptr );
        MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
        MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行
    }

    sprintf( temp_ptr, "Network: ");
    temp_len = SCI_STRLEN( ( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );

    {
        PHONE_SERVICE_STATUS_T *s_temp = MMIAPIPHONE_GetServiceStatus();
        MMI_GetLabelTextByLang( MMIAPIPHONE_GetNetWorkNameId(0,&(s_temp->plmn)), &plmn_name );
    }
    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &plmn_name );
    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行

    if( ueCapabilityGsm.Roaming ) 
    {
        sprintf( temp_ptr, "Roaming: %s", "roaming" );
    } else 
    {
        sprintf( temp_ptr, "Roaming: %s", "Non-roaming" );
    }
    temp_len = SCI_STRLEN( ( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行


    sprintf( temp_ptr, "CellID: " );
    temp_len = SCI_STRLEN( ( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
    for( i = 0; i <= 1; i++ )
    {
        sprintf( temp_ptr, "%d", ueCapabilityGsm.CellId[i] );
        temp_len = SCI_STRLEN( ( char * )temp_ptr );
        MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
    }
    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行

    sprintf( temp_ptr, "Arfcn: %d", ueCapabilityGsm.Arfcn );
    temp_len = SCI_STRLEN( ( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行

    sprintf( temp_ptr, "Bsic: %d", ueCapabilityGsm.Bsic );
    temp_len = SCI_STRLEN( ( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行

    sprintf( temp_ptr, "Rla: %d", ueCapabilityGsm.Rla );
    temp_len = SCI_STRLEN( ( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行

    text_s.wstr_ptr = uint16_str;
    text_s.wstr_len = uint16_str_len;
    GUITEXT_SetString( MMIENG_TEXTBOX1_CTRL_ID, text_s.wstr_ptr, text_s.wstr_len, need_update );
}


LOCAL void ShowServingCellInfo(mn_lteScell_t lteScell,BOOLEAN need_update)
{
    wchar           unicode_cr = 0x0d;
    MMI_STRING_T    cr_s = {0};
    MMI_STRING_T    text_s = {0};
    MMI_STRING_T    plmn_name = {0};
    uint16          uint16_str[400] = {0};
    uint16          uint16_str_len = 0;
    uint16          temp_len = 0;
    uint8 i = 0;
    char temp_ptr[100] = {0};
    uint16 mnc = 0;
    SCI_MEMSET(temp_ptr, 0, 100);

    cr_s.wstr_ptr = &unicode_cr;
    cr_s.wstr_len = 1;

    SCI_TRACE_LOW( "[MMIENG] lteScell.plmn = [%2X] [%2X] [%2X] ", lteScell.plmn[0], lteScell.plmn[1], lteScell.plmn[2] );
    sprintf( temp_ptr, "PLMN: %d%d%d ", lteScell.plmn[0] & 0x0F, ( lteScell.plmn[0] & 0xF0 ) >> 4, lteScell.plmn[1] & 0x0F );
    temp_len = SCI_STRLEN( ( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );

    if( 0xF == ( ( lteScell.plmn[1] & 0xF0 ) >> 4 ) )
    {
        mnc = ( lteScell.plmn[2] & 0x0F ) * 10 + ( ( lteScell.plmn[2] & 0xF0 ) >> 4 );
        sprintf( temp_ptr, " %d%d ", mnc / 10, mnc % 10 );
    } else
    {
        mnc = ( lteScell.plmn[2] & 0x0F ) * 100 + ( ( lteScell.plmn[2] & 0xF0 ) >> 4 ) * 10 + ( ( lteScell.plmn[1] & 0xF0 ) >> 4 );
        sprintf( temp_ptr, " %d ", mnc );
    }

    temp_len = SCI_STRLEN(( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );

    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行

    SCI_TRACE_LOW( "[MMIENG] lteScell.imsi[0] = %d ", lteScell.imsi[0] );

    if( lteScell.imsi[0] != 0)
    {
        sprintf( temp_ptr, "IMSI: ");
        temp_len = SCI_STRLEN( ( char * )temp_ptr);
        MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
        for( i = 1; i <= lteScell.imsi[0]; i++ )
        {
            sprintf( temp_ptr, "%d", lteScell.imsi[i]);
            temp_len = SCI_STRLEN( ( char * )temp_ptr);
            MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
        }
        MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行
    }else
    {
        sprintf( temp_ptr, "IMSI: None " );
        temp_len = SCI_STRLEN( ( char * )temp_ptr );
        MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
        MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行
    }

    sprintf( temp_ptr, "Network: " );
    temp_len = SCI_STRLEN( ( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
    {
        PHONE_SERVICE_STATUS_T *s_temp = MMIAPIPHONE_GetServiceStatus();
        MMI_GetLabelTextByLang(MMIAPIPHONE_GetNetWorkNameId(0,&(s_temp->plmn)), &plmn_name );
    }

    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &plmn_name );
    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行

    if( lteScell.roamingFlag )
    {
        sprintf( temp_ptr, "Roaming: %s", "roaming" );
    } else
    {
        sprintf( temp_ptr, "Roaming: %s", "Non-roaming" );
    }
    temp_len = SCI_STRLEN( ( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行

    sprintf( temp_ptr, "BAND: %d", lteScell.bandInfo );
    temp_len = SCI_STRLEN( ( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行

    sprintf( temp_ptr, "EARFCN_DL: %d", lteScell.dlEarfcn );
    temp_len = SCI_STRLEN( ( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行

    sprintf( temp_ptr, "PCI: %d", lteScell.pcid );
    temp_len = SCI_STRLEN( ( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行

    lteScell.rsrp = lteScell.rsrp - 141;
    sprintf( temp_ptr, "RSRP: %ddBm", lteScell.rsrp );
    temp_len = SCI_STRLEN( ( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行

    lteScell.rsrq = lteScell.rsrq / 2 - 19.5;
    sprintf( temp_ptr, "RSRQ: %ddBm", lteScell.rsrq );
    temp_len = SCI_STRLEN( ( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行

    sprintf( temp_ptr, "TS MODE: %d", lteScell.tsMode );
    temp_len = SCI_STRLEN( ( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行

    sprintf( temp_ptr, "BAND WIDTH: %d", lteScell.bandwidth );
    temp_len = SCI_STRLEN( ( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行

    sprintf( temp_ptr, "SA: %d", lteScell.SA );
    temp_len = SCI_STRLEN( ( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行

    sprintf( temp_ptr, "SSP: %d", lteScell.SSP );
    temp_len = SCI_STRLEN( ( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行

    sprintf( temp_ptr, "SINR: %d", lteScell.SINR );
    temp_len = SCI_STRLEN( ( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行

    sprintf( temp_ptr, "UL_MCS: %d", lteScell.ulMcs );
    temp_len = SCI_STRLEN( ( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行

    sprintf( temp_ptr, "DL_MCS: %d", lteScell.dlMcs );
    temp_len = SCI_STRLEN( ( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行

    sprintf( temp_ptr, "UL_BLER: %d", lteScell.ulBler );
    temp_len = SCI_STRLEN( ( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行

    sprintf( temp_ptr, "DL_BLER: %d", lteScell.dlBler );
    temp_len = SCI_STRLEN( ( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行

    sprintf( temp_ptr, "E-NodeB ID: %d", lteScell.enodeBID );
    temp_len = SCI_STRLEN( ( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行

    sprintf( temp_ptr, "CELL ID: %d", lteScell.cellId );
    temp_len = SCI_STRLEN( ( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行
    
    text_s.wstr_ptr = uint16_str;
    text_s.wstr_len = uint16_str_len;
    GUITEXT_SetString( MMIENG_TEXTBOX1_CTRL_ID, text_s.wstr_ptr, text_s.wstr_len, need_update );
}

LOCAL void ShowAdjacentCellInfo(uint16 lteNcellNum,mn_lteNcell_t *lteNcell,BOOLEAN need_update )
{
    wchar           unicode_cr = 0x0d;
    MMI_STRING_T    cr_s = {0};
    MMI_STRING_T    text_s = {0};
    uint16          uint16_str[1024] = {0};
    uint16          uint16_str_len = 0;
    char            temp_ptr[50] = {0};

    uint16          temp_len = 0;
    uint8 i = 0;

    const char *item_name[2] = { "Frequency ",  "PCI "};
    const MMIENG_NETINFO_SHOW_TYPE_E   item_type[2] = {ENG_STRING_NUM, ENG_STRING_NUM};
    uint32 item_data[10*2] = {0};
    uint8 cell_arrow = MIN(10 , lteNcellNum);
    uint8 cell_colunm = (sizeof( item_name ) / ( sizeof( char * ) ));

    netinfoshow_t adjacentcell_t = {0};

    cr_s.wstr_ptr = &unicode_cr;
    cr_s.wstr_len = 1;


    for( i = 0; i < cell_arrow; i++ )
    {
        item_data[i * cell_colunm]     = lteNcell[i].frequency;
        item_data[i * cell_colunm + 1] = lteNcell[i].pcid;
    }

    adjacentcell_t.item = item_name;
    adjacentcell_t.item_type = item_type;
    adjacentcell_t.data = item_data;
    adjacentcell_t.colunm = cell_colunm;

    SCI_MEMSET( temp_ptr, 0, 50 );
    if( lteNcellNum != 0 )
    {
        for( i = 0; i < cell_arrow; i++ )
        {
            sprintf( temp_ptr, "<cell_%d>", i );
            temp_len = SCI_STRLEN( ( char * )temp_ptr );
            MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
            MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行

            adjacentcell_t.arrow = i;
            MMIENGARRAY_StrcatFromStrToUCS2( adjacentcell_t, uint16_str, &uint16_str_len );

            sprintf( temp_ptr, "RSRP: %ddBM", lteNcell[i].rsrp );
            temp_len = SCI_STRLEN( ( char * )temp_ptr );
            MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
            MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行

            sprintf( temp_ptr, "RSRQ: %ddBM", lteNcell[i].rsrq );
            temp_len = SCI_STRLEN( ( char * )temp_ptr );
            MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
            MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行
        }
    }else
    {
        sprintf( temp_ptr, "Cell_Num = 0" );
        temp_len = SCI_STRLEN( ( char * )temp_ptr );
        MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
        MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行
    }

    text_s.wstr_ptr = uint16_str;
    text_s.wstr_len = uint16_str_len;
    GUITEXT_SetString( MMIENG_TEXTBOX1_CTRL_ID, text_s.wstr_ptr, text_s.wstr_len, need_update );
}
LOCAL void ShowBetweenAdjacentCell_2G_Info(uint16 gsmNcellNum, mn_gsmNcell_t *gsmNcell,  BOOLEAN need_update)
{
    wchar           unicode_cr = 0x0d;
    MMI_STRING_T    cr_s = {0};
    MMI_STRING_T    text_s = {0};
    uint16          uint16_str[400] = {0};
    uint16          uint16_str_len = 0;
    char            temp_ptr[50] = {0};

    uint16          temp_len = 0;
    uint8 i = 0;

    const char *item_colunm_name[] = { "arfcn ",  "bsic ",  "rxlev "};
    const MMIENG_NETINFO_SHOW_TYPE_E   item_type[] = {ENG_STRING_NUM, ENG_STRING_NUM, ENG_STRING_NUM_DBM};
    uint32 item_data[15] = {0};

    uint8 cell_arrow = gsmNcellNum;
    uint8 cell_colunm = ( sizeof( item_colunm_name ) / ( sizeof( char * ) ) );
    netinfoshow_t adjacentcell_t = {0};

    cr_s.wstr_ptr = &unicode_cr;
    cr_s.wstr_len = 1;

    for( i = 0; i < cell_arrow; i++ )
    {
        item_data[i * cell_colunm]     = gsmNcell[i].arfcn;
        item_data[i * cell_colunm + 1] = gsmNcell[i].bsic;
        item_data[i * cell_colunm + 2] = gsmNcell[i].rxlev;
    }

    SCI_TRACE_LOW( "[ENG] ShowBetweenAdjacentCell_2G_Info gsmNcellNum=%d ", gsmNcellNum );

    adjacentcell_t.item = item_colunm_name;
    adjacentcell_t.item_type = item_type;
    adjacentcell_t.data = item_data;
    adjacentcell_t.colunm = cell_colunm;

    SCI_MEMSET( temp_ptr, 0, 50 );

    if( gsmNcellNum != 0 )
    {
        for( i = 0; i < cell_arrow; i++ )
        {
            sprintf( temp_ptr, "<cell_%d>", i );
            temp_len = SCI_STRLEN( ( char * )temp_ptr );
            MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
            MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行

            adjacentcell_t.arrow = i;
            MMIENGARRAY_StrcatFromStrToUCS2( adjacentcell_t, uint16_str, &uint16_str_len );
        }
    }else
    {
        sprintf( temp_ptr, "Cell_Num = 0");
        temp_len = SCI_STRLEN( ( char * )temp_ptr );
        MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
        MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行
    }

    text_s.wstr_ptr = uint16_str;
    text_s.wstr_len = uint16_str_len;
    GUITEXT_SetString( MMIENG_TEXTBOX1_CTRL_ID, text_s.wstr_ptr, text_s.wstr_len, need_update );
}

LOCAL void ShowOutFieldNetWorkInfo(mn_capInfoLte_t capInfoLte,BOOLEAN need_update)
{
    wchar           unicode_cr = 0x0d;
    MMI_STRING_T    cr_s = {0};
    MMI_STRING_T    text_s = {0};
    uint16          uint16_str[400] = {0};
    uint16          uint16_str_len = 0;
    char            temp_ptr[50] = {0};

    uint16          temp_len = 0;

    const char *item_colunm_name[] = { "Bsrvcc ",  "EMFBI ",  "IPV6 ", "ASRVCC ", "ESRVCC "};
    const MMIENG_NETINFO_SHOW_TYPE_E   item_type[] = {ENG_STRING_SUPPOT, ENG_STRING_SUPPOT, ENG_STRING_SUPPOT, ENG_STRING_SUPPOT, ENG_STRING_SUPPOT};

    uint32 item_data[5] = {0};

    uint8 cell_colunm = ( sizeof( item_colunm_name ) / ( sizeof( char * ) ) );
    netinfoshow_t adjacentcell_t = {0};

    cr_s.wstr_ptr = &unicode_cr;
    cr_s.wstr_len = 1;
    item_data[0] = capInfoLte.bsrvccFlag;
    item_data[1] = capInfoLte.emfbiFlag;
    item_data[2] = capInfoLte.ipv6Flag;
    item_data[3] = capInfoLte.asrvccFlag;
    item_data[4] = capInfoLte.esrvccFlag;
    adjacentcell_t.item = item_colunm_name;
    adjacentcell_t.item_type = item_type;
    adjacentcell_t.data = item_data;
    adjacentcell_t.colunm = cell_colunm;

    SCI_MEMSET( temp_ptr, 0, 50 );

    if( capInfoLte.lteCipherFlag )
    {
        sprintf( temp_ptr, "4G Cipher %s", "Support" );
    } else
    {
        sprintf( temp_ptr, "4G Cipher %s", "not Support" );
    }
    temp_len = SCI_STRLEN( ( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行

    adjacentcell_t.arrow = 0;
    MMIENGARRAY_StrcatFromStrToUCS2( adjacentcell_t, uint16_str, &uint16_str_len );

    text_s.wstr_ptr = uint16_str;
    text_s.wstr_len = uint16_str_len;
    GUITEXT_SetString( MMIENG_TEXTBOX1_CTRL_ID, text_s.wstr_ptr, text_s.wstr_len, need_update );
}
/*********************************************************************************************/
/*************************************Netinfo Begin*******************************************/
/*********************************************************************************************/
#define ENG_MAX_STR_LENGTH 255
#define ENG_MAX_ARR_SIZE   50

#define MMIENG_NETINFO_LEN 1024
#ifdef PLATFORM_ANTISW3

#ifndef WIN32
//结构体中某个item 的内容
typedef struct
{ 
uint8 item_name[ENG_MAX_STR_LENGTH];
uint32 arr_count;
uint32 arr_value[ENG_MAX_ARR_SIZE];
uint32 min_value;
uint32 max_value;
}ITEM_T;
#endif
#endif
LOCAL MN_GMMREG_RAT_E GetCurrentRat(MN_DUAL_SYS_E  dual_sys)
{
    TRACE_APP_ENGINEERMODE("GetCurrentRat dual_sys=%d",dual_sys);
    return MNPHONE_GetCurrentRATEx(dual_sys);
}

void MMIENG_GSM_getServingCell(MMI_CTRL_ID_T ctrl_id,BOOLEAN is_update)
{
    uint32 i = 0, item_count = 0;
    ITEM_T item = {0};
    wchar           unicode_cr = 0x0d;
    MMI_STRING_T    cr_s = {0};
    MMI_STRING_T    text_s = {0};
    MMI_STRING_T    opn_spn_name_str = {0};
    wchar           opn_spn_name[MMIPHONE_MAX_OPER_NAME_LEN + 1] = {0};
    wchar          *service_cell_info = PNULL;
    uint16          cell_info_len = 0;
    uint16          temp_len = 0;
    char temp_ptr[200] = {0};
    uint8 item_name[][40] = {
        "CellID",
        "ARFCN_DL",
        "BSIC",
        "Interference",
        "Signal strength",
    };
    uint8 item_index[] = {
        1, 2, 0, 3, 4
    };

    PHONE_SERVICE_STATUS_T service_info = {0};
    service_cell_info = (wchar*)SCI_ALLOC_APPZ( sizeof(wchar)*(MMIENG_NETINFO_LEN+1) );
    if(PNULL == service_cell_info)
    {
        TRACE_APP_ENGINEERMODE("malloc fail");
        return;
    }
    SCI_MEMSET( temp_ptr, 0, sizeof( temp_ptr ) );
    cr_s.wstr_ptr = &unicode_cr;
    cr_s.wstr_len = 1;
    MMIAPIPHONE_GetCurServiceStatus(g_dual_sys,&service_info);
    TRACE_APP_ENGINEERMODE("mnc_digit_num=%d",service_info.plmn.mnc_digit_num);
    if(2 == service_info.plmn.mnc_digit_num)
    {
        sprintf( temp_ptr, "PLMN: %03d %02d", service_info.plmn.mcc,service_info.plmn.mnc);
    }else if(3 == service_info.plmn.mnc_digit_num)
    {
        sprintf( temp_ptr, "PLMN: %03d %03d", service_info.plmn.mcc,service_info.plmn.mnc);
    }else
    {
        sprintf( temp_ptr, "PLMN: %03d %d", service_info.plmn.mcc,service_info.plmn.mnc);
    }
    //ssprintf( temp_ptr, "PLMN: %d %d", service_info.plmn.mcc,service_info.plmn.mnc);//bug1831806
    temp_len = SCI_STRLEN( ( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( service_cell_info, &cell_info_len, ( uint8 * )temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2( service_cell_info, &cell_info_len, &cr_s ); //换行
    sprintf( temp_ptr, "Network: " );
    temp_len = SCI_STRLEN( ( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( service_cell_info, &cell_info_len, ( uint8 * )temp_ptr, temp_len );
    opn_spn_name_str.wstr_ptr = opn_spn_name;
    MMIAPIPHONE_GetSimAndServiceString(g_dual_sys,&opn_spn_name_str);//Bug 1960184
    MMIAPICOM_StrcatFromSTRINGToUCS2( service_cell_info, &cell_info_len, &opn_spn_name_str );
    MMIAPICOM_StrcatFromSTRINGToUCS2( service_cell_info, &cell_info_len, &cr_s ); //换行
    if( MMIPHONE_ROAMING_STATUS_NO_ROMING == MMIAPIPHONE_GetRoamingStatus(g_dual_sys) )
    {
        sprintf( temp_ptr, "Roaming: %s", "Non-roaming" );
    } else
    {
        sprintf( temp_ptr, "Roaming: %s", "roaming" );
    }
    temp_len = SCI_STRLEN( ( char * )temp_ptr );
    MMIAPICOM_StrcatFromStrToUCS2( service_cell_info, &cell_info_len, ( uint8 * )temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2( service_cell_info, &cell_info_len, &cr_s ); //换行
    SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
#ifdef PLATFORM_ANTISW3
    item_count  = em_get_2g_serv_cell_info_count();
    for( i = 0; i < 5; i++ )
   	{
        if( i != 4 )
        {
            em_get_2g_serv_cell_info( ( int32 )g_dual_sys, &item, i );
            TRACE_APP_ENGINEERMODE("item.arr_value[0]=%d",item.arr_value[0]);
            sprintf( temp_ptr,  "%s:%d ", item_name[item_index[i]], item.arr_value[0] );
            temp_len = SCI_STRLEN( ( char * )temp_ptr );
            MMIAPICOM_StrcatFromStrToUCS2( service_cell_info, &cell_info_len, ( uint8 * )temp_ptr, temp_len );
            MMIAPICOM_StrcatFromSTRINGToUCS2( service_cell_info, &cell_info_len, &cr_s ); //换行
            memset( ( void * )temp_ptr, 0, sizeof( temp_ptr ) );
        } else {
            em_get_2g_serv_cell_info( ( int32 )g_dual_sys, &item, i );
            TRACE_APP_ENGINEERMODE("item.arr_value[0]=%d",item.arr_value[0]);
            sprintf( temp_ptr,  "%s:%d dBm", item_name[item_index[i]],(int)( item.arr_value[0] - 110) );
            temp_len = SCI_STRLEN( ( char * )temp_ptr );
            MMIAPICOM_StrcatFromStrToUCS2( service_cell_info, &cell_info_len, ( uint8 * )temp_ptr, temp_len );
            MMIAPICOM_StrcatFromSTRINGToUCS2( service_cell_info, &cell_info_len, &cr_s ); //换行
        }
    }
#endif
    text_s.wstr_ptr = service_cell_info;
    text_s.wstr_len = cell_info_len;
    GUITEXT_SetString( ctrl_id, text_s.wstr_ptr, text_s.wstr_len, is_update );

    if(PNULL != service_cell_info)
    {
        SCI_FREE(service_cell_info);
        service_cell_info = PNULL;
    }
}
void MMIENG_WCDMA_getServingCell(MMI_CTRL_ID_T      ctrl_id,
                               BOOLEAN            is_update)
{
    uint32 i = 0, j = 0, item_count = 0, num = 0;
    ITEM_T item = {0};
    wchar           unicode_cr = 0x0d;
    MMI_STRING_T    cr_s = {0};
    MMI_STRING_T    text_s = {0};
    MMI_STRING_T plmn_name = {0};
    wchar          *WCDMA_str = PNULL;
    uint16          WCDMA_str_len = 0;
    uint16          temp_len = 0;
    char temp_ptr[200] = {0};
    uint8 item_name[][40] = {
        "CellID",
        "RNC_ID",
        "UARFCN_DL",
        "Scrambler",
        "ECNO",
        "Signal",
        "CQI_MIN",
        "CQI_MAX",
        "CQI_AVG",
        "TB_SIZE",
        "BLER",
        "DC_HSDPA",
        "PCell_Frequency",
        "PCell_cellid",
        "PCell_ecno",
        "PCell_rssi",
        "SCell_Frequency",
        "SCell_cellid",
        "SCell_ecno",
        "SCell_rssi",
    };
#ifndef WIN32
    uint8 item_name_value[20][40] = {0};
#else
    uint8 item_name_value[][40] = {
        "CellID",
        "RNC_ID",
        "UARFCN_DL",
        "Scrambler",
        "ECNO",
        "Signal",
        "CQI_MIN",
        "CQI_MAX",
        "CQI_AVG",
        "TB_SIZE",
        "BLER",
        "DC_HSDPA",
        "PCell_Frequency",
        "PCell_cellid",
        "PCell_ecno",
        "PCell_rssi",
        "SCell_Frequency",
        "SCell_cellid",
        "SCell_ecno",
        "SCell_rssi",
    };
#endif
    WCDMA_str = (wchar*)SCI_ALLOC_APPZ( sizeof(wchar)*(MMIENG_NETINFO_LEN+1) );
    if(PNULL == WCDMA_str)
    {
        TRACE_APP_ENGINEERMODE("malloc fail");
        return;
    }

    SCI_MEMSET( temp_ptr, 0, sizeof( temp_ptr ) );
    cr_s.wstr_ptr = &unicode_cr;
    cr_s.wstr_len = 1;
#ifndef WIN32
#ifdef PLATFORM_ANTISW3
    SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
    item_count  = 8;//mmi_get_em_serv_cell_info_count();//todo:
    for( i = 0; i < item_count; i++ ) {
        if( i == 0 ) {
            em_get_3g_serv_cell_info( ( int32 )g_dual_sys, &item, i );
            TRACE_APP_ENGINEERMODE("item.arr_value[0]=%d",item.arr_value[0]);
            sprintf( item_name_value[2],  "%s:%d ", item_name[2], item.arr_value[0] );
        }
        if( i == 1 ) {
            em_get_3g_serv_cell_info( ( int32 )g_dual_sys, &item, i );
            TRACE_APP_ENGINEERMODE("item.arr_value[0]=%d",item.arr_value[0]);
            sprintf( item_name_value[3],  "%s:%d ", item_name[3], item.arr_value[0] );
        }
        if( i == 2 ) {
            em_get_3g_serv_cell_info( ( int32 )g_dual_sys, &item, i );
            TRACE_APP_ENGINEERMODE("item.arr_value[0]=%d",item.arr_value[0]);
            sprintf( item_name_value[5],  "%s:%ddBm", item_name[5], item.arr_value[0] );
        }
#if 0 // item count =8?
        if( i == 15 ) {
            em_get_3g_serv_cell_info( ( int32 )g_dual_sys, &item, i );
            TRACE_APP_ENGINEERMODE("item.arr_value[0]=%d",item.arr_value[0]);
            sprintf( item_name_value[4],  "%s:%d ", item_name[4], item.arr_value[0] * 10 / 20 );
        }
        if( i == 16 ) {
            em_get_3g_serv_cell_info( ( int32 )g_dual_sys, &item, i );
            TRACE_APP_ENGINEERMODE("item.arr_value[0]=%d",item.arr_value[0]);
            sprintf( item_name_value[0],  "%s:%d ", item_name[0], item.arr_value[0] );
        }
        if( i == 17 ) {
            em_get_3g_serv_cell_info( ( int32 )g_dual_sys, &item, i );
            TRACE_APP_ENGINEERMODE("item.arr_value[0]=%d",item.arr_value[0]);
            sprintf( item_name_value[1],  "%s:%d ", item_name[1], item.arr_value[0] );
        }
#endif
    }
#endif
#endif
#ifdef PLATFORM_ANTISW3
    SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
    item_count  = em_get_3g_cqi_tb_size_count();
    num = 6;
    for( i = 0; i < item_count; i++ ) {
        if( i == 0 ) {
            em_get_3g_cqi_tb_size_info( ( int32 )g_dual_sys, &item, i );
            for( j = 0; j < 3; j++ ) {
                sprintf( item_name_value[num],  "%s:%d ", item_name[num], item.arr_value[j] );
                TRACE_APP_ENGINEERMODE( "value[%d] ", item_name[num], item.arr_value[j] );
                num++;
            }
        } else {
            em_get_3g_cqi_tb_size_info( ( int32 )g_dual_sys, &item, i );
            sprintf( item_name_value[num],  "%s:%d ", item_name[num], item.arr_value[0] );
            TRACE_APP_ENGINEERMODE( "vlue[%d] ", item.arr_value[0] );
            num++;
        }
    }
#ifndef WIN32
    SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
    em_get_generic_nv_info( ( int32 )g_dual_sys, &item, 13 );
    TRACE_APP_ENGINEERMODE("item.arr_value[0]=%d",item.arr_value[0]);
    if( item.arr_value[0] ) {
        sprintf( item_name_value[11],  "%s: YES ", item_name[11] );
    } else {
        sprintf( item_name_value[11],  "%s: NO ", item_name[11] );
    }
    SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
    item_count  = em_get_3g_pcell_scell_info_count();
    num = 12;
    if(item_count < 8)
    {
        for( i = 0; i < item_count ; i++ ) {
            if( i == 3 || i == 7 ) {
                em_get_3g_pcell_scell_info( ( int32 )g_dual_sys, &item, i );
                TRACE_APP_ENGINEERMODE("item.arr_value[0]=%d",item.arr_value[0]);
                sprintf( item_name_value[num + i],  "%s:%d dBm", item_name[num+i], item.arr_value[0] );
            } else {
                em_get_3g_pcell_scell_info( ( int32 )g_dual_sys, &item, i );
                sprintf( item_name_value[num + i],  "%s:%d ", item_name[num + i], item.arr_value[0] );
                TRACE_APP_ENGINEERMODE( "name[%s] vlue[%d] ", item_name[num + i], item.arr_value[0] );
                //num++;
            }
        }
    }
#endif
#endif
     {
        MMI_STRING_T opn_spn_name_str = {0};
        wchar opn_spn_name[MMIPHONE_MAX_OPER_NAME_LEN + 1] = {0};
        PHONE_SERVICE_STATUS_T s_temp = {0};
        MMIAPIPHONE_GetCurServiceStatus(g_dual_sys,&s_temp);
        TRACE_APP_ENGINEERMODE("mnc_digit_num=%d",s_temp.plmn.mnc_digit_num);
        if(2 == s_temp.plmn.mnc_digit_num)
        {
            sprintf( temp_ptr, "PLMN: %03d %02d", s_temp.plmn.mcc,s_temp.plmn.mnc);
        }else if(3 == s_temp.plmn.mnc_digit_num)
        {
            sprintf( temp_ptr, "PLMN: %03d %03d", s_temp.plmn.mcc,s_temp.plmn.mnc);
        }else
        {
            sprintf( temp_ptr, "PLMN: %03d %d", s_temp.plmn.mcc,s_temp.plmn.mnc);
        }
        temp_len = SCI_STRLEN( ( char * )temp_ptr );
        MMIAPICOM_StrcatFromStrToUCS2( WCDMA_str, &WCDMA_str_len, ( uint8 * )temp_ptr, temp_len );
        MMIAPICOM_StrcatFromSTRINGToUCS2( WCDMA_str, &WCDMA_str_len, &cr_s ); //换行
        sprintf( temp_ptr, "Network: " );
        temp_len = SCI_STRLEN( ( char * )temp_ptr );
        MMIAPICOM_StrcatFromStrToUCS2( WCDMA_str, &WCDMA_str_len, ( uint8 * )temp_ptr, temp_len );
        opn_spn_name_str.wstr_ptr = opn_spn_name;
        MMIAPIPHONE_GetSimAndServiceString(g_dual_sys,&opn_spn_name_str);//Bug 1960184
        MMIAPICOM_StrcatFromSTRINGToUCS2( WCDMA_str, &WCDMA_str_len, &opn_spn_name_str );
        MMIAPICOM_StrcatFromSTRINGToUCS2( WCDMA_str, &WCDMA_str_len, &cr_s ); //换行
        if( MMIPHONE_ROAMING_STATUS_NO_ROMING == MMIAPIPHONE_GetRoamingStatus(g_dual_sys) ) {
                sprintf( temp_ptr, "Roaming: %s", "Non-roaming" );
        } else {
                sprintf( temp_ptr, "Roaming: %s", "roaming" );
        }
        temp_len = SCI_STRLEN( ( char * )temp_ptr );
        MMIAPICOM_StrcatFromStrToUCS2( WCDMA_str, &WCDMA_str_len, ( uint8 * )temp_ptr, temp_len );
        MMIAPICOM_StrcatFromSTRINGToUCS2( WCDMA_str, &WCDMA_str_len, &cr_s ); //换行
    }
    for( i = 0; i < 20; i++ ) {
        sprintf( temp_ptr,  "%s", item_name_value[i] );
        temp_len = SCI_STRLEN( ( char * )temp_ptr );
        MMIAPICOM_StrcatFromStrToUCS2( WCDMA_str, &WCDMA_str_len, ( uint8 * )temp_ptr, temp_len );
        MMIAPICOM_StrcatFromSTRINGToUCS2( WCDMA_str, &WCDMA_str_len, &cr_s ); //换行
        memset( ( void * )temp_ptr, 0, sizeof( temp_ptr ) );
    }
    text_s.wstr_ptr = WCDMA_str;
    text_s.wstr_len = WCDMA_str_len;
    GUITEXT_SetString( ctrl_id, text_s.wstr_ptr, text_s.wstr_len, is_update );
    if(PNULL != WCDMA_str)
    {
        SCI_FREE(WCDMA_str);
        WCDMA_str = PNULL;
    }
}
void MMIENG_LTE_getServingCell( MMI_CTRL_ID_T ctrl_id, BOOLEAN is_update )
{
    uint32 i = 0, j = 0, item_count = 0, num = 0;
    ITEM_T item = {0};
    wchar           unicode_cr = 0x0d;
    MMI_STRING_T    cr_s = {0};
    MMI_STRING_T    text_s = {0};
    MMI_STRING_T plmn_name = {0};
    wchar          *LTE_service_cel_info = PNULL;
    uint16          LTE_service_cel_info_len = 0;
    uint16          temp_len = 0;

    uint32          temp_ret = 0;

    uint8 *temp_ptr = PNULL;
    uint8 item_name[][15] = {
        "BAND",
        "EARFCN_DL",
        "PCI",
        "RSRP",
        "RSRQ",
        "TS_MODE",
        "BAND WIDTH",
        "E_NodeB_ID",
        "Cell_ID",
        "SA",
        "SSP",
        "SINR",
        "UL_MCS",
        "DL_MCS",
        "UL_BLER",
        "DL_BLER",
    };
    uint8 bandwidth_name[][6] = {
        "1.4M",
        "3M",
        "5M",
        "10M",
        "15M",
        "20M",
        "NA"
    };
    uint8 *item_heap = NULL;
    uint8 item_one_size = 80;
    uint8 *item_name_value[16] = {0};
    uint8 item_index[] = {0, 1, 2, 3, 4, 6, 7, 10, 11};

    int32  rsrp_dbm = 0;
    int32  rsrq_dbm= 0;
    LTE_service_cel_info = (wchar*)SCI_ALLOC_APPZ( sizeof(wchar)*(MMIENG_NETINFO_LEN+1) );
    if(PNULL == LTE_service_cel_info)
    {
        TRACE_APP_ENGINEERMODE("LTE_service_cel_info malloc fail");
        return;
    }

    temp_ptr = (uint8*)SCI_ALLOC_APPZ( sizeof(uint8)*(200+1) );
    if(PNULL == temp_ptr)
    {
        SCI_FREE(LTE_service_cel_info);
        TRACE_APP_ENGINEERMODE("temp_ptr malloc fail");
        return;
    }

    item_heap = (uint8 *)SCI_ALLOC_APPZ(sizeof(uint8) * item_one_size * 16);
    if (item_heap == PNULL)
    {
        SCI_FREE(LTE_service_cel_info);
        SCI_FREE(temp_ptr);
        TRACE_APP_ENGINEERMODE("item_heap malloc fail");
        return;
    }
    TRACE_APP_ENGINEERMODE("item_heap = %X",item_heap);

    for(i = 0;i < 16;i++)
    {
        item_name_value[i] = item_heap + i * item_one_size;
        TRACE_APP_ENGINEERMODE("item_name_value[%d] = %X",i,item_name_value[i]);
    }
    
    SCI_MEMSET( temp_ptr, 0, sizeof( temp_ptr ) );
    cr_s.wstr_ptr = &unicode_cr;
    cr_s.wstr_len = 1;
    SCI_MEMSET( &item, 0, sizeof( ITEM_T ) );
    item_count  = em_get_4g_serv_cell_info_count();
    TRACE_APP_ENGINEERMODE("item_count =%d",item_count);
#ifdef PLATFORM_ANTISW3
    for( i = 0; i < 9; i++ )
    {
        TRACE_APP_ENGINEERMODE("i=%d",i);
        if( i == 3 || i == 4 )
        {
            em_get_4g_serv_cell_info( ( int32 )g_dual_sys, &item, i );
            TRACE_APP_ENGINEERMODE("item.arr_count=%d",item.arr_count);
            if( item.arr_count == 0 ) 
            {
                sprintf( item_name_value[i],  "%s: NA", item_name[i] );
            } else
            {
                rsrp_dbm = (int32)item.arr_value[0] / (int32)100;
                rsrq_dbm= (int32)item.arr_value[1] / (int32)100; 
                TRACE_APP_ENGINEERMODE("item.arr_value[0] = %d,/100=%d,item.arr_value[1]=%d,/100=%d",
                                        item.arr_value[0],rsrp_dbm,item.arr_value[1],rsrq_dbm);

                sprintf( item_name_value[i],  "%s: %d dBm %d dBm", item_name[i],rsrp_dbm,rsrq_dbm ) ;
            }
        } else if( i == 6 )
        {
            uint8 bandindex1 = 0;
            uint8 bandindex2 = 0;
            em_get_4g_serv_cell_info( ( int32 )g_dual_sys, &item, (uint32)item_index[i] );
            bandindex1 = ( item.arr_value[0] > 5 ||  item.arr_value[0] < 0 ) ? 6 : item.arr_value[0];
            bandindex2 = ( item.arr_value[1] > 5 ||  item.arr_value[1] < 0 ) ? 6 : item.arr_value[1];
            TRACE_APP_ENGINEERMODE("item.arr_count=%d",item.arr_count);
            if( item.arr_count == 0 )
            {
                sprintf( item_name_value[i],  "%s: NA", item_name[i] );
            } else
            {
                sprintf( item_name_value[i],  "%s: %s,%s", item_name[i],  bandwidth_name[bandindex1], bandwidth_name[bandindex2] );
            }
        } else
        {
            SCI_MEMSET( &item, 0, sizeof( ITEM_T ) );
            TRACE_APP_ENGINEERMODE("before");
            TRACE_APP_ENGINEERMODE("g_dual_sys=%d,item_index[i]=%d,sizeof( ITEM_T )=%d",g_dual_sys,item_index[i],sizeof( ITEM_T ));
            em_get_4g_serv_cell_info( ( int32 )g_dual_sys, &item, (uint32)item_index[i] );
            TRACE_APP_ENGINEERMODE("after");
            sprintf( item_name_value[i],  "%s:", item_name[i] );
            TRACE_APP_ENGINEERMODE("item.arr_count=%d",item.arr_count);
            if(50 < item.arr_count || 0 > item.arr_count)
            {
                TRACE_APP_ENGINEERMODE(" item.arr_count value error");
                continue;
            }
            if( item.arr_count == 0 )
            {
                sprintf( item_name_value[i],  "%s NA ", item_name_value[i] );
            } else
            {
                for( j = 0; j < item.arr_count; j++ )
                {
                    TRACE_APP_ENGINEERMODE("item.arr_value[j]=%d",item.arr_value[j]);
                    sprintf( item_name_value[i],  "%s%d ", item_name_value[i], item.arr_value[j] );
                }
            }
        }
        TRACE_APP_ENGINEERMODE("item_name_value[%d] = %X",i,item_name_value[i]);
    }
    SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
    item_count  = em_get_4g_cqi_tb_size_count();
    TRACE_APP_ENGINEERMODE("item_count =%d",item_count);
    num = 9;
    for( i = 0; i < 7; i++ )
    {
        em_get_4g_cqi_tb_size_info( ( int32 )g_dual_sys, &item, i );
        sprintf( item_name_value[i + num],  "%s:", item_name[i + num] );
        TRACE_APP_ENGINEERMODE("item.arr_count=%d",item.arr_count);
        if( item.arr_count == 0 )
        {
            sprintf(item_name_value[i + num],  "%s NA", item_name_value[i + num] );
            TRACE_APP_ENGINEERMODE("item_name_value[i + num]=%s",item_name_value[i + num]);
        } else
        {
            for( j = 0; j < item.arr_count; j++ )
            {
                TRACE_APP_ENGINEERMODE("item.arr_value[j]=%d",item.arr_value[j]);
                sprintf( item_name_value[i + num],  "%s%d ", item_name_value[i + num], item.arr_value[j] );
            }
        }
        TRACE_APP_ENGINEERMODE("item_name_value[%d] = %X",i,item_name_value[i]);
    }
#endif
    {
        MMI_STRING_T opn_spn_name_str = {0};
        wchar opn_spn_name[MMIPHONE_MAX_OPER_NAME_LEN + 1] = {0};
        PHONE_SERVICE_STATUS_T s_temp = {0};
        MMIAPIPHONE_GetCurServiceStatus(g_dual_sys,&s_temp);
        TRACE_APP_ENGINEERMODE("mnc_digit_num=%d",s_temp.plmn.mnc_digit_num);
        if(2 == s_temp.plmn.mnc_digit_num)
        {
            sprintf( temp_ptr, "PLMN: %03d %02d", s_temp.plmn.mcc,s_temp.plmn.mnc);
        }else if(3 == s_temp.plmn.mnc_digit_num)
        {
            sprintf( temp_ptr, "PLMN: %03d %03d", s_temp.plmn.mcc,s_temp.plmn.mnc);
        }else
        {
            sprintf( temp_ptr, "PLMN: %03d %d", s_temp.plmn.mcc,s_temp.plmn.mnc);
        }
        temp_len = SCI_STRLEN( ( char * )temp_ptr );
        MMIAPICOM_StrcatFromStrToUCS2( LTE_service_cel_info, &LTE_service_cel_info_len, ( uint8 * )temp_ptr, temp_len );
        MMIAPICOM_StrcatFromSTRINGToUCS2( LTE_service_cel_info, &LTE_service_cel_info_len, &cr_s ); //换行
        sprintf( temp_ptr, "Network: " );
        temp_len = SCI_STRLEN( ( char * )temp_ptr );
        MMIAPICOM_StrcatFromStrToUCS2( LTE_service_cel_info, &LTE_service_cel_info_len, ( uint8 * )temp_ptr, temp_len );
        opn_spn_name_str.wstr_ptr = opn_spn_name;
        MMIAPIPHONE_GetSimAndServiceString(g_dual_sys,&opn_spn_name_str);//Bug 1960184
        MMIAPICOM_StrcatFromSTRINGToUCS2( LTE_service_cel_info, &LTE_service_cel_info_len, &opn_spn_name_str );
        MMIAPICOM_StrcatFromSTRINGToUCS2( LTE_service_cel_info, &LTE_service_cel_info_len, &cr_s ); //换行
        if( MMIPHONE_ROAMING_STATUS_NO_ROMING == MMIAPIPHONE_GetRoamingStatus(g_dual_sys) ) 
        {
                sprintf( temp_ptr, "Roaming: %s", "Non-roaming" );
        } else
        {
                sprintf( temp_ptr, "Roaming: %s", "roaming" );
        }
        temp_len = SCI_STRLEN( ( char * )temp_ptr );
        MMIAPICOM_StrcatFromStrToUCS2( LTE_service_cel_info, &LTE_service_cel_info_len, ( uint8 * )temp_ptr, temp_len );
        MMIAPICOM_StrcatFromSTRINGToUCS2( LTE_service_cel_info, &LTE_service_cel_info_len, &cr_s ); //换行
    }
    for( i = 0; i < 16; i++ )
    {
        sprintf( temp_ptr,  "%s", item_name_value[i] );
        temp_len = SCI_STRLEN( ( char * )temp_ptr );
        MMIAPICOM_StrcatFromStrToUCS2( LTE_service_cel_info, &LTE_service_cel_info_len, ( uint8 * )temp_ptr, temp_len );
        MMIAPICOM_StrcatFromSTRINGToUCS2( LTE_service_cel_info, &LTE_service_cel_info_len, &cr_s ); //换行
        memset( ( void * )temp_ptr, 0, sizeof( temp_ptr ) );
    }
    text_s.wstr_ptr = LTE_service_cel_info;
    text_s.wstr_len = LTE_service_cel_info_len;
    GUITEXT_SetString( ctrl_id, text_s.wstr_ptr, text_s.wstr_len, is_update );
    if(PNULL != LTE_service_cel_info)
    {
        TRACE_APP_ENGINEERMODE("free");
        SCI_FREE(LTE_service_cel_info);
        LTE_service_cel_info = PNULL;
    }
    if(PNULL != temp_ptr)
    {
        TRACE_APP_ENGINEERMODE("free");
        SCI_FREE(temp_ptr);
        temp_ptr = PNULL;
    }

    if (item_heap != PNULL)
    {
        SCI_FREE(item_heap);
    }

}
LOCAL void MMIENG_GSMShowAdjacentCellInfo( uint32 rat_id, MMI_CTRL_ID_T ctrl_id, BOOLEAN need_update )
{
    uint32 i = 0, j = 0, item_count = 0, ncellnum = 0;
    wchar           unicode_cr = 0x0d;
    MMI_STRING_T    cr_s = {0};
    MMI_STRING_T    text_s = {0};
    wchar          *uint16_str = PNULL;
    uint16          uint16_str_len = 0;
    char            temp_ptr[100] = {0};
    uint16          temp_len = 0;
    ITEM_T item = {0};
    const char *item_name_gsm[] = { "CellID", "Frequency", "BSIC", "Interference", "Signal"};
    const MMIENG_NETINFO_SHOW_TYPE_E   item_type_gsm[] = {ENG_STRING_NUM, ENG_STRING_NUM, ENG_STRING_NUM, ENG_STRING_NUM, ENG_STRING_NUM_DBM};
    const char *item_name_wcdma[] = { "Frequency", "PSC","Signal"};
    const MMIENG_NETINFO_SHOW_TYPE_E   item_type_wcdma[] = {ENG_STRING_NUM, ENG_STRING_NUM,ENG_STRING_NUM_DBM};
    const char *item_name_lte[] = { "Frequency", "PCI", "RSRP", "RSRQ"};
    const MMIENG_NETINFO_SHOW_TYPE_E   item_type_lte[] = {ENG_STRING_NUM, ENG_STRING_NUM, ENG_STRING_NUM_DBM, ENG_STRING_NUM_DBM};
    uint32 item_data[50] = {0};
    uint32 cellnumcount = 0;
    netinfoshow_t adjacentcell_t = {0};
    cr_s.wstr_ptr = &unicode_cr;
    cr_s.wstr_len = 1;
    TRACE_APP_ENGINEERMODE("RAT_ID=%d",rat_id);

    uint16_str = (wchar*)SCI_ALLOC_APPZ( sizeof(wchar)*(MMIENG_NETINFO_LEN+1) );
    if(PNULL == uint16_str)
    {
        TRACE_APP_ENGINEERMODE("malloc fail");
        return;
    }

    switch(rat_id)
    {
        case 0: //GSM
        {
#ifdef PLATFORM_ANTISW3
            for( i = 0; i < 5; i++ )
            {
                em_get_2g_inter_neig_cell_info( ( int32 )g_dual_sys, &item, i );
                TRACE_APP_ENGINEERMODE("item.arr_count=%d",item.arr_count);
                if( item.arr_count )
                {
                    ncellnum++;
                    for( j = 0; j < (item.arr_count >5?5:item.arr_count); j++ )
                    {
                        if(i==4)
                        {
                            item_data[j * 5 + i]  = item.arr_value[j]-110;
                        }
                        else
                        {
                            item_data[j * 5 + i]  = item.arr_value[j] ;
                        }
                    }
                }
            }
#endif
            adjacentcell_t.item = item_name_gsm;
            adjacentcell_t.item_type = item_type_gsm;
            adjacentcell_t.data = item_data;
            adjacentcell_t.colunm = ( sizeof( item_name_gsm ) / ( sizeof( char * ) ) );
            cellnumcount = (item.arr_count >5?5:item.arr_count);
            break;
        }
        case 1: //Wcdma
        {
            for( i = 0; i < 5; i++ )
            {
#ifndef WIN32
#ifdef PLATFORM_ANTISW3
                em_get_3g_inter_neig_cell_info( ( int32 )g_dual_sys, &item, i );//BUG 1810570
#endif
#endif
                TRACE_APP_ENGINEERMODE("item.arr_count=%d",item.arr_count);
                if( item.arr_count )
                {
                    ncellnum++;
                    for( j = 0; j < 3; j++ )
                    {
                        item_data[i * 3 + j]  = item.arr_value[j] ;
                    }
                }
            }
            adjacentcell_t.item = item_name_wcdma;
            adjacentcell_t.item_type = item_type_wcdma;
            adjacentcell_t.data = item_data;
            adjacentcell_t.colunm = ( sizeof( item_name_wcdma ) / ( sizeof( char * ) ) );
            cellnumcount = 5;
            break;
        }
        case 2:  //LTE
        {
#ifdef PLATFORM_ANTISW3
            item_count = em_get_4g_inter_neig_cell_info_count();
            TRACE_APP_ENGINEERMODE("item_count = %d",item_count);
            for( i = 0; i < 5; i++ )
            {
                em_get_4g_inter_neig_cell_info( ( int32 )g_dual_sys, &item, i );
                TRACE_APP_ENGINEERMODE("item.arr_count=%d",item.arr_count);
                if( item.arr_count )
                {
                    ncellnum++;
                    for( j = 0; j < 4; j++ )
                    {
                        if(j==2 | j==3)
                        {
                             item_data[i*4 + j]  = (item.arr_value[j])/100 ;
                        }
                        else
                        {
                            item_data[i*4 + j]  = item.arr_value[j] ;
                        }
                    }
                }
            }
#endif
            adjacentcell_t.item = item_name_lte;
            adjacentcell_t.item_type = item_type_lte;
            adjacentcell_t.data = item_data;
            adjacentcell_t.colunm = ( sizeof( item_name_lte ) / ( sizeof( char * ) ) );
            cellnumcount = 5;
            break;
        }
        default:
            TRACE_APP_ENGINEERMODE("default");
            break;
    }
    SCI_MEMSET( temp_ptr, 0, sizeof( temp_ptr ) );
    TRACE_APP_ENGINEERMODE("ncellnum = %d",ncellnum);
    if( ncellnum != 0 )
    {
        for( i = 0; i < cellnumcount; i++ )
        {
            sprintf( temp_ptr, "<cell_%d>", i );
            temp_len = SCI_STRLEN( ( char * )temp_ptr );
            MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
            MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行
            adjacentcell_t.arrow = i;
            MMIENGARRAY_StrcatFromStrToUCS2( adjacentcell_t, uint16_str, &uint16_str_len );
        }
    } else
    {
        sprintf( temp_ptr, "Cell_Num = 0" );
        temp_len = SCI_STRLEN( ( char * )temp_ptr );
        MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
        MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行
    }
    text_s.wstr_ptr = uint16_str;
    text_s.wstr_len = uint16_str_len;
    GUITEXT_SetString( ctrl_id, text_s.wstr_ptr, text_s.wstr_len, need_update );

    if(PNULL != uint16_str)
    {
        SCI_FREE(uint16_str);
        uint16_str = PNULL;
    }
}
LOCAL void MMIENG_OutfieldNetShow( MMI_CTRL_ID_T  ctrl_id, uint32 rat_id, BOOLEAN is_update )
{
    uint32 i = 0, j = 0, item_count = 0, ncellnum = 0;
    wchar           unicode_cr = 0x0d;
    MMI_STRING_T    cr_s = {0};
    MMI_STRING_T    text_s = {0};
    wchar          *uint16_str = PNULL;
    uint16          uint16_str_len = 0;
    char            temp_ptr[200] = {0};
    uint16          temp_len = 0;
    ITEM_T item = {0};
    uint32 item_data[50] = {0};
    netinfoshow_t adjacentcell_t = {0};
    char *Description_name [][7] = {
        { "Not Support", "Support" },
        { "Not Support", "Support" },
        { "Unknown", "GEA1", "GEA2", "GEA3" },
        { "A51", "A52", "A53", "A54", "A55", "A56", "A57" },
        { "Unknown", "UEA0", "UEA1", "UEA0,UEA1"},
        { "Not support Hsdpa and Hsupa", "Support Hsdpa", "Support Hsupa", "Support Hsdpa and Hsupa"},
        { "Not Support", "Support" },
        { "Not Support", "VAMOS1", "VAMOS2" },
        { "Not Support", "Support" },
        { "Not Support", "Support" },
        { "other", "R8", "R9" },
        { "Not Support", "Support" },
        { "Unknown", "eea0", "eea1", "eea2" },
        { "Unknown", "eia0 ", "eia1", "eia2" },
        { "Not Support", "Support" }
    };
    cr_s.wstr_ptr = &unicode_cr;
    cr_s.wstr_len = 1;

    uint16_str = (wchar*)SCI_ALLOC_APPZ( sizeof(wchar)*(MMIENG_NETINFO_LEN+1) );
    if(PNULL == uint16_str)
    {
        TRACE_APP_ENGINEERMODE("malloc fail");
        return;
    }

    switch( rat_id )
    {
        case 0://GSM
        { 
            const char *item_name[] = { "AMR_WB ", "BSS_PAGING_COORDINATION ", "GPRS Encryption Algorithm ", "GSM Cipher with Algorithm ", "CBS ", "VAMOS", "Repeat Seacch Facch"};

            for( i = 0; i < 10; i++ )
            {
                if( i == 0 || i == 1 || i == 2  || i == 6 || i == 7 || i == 9 )
                {
                    SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
                    SCI_MEMSET( temp_ptr, 0, sizeof( temp_ptr ) );
#ifdef PLATFORM_ANTISW3
                    em_get_sys_capa_support_info( ( int32 )g_dual_sys, &item, i );
#endif
                    sprintf( temp_ptr, "%s: %s", item_name[j], Description_name[i][item.arr_value[1]] );//BUG1810507
                    j++;
                    TRACE_APP_ENGINEERMODE( "[mmieng ]itemname[%s],item.arr_value[0]=%d", item.item_name,item.arr_value[0] );
                    temp_len = SCI_STRLEN( ( char * )temp_ptr );
                    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
                    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行
                } else if( i == 3 )
                {
                    int bite[7] = {0};
                    int count = 0;
                    SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
                    SCI_MEMSET( temp_ptr, 0, sizeof( temp_ptr ) );
#ifdef PLATFORM_ANTISW3

                    em_get_sys_capa_support_info( ( int32 )g_dual_sys, &item, i );
#endif
                    bite[6] = item.arr_value[0] % 128 / 64;
                    bite[5] = item.arr_value[0] % 64 / 32;
                    bite[4] = item.arr_value[0] % 32 / 16;
                    bite[3] = item.arr_value[0] % 16 / 8;
                    bite[2] = item.arr_value[0] % 8 / 4;
                    bite[1] = item.arr_value[0] % 4 / 2;
                    bite[0] = item.arr_value[0] % 2;
                    sprintf( temp_ptr, "%s", item_name[j] );
                    for( count = 0; count < 7; count++ )
                    {
                        TRACE_APP_ENGINEERMODE( "bite[count]=%d",bite[count]);
                        if( bite[count] ) 
                        {
                            sprintf( temp_ptr, "%s %s", temp_ptr, Description_name[i][count] );
                        }
                    }
                    j++;
                    TRACE_APP_ENGINEERMODE( "itemname[%s]", item.item_name );
                    temp_len = SCI_STRLEN( ( char * )temp_ptr );
                    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
                    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行
                }
            }
        }
        break;
        case 1: //Wcdma
        {
            const char *item_name[] = {
                "UMTS Cipher ", "Hsdpa/Hsupa ",
                "CBS ", "Efach ",
                "Less Mode ", "CPC", "UL_16QAM",
                "eRACH", "eDRX", "Fast Dormancy",
                "DC_HSDPA", "DB_HSDPA", "snow3G"
            };

            {
                uint8 itemindex[] = {4, 5, 6, 8, 11, 14, 26};
                for( i = 0; i < ( sizeof( itemindex ) ); i++ )
                {
                    if( itemindex[i] == 26 ) 
                    {
                        SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
                        SCI_MEMSET( temp_ptr, 0, sizeof( temp_ptr ) );
#ifdef PLATFORM_ANTISW3
                        em_get_sys_capa_support_info( ( int32 )g_dual_sys, &item, itemindex[i] );
#endif
                        TRACE_APP_ENGINEERMODE( "[mmieng ]itemname[%s],item.arr_value[0]=%d", item.item_name,item.arr_value[0] );
                        sprintf( temp_ptr, "%s: %s", item_name[j], Description_name[0][item.arr_value[0]] );
                    } else if( itemindex[i] == 14 ) 
                    {
                        SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
                        SCI_MEMSET( temp_ptr, 0, sizeof( temp_ptr ) );
#ifdef PLATFORM_ANTISW3
                        em_get_sys_capa_support_info( ( int32 )g_dual_sys, &item, itemindex[i] );
#endif
                        TRACE_APP_ENGINEERMODE( "item.arr_value[1]=%d",item.arr_value[1] );
                        sprintf( temp_ptr, "%s: %s", item_name[j], Description_name[0][item.arr_value[1]] );
                    } else 
                    {
                        SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
                        SCI_MEMSET( temp_ptr, 0, sizeof( temp_ptr ) );
#ifdef PLATFORM_ANTISW3
                        em_get_sys_capa_support_info( ( int32 )g_dual_sys, &item, itemindex[i] );
#endif
                        TRACE_APP_ENGINEERMODE( "item.arr_value[0]=%d",item.arr_value[0] );
                        sprintf( temp_ptr, "%s: %s", item_name[j], Description_name[itemindex[i]][item.arr_value[0]] );
                    }
                    j++;
                    TRACE_APP_ENGINEERMODE( "itemname[%s]",item.item_name );
                    temp_len = SCI_STRLEN( ( char * )temp_ptr );
                    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
                    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行
                }
            }

            {
                uint8 itemindex[] = {2, 3, 8, 13, 18, 20};
                for( i = 0; i < 6; i++ ) 
                {
                    if( itemindex[i] == 8 ) 
                    {
                        SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
                        SCI_MEMSET( temp_ptr, 0, sizeof( temp_ptr ) );
#ifdef PLATFORM_ANTISW3
                        em_get_generic_nv_info( ( int32 )g_dual_sys, &item, itemindex[i] );
#endif
                        TRACE_APP_ENGINEERMODE( "item.arr_value[1]=%d",item.arr_value[1] );
                        sprintf( temp_ptr, "%s: %d", item_name[j], item.arr_value[1] );
                    } else if( itemindex[i] == 2 || itemindex[i] == 3 ) 
                    {
                        SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
                        SCI_MEMSET( temp_ptr, 0, sizeof( temp_ptr ) );
                        em_get_generic_nv_info( ( int32 )g_dual_sys, &item, itemindex[i] );
                        TRACE_APP_ENGINEERMODE( "item.arr_value[1]=%d",item.arr_value[1] );
                        sprintf( temp_ptr, "%s: %s", item_name[j], Description_name[0][item.arr_value[1]] );
                    } else 
                    {
                        SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
                        SCI_MEMSET( temp_ptr, 0, sizeof( temp_ptr ) );
#ifdef PLATFORM_ANTISW3
                        em_get_generic_nv_info( ( int32 )g_dual_sys, &item, itemindex[i] );
#endif
                        TRACE_APP_ENGINEERMODE( "item.arr_value[0]=%d",item.arr_value[0] );
                        sprintf( temp_ptr, "%s: %s", item_name[j], Description_name[0][item.arr_value[0]] );
                    }
                    j++;
                    TRACE_APP_ENGINEERMODE( "itemname[%s]",item.item_name );
                    temp_len = SCI_STRLEN( ( char * )temp_ptr );
                    MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
                    MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行
                }
            }
        }
        break;
        case 2://LTE
        {
            const char *item_name[] = { "4G Cipher ", "asrvcc", "esrvcc", "Bsrvcc ", "UL_CA", "DL_CA",
                                        "eMFBI ", "uL_64QAM", "IPV6"
                                      };
            uint32 value1 = 0;

            SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
            SCI_MEMSET( temp_ptr, 0, sizeof( temp_ptr ) );
#ifdef PLATFORM_ANTISW3
            em_get_sys_capa_support_info( ( int32 )g_dual_sys, &item, 12 );
#endif
            sprintf( temp_ptr, "%s: %s", item_name[j], Description_name[4][item.arr_value[0]] );
            TRACE_APP_ENGINEERMODE( "itemname[%s],item.arr_value[0]=%d",item.item_name,item.arr_value[0] );
            j++;
            temp_len = SCI_STRLEN( ( char * )temp_ptr );
            MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
            MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行
            for( i = 0; i < 3; i++ )
            {
#ifndef WIN32
                char value1_ptr[256] = {0};
#ifdef PLATFORM_ANTISW3
                mn_al_em_get_ims_parameter( g_dual_sys, 80 + i, value1_ptr );
#endif
                TRACE_APP_ENGINEERMODE( "value1_ptr[%s] value1_ptr = %s,len = %d", value1_ptr,value1_ptr,strlen(value1_ptr) );
                sscanf( value1_ptr, "%d", &value1 );
#else
                value1 = 1;
#endif
                SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
                SCI_MEMSET( temp_ptr, 0, sizeof( temp_ptr ) );
                TRACE_APP_ENGINEERMODE("value1=%d",value1);
                sprintf( temp_ptr, "%s: %s", item_name[j], Description_name[0][value1] );
                j++;
                temp_len = SCI_STRLEN( ( char * )temp_ptr );
                MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
                MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行
            }

            SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
            SCI_MEMSET( temp_ptr, 0, sizeof( temp_ptr ) );
#ifdef PLATFORM_ANTISW3
            em_get_4g_serv_cell_info( ( int32 )g_dual_sys, &item, 12 );
#endif
            TRACE_APP_ENGINEERMODE("item.arr_value[0]=%d",item.arr_value[0]);
            sprintf( temp_ptr, "%s: %s", item_name[j], Description_name[0][item.arr_value[0]] );
            TRACE_APP_ENGINEERMODE( "[mmieng ] line[%d] itemname[%s]", __LINE__, item.item_name );
            j++;
            temp_len = SCI_STRLEN( ( char * )temp_ptr );
            MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
            MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行
            sprintf( temp_ptr, "%s: %s", item_name[j], Description_name[0][item.arr_value[1]] );
            j++;
            temp_len = SCI_STRLEN( ( char * )temp_ptr );
            MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
            MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行
            for( i = 21; i < 23; i++ )
            {
                SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
                SCI_MEMSET( temp_ptr, 0, sizeof( temp_ptr ) );
#ifdef PLATFORM_ANTISW3
                em_get_4g_serv_cell_info( ( int32 )g_dual_sys, &item, i );
#endif
                sprintf( temp_ptr, "%s: %s", item_name[j], Description_name[0][item.arr_value[0]] );
                TRACE_APP_ENGINEERMODE( "itemname[%s],item.arr_value[0]=%d", item.item_name,item.arr_value[0]);
                j++;
                temp_len = SCI_STRLEN( ( char * )temp_ptr );
                MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
                MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行
            }
            {
                uint8 ipv6value = 0;
#ifndef WIN32
                {
                    MN_GPRS_PDP_CON_T    *pdp_con_arr =  PNULL;
                    uint32   pdp_con_num = 0;
                    MNGPRS_ReadPdpContextEx( g_dual_sys, &pdp_con_arr, &pdp_con_num );
                    for( i = 0; i < 10; i++ ) 
                    {
                        TRACE_APP_ENGINEERMODE( "pdptype[%s]", pdp_con_arr[i].pdp_addr_type );
                        if( strstr( pdp_con_arr[i].pdp_addr_type, "V6" ) )
                        {
                            ipv6value  = 1;
                            break;
                        }
                    }
                }
#else
                ipv6value = 1;
#endif
                SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
                SCI_MEMSET( temp_ptr, 0, sizeof( temp_ptr ) );
                TRACE_APP_ENGINEERMODE( "ipv6value=%d", ipv6value );
                sprintf( temp_ptr, "%s: %s", item_name[j], Description_name[0][ipv6value] );
                j++;
                temp_len = SCI_STRLEN( ( char * )temp_ptr );
                MMIAPICOM_StrcatFromStrToUCS2( uint16_str, &uint16_str_len, ( uint8 * )temp_ptr, temp_len );
                MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, &uint16_str_len, &cr_s ); //换行
            }
        }
        break;
        default:
            TRACE_APP_ENGINEERMODE("default");
            break;
    }
    text_s.wstr_ptr = uint16_str;
    text_s.wstr_len = uint16_str_len;
    GUITEXT_SetString( ctrl_id, text_s.wstr_ptr, text_s.wstr_len, is_update );

    if(PNULL != uint16_str)
    {
        SCI_FREE(uint16_str);
        uint16_str = PNULL;
    }
}
#ifdef  PLATFORM_ANTISW3
LOCAL MMI_RESULT_E ENGNWCAPShowWinHandleMsg( MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param )
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    uint32 menu_id = ( uint32 )MMK_GetWinAddDataPtr( win_id );
    MMI_CTRL_ID_T      ctrl_id = MMIENG_TEXTBOX1_CTRL_ID;

    switch( msg_id )
    {
        case MSG_OPEN_WINDOW:
        {
            TRACE_APP_ENGINEERMODE( "[ENG] ENGNWCAPShowWinHandleMsg menuid = %d", menu_id );
            MMK_SetAtvCtrl( win_id, MMIENG_TEXTBOX1_CTRL_ID );

            switch( menu_id )
            {
                case ID_ENG_SERVINGCELL:
                {
                    MN_GMMREG_RAT_E rat = MN_GMMREG_RAT_GPRS;
                    rat = MNPHONE_GetCurrentRATEx((MN_DUAL_SYS_E)g_dual_sys);
                    switch(rat)
                    {
                        TRACE_APP_ENGINEERMODE("rate = %d,g_dual_sys=%d",rat,g_dual_sys);
                        case MN_GMMREG_RAT_GPRS:
                            MMIENG_GSM_getServingCell(ctrl_id,FALSE);
                            break;
                        case MN_GMMREG_RAT_3G:
                        case MN_GMMREG_RAT_GPRS_AND_3G:
                            MMIENG_WCDMA_getServingCell(ctrl_id,FALSE);
                            break;

                        case MN_GMMREG_RAT_LTE:
                        case MN_GMMREG_RAT_GPRS_LTE:
                        case MN_GMMREG_RAT_3G_LTE:
                        case MN_GMMREG_RAT_GPRS_3G_LTE :
                            MMIENG_LTE_getServingCell(ctrl_id,FALSE);
                            break;
                        default:
                            break;
                    }
                    GUIWIN_SetTitleTextId( MMIENG_NW_CAP_SHOW_WIN_ID, ( MMI_TEXT_ID_T )TXT_ENG_SERVING_CELL, FALSE );
                    break;
                }
                case ID_ENG_ADJACENTCELL:
                {
                    MN_GMMREG_RAT_E rat = MN_GMMREG_RAT_GPRS;
                    rat = GetCurrentRat(g_dual_sys);
                    TRACE_APP_ENGINEERMODE("rate = %d,g_dual_sys=%d",rat,g_dual_sys);
                    switch(rat)
                    {
                        case MN_GMMREG_RAT_GPRS:
                            MMIENG_GSMShowAdjacentCellInfo(0,ctrl_id,FALSE);
                            break;
                        case MN_GMMREG_RAT_3G:
                        case MN_GMMREG_RAT_GPRS_AND_3G:
                            MMIENG_GSMShowAdjacentCellInfo(1,ctrl_id,FALSE);
                            break;
                        case MN_GMMREG_RAT_LTE:
                        case MN_GMMREG_RAT_GPRS_LTE:
                        case MN_GMMREG_RAT_3G_LTE:
                        case MN_GMMREG_RAT_GPRS_3G_LTE :
                            MMIENG_GSMShowAdjacentCellInfo(2,ctrl_id,FALSE);
                            break;
                        default:
                            break;
                    }
                }
                    GUIWIN_SetTitleTextId( MMIENG_NW_CAP_SHOW_WIN_ID, ( MMI_TEXT_ID_T )TXT_ENG_THE_ADJACENT_CELL, FALSE );
                    break;
                case ID_ENG_OUTFIELD_NETWORK_INFORMATION:
                {   
                    MN_GMMREG_RAT_E rat = MN_GMMREG_RAT_GPRS;
                    rat = GetCurrentRat(g_dual_sys);
                    TRACE_APP_ENGINEERMODE("rate = %d,g_dual_sys=%d",rat,g_dual_sys);
                    switch(rat)
                    {
                        case MN_GMMREG_RAT_GPRS://GSM
                            MMIENG_OutfieldNetShow(ctrl_id,0,FALSE);
                            break;
                        case MN_GMMREG_RAT_3G:
                        case MN_GMMREG_RAT_GPRS_AND_3G:
                            MMIENG_OutfieldNetShow(ctrl_id,1,FALSE);//WCDMA
                            break;
                        case MN_GMMREG_RAT_LTE:
                        case MN_GMMREG_RAT_GPRS_LTE:
                        case MN_GMMREG_RAT_3G_LTE:
                        case MN_GMMREG_RAT_GPRS_3G_LTE :
                            MMIENG_OutfieldNetShow(ctrl_id,2,FALSE);//LTE
                            break;
                        default:
                            break;
                    }
                }
                GUIWIN_SetTitleTextId( MMIENG_NW_CAP_SHOW_WIN_ID, ( MMI_TEXT_ID_T )TXT_ENG_OUTFIELD_NETWORK_INFORMATION, FALSE );
                break;
                default:
                    TRACE_APP_ENGINEERMODE("default");
                    break;
            }

        }
        break;
        case MSG_FULL_PAINT:
            break;
        case MSG_CTL_MIDSK:
        case MSG_CTL_OK:
        case MSG_CTL_CANCEL:
            MMK_CloseWin( win_id );
            break;
        case MSG_TIMER:
            #if 0
            if(( *( uint8 * )param ) == s_mmieng_netinfo_timer_id )
            {
                MMK_SendMsg(win_id, MSG_FULL_PAINT,0);
                s_mmieng_netinfo_timer_id = MMK_CreateWinTimer(win_id, ENG_NETINFO_UPDATE_TIMEOUT, FALSE);
            }
            #endif
            break;

        case MSG_LOSE_FOCUS:
            #if 0
            if( s_mmieng_netinfo_timer_id != 0) 
            {
                MMK_StopTimer( s_mmieng_netinfo_timer_id );
                s_mmieng_netinfo_timer_id = 0;
            }
            #endif
            break;
        case MSG_GET_FOCUS:
            #if 0
            if( s_mmieng_netinfo_timer_id != 0 )
            {
                MMK_StopTimer( s_mmieng_netinfo_timer_id );
                s_mmieng_netinfo_timer_id = 0;
            }
            s_mmieng_netinfo_timer_id = MMK_CreateWinTimer(win_id, ENG_NETINFO_UPDATE_TIMEOUT, FALSE);
            #endif
            break;
        case MSG_CLOSE_WINDOW:
            #if 0
            if( s_mmieng_netinfo_timer_id != 0 )
            {
                MMK_StopTimer( s_mmieng_netinfo_timer_id );
                s_mmieng_netinfo_timer_id = 0;
            }
            #endif
            break;
        default:
            result = MMI_RESULT_FALSE;
            break;
    }
    return ( result );
}
#elif defined (PLATFORM_UWS6121E)
/********************************************************************************
 NAME:          ENGNWCAPShowWinHandleMsg
 DESCRIPTION:
 PARAM IN:      win_id -
                msg_id -
                param -
 PARAM OUT:
 AUTHOR:        zhaohui
 DATE:          2008.10.24
********************************************************************************/
LOCAL MMI_RESULT_E ENGNWCAPShowWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    uint8 buf[1024] = {0};
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    uint32 menu_id= (uint32)MMK_GetWinAddDataPtr(win_id);
    wchar w_buf[1024] = {0};
    MN_NET_INFO_T pNetInfo;
        
    switch (msg_id)
    {
    case MSG_OPEN_WINDOW:
        SCI_TRACE_LOW("[ENG] ENGNWCAPShowWinHandleMsg menuid = %d",menu_id);
        MMK_SetAtvCtrl(win_id, MMIENG_TEXTBOX1_CTRL_ID);

        MNPHONE_FacGetNetInfo(&pNetInfo,g_dual_sys_eng_win );
        switch(menu_id)
        {
            case ID_ENG_SERVINGCELL:

                if(MN_GMMREG_RAT_GPRS == MNPHONE_GetCurrentRAT(g_dual_sys_eng_win))
                {
                    SCI_TRACE_LOW("[ENG] ENGNWCAPShowWinHandleMsg line[%d] ",__LINE__);
                    ShowServingUECapInfo( pNetInfo.ueCapabilityGsm,FALSE);
                }
                else
                {
                    ShowServingCellInfo( pNetInfo.nwCapabilityLte.lteScell,FALSE);
                }
                //text.wstr_len = GetAdcCalibrateInfoStr(buf, 1024);
                GUIWIN_SetTitleTextId(MMIENG_NW_CAP_SHOW_WIN_ID, (MMI_TEXT_ID_T)TXT_ENG_SERVING_CELL, FALSE);
                break;
            case ID_ENG_ADJACENTCELL:
                ShowAdjacentCellInfo(pNetInfo.nwCapabilityLte.lteNcellNum,pNetInfo.nwCapabilityLte.lteNcell,FALSE);
                GUIWIN_SetTitleTextId(MMIENG_NW_CAP_SHOW_WIN_ID, (MMI_TEXT_ID_T)TXT_ENG_THE_ADJACENT_CELL, FALSE);
                break;
            case ID_ENG_BETWEEN_ADJACENTCELL_2G:
                ShowBetweenAdjacentCell_2G_Info(pNetInfo.nwCapabilityLte.gsmNcellNum,pNetInfo.nwCapabilityLte.gsmNcell,FALSE);
                GUIWIN_SetTitleTextId(MMIENG_NW_CAP_SHOW_WIN_ID, (MMI_TEXT_ID_T)TXT_ENG_BETWEEN_ADJACENT_CELL_2G, FALSE);
                break;
            case ID_ENG_OUTFIELD_NETWORK_INFORMATION:
                ShowOutFieldNetWorkInfo(pNetInfo.nwCapabilityLte.capInfoLte,FALSE);
                GUIWIN_SetTitleTextId(MMIENG_NW_CAP_SHOW_WIN_ID, (MMI_TEXT_ID_T)TXT_ENG_OUTFIELD_NETWORK_INFORMATION, FALSE);
                break;
        }

        if (s_mmieng_netinfo_timer_id != 0)
        {
            MMK_StopTimer(s_mmieng_netinfo_timer_id);
            s_mmieng_netinfo_timer_id = 0;
        }

        break;

    case MSG_CTL_MIDSK:
    case MSG_CTL_OK:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_TIMER:
        if((*(uint8*)param) != s_mmieng_netinfo_timer_id)
        {
            break;
        }
        break;

    case MSG_LOSE_FOCUS:
        if (s_mmieng_netinfo_timer_id != 0)
        {
            MMK_StopTimer(s_mmieng_netinfo_timer_id);
            s_mmieng_netinfo_timer_id = 0;
        }
        break;
    case MSG_GET_FOCUS:

        if (s_mmieng_netinfo_timer_id != 0)
        {
            MMK_StopTimer(s_mmieng_netinfo_timer_id);
            s_mmieng_netinfo_timer_id = 0;
        }
        break;
    case MSG_CLOSE_WINDOW:
        if (s_mmieng_netinfo_timer_id != 0)
        {
            MMK_StopTimer(s_mmieng_netinfo_timer_id);
            s_mmieng_netinfo_timer_id = 0;
        }        
        break;

    default:
        result = MMI_RESULT_FALSE;
        break;

    }
    return (result);
}

#else
    #error
#endif
LOCAL uint16 MMIENGCELL_StrcatFromStrToUCS2( netinfoshow_t adjacentcell_t, uint16  *uint16_str, uint16  *uint16_str_len )
{

    uint32 i = 0;

    char            temp_ptr[100] = {0};
    uint16          temp_len = 0;
    ITEM_T item = {0};
    wchar           unicode_cr = 0x0d;
    MMI_STRING_T    cr_s = {0};
    cr_s.wstr_ptr = &unicode_cr;
    cr_s.wstr_len = 1;

    SCI_MEMSET( temp_ptr, 0, sizeof( temp_ptr ) );

    if( adjacentcell_t.ncellnum != 0 )
    {
        for( i = 0; i < adjacentcell_t.ncellnum; i++ )
        {
            sprintf( temp_ptr, "<cell_%d>", i );
            temp_len = SCI_STRLEN( ( char * )temp_ptr );
            MMIAPICOM_StrcatFromStrToUCS2( uint16_str, uint16_str_len, ( uint8 * )temp_ptr, temp_len );
            MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, uint16_str_len, &cr_s ); //换行

            adjacentcell_t.arrow = i;
            MMIENGARRAY_StrcatFromStrToUCS2( adjacentcell_t, uint16_str, uint16_str_len );
        }
    } else
    {
        sprintf( temp_ptr, "Cell_Num = 0" );
        temp_len = SCI_STRLEN( ( char * )temp_ptr );
        MMIAPICOM_StrcatFromStrToUCS2( uint16_str, uint16_str_len, ( uint8 * )temp_ptr, temp_len );
        MMIAPICOM_StrcatFromSTRINGToUCS2( uint16_str, uint16_str_len, &cr_s ); //换行
    }
      return 0;
}

LOCAL void MMIENG_BetweenCellShow( MMI_CTRL_ID_T ctrl_id, uint32 rat_id, BOOLEAN is_update )
{
    enum {ENG_RAT2G_SHOW3G = ( 2 << 8 | 3 ),
          ENG_RAT2G_SHOW4G = ( 2 << 8 | 4 ), 
          ENG_RAT3G_SHOW2G = ( 3 << 8 | 2 ),
          ENG_RAT3G_SHOW4G = ( 3 << 8 | 4 ),
          ENG_RAT4G_SHOW2G = ( 4 << 8 | 2 ),
          ENG_RAT4G_SHOW3G = ( 4 << 8 | 3 )};
    uint32 i = 0, j = 0, item_count = 0, ncellnum = 0 ;
    wchar           unicode_cr = 0x0d;
    MMI_STRING_T    cr_s = {0};
    MMI_STRING_T    text_s = {0};
    uint16          *uint16_str = PNULL;
    uint16          uint16_str_len = 0;
    char            temp_ptr[100] = {0};
    uint16          temp_len = 0;
    ITEM_T item = {0};


    uint32 item_data[50] = {0};
    netinfoshow_t adjacentcell_t = {0};

    uint16_str = (wchar*)SCI_ALLOC_APPZ( sizeof(wchar)*(MMIENG_NETINFO_LEN+1) );
    if(PNULL == uint16_str)
    {
        TRACE_APP_ENGINEERMODE("malloc fail");
        return;
    }

    cr_s.wstr_ptr = &unicode_cr;
    cr_s.wstr_len = 1;

    switch( rat_id )
    {
        case ENG_RAT2G_SHOW3G:
        {
            const char *item_name[] = { "Frequency", "CPID", "Signal"};
            const MMIENG_NETINFO_SHOW_TYPE_E   item_type[] = {ENG_STRING_NUM, ENG_STRING_NUM, ENG_STRING_NUM_DBM};

            TRACE_APP_ENGINEERMODE("ENG_RAT2G_SHOW3G");
#ifdef PLATFORM_ANTISW3
            item_count = em_get_2g_intra_3g_neig_cell_info_count();
            for( i = 0; i < 3; i++ ) {
                SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
                em_get_2g_intra_3g_neig_cell_info( ( int32 )g_dual_sys, &item, i );
                TRACE_APP_ENGINEERMODE("item.arr_count=%d",item.arr_count);
                if( item.arr_count ) 
                {
                    ncellnum++;
                    for( j = 0; j < ( item.arr_count > 5 ? 5 : item.arr_count ); j++ ) 
                    {
                        if( i == 2 ) 
                        {
                            item_data[j * 3 + i]  = item.arr_value[j]  - 116;
                        } else 
                        {
                            item_data[j * 3 + i]  = item.arr_value[j] ;
                        }
                    }
                }
            }
#endif
            adjacentcell_t.item = item_name;
            adjacentcell_t.item_type = item_type;
            adjacentcell_t.data = item_data;
            adjacentcell_t.colunm = ( sizeof( item_name ) / ( sizeof( char * ) ) );
            adjacentcell_t.ncellnum = ( item.arr_count > 5 ? 5 : item.arr_count );
            MMIENGCELL_StrcatFromStrToUCS2( adjacentcell_t, uint16_str, &uint16_str_len );
        }
        break;
        case ENG_RAT2G_SHOW4G:
        {
            const char *item_name[] = { "Frequency", "PCI", "RSRP", "RSRQ"};
            const MMIENG_NETINFO_SHOW_TYPE_E   item_type[] = {ENG_STRING_NUM, ENG_STRING_NUM, ENG_STRING_NUM_DBM, ENG_STRING_NUM_DBM};

            TRACE_APP_ENGINEERMODE("ENG_RAT2G_SHOW4G");
#ifdef PLATFORM_ANTISW3
            item_count = em_get_2g_intra_4g_neig_cell_info_count();
            for( i = 0; i < 4; i++ )
            {
                SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
                em_get_2g_intra_4g_neig_cell_info( ( int32 )g_dual_sys, &item, i );
                TRACE_APP_ENGINEERMODE("item.arr_count=%d",item.arr_count);
                if( item.arr_count )
                {
                    ncellnum++;
                    for( j = 0; j < ( item.arr_count > 5 ? 5 : item.arr_count ); j++ )
                    {
                        if( i == 2 | i == 3 )
                        {
                            item_data[j * 4 + i]  = item.arr_value[j] / 100;
                        } else
                        {
                            item_data[j * 4 + i]  = item.arr_value[j] ;
                        }
                    }
                }
            }
#endif
            adjacentcell_t.item = item_name;
            adjacentcell_t.item_type = item_type;
            adjacentcell_t.data = item_data;
            adjacentcell_t.colunm = ( sizeof( item_name ) / ( sizeof( char * ) ) );
            adjacentcell_t.ncellnum = ( item.arr_count > 5 ? 5 : item.arr_count );
            MMIENGCELL_StrcatFromStrToUCS2( adjacentcell_t, uint16_str, &uint16_str_len );
        }
        break;
        case ENG_RAT3G_SHOW2G:
        {
            const char *item_name[] = { "Frequency", "PSC", "Signal"};
            const MMIENG_NETINFO_SHOW_TYPE_E   item_type[] = {ENG_STRING_NUM, ENG_STRING_NUM, ENG_STRING_NUM_DBM};

            TRACE_APP_ENGINEERMODE("ENG_RAT3G_SHOW2G");

            for( i = 0; i < 5; i++ )
            {
                SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
#ifdef PLATFORM_ANTISW3
                em_get_3g_intra_2g_neig_cell_info( ( int32 )g_dual_sys, &item, i + 3 );
#endif
                TRACE_APP_ENGINEERMODE("item.arr_count=%d",item.arr_count);
                if( item.arr_count )
                {
                    ncellnum++;
                    for( j = 1; j < 4; j++ )
                    {
                        item_data[i * 3 + j-1]  = item.arr_value[j] ;
                    }
                }
            }

            adjacentcell_t.item = item_name;
            adjacentcell_t.item_type = item_type;
            adjacentcell_t.data = item_data;
            adjacentcell_t.colunm = ( sizeof( item_name ) / ( sizeof( char * ) ) );
            adjacentcell_t.ncellnum = 5;
            MMIENGCELL_StrcatFromStrToUCS2( adjacentcell_t, uint16_str, &uint16_str_len );
        }
        break;
        case ENG_RAT3G_SHOW4G:
        {
            const char *item_name[] = { "Frequency", "PCI", "RSRP", "RSRQ"};
            const MMIENG_NETINFO_SHOW_TYPE_E   item_type[] = {ENG_STRING_NUM, ENG_STRING_NUM, ENG_STRING_NUM_DBM, ENG_STRING_NUM_DBM};
            uint8 column  = 0;
            column = ( sizeof( item_name ) / ( sizeof( char * ) ) );

            TRACE_APP_ENGINEERMODE("ENG_RAT3G_SHOW4G");

            for( i = 0; i < 5; i++ ) 
            {
                SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
#ifdef PLATFORM_ANTISW3
                em_get_3g_intra_4g_neig_cell_info( ( int32 )g_dual_sys, &item, i + 2 );
#endif
                TRACE_APP_ENGINEERMODE("item.arr_count=%d",item.arr_count);
                if( item.arr_count )
                {
                    ncellnum++;
                    for( j = 0; j < column; j++ )
                    {
                        if( j == 2 ) 
                        {
                            item_data[i * column + j]  = item.arr_value[j] - 120 ;
                        } else if( j == 3 ) 
                        {
                            item_data[i * column + j]  = item.arr_value[j] - 49 ;
                        } else 
                        {
                            item_data[i * column + j]  = item.arr_value[j] ;
                        }
                    }
                }
            }

            adjacentcell_t.item = item_name;
            adjacentcell_t.item_type = item_type;
            adjacentcell_t.data = item_data;
            adjacentcell_t.colunm = column;
            adjacentcell_t.ncellnum = 5;
            MMIENGCELL_StrcatFromStrToUCS2( adjacentcell_t, uint16_str, &uint16_str_len );

        }
        break;
        case ENG_RAT4G_SHOW2G:
        {
            const char *item_name[] = { "Frequency", "PCI", "Signal"};
            const MMIENG_NETINFO_SHOW_TYPE_E   item_type[] = {ENG_STRING_NUM, ENG_STRING_NUM, ENG_STRING_NUM_DBM};
            uint8 column  = 0;
            column = ( sizeof( item_name ) / ( sizeof( char * ) ) );

            TRACE_APP_ENGINEERMODE("ENG_RAT4G_SHOW2G");

            for( i = 0; i < 5; i++ )
            {
                SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
#ifdef PLATFORM_ANTISW3
                em_get_4g_intra_2g_neig_cell_info( ( int32 )g_dual_sys, &item, i );
#endif
                TRACE_APP_ENGINEERMODE("item.arr_count=%d",item.arr_count);
                if( item.arr_count )
                {
                    ncellnum++;
                    for( j = 0; j < column; j++ )
                    {
                        if( j == 2 )
                        {
                            item_data[i * column + j]  = item.arr_value[j] / 100 ;
                        } else {
                            item_data[i * column + j]  = item.arr_value[j] ;
                        }
                    }
                }
            }

            adjacentcell_t.item = item_name;
            adjacentcell_t.item_type = item_type;
            adjacentcell_t.data = item_data;
            adjacentcell_t.colunm = column;
            adjacentcell_t.ncellnum = 5;
            MMIENGCELL_StrcatFromStrToUCS2( adjacentcell_t, uint16_str, &uint16_str_len );

        }
        break;
        case ENG_RAT4G_SHOW3G:
        {
            const char *item_name[] = { "Frequency", "PCI", "Signal"};
            const MMIENG_NETINFO_SHOW_TYPE_E   item_type[] = {ENG_STRING_NUM, ENG_STRING_NUM, ENG_STRING_NUM_DBM};
            uint8 column  = 0;
            column = ( sizeof( item_name ) / ( sizeof( char * ) ) );

            TRACE_APP_ENGINEERMODE("ENG_RAT4G_SHOW3G");

            for( i = 0; i < 5; i++ )
            {
                SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
#ifdef PLATFORM_ANTISW3
                em_get_4g_intra_3g_neig_cell_info( ( int32 )g_dual_sys, &item, i );
#endif
                TRACE_APP_ENGINEERMODE("item.arr_count=%d",item.arr_count);
                if( item.arr_count )
                {
                    ncellnum++;
                    for( j = 0; j < column; j++ )
                    {
                        if( j == 2 ) 
                        {
                            item_data[i * column + j]  = item.arr_value[j] / 100 ;
                        } else 
                        {
                            item_data[i * column + j]  = item.arr_value[j] ;
                        }
                    }
                }
            }

            adjacentcell_t.item = item_name;
            adjacentcell_t.item_type = item_type;
            adjacentcell_t.data = item_data;
            adjacentcell_t.colunm = column;
            adjacentcell_t.ncellnum = 5;
            MMIENGCELL_StrcatFromStrToUCS2( adjacentcell_t, uint16_str, &uint16_str_len );
        }
        break;
        default:
            TRACE_APP_ENGINEERMODE("default");
            break;
    }

    text_s.wstr_ptr = uint16_str;
    text_s.wstr_len = uint16_str_len;
    GUITEXT_SetString( ctrl_id, text_s.wstr_ptr, text_s.wstr_len, is_update );

    if(PNULL != uint16_str)
    {
        SCI_FREE(uint16_str);
        uint16_str = PNULL;
    }
}

/********************************************************************************
 NAME:          ENGBetweenCellShowWinHandleMsg
 DESCRIPTION:
 PARAM IN:      win_id -
                msg_id -
                param -
 PARAM OUT:
 AUTHOR:        chunjuan.liang
 DATE:          2020.7.6
********************************************************************************/
LOCAL MMI_RESULT_E ENGBetweenCellShowWinHandleMsg( MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param )
{
        MMI_RESULT_E result = MMI_RESULT_TRUE;
        uint32 rat_id = ( uint32 )MMK_GetWinAddDataPtr( win_id );
        MMI_CTRL_ID_T      ctrl_id = MMIENG_TEXTBOX2_CTRL_ID;
        switch( msg_id ) 
        {
            case MSG_OPEN_WINDOW:
            {
                uint8 temp_ptr[40] = {0};
                wchar wstr[TX_PARAM_LEN] = {0};
                MMI_STRING_T text = {0};

                sprintf( temp_ptr, "Between Cell %dG", rat_id&0xf);
                text.wstr_len = strlen( temp_ptr );
                text.wstr_ptr = wstr;
                MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, ( uint8 * )temp_ptr, text.wstr_len, text.wstr_len );
                GUIWIN_SetTitleText(win_id,text.wstr_ptr,text.wstr_len, FALSE);

                TRACE_APP_ENGINEERMODE( "rat_id = %d", rat_id );
                MMIENG_BetweenCellShow(ctrl_id,rat_id,FALSE);
                MMK_SetAtvCtrl( win_id, ctrl_id );
            }
                break;

            case MSG_CTL_MIDSK:
            case MSG_CTL_OK:
            case MSG_CTL_CANCEL:
                MMK_CloseWin( win_id );
                break;
            default:
                result = MMI_RESULT_FALSE;
                break;
        }
        return ( result );
}

/********************************************************************************
 NAME:          EngBetweenCelllWinHandleMsg
 DESCRIPTION:  
 PARAM IN:      win_id -  msg_id -  param -
 PARAM OUT:
 AUTHOR:        chunjuan.liang
 DATE:          2020.7.6
********************************************************************************/
LOCAL MMI_RESULT_E EngBetweenCelllWinHandleMsg( MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param )
{

    char *str = PNULL;
    uint32 i = 0;
    MMI_STRING_T itemStr = {0};
    MMI_STRING_T        edit_1_str = {0};
    GUISETLIST_ITEM_INFO_T item_info  = {0};
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    uint32 ctrl_id = MMIENG_COMMON_EDIT_CTRL4_ID;

    switch( msg_id )
    {
        case MSG_OPEN_WINDOW:
        {
            uint32 engrat[2] = {0};
            uint8 engrat_flag[2] = {0};
            uint8 temp_ptr[33] = {0};
            wchar wstr[TX_PARAM_LEN] = {0};
            static uint32 temp = MN_GMMREG_RAT_GPRS;
            MMI_STRING_T text = {0};
            GUILIST_SetMaxItem( ctrl_id, 2, FALSE );
            GUILIST_SetOwnSofterKey( ctrl_id, TRUE );
            #ifndef WIN32
#if defined (PLATFORM_ANTISW3)
            switch( MNPHONE_GetCurrentRATEx( g_dual_sys ) )
            #else
			switch( MNPHONE_GetCurrentRAT( g_dual_sys ) )
#endif
            #else
            switch(temp)
            #endif
            {
                case MN_GMMREG_RAT_GPRS:
                    engrat[0] = 3 | (2<<8);
                    engrat[1] = 4 | (2<<8);
                    break;
                case MN_GMMREG_RAT_3G:
                case MN_GMMREG_RAT_GPRS_AND_3G:
                    engrat[0] = 2 | (3<<8) ;
                    engrat[1] = 4 | (3<<8);
                    break;
#if defined (PLATFORM_ANTISW3)
                case MN_GMMREG_RAT_LTE:
                case MN_GMMREG_RAT_GPRS_LTE:
                case MN_GMMREG_RAT_3G_LTE:
                case MN_GMMREG_RAT_GPRS_3G_LTE :
#else
				case MN_GMMREG_RAT_4G:
#endif
                    engrat[0] = 2 | (4<<8);
                    engrat[1] = 3 | (4<<8);
                    break;
                default:
                    TRACE_APP_ENGINEERMODE("default");
                    break;
            }

            for(i=0;i<2;i++)
            {
                TRACE_APP_ENGINEERMODE("engrat[i] = %d",engrat[i]);
                sprintf( temp_ptr, "Between Cell %dG", engrat[i]&0xf);
                text.wstr_len = strlen( temp_ptr );
                text.wstr_ptr = wstr;
                MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, ( uint8 * )temp_ptr, text.wstr_len, text.wstr_len );
                MMIAPISET_AppendListItemByTextBuffer( text.wstr_ptr, text.wstr_len, engrat[i], TXT_ENG_COMMON_SET, TXT_NULL, TXT_ENG_RETURN, ctrl_id, GUIITEM_STYLE_ONE_LINE_TEXT );
            }

            MMK_SetAtvCtrl( win_id, ctrl_id );
        }
        break;

        case MSG_FULL_PAINT:
            MMITHEME_UpdateRect();
            break;

        case MSG_CTL_MIDSK:
        case MSG_APP_WEB:
        case MSG_APP_OK:
        case MSG_CTL_OK: 
        {
            int iCurSelectIndex = 0;
            uint32 userdate = 0;
            iCurSelectIndex = GUILIST_GetCurItemIndex(ctrl_id);
            CTRLLIST_GetItemData(ctrl_id,iCurSelectIndex,&userdate);
            TRACE_APP_ENGINEERMODE("userdata=%d",userdate);
            MMK_CreateWin( ( uint32 * )MMIENG_BETWEEN_CELL_SHOW_WIN_TAB, ( ADD_DATA )userdate );
        }
        break;

        case MSG_APP_CANCEL:
        case MSG_CTL_CANCEL:
            MMK_CloseWin( win_id );
            break;

        default:
            result = MMI_RESULT_FALSE;
            break;
    }

    return ( result );
}

/*********************************************************************************************/
/*************************************Netinfo End*********************************************/
/*********************************************************************************************/

LOCAL MMI_RESULT_E ENGNetinfoStatisticsWinHandleMsg( MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param )
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    uint32 group_id = 0;
    uint32 menu_id = 0;
    uint32  dual_sys = ( uint32 )MMK_GetWinAddDataPtr( win_id );

    switch( msg_id )
    {
        case MSG_OPEN_WINDOW:
            CTRLMENU_SetSecMenuItemHeight(MMIENG_NETINFO_STATISTICS_CTRL_ID,MMIENG_MENU_ITEM_HEIGHT,MMIENG_MENU_ITEM_HEIGHT);
            CTRLMENU_SetSecMenuFontSize(MMIENG_NETINFO_STATISTICS_CTRL_ID,MMIENG_MENU_ITEM_FONT,MMIENG_MENU_ITEM_FONT);

            CTRLMENU_SetFontColor(MMIENG_NETINFO_STATISTICS_CTRL_ID,MMI_WHITE_COLOR);
            g_dual_sys = dual_sys;
            GUIWIN_SetSoftkeyTextId(win_id, TXT_ENG_OK, TXT_NULL, TXT_ENG_RETURN, FALSE);
            MMK_SetAtvCtrl( MMIENG_NETINFO_STATISTICS_WIN_ID, MMIENG_NETINFO_STATISTICS_CTRL_ID );
            break;

        case MSG_FULL_PAINT:
            break;

        case MSG_KEYDOWN_CANCEL:
        case MSG_CTL_CANCEL:
            MMK_CloseWin( MMIENG_NETINFO_STATISTICS_WIN_ID );
            break;
#ifdef TOUCH_PANEL_SUPPORT
        case MSG_CTL_PENOK:
#endif
        case MSG_CTL_MIDSK:
        case MSG_KEYDOWN_OK:
        case MSG_CTL_OK:
        case MSG_APP_WEB:
            GUIMENU_GetId( MMIENG_NETINFO_STATISTICS_CTRL_ID, &group_id, &menu_id );
            SCI_TRACE_LOW( " ENGNetinfoStatisticsWinHandleMsg menuid = %d", menu_id );
            MMK_CreateWin( ( uint32 * )MMIENG_NETINFO_STATISTICS_HANDLE_WIN_TAB, ( ADD_DATA )menu_id );
            break;
        default:
            result = MMI_RESULT_FALSE;
            break;
    }
    return ( result );
}




#if defined(PLATFORM_UWS6121E)
LOCAL void ShowNetinfoStatisticsDroptimesInfo(
                           mn_dropTimes_t      dropTimes , BOOLEAN   need_update
                            )
 {
	wchar           unicode_cr = 0x0d;
	MMI_STRING_T    cr_s = {0};
	MMI_STRING_T    text_s = {0};
	uint16          uint16_str[400] = {0};
	uint16          uint16_str_len = 0;
	char            temp_ptr[50] = {0};
	uint16          temp_len = 0;	
	uint8 i=0;
	uint8 j =0;

	const char * item_colunm_name[] =  { "Drop times on 2G ",  "Drop times on 4G "};
	const MMIENG_NETINFO_SHOW_TYPE_E   item_type[] = {ENG_STRING_NUM,ENG_STRING_NUM};
	uint32 item_data[2]={0};

	uint8 cell_colunm = (sizeof(item_colunm_name)/(sizeof(char *)));
	netinfoshow_t adjacentcell_t= {0};

	item_data[0] = dropTimes.dropOn2g ; 
	item_data[1] = dropTimes.dropOn4g ;
	
	cr_s.wstr_ptr = &unicode_cr;
	cr_s.wstr_len = 1;
		
	adjacentcell_t.item=item_colunm_name;
	adjacentcell_t.item_type= item_type;
	adjacentcell_t.data = item_data;
	adjacentcell_t.colunm = cell_colunm;

	SCI_MEMSET(temp_ptr, 0, 50);
	
	adjacentcell_t.arrow = 0;
	MMIENGARRAY_StrcatFromStrToUCS2(adjacentcell_t,uint16_str, &uint16_str_len);	
		
	text_s.wstr_ptr = uint16_str;
	text_s.wstr_len = uint16_str_len;
	GUITEXT_SetString(MMIENG_TEXTBOX1_CTRL_ID, text_s.wstr_ptr,text_s.wstr_len, need_update);
 }

LOCAL  void ShowNetinfoStatisticsAttachtimeInfo(
                          mn_attachTime_t     attachTime,  BOOLEAN   need_update
                            )
 {
	wchar           unicode_cr = 0x0d;
	MMI_STRING_T    cr_s = {0};
	MMI_STRING_T    text_s = {0};
	uint16          uint16_str[400] = {0};
	uint16          uint16_str_len = 0;
	char            temp_ptr[50] = {0};
	uint16          temp_len = 0;	
	uint8 i=0;
	uint8 j =0;

	const char * item_colunm_name[] =  { "Time on 2G ",  "Time on 4G ", "Time on VOLTE ","Time on Unknow","All the time "};
	const MMIENG_NETINFO_SHOW_TYPE_E   item_type[] = {ENG_STRING_NUM,ENG_STRING_NUM,ENG_STRING_NUM,ENG_STRING_NUM,ENG_STRING_NUM};
	uint32 item_data[5]={0};

	uint8 cell_colunm = (sizeof(item_colunm_name)/(sizeof(char *)));
	netinfoshow_t adjacentcell_t= {0};

	item_data[0] = attachTime.timeOn2g ;
	item_data[1] = attachTime.timeOn4g ;
	item_data[2] = attachTime.timeOnVolte ;
	item_data[3] = attachTime.timeOnUnknow ;
	item_data[4] = attachTime.allTheTime ;

	cr_s.wstr_ptr = &unicode_cr;
	cr_s.wstr_len = 1;
		
	adjacentcell_t.item=item_colunm_name;
	adjacentcell_t.item_type= item_type;
	adjacentcell_t.data = item_data;
	adjacentcell_t.colunm = cell_colunm;

	SCI_MEMSET(temp_ptr, 0, 50);

	adjacentcell_t.arrow = 0;
	MMIENGARRAY_StrcatFromStrToUCS2(adjacentcell_t,uint16_str, &uint16_str_len);	
		
	text_s.wstr_ptr = uint16_str;
	text_s.wstr_len = uint16_str_len;
	GUITEXT_SetString(MMIENG_TEXTBOX1_CTRL_ID, text_s.wstr_ptr,text_s.wstr_len, need_update);
 }

LOCAL  void ShowNetinfoStatisticsHandoverInfo(                    
	mn_handoverInfo_t   handoverInfo, BOOLEAN   need_update
                            )
 {
	wchar           unicode_cr = 0x0d;
	MMI_STRING_T    cr_s = {0};
	MMI_STRING_T    text_s = {0};
	uint16          uint16_str[600] = {0};
	uint16          uint16_str_len = 0;
	char            temp_ptr[50] = {0};

	uint16          temp_len = 0;
	
	uint8 i=0;
	uint8 j =0;

	const char * item_array_name[] = { "<2G-2G HO> ", "<2G-2G CCO> ", "<2G-4G CCO> ","<4G-2G CCO> ","<2G-4G HO> ","<4G-4G HO> ","<4G-2G HO> ","<SRVCC 2G> "};
	const char * item_colunm_name[] = { "success ",  "fail ",  "passratio ","delay"};
	const MMIENG_NETINFO_SHOW_TYPE_E   item_type[] = {ENG_STRING_NUM,ENG_STRING_NUM,ENG_STRING_PERCENT,ENG_STRING_NUM};
	uint32 item_data[40]={0};

	uint8 cell_arrow = (sizeof(item_array_name)/(sizeof(char *)));
	uint8 cell_colunm = (sizeof(item_colunm_name)/(sizeof(char *)));
	netinfoshow_t adjacentcell_t= {0};
	  
	cr_s.wstr_ptr = &unicode_cr;
    	cr_s.wstr_len = 1;
		
	adjacentcell_t.item=item_colunm_name;
	adjacentcell_t.item_type= item_type;
	adjacentcell_t.data = item_data;
	adjacentcell_t.colunm = cell_colunm;
	
	SCI_MEMSET(temp_ptr, 0, 50);

	for(i=0;i<cell_arrow;i++)
	{
		item_data[i*cell_colunm] = handoverInfo.handoverStatistic[i].success ;
		item_data[i*cell_colunm+1] =  handoverInfo.handoverStatistic[i].fail ;
		item_data[i*cell_colunm+2] =  handoverInfo.handoverStatistic[i].passRatio ;
		item_data[i*cell_colunm+3] =  handoverInfo.handoverStatistic[i].delay ;
	}
	
	for(i=0;i<cell_arrow;i++)
	{
		sprintf(temp_ptr,"%s",item_array_name[i]);
		temp_len = SCI_STRLEN((char*)temp_ptr);
		MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)temp_ptr, temp_len);
		MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行

		adjacentcell_t.arrow = i;
		MMIENGARRAY_StrcatFromStrToUCS2(adjacentcell_t,uint16_str, &uint16_str_len);	
	}
	
    text_s.wstr_ptr = uint16_str;
    text_s.wstr_len = uint16_str_len;
    GUITEXT_SetString(MMIENG_TEXTBOX1_CTRL_ID, text_s.wstr_ptr,text_s.wstr_len, need_update);
 }
LOCAL void ShowNetinfoStatisticsReselectInfo(
                          mn_reselectInfo_t  reselectInfo, BOOLEAN    need_update
                            )
{   
    wchar           unicode_cr = 0x0d;
    MMI_STRING_T    cr_s = {0};
    MMI_STRING_T    text_s = {0};
    uint16          uint16_str[400] = {0};
    uint16          uint16_str_len = 0;
    char            temp_ptr[50] = {0};

    uint16          temp_len = 0;
	uint8 i=0;
	uint8 j =0;

	const char * item_array_name[] = { "<2G-2G> ",  "<2G-4G> ", "<4G-4G> " ,"<4G-2G> "};
	const char * item_colunm_name[] = { "success ",  "fail ",  "passratio ","delay"};
	const MMIENG_NETINFO_SHOW_TYPE_E   item_type[] = {ENG_STRING_NUM,ENG_STRING_NUM,ENG_STRING_PERCENT,ENG_STRING_NUM};
	uint32 item_data[16]={0};
	
	uint8 cell_arrow = (sizeof(item_array_name)/(sizeof(char *)));
	uint8 cell_colunm = (sizeof(item_colunm_name)/(sizeof(char *)));
	netinfoshow_t adjacentcell_t= {0};
	  
	
	for(i=0;i<cell_arrow;i++)
	{
		item_data[i*cell_colunm] = reselectInfo.reselStatistic[i].success ;
		item_data[i*cell_colunm + 1] = reselectInfo.reselStatistic[i].fail ;
		item_data[i*cell_colunm + 2] = reselectInfo.reselStatistic[i].passRatio ;	
		item_data[i*cell_colunm + 3] = reselectInfo.reselStatistic[i].delay ;
		//SCI_TRACE_LOW("mymark ShowNetinfoStatisticsReselectInfo i = %d success=%d,fail=%d,paseeration=%d,delay=%d " ,i,reselectInfo.reselStatistic[i].success, reselectInfo.reselStatistic[i].fail ,reselectInfo.reselStatistic[i].passRatio,reselectInfo.reselStatistic[i].delay);
	}
	
	cr_s.wstr_ptr = &unicode_cr;
    	cr_s.wstr_len = 1;
	adjacentcell_t.item=item_colunm_name;
	adjacentcell_t.item_type= item_type;
	adjacentcell_t.data = item_data;
	adjacentcell_t.colunm = cell_colunm;
	
	SCI_MEMSET(temp_ptr, 0, 50);
	for(i=0;i<cell_arrow;i++)
	{
		sprintf(temp_ptr,"%s",item_array_name[i]);
		temp_len = SCI_STRLEN((char*)temp_ptr);
		MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)temp_ptr, temp_len);
		MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行

		adjacentcell_t.arrow = i;
		MMIENGARRAY_StrcatFromStrToUCS2(adjacentcell_t,uint16_str, &uint16_str_len);	
	}
	
    text_s.wstr_ptr = uint16_str;
    text_s.wstr_len = uint16_str_len;
    GUITEXT_SetString(MMIENG_TEXTBOX1_CTRL_ID, text_s.wstr_ptr,text_s.wstr_len, need_update);
}

/********************************************************************************
 NAME:          ENGNWCAPShowWinHandleMsg
 DESCRIPTION:   
 PARAM IN:      win_id - 
                msg_id - 
                param - 
 PARAM OUT:     
 AUTHOR:        zhaohui
 DATE:          2008.10.24
********************************************************************************/
LOCAL MMI_RESULT_E ENG_Netinfo_Statistics_WinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    uint8 buf[1024] = {0};
    MMI_STRING_T text = {0};
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    uint32 menu_id= (uint32)MMK_GetWinAddDataPtr(win_id);
    wchar w_buf[1024] = {0};
	MN_NET_INFO_STATISTIC_T pNetinfoStatistic;
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
		SCI_TRACE_LOW("mymark ENG_Netinfo_Statistics_WinHandleMsg menuid = %d",menu_id);
		  MMK_SetAtvCtrl(win_id, MMIENG_TEXTBOX1_CTRL_ID);
		MNPHONE_FacGetNetInfoStatistic(&pNetinfoStatistic, g_dual_sys_eng_win);
		switch(menu_id)
		{
			case ID_ENG_NETINFO_RESELECT:
				ShowNetinfoStatisticsReselectInfo(pNetinfoStatistic.reselectInfo ,FALSE);
				GUIWIN_SetTitleTextId(MMIENG_NETINFO_STATISTICS_HANDLE_WIN_ID, (MMI_TEXT_ID_T)TXT_ENG_NETINFO_RESELECT, FALSE);
				break;
			case ID_ENG_NETINFO_HANDOVER:
				ShowNetinfoStatisticsHandoverInfo(pNetinfoStatistic.handoverInfo,FALSE);
				GUIWIN_SetTitleTextId(MMIENG_NETINFO_STATISTICS_HANDLE_WIN_ID, (MMI_TEXT_ID_T)TXT_ENG_NETINFO_HANDOVER, FALSE);
				break;
			case ID_ENG_NETINFO_ATTACHTIME:
				ShowNetinfoStatisticsAttachtimeInfo(pNetinfoStatistic.attachTime,FALSE);
				GUIWIN_SetTitleTextId(MMIENG_NETINFO_STATISTICS_HANDLE_WIN_ID, (MMI_TEXT_ID_T)TXT_ENG_NETINFO_ATTACHTIME, FALSE);
				break;
			case ID_ENG_NETINFO_DROPTIMES:
				ShowNetinfoStatisticsDroptimesInfo(pNetinfoStatistic.dropTimes,FALSE);
				GUIWIN_SetTitleTextId(MMIENG_NETINFO_STATISTICS_HANDLE_WIN_ID, (MMI_TEXT_ID_T)TXT_ENG_NETINFO_DROPTIMES, FALSE);
				break;	
		}
        break;
        
    case MSG_CTL_MIDSK:
    case MSG_CTL_OK:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

#else
LOCAL void ShowNetinfoStatisticsReselectInfo( BOOLEAN need_update)
{
    wchar           unicode_cr = 0x0d;
    MMI_STRING_T    cr_s = {0};
    MMI_STRING_T    text_s = {0};
    uint16          *pReselectInfo = PNULL;
    uint16          reselectinfo_len = 0;
    char            temp_ptr[50] = {0};

    uint16          temp_len = 0;
    uint8 i = 0;

    ITEM_T item = {0};

    const char *item_array_name[] = {
                                     "<3G->3G> ", 
                                     "<3G->2G> ",  
                                     "<2G-2G> ", 
                                     "<2G->3G> ",
                                     "<3G->4G> ",
                                     "<2G->4G> ",
                                     "<4G->4G> ",
                                     "<4G->2G> ",
                                     "<4G->3G> "
                                     };
    uint8 item_index[] = {  0, 1, 2, 32, //33
                        2, 4, 5, 33, //32
                        6, 7, 8, 29, //22
                        9, 10, 11, 30, //23
                        14, 15, 16, 34, //34
                        17, 18, 19, 31, //24
                        20, 21, 22, 35, //44
                        23, 24, 25, 36, //42
                        26, 27, 28, 37 //43
                     };
    const char *item_colunm_name[] = { "success ",  
                                        "fail ",  
                                        "passratio ", 
                                        "delay"
                                        };
    const MMIENG_NETINFO_SHOW_TYPE_E   item_type[] = {ENG_STRING_NUM, ENG_STRING_NUM, ENG_STRING_PERCENT, ENG_STRING_NUM};
    uint32 item_data[50] = {0};

    uint8 cell_arrow = ( sizeof( item_array_name ) / ( sizeof( char * ) ));
    uint8 cell_colunm = ( sizeof( item_colunm_name ) / ( sizeof( char * ) ));
    netinfoshow_t adjacentcell_t = {0};

    pReselectInfo = (uint16*)SCI_ALLOC_APPZ( sizeof(uint16)*(MMIENG_NETINFO_LEN + 1) );

    if(PNULL == pReselectInfo)
    {
        TRACE_APP_ENGINEERMODE("malloc fail");
        return;
    }

    TRACE_APP_ENGINEERMODE("cell_arrow = %d,cell_colunm=%d",cell_arrow,cell_colunm);

    for( i = 0; i < cell_arrow; i++ )
    {
        TRACE_APP_ENGINEERMODE("i = %d",i);
        SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
#ifdef PLATFORM_ANTISW3
        em_get_cell_resel_stat( ( int32 )g_dual_sys, &item, item_index[i * cell_colunm] );
        item_data[i * cell_colunm] = item.arr_value[0] ;

        SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
        em_get_cell_resel_stat( ( int32 )g_dual_sys, &item, item_index[i * cell_colunm + 1] );
        item_data[i * cell_colunm + 1] = item.arr_value[0] ;

        SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
        em_get_cell_resel_stat( ( int32 )g_dual_sys, &item, item_index[i * cell_colunm + 2] );
        if( item.arr_value[0]  == 0 ) 
        {
            item_data[i * cell_colunm + 2] = 0;
        } else 
        {
            item_data[i * cell_colunm + 2] = ( (float)item_data[i * cell_colunm] / (float)item.arr_value[0] )*100;
        }

        SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
        em_get_cell_resel_stat( ( int32 )g_dual_sys, &item, item_index[i * cell_colunm + 3] );
#endif
        item_data[i * cell_colunm + 3] = item.arr_value[0] ;

    }

    cr_s.wstr_ptr = &unicode_cr;
    cr_s.wstr_len = 1;
    adjacentcell_t.item = item_colunm_name;
    adjacentcell_t.item_type = item_type;
    adjacentcell_t.data = item_data;
    adjacentcell_t.colunm = cell_colunm;

    SCI_MEMSET( temp_ptr, 0, 50 );
    for( i = 0; i < cell_arrow; i++ )
    {
        sprintf( temp_ptr, "%s", item_array_name[i] );
        temp_len = SCI_STRLEN( ( char * )temp_ptr );
        MMIAPICOM_StrcatFromStrToUCS2( pReselectInfo, &reselectinfo_len, ( uint8 * )temp_ptr, temp_len );
        MMIAPICOM_StrcatFromSTRINGToUCS2( pReselectInfo, &reselectinfo_len, &cr_s ); //换行

        adjacentcell_t.arrow = i;
        MMIENGARRAY_StrcatFromStrToUCS2( adjacentcell_t, pReselectInfo, &reselectinfo_len );
    }

    text_s.wstr_ptr = pReselectInfo;
    text_s.wstr_len = reselectinfo_len;
    GUITEXT_SetString( MMIENG_TEXTBOX1_CTRL_ID, text_s.wstr_ptr, text_s.wstr_len, need_update );

    if(PNULL != pReselectInfo)
    {
        SCI_FREE(pReselectInfo);
        pReselectInfo = PNULL;
    }
}

LOCAL  void ShowNetinfoStatisticsHandoverInfo( BOOLEAN need_update)
{
    wchar           unicode_cr = 0x0d;
    MMI_STRING_T    cr_s = {0};
    MMI_STRING_T    text_s = {0};
    uint16          *pHandoverInfo = PNULL;
    uint16          pHandoverInfo_len = 0;
    char            temp_ptr[50] = {0};

    uint16          temp_len = 0;

    ITEM_T item = {0};

    uint8 i = 0;

    const char *item_array_name[] = { 
                                      "<3G-3G HO> ",
                                      "<3G->2G HO> ",
                                      "<2G->2G HO> ",
                                      "<2G->3G HO> ",
                                      "<3G-2G CCO> ",
                                      "<2G-2G CCO> ",
                                      "<2G-3G CCO> ",
                                      "<2G-4G CCO> ",
                                      "<4G-2G CCO> ",
                                      "<2G-4G HO> ",
                                      "<3G-4G HO> ",
                                      "<4G-4G HO> ", 
                                      "<4G-3G HO> ",
                                      "<4G-2G HO> ",
                                      "<SRVCC 2G> ",
                                      "<SRVCC 3G> "
                                      };
        uint8 item_index[] = {0, 1, 2, 48,
                          3, 4, 5, 49,
                          6, 7, 8, 42,
                          9, 10, 11, 44,
                          12, 13, 14, 50,
                          15, 16, 17, 43,
                          18, 19, 20, 45,
                          21, 22, 23, 47,
                          24, 25, 26, 54,
                          27, 28, 29, 46,
                          30, 31, 32, 51,
                          33, 34, 35, 52,
                          36, 37, 38, 55,
                          39, 40, 41, 53,
                          60, 61, 62, 66,
                          63, 64, 65, 67
                         };


    const char *item_colunm_name[] = { "success ",  "fail ",  "passratio ", "delay"};
    const MMIENG_NETINFO_SHOW_TYPE_E   item_type[] = {ENG_STRING_NUM, ENG_STRING_NUM, ENG_STRING_PERCENT, ENG_STRING_NUM};
    uint32 item_data[100] = {0};

    uint8 cell_arrow = ( sizeof( item_array_name ) / ( sizeof( char * ) ) );
    uint8 cell_colunm = ( sizeof( item_colunm_name ) / ( sizeof( char * ) ) );
    netinfoshow_t adjacentcell_t = {0};


    pHandoverInfo = (uint16*)SCI_ALLOC_APPZ( sizeof(uint16)*(MMIENG_NETINFO_LEN + 1) );

    if(PNULL == pHandoverInfo)
    {
        TRACE_APP_ENGINEERMODE("malloc fail");
        return;
    }

    cr_s.wstr_ptr = &unicode_cr;
    cr_s.wstr_len = 1;

    adjacentcell_t.item = item_colunm_name;
    adjacentcell_t.item_type = item_type;
    adjacentcell_t.data = item_data;
    adjacentcell_t.colunm = cell_colunm;

    SCI_MEMSET( temp_ptr, 0, 50 );

    TRACE_APP_ENGINEERMODE("cell_arrow=%d,cell_colunm=%d",cell_arrow,cell_colunm);

    for( i = 0; i < cell_arrow; i++ ) 
    {
        SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
#ifdef PLATFORM_ANTISW3
        em_get_cell_handover_stat( ( int32 )g_dual_sys, &item, item_index[i * cell_colunm] );
        item_data[i * cell_colunm] = item.arr_value[0] ;

        SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
        em_get_cell_handover_stat( ( int32 )g_dual_sys, &item, item_index[i * cell_colunm + 1] );
        item_data[i * cell_colunm + 1] = item.arr_value[0] ;

        SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
        em_get_cell_handover_stat( ( int32 )g_dual_sys, &item, item_index[i * cell_colunm + 2] );
        if( item.arr_value[0]  == 0 ) {
            item_data[i * cell_colunm + 2] = 0;
        } else {
            item_data[i * cell_colunm + 2] = ( (float)item_data[i * cell_colunm] / (float)item.arr_value[0] )*100;
        }

        SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
        em_get_cell_handover_stat( ( int32 )g_dual_sys, &item, item_index[i * cell_colunm + 3] );
        item_data[i * cell_colunm + 3] = item.arr_value[0] ;
#endif
    }

    for( i = 0; i < cell_arrow; i++ )
    {
        SCI_MEMSET( temp_ptr, 0, 50 );
        sprintf( temp_ptr, "%s", item_array_name[i] );
        temp_len = SCI_STRLEN( ( char * )temp_ptr );
        MMIAPICOM_StrcatFromStrToUCS2( pHandoverInfo, &pHandoverInfo_len, ( uint8 * )temp_ptr, temp_len );
        MMIAPICOM_StrcatFromSTRINGToUCS2( pHandoverInfo, &pHandoverInfo_len, &cr_s ); //换行

        adjacentcell_t.arrow = i;
        MMIENGARRAY_StrcatFromStrToUCS2( adjacentcell_t, pHandoverInfo, &pHandoverInfo_len );
    }

    text_s.wstr_ptr = pHandoverInfo;
    text_s.wstr_len = pHandoverInfo_len;
    GUITEXT_SetString( MMIENG_TEXTBOX1_CTRL_ID, text_s.wstr_ptr, text_s.wstr_len, need_update );

    if(PNULL != pHandoverInfo)
    {
        SCI_FREE(pHandoverInfo);
        pHandoverInfo = PNULL;
    }

}

LOCAL  void ShowNetinfoStatisticsAttachtimeInfo(BOOLEAN need_update)
{
    wchar           unicode_cr = 0x0d;
    MMI_STRING_T    cr_s = {0};
    MMI_STRING_T    text_s = {0};
    uint16          *pAttachTimeInfo = PNULL;
    uint16          pAttachTimeInfo_len = 0;
    uint8 i = 0;

    ITEM_T item = {0};

    const char *item_colunm_name[] =  { "Time on 2G ", 
                                        "Time on 3G ", 
                                        "Time on Unknow",
                                        "Time All",
                                        "Time on lte",
                                        "Time on volte",
                                        "Time on lte ca"
                                        };
    const MMIENG_NETINFO_SHOW_TYPE_E   item_type[] = {ENG_STRING_NUM, ENG_STRING_NUM, ENG_STRING_NUM, ENG_STRING_NUM, ENG_STRING_NUM, ENG_STRING_NUM, ENG_STRING_NUM};
    uint32 item_data[20] = {0};

    uint8 cell_colunm = ( sizeof( item_colunm_name ) / ( sizeof( char * ) ) );
    netinfoshow_t adjacentcell_t = {0};

    pAttachTimeInfo = (uint16*)SCI_ALLOC_APPZ( sizeof(uint16)*(MMIENG_NETINFO_LEN + 1) );

    if(PNULL == pAttachTimeInfo)
    {
        TRACE_APP_ENGINEERMODE("malloc fail");
        return;
    }

    TRACE_APP_ENGINEERMODE("cell_colunm=%d",cell_colunm);

    for( i = 0; i < cell_colunm; i++ ) 
    {
        SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
#ifdef PLATFORM_ANTISW3
        em_get_2g_3g_4g_time( ( int32 )g_dual_sys, &item, i );
#endif
        item_data[i] = item.arr_value[0] ;
    }

    cr_s.wstr_ptr = &unicode_cr;
    cr_s.wstr_len = 1;

    adjacentcell_t.item = item_colunm_name;
    adjacentcell_t.item_type = item_type;
    adjacentcell_t.data = item_data;
    adjacentcell_t.colunm = cell_colunm;

    adjacentcell_t.arrow = 0;
    MMIENGARRAY_StrcatFromStrToUCS2( adjacentcell_t, pAttachTimeInfo, &pAttachTimeInfo_len );

    text_s.wstr_ptr = pAttachTimeInfo;
    text_s.wstr_len = pAttachTimeInfo_len;
    GUITEXT_SetString( MMIENG_TEXTBOX1_CTRL_ID, text_s.wstr_ptr, text_s.wstr_len, need_update );

    if(PNULL != pAttachTimeInfo)
    {
        SCI_FREE(pAttachTimeInfo);
        pAttachTimeInfo = PNULL;
    }
}

LOCAL void ShowNetinfoStatisticsDroptimesInfo(BOOLEAN need_update)
{
    wchar           unicode_cr = 0x0d;
    MMI_STRING_T    cr_s = {0};
    MMI_STRING_T    text_s = {0};
    uint16          *pDropTimeInfo = PNULL;
    uint16          pDropTimeInfo_len = 0;

    uint8 i = 0;

    ITEM_T item = {0};

    const char *item_colunm_name[] =  { "Drop times on 2G ", 
                                        "Drop times on 3G",
                                        "Drop times on 4G "
                                      };
    const MMIENG_NETINFO_SHOW_TYPE_E   item_type[] = {ENG_STRING_NUM, ENG_STRING_NUM, ENG_STRING_NUM};
    uint32 item_data[5] = {0};

    uint8 cell_colunm = ( sizeof( item_colunm_name ) / ( sizeof( char * ) ) );
    netinfoshow_t adjacentcell_t = {0};

    cr_s.wstr_ptr = &unicode_cr;
    cr_s.wstr_len = 1;

    pDropTimeInfo = (uint16*)SCI_ALLOC_APPZ( sizeof(uint16)*(MMIENG_NETINFO_LEN + 1) );
    
     if(PNULL == pDropTimeInfo)
     {
         TRACE_APP_ENGINEERMODE("malloc fail");
         return;
     }

    TRACE_APP_ENGINEERMODE("cell_colunm = %d",cell_colunm);
    for( i = 0; i < cell_colunm; i++ ) 
    {
        SCI_MEMSET( ( void * )&item, 0, sizeof( ITEM_T ) );
#ifdef PLATFORM_ANTISW3
        em_get_drop_network_stat_count( ( int32 )g_dual_sys, &item, i );
#endif
        item_data[i] = item.arr_value[0] ;
    }

    adjacentcell_t.item = item_colunm_name;
    adjacentcell_t.item_type = item_type;
    adjacentcell_t.data = item_data;
    adjacentcell_t.colunm = cell_colunm;

    adjacentcell_t.arrow = 0;
    MMIENGARRAY_StrcatFromStrToUCS2( adjacentcell_t, pDropTimeInfo, &pDropTimeInfo_len );

    text_s.wstr_ptr = pDropTimeInfo;
    text_s.wstr_len = pDropTimeInfo_len;
    GUITEXT_SetString( MMIENG_TEXTBOX1_CTRL_ID, text_s.wstr_ptr, text_s.wstr_len, need_update );

    if(PNULL != pDropTimeInfo)
    {
        SCI_FREE(pDropTimeInfo);
        pDropTimeInfo = PNULL;
    }
}
LOCAL MMI_RESULT_E ENGNetinfoStatisticsDetailInfoWinHandleMsg( MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param )
{
    MMI_STRING_T text = {0};
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    uint32 menu_id = ( uint32 )MMK_GetWinAddDataPtr( win_id );
    switch( msg_id )
    {
        case MSG_OPEN_WINDOW:
        {
            TRACE_APP_ENGINEERMODE( "menuid = %d", menu_id );
            MMK_SetAtvCtrl( win_id, MMIENG_TEXTBOX1_CTRL_ID );
            switch( menu_id )
            {
                case ID_ENG_NETINFO_RESELECT:
                    ShowNetinfoStatisticsReselectInfo( FALSE );
                    GUIWIN_SetTitleTextId( MMIENG_NETINFO_STATISTICS_HANDLE_WIN_ID, ( MMI_TEXT_ID_T )TXT_ENG_NETINFO_RESELECT, FALSE );
                    break;
                case ID_ENG_NETINFO_HANDOVER:
                    ShowNetinfoStatisticsHandoverInfo( FALSE );
                    GUIWIN_SetTitleTextId( MMIENG_NETINFO_STATISTICS_HANDLE_WIN_ID, ( MMI_TEXT_ID_T )TXT_ENG_NETINFO_HANDOVER, FALSE );
                    break;
                case ID_ENG_NETINFO_ATTACHTIME:
                    ShowNetinfoStatisticsAttachtimeInfo( FALSE );
                    GUIWIN_SetTitleTextId( MMIENG_NETINFO_STATISTICS_HANDLE_WIN_ID, ( MMI_TEXT_ID_T )TXT_ENG_NETINFO_ATTACHTIME, FALSE );
                    break;
                case ID_ENG_NETINFO_DROPTIMES:
                    ShowNetinfoStatisticsDroptimesInfo( FALSE );
                    GUIWIN_SetTitleTextId( MMIENG_NETINFO_STATISTICS_HANDLE_WIN_ID, ( MMI_TEXT_ID_T )TXT_ENG_NETINFO_DROPTIMES, FALSE );
                    break;
            }
            break;
        }
        case MSG_CTL_MIDSK:
        case MSG_CTL_OK:
        case MSG_CTL_CANCEL:
            MMK_CloseWin( win_id );
            break;
        default:
            result = MMI_RESULT_FALSE;
            break;
    }
    return ( result );
}
#endif

/*********************************************************************************************/
/*************************************Netinfo End*********************************************/
/*********************************************************************************************/

LOCAL MMI_RESULT_E Eng_IMS_NV_PARAM_ID_WinHandleMsg( MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param )
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T  label_ctrl_id = MMIENG_COMMON_LABEL_CTRL1_ID;
    MMI_CTRL_ID_T  label2_ctrl_id = MMIENG_COMMON_LABEL_CTRL2_ID;
    MMI_CTRL_ID_T  edit1_ctrl_id = MMIENG_COMMON_EDIT_CTRL1_ID;
    MMI_CTRL_ID_T  edit2_ctrl_id = MMIENG_COMMON_EDIT_CTRL2_ID;
    MMI_CTRL_ID_T  form_ctrl_id = MMIENG_FORM_CTRL_ID;
    MMI_CTRL_ID_T  form1_ctrl_id = MMIENG_COMMON_CTRL1_ID;
    MMI_CTRL_ID_T  form2_ctrl_id = MMIENG_COMMON_CTRL2_ID;
    GUI_LCD_DEV_INFO lcd_dev_info = {GUI_MAIN_LCD_ID, GUI_BLOCK_MAIN};
    GUI_BOTH_RECT_T  both_rect = MMITHEME_GetWinClientBothRect( win_id );
    GUI_RECT_T  both_client_rect = {0};
    GUI_FONT_T  text_font = MMI_DEFAULT_NORMAL_FONT_SIZE;
    GUI_COLOR_T text_color = MMI_WHITE_COLOR;
    GUI_COLOR_T by_color = MMI_BLACK_COLOR;

    MMI_STRING_T  sIMS_NV_ID = {0};
    uint16        uiIMS_NV_ID = 0;
    MMI_STRING_T  sIMS_NV_VALUE = {0};
    wchar         wcIMS_NV_Value[256] = {0};
    uint8         ucIMS_NV_ID[4] = {0};
    uint8        *ucIMS_NV_ID1 = PNULL;
    uint8         ucIMS_NV_Value[256] = {0};
    uint8        *ucIMS_NV_Value1 = PNULL;
    uint16        i = 0;
    uint32        dual_sys = ( uint32 )MMK_GetWinAddDataPtr( win_id );
    wchar         wstr[TX_PARAM_LEN] = {0};
    char         *str = PNULL;
    MMI_STRING_T  text = {0};


    switch( msg_id )
    {
        case MSG_OPEN_WINDOW:
        {
            TRACE_APP_ENGINEERMODE( "dual_sys %d ",  dual_sys );
            g_dual_sys = dual_sys;

            GUIFORM_SetType( form_ctrl_id, GUIFORM_TYPE_TP );

            GUIFORM_SetStyle( form1_ctrl_id, GUIFORM_STYLE_UNIT );
            GUIFORM_SetStyle( form2_ctrl_id, GUIFORM_STYLE_UNIT );

            str = "IMS ID";
            text.wstr_len = strlen( str );
            text.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, ( uint8 * )str, text.wstr_len, text.wstr_len );
            GUILABEL_SetText( label_ctrl_id, &text, FALSE );
            GUIEDIT_SetStyle( edit1_ctrl_id, GUIEDIT_STYLE_SINGLE );

            str = "IMS Value";
            text.wstr_len = strlen( str );
            text.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, ( uint8 * )str, text.wstr_len, text.wstr_len );
            GUILABEL_SetText( label2_ctrl_id, &text, FALSE );
            GUIEDIT_SetStyle( edit2_ctrl_id, GUIEDIT_STYLE_SINGLE );

            MMK_SetAtvCtrl( win_id, form1_ctrl_id );
        }
            break;
        case MSG_FULL_PAINT:
            if( MMITHEME_IsMainScreenLandscape() )
            {
                both_client_rect = both_rect.h_rect;
            }
            else
            {
                both_client_rect = both_rect.v_rect;
            }
            GUI_FillRect( &lcd_dev_info, both_client_rect, MMI_WHITE_COLOR );
            break;
        case MSG_CTL_EDITBOX_UPDATE_STRNUM:
            MMK_SendMsg( win_id, MSG_FULL_PAINT, PNULL );
            break;

        case MSG_KEYDOWN_CANCEL:
        case MSG_KEYDOWN_OK:
            break;
        case MSG_CTL_CANCEL:
            MMK_CloseWin( win_id );
            break;
        case MSG_CTL_MIDSK:
        case MSG_APP_WEB:
        {
            GUIEDIT_GetString( edit1_ctrl_id, &sIMS_NV_ID );

            if( sIMS_NV_ID.wstr_len > 0 )
            {
                ucIMS_NV_ID1 = MMIAPICOM_WstrToStr( sIMS_NV_ID.wstr_ptr, ucIMS_NV_ID );

                for( i = 0; i < sIMS_NV_ID.wstr_len; ++i )
                {
                    if( ucIMS_NV_ID1[i] >= '0' && ucIMS_NV_ID1[i] <= '9' )
                    {
                        uiIMS_NV_ID *= 10;
                        uiIMS_NV_ID +=  ucIMS_NV_ID1[i] - '0' ;
                    } else
                    {
                        break;
                    }
                }

                TRACE_APP_ENGINEERMODE( "[eng] Eng_IMS_NV_PARAM_ID_WinHandleMsg uiIMS_NV_ID = %d dual_sys %d", uiIMS_NV_ID, dual_sys );
#ifndef WIN32
#if defined MODEM_SUPPORT_RDA
               MNPHONE_ImsNvParamGet(uiIMS_NV_ID,ucIMS_NV_Value,  dual_sys);
#elif defined MODEM_SUPPORT_SPRD
               mn_al_em_get_ims_parameter( dual_sys, uiIMS_NV_ID, ucIMS_NV_Value );
#endif
#endif
                SCI_TRACE_LOW( "[eng] Eng_IMS_NV_PARAM_ID_WinHandleMsg ucIMS_NV_Value = %s", ucIMS_NV_Value );
                sIMS_NV_VALUE.wstr_len = strlen( ucIMS_NV_Value ) ;
                if( sIMS_NV_VALUE.wstr_len < 1 )
                {
                    CTRLBASEFLEX_ClearAllStr( edit2_ctrl_id );
                } else
                {
                    MMI_STRNTOWSTR( wcIMS_NV_Value, 256, ( uint8 * )ucIMS_NV_Value, 256, sIMS_NV_VALUE.wstr_len );
                    GUIEDIT_SetString( edit2_ctrl_id, wcIMS_NV_Value, sIMS_NV_VALUE.wstr_len );
                }
            }
        }
            break;
        case MSG_CTL_OK:
            GUIEDIT_GetString( edit1_ctrl_id, &sIMS_NV_ID );
            GUIEDIT_GetString( edit2_ctrl_id, &sIMS_NV_VALUE );
            if( ( sIMS_NV_ID.wstr_len > 0 ))
            {
                ucIMS_NV_ID1 = MMIAPICOM_WstrToStr( sIMS_NV_ID.wstr_ptr, ucIMS_NV_ID );
                if(0 < sIMS_NV_VALUE.wstr_len)
                {
                    ucIMS_NV_Value1 = MMIAPICOM_WstrToStr( sIMS_NV_VALUE.wstr_ptr, ucIMS_NV_Value );
                }else
                {
                    SCI_MEMSET( ucIMS_NV_Value, 0, 256 );
                }

                for( i = 0; i < sIMS_NV_ID.wstr_len; ++i )
                {
                    if( ucIMS_NV_ID1[i] >= '0' && ucIMS_NV_ID1[i] <= '9' )
                    {
                        uiIMS_NV_ID *= 10;
                        uiIMS_NV_ID +=  ucIMS_NV_ID1[i] - '0' ;
                    }
                    else
                    {
                        break;
                    }
                }
                SCI_TRACE_LOW( "[eng] Eng_IMS_NV_PARAM_ID_WinHandleMsg uiIMS_NV_ID = %d dual_sys %d", uiIMS_NV_ID, dual_sys );
                SCI_TRACE_LOW( "[eng] Eng_IMS_NV_PARAM_ID_WinHandleMsg  len %d sIMS_NV_VALUE = %s", sIMS_NV_VALUE.wstr_len, ucIMS_NV_Value1 );
#ifndef WIN32
#if defined MODEM_SUPPORT_RDA
                MNPHONE_ImsNvParamSet(uiIMS_NV_ID,ucIMS_NV_Value1,  dual_sys);
#elif defined MODEM_SUPPORT_SPRD
                mn_al_em_set_ims_parameter( dual_sys, uiIMS_NV_ID, ucIMS_NV_Value );
#endif
#endif
            }
            break;
        default:
            result = MMI_RESULT_FALSE;
            break;
    }
    return ( result );
}

LOCAL MMI_RESULT_E EngTeleVoltePLMNWhiteListWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_STRING_T text = {0};
    wchar wstr[TX_PARAM_LEN] = {0};
    char* str = PNULL;
    uint32 i  = 0;
    MMI_STRING_T         itemStr = {0};
    MMI_STRING_T         edit_1_str = {0};
    GUISETLIST_ITEM_INFO_T item_info = {0};
    MMI_RESULT_E           result = MMI_RESULT_TRUE;
    uint32                 ctrl_id = MMIENG_COMMON_EDIT_CTRL4_ID;

    uint8   ucIMS_NV_Value[256] = {0};

    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            GUI_FONT_ALL_T font = {0};

            GUIFORM_SetType(MMIENG_FORM_CTRL_ID, GUIFORM_TYPE_TP);

            GUIFORM_SetStyle(MMIENG_COMMON_CTRL2_ID,GUIFORM_STYLE_UNIT);
            GUIFORM_SetStyle(MMIENG_COMMON_CTRL3_ID,GUIFORM_STYLE_UNIT);
            GUIFORM_SetStyle(MMIENG_COMMON_CTRL4_ID,GUIFORM_STYLE_UNIT);
            GUIWIN_SetSoftkeyTextId(win_id,  (MMI_TEXT_ID_T)TXT_ENG_COMMON_SET, (MMI_TEXT_ID_T)TXT_NULL, (MMI_TEXT_ID_T)TXT_ENG_RETURN, FALSE);

            str = "Test PLMN1";
            text.wstr_len = strlen(str);
            text.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
            GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL2_ID, &text, FALSE);
            GUIEDIT_SetStyle(MMIENG_COMMON_EDIT_CTRL2_ID, GUIEDIT_STYLE_SINGLE);
            GUIEDIT_SetSoftkey(MMIENG_COMMON_EDIT_CTRL2_ID,0,0,TXT_ENG_COMMON_SET,TXT_ENG_COMMON_SET,PNULL);
            GUIEDIT_SetSoftkey(MMIENG_COMMON_EDIT_CTRL2_ID,1,0,NULL,NULL,PNULL);
            GUIEDIT_SetSoftkey(MMIENG_COMMON_EDIT_CTRL2_ID,2,1,TXT_ENG_RETURN,TXT_ENG_CLEAR,PNULL);

            //for test
#ifndef WIN32
#ifdef PLATFORM_ANTISW3
            mn_al_em_get_ims_parameter( 0, 107, ucIMS_NV_Value );
            str = ucIMS_NV_Value;
#endif
#else
            str = "000000";
#endif

            text.wstr_len = strlen( str );
            if( text.wstr_len > 0 )
            {
                text.wstr_ptr = wstr;
                TRACE_APP_ENGINEERMODE( "text.wstr_len =%d ", text.wstr_len );
                SCI_MEMSET( wstr, 0,  TX_PARAM_LEN * sizeof( wchar ) );
                MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, ( uint8 * )str, text.wstr_len, text.wstr_len );
                GUIEDIT_SetString( MMIENG_COMMON_EDIT_CTRL2_ID, text.wstr_ptr, text.wstr_len );
            } else
            {
                CTRLBASEFLEX_ClearAllStr( MMIENG_COMMON_EDIT_CTRL2_ID );
            }

            str =  "Test PLMN2";
            text.wstr_len = strlen(str);
            text.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, (uint8*)str, text.wstr_len, text.wstr_len );
            GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL3_ID, &text, FALSE);
            GUIEDIT_SetStyle(MMIENG_COMMON_EDIT_CTRL3_ID, GUIEDIT_STYLE_SINGLE);
            GUIEDIT_SetSoftkey(MMIENG_COMMON_EDIT_CTRL3_ID,0,0,TXT_ENG_COMMON_SET,TXT_ENG_COMMON_SET,PNULL);
            GUIEDIT_SetSoftkey(MMIENG_COMMON_EDIT_CTRL3_ID,1,0,NULL,NULL,PNULL);
            GUIEDIT_SetSoftkey(MMIENG_COMMON_EDIT_CTRL3_ID,2,1,TXT_ENG_RETURN,TXT_ENG_CLEAR,PNULL);

            //for test
#ifndef WIN32
#ifdef PLATFORM_ANTISW3
            mn_al_em_get_ims_parameter( 0, 108, ucIMS_NV_Value );
#endif
            str = ucIMS_NV_Value;
#else
            str = "000000";
#endif
            text.wstr_len = strlen( str );
            if( text.wstr_len > 0 )
            {
                text.wstr_ptr = wstr;
                TRACE_APP_ENGINEERMODE( "text.wstr_len=[%d]", text.wstr_len );
                SCI_MEMSET( wstr, 0,  TX_PARAM_LEN * sizeof( wchar ) );
                MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, ( uint8 * )str, text.wstr_len, text.wstr_len );
                GUIEDIT_SetString( MMIENG_COMMON_EDIT_CTRL3_ID, text.wstr_ptr, text.wstr_len );
            } else
            {
                CTRLBASEFLEX_ClearAllStr( MMIENG_COMMON_EDIT_CTRL3_ID );
            }



            //Released PLMN White list
            MMI_GetLabelTextByLang(TXT_ENG_TEL_VOLTE_PLMN_WHITE_LIST_RELEASED_TITLE, &text);
            GUIBUTTON_SetText(ctrl_id, text.wstr_ptr, text.wstr_len);
            GUIBUTTON_SetTextAlign(ctrl_id, ALIGN_LEFT);

            font.font = MMI_DEFAULT_TEXT_FONT;
            GUIBUTTON_SetFont(ctrl_id, &font);

            MMK_SetAtvCtrl(win_id, MMIENG_COMMON_EDIT_CTRL2_ID);
        }
            break;
        case MSG_FULL_PAINT:
        {

#ifndef WIN32
#ifdef PLATFORM_ANTISW3
            mn_al_em_get_ims_parameter( 0, 107, ucIMS_NV_Value );
#endif
            str = ucIMS_NV_Value;
#else
            str = "000000";
#endif
            text.wstr_len = strlen( str );
            if( text.wstr_len > 0 )
            {
                text.wstr_ptr = wstr;
                TRACE_APP_ENGINEERMODE( "text.wstr_len=[%d]", text.wstr_len );
                SCI_MEMSET( wstr, 0,  TX_PARAM_LEN * sizeof( wchar ) );
                MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, ( uint8 * )str, text.wstr_len, text.wstr_len );
                GUIEDIT_SetString( MMIENG_COMMON_EDIT_CTRL2_ID, text.wstr_ptr, text.wstr_len );
            } else
            {
                CTRLBASEFLEX_ClearAllStr( MMIENG_COMMON_EDIT_CTRL2_ID );
            }

#ifndef WIN32
#ifdef PLATFORM_ANTISW3
            mn_al_em_get_ims_parameter( 0, 108, ucIMS_NV_Value );
#endif
            str = ucIMS_NV_Value;
#else
            str = "000000";
#endif
            text.wstr_len = strlen( str );
            if( text.wstr_len > 0 )
            {
                text.wstr_ptr = wstr;
                TRACE_APP_ENGINEERMODE( "text.wstr_len = [%d]", text.wstr_len );
                SCI_MEMSET( wstr, 0,  TX_PARAM_LEN * sizeof( wchar ) );
                MMI_STRNTOWSTR( wstr, TX_PARAM_LEN, ( uint8 * )str, text.wstr_len, text.wstr_len );
                GUIEDIT_SetString( MMIENG_COMMON_EDIT_CTRL3_ID, text.wstr_ptr, text.wstr_len );
            } else
            {
                CTRLBASEFLEX_ClearAllStr( MMIENG_COMMON_EDIT_CTRL3_ID );
            }
        }
            MMITHEME_UpdateRect();
            break;

        case MSG_CTL_MIDSK:
        case MSG_APP_WEB:
        {
            if(MMIENG_COMMON_EDIT_CTRL4_ID == MMK_GetActiveCtrlId(win_id))
            {
                MMK_CreateWin((uint32*)MMIENG_TELE_VOLTE_PLMN_WHITE_REL_WIN_TAB, NULL);
            }
        }
            break;
#ifdef TOUCH_PANEL_SUPPORT
        case MSG_CTL_PENOK:
#endif
        case MSG_APP_OK:
        case MSG_CTL_OK:
        {
            uint32 iCurCtrl_id =0;

            uint32 uiEditDigitalNum = 0;
            uint8 tmp_string[10] ={0};
            uint32 menu_id = 0;

            iCurCtrl_id = MMK_GetActiveCtrlId(win_id);
            switch(iCurCtrl_id)
            {
                case MMIENG_COMMON_EDIT_CTRL2_ID:  //Test PLMN 1
                {
                    GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL2_ID,&edit_1_str);
                    MMIAPICOM_WstrToStr(edit_1_str.wstr_ptr,tmp_string);
                    sscanf( tmp_string, "%d", &uiEditDigitalNum );
                    TRACE_APP_ENGINEERMODE( "num[%d]", uiEditDigitalNum );
#ifdef PLATFORM_ANTISW3

#ifndef WIN32
                    if(mn_al_em_set_ims_parameter( 0, 107, tmp_string ))//upload function   or use call back to warning Tester
                    {
                        MMIPUB_OpenAlertWarningWin(TXT_SUCCESS);
                    }
                    else
                    {
                        MMIPUB_OpenAlertWarningWin(TXT_ERROR);
                    }
#endif
#endif
                    MMK_SendMsg( win_id, MSG_FULL_PAINT, PNULL );

                }
                    break;
                case MMIENG_COMMON_EDIT_CTRL3_ID:  //Test PLMN 2
                {
                    GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL3_ID,&edit_1_str);
                    MMIAPICOM_WstrToStr(edit_1_str.wstr_ptr,tmp_string);
                    sscanf( tmp_string, "%d", &uiEditDigitalNum );
                    TRACE_APP_ENGINEERMODE( " num[%d]", uiEditDigitalNum );
#ifdef PLATFORM_ANTISW3

#ifndef WIN32
                    if( mn_al_em_set_ims_parameter( 0, 108, tmp_string ))//upload function   or use call back to warning Tester
                    {
                        MMIPUB_OpenAlertWarningWin(TXT_SUCCESS);
                    }
                    else
                    {
                        MMIPUB_OpenAlertWarningWin(TXT_ERROR);
                    }
#endif
#endif
                    MMK_SendMsg( win_id, MSG_FULL_PAINT, PNULL );

                }
                    break;
                case MMIENG_COMMON_EDIT_CTRL4_ID:
                {
                    MMK_CreateWin((uint32*)MMIENG_TELE_VOLTE_PLMN_WHITE_REL_WIN_TAB, NULL);
                }
                    break;
            }
        }
            break;
        case MSG_APP_CANCEL:
        case MSG_CTL_CANCEL:
            MMK_CloseWin(win_id);
            break;
        default:
            result = MMI_RESULT_FALSE;
            break;
    }
    return (result);
}

#ifdef MMI_VOLTE_SUPPORT

LOCAL MMI_RESULT_E EngTeleVolteOnOffWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E  result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_VOLTE_LISTBOX_CTRL_ID;
    uint16 uiMaxItem = 2;
    uint16 cur_selection = 0;
    uint32 dual_sys = MN_DUAL_SYS_1;

    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            uint8 volte = MMIAPIPHONE_GetVolteInfo();
            BOOLEAN is_volte_on = FALSE;

            GUILIST_SetMaxItem(ctrl_id,uiMaxItem, FALSE );
            MMIAPISET_AppendListItemByTextIdExt(TXT_COMMON_OPEN,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
            MMIAPISET_AppendListItemByTextIdExt(TXT_COMMON_CLOSE,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
            is_volte_on =  volte & (1 << dual_sys);
            if( TRUE == is_volte_on )// on
            {
                cur_selection   = 0;
            }
            else
            {
                cur_selection   = 1;
            }
            //set selected item
            GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);

            //set current item
            GUILIST_SetCurItemIndex(ctrl_id,cur_selection);

            MMK_SetAtvCtrl(win_id,ctrl_id);
            break;
        }
        case MSG_CTL_LIST_SET_SELECT:
        {
            ERR_MNPHONE_CODE_E ret = ERR_MNPHONE_NO_ERR;

	        cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
#ifndef WIN32
            if (0 == cur_selection)//open volte
            {
                ret = MMIAPIPHONE_SetVolteInfo(dual_sys, TRUE);
            }
            else//close volte
            {
                ret = MMIAPIPHONE_SetVolteInfo(dual_sys, FALSE);
            }
#endif
            SCI_TraceLow("VLOTE OnOff ret=%d,cur_selection=%d",ret,cur_selection);
            MMK_CloseWin(win_id);
            break;
        }
        case MSG_CTL_CANCEL:
        case MSG_APP_CANCEL:
        {
            MMK_CloseWin(win_id);
            break;
        }
        default:
            result = MMI_RESULT_FALSE;
            break;
    }
    return result;
}

uint16 s_ims_pdn_type = UAL_TELE_DATA_IP_V4V6;
LOCAL MMI_RESULT_E EngTeleImsPdnWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E  result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_VOLTE_LISTBOX_CTRL_ID;
    uint16 uiMaxItem = 3;
    uint16 cur_selection = 0;
    uint32 dual_sys = MN_DUAL_SYS_1;

    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            GUILIST_SetMaxItem(ctrl_id, uiMaxItem, FALSE);
            MMIAPISET_AppendListItemByTextIdExt(TXT_ENG_TEL_VOLTE_IPV4,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
            MMIAPISET_AppendListItemByTextIdExt(TXT_ENG_TEL_VOLTE_IPV6,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
            MMIAPISET_AppendListItemByTextIdExt(TXT_ENG_TEL_VOLTE_IPV4V6,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);

            cur_selection = s_ims_pdn_type;
            //set selected item
            GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);

            //set current item
            GUILIST_SetCurItemIndex(ctrl_id, cur_selection);

            MMK_SetAtvCtrl(win_id, ctrl_id);
            break;
        }
        case MSG_CTL_LIST_SET_SELECT:
        {
            ERR_MNGPRS_CODE_E ret = ERR_MNGPRS_NO_ERR;
            BOOLEAN context_param[14] = {TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE};
            MN_GPRS_PDP_ADDR_T pdp_addr = {0};

            cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
#ifndef WIN32
            if (UAL_TELE_DATA_IP_V4 == cur_selection)
            {
                ret = MNGPRS_SetInteralPdpContextEx(dual_sys, context_param, MN_PDP_CTX_TYPE_IMS, (uint8 *)"IP", (uint8 *)"ims", pdp_addr, 0, 0, 0, "", "", UAL_TELE_DATA_AUTH_TYPE_PAP);
            }
            else if (UAL_TELE_DATA_IP_V6 == cur_selection)
            {
                ret = MNGPRS_SetInteralPdpContextEx(dual_sys, context_param, MN_PDP_CTX_TYPE_IMS, (uint8 *)"IPV6", (uint8 *)"ims", pdp_addr, 0, 0, 0, "", "", UAL_TELE_DATA_AUTH_TYPE_PAP);
            }
            else
            {
                ret = MNGPRS_SetInteralPdpContextEx(dual_sys, context_param, MN_PDP_CTX_TYPE_IMS, (uint8 *)"IPV4V6", (uint8 *)"ims", pdp_addr, 0, 0, 0, "", "", UAL_TELE_DATA_AUTH_TYPE_PAP);
            }
#endif
            if (ERR_MNGPRS_NO_ERR != ret)
            {
                SCI_TRACE_LOW("MNGPRS_SetInteralPdpContextEx error(%d).", ret);
                MMIPUB_OpenAlertWinByTextId(PNULL, TXT_ERROR, TXT_NULL, IMAGE_PUBWIN_FAIL, PNULL, PNULL, MMIPUB_SOFTKEY_ONE, PNULL);
                MMK_CloseWin(win_id);
                break;
            }
            else
            {
                MMI_STRING_T text_str = {0};
                uint8        str_buf[100] = {0};
                wchar     w_str_buf[100] = {0};
                s_ims_pdn_type = cur_selection;
                SCI_TraceLow("Set ims apn info, ret=%d, cur_selection=%d", ret, cur_selection);

                sprintf((char*)str_buf, "Success! Then In/out Flymode to make it work!");
                MMI_STRNTOWSTR(w_str_buf, 100, str_buf, strlen((char*)str_buf), strlen((char*)str_buf));
                text_str.wstr_ptr = w_str_buf;
                text_str.wstr_len = strlen((char*)str_buf);
                MMIPUB_OpenAlertWinByTextPtr(PNULL, &text_str, PNULL, IMAGE_PUBWIN_SUCCESS, PNULL, PNULL, MMIPUB_SOFTKEY_ONE, PNULL);
                MMK_CloseWin(win_id);
                break;
            }

        }
        case MSG_CTL_CANCEL:
        case MSG_APP_CANCEL:
        {
            MMK_CloseWin(win_id);
            break;
        }
        default:
            result = MMI_RESULT_FALSE;
            break;
    }
    return result;
}

#endif
LOCAL MMI_RESULT_E EngTeleVoltePLMNWhiteListRelWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E  result = MMI_RESULT_TRUE;

    MMI_CTRL_ID_T ctrl_id = MMIENG_COMMON_EDIT_CTRL5_ID;
    MMI_STRING_T  Get_edit_str = {0};
    wchar         txt_array[50]= {0};
    char          buf[25] = {0};
    uint16        txt_len = 0;
    static uint32 uiMaxItem = 100;
    uint32 i = 0;
    switch (msg_id) 
    {
        case MSG_OPEN_WINDOW:
        {
            GUILIST_SetMaxItem(ctrl_id,uiMaxItem, FALSE );
            GUILIST_SetOwnSofterKey(ctrl_id,TRUE);

            for(i = 0;i < uiMaxItem; i++)
            {
                sprintf(buf, "%d",46000+i);
                SCI_MEMSET(txt_array, 0,  50*sizeof(wchar));
                txt_len = SCI_STRLEN(buf);
                MMI_STRNTOWSTR(txt_array, 50, (uint8*)buf, 50, txt_len);
                MMIAPISET_AppendListItemByTextBuffer(txt_array, 
                                                     txt_len, 
                                                     0,
                                                     TXT_ENG_OK, 
                                                     TXT_NULL, 
                                                     TXT_ENG_RETURN, 
                                                     ctrl_id,
                                                     GUIITEM_STYLE_1STR_ENG
                                                     );
            }
            GUILIST_SetSelectedItem(ctrl_id, 0, TRUE);
            GUILIST_SetCurItemIndex(ctrl_id,0);
            MMK_SetAtvCtrl(win_id,ctrl_id);
        }
            break;
        case MSG_FULL_PAINT:
            break;
#ifdef TOUCH_PANEL_SUPPORT 
        case MSG_CTL_PENOK:
#endif 
        case MSG_CTL_MIDSK:
        case MSG_CTL_OK:
        case MSG_APP_WEB:
            break;
        case MSG_CTL_CANCEL:
        case MSG_APP_CANCEL:
            MMK_CloseWin(win_id);
            break;
        default:
            result = MMI_RESULT_FALSE;
            break;
    }
    return result;
}

LOCAL MMI_RESULT_E  EngTeleCSFBToGSmWinHandleMsg(
                                               MMI_WIN_ID_T    win_id,
                                               MMI_MESSAGE_ID_E   msg_id,
                                               DPARAM             param
                                               )
{
    MMI_RESULT_E    recode      =   MMI_RESULT_TRUE; 
    uint16          cur_index   =   0;
    uint16          top_index   =   0;
    MMI_CTRL_ID_T   ctrl_id = MMIENG_COMMON_EDIT_CTRL2_ID;
    uint8 status[2] = {0};

    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            const MMI_TEXT_ID_T idle_text_id[] = {TXT_ENG_TEL_GRRC_RESI,
                                              TXT_ENG_TEL_CRRC_RAND,
                                             };
            uint32    num = ARR_SIZE(idle_text_id);
            uint8     i = 0;
            GUILIST_SetMaxItem(ctrl_id, num, FALSE );//max item 2
            GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
            for(i = 0;i < num;i++)
            {
                MMIAPISET_AppendListItemByTextIdExt(idle_text_id[i],TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1CHECK_ENG);
            }

            GUILIST_SetTopItemIndex( ctrl_id, top_index );
            GUILIST_SetCurItemIndex( ctrl_id, cur_index );
#ifdef PLATFORM_ANTISW3

#ifndef WIN32
            if( RRENG_Is_Delay_CSFB_1_Enable_upper() )
            {
                status[0] = 1;
                status[1] = 0;
            } else if( RRENG_Is_Delay_CSFB_2_Enable_upper() )
            {
                status[0] = 0;
                status[1] = 1;
            } else 
            {
                status[0] = 0;
                status[1] = 0;
            }
#endif
#endif
            CTRLLIST_SetItemStateById( ctrl_id, 0, GUIITEM_STATE_SELECTED, status[0] );
            CTRLLIST_SetItemStateById( ctrl_id, 1, GUIITEM_STATE_SELECTED, status[1] );
            CTRLLIST_SetItemGray( ctrl_id, 0, status[1] );
            CTRLLIST_SetItemGray( ctrl_id, 1, status[0] );


            MMK_SetAtvCtrl( win_id, ctrl_id );
        }
        break;
        case MSG_FULL_PAINT:
            cur_index = GUILIST_GetCurItemIndex(ctrl_id);
            GUILIST_SetCurItemIndex(ctrl_id, cur_index);
#ifndef WIN32
#ifdef PLATFORM_ANTISW3

            if( RRENG_Is_Delay_CSFB_1_Enable_upper() )
            {
                status[0] = 1;
                status[1] = 0;
            } else if( RRENG_Is_Delay_CSFB_2_Enable_upper() )
            {
                status[0] = 0;
                status[1] = 1;
            } else 
            {
                status[0] = 0;
                status[1] = 0;
            }
#endif
#endif
            CTRLLIST_SetItemGray( ctrl_id, 0, status[1] );
            CTRLLIST_SetItemGray( ctrl_id, 1, status[0] );
            MMITHEME_UpdateRect();

            break;
#ifdef TOUCH_PANEL_SUPPORT
        case MSG_CTL_PENOK:
#endif
        case MSG_APP_OK:
        case MSG_APP_WEB:
        case MSG_CTL_MIDSK:
        case MSG_CTL_OK:
        {
            cur_index = GUILIST_GetCurItemIndex(ctrl_id);
            if (TRUE == GUILIST_GetItemState(GUILIST_GetItemPtrByIndex(ctrl_id, cur_index), GUIITEM_STATE_SELECTED))  //selected 
            {
                CTRLLIST_SetItemStateById(ctrl_id,cur_index,GUIITEM_STATE_SELECTED,FALSE);
#ifdef PLATFORM_ANTISW3
                //func to remove the item
                if(0 == cur_index)
                {
                    //AT+SPSETGRRC
                    RRENG_Delay_CSFB_Disable( 1 );
                }else if(1 == cur_index)
                {
                    //AT+SPSETGRRC
                    RRENG_Delay_CSFB_Disable( 2 );
                }
#endif
            }
            else //unselect
            {
                CTRLLIST_SetItemStateById(ctrl_id,cur_index,GUIITEM_STATE_SELECTED,TRUE);
#ifdef PLATFORM_ANTISW3
                //func to add item
                if(0 == cur_index)
                {
                    //AT+SPSETGRRC
                    RRENG_Delay_CSFB_Enable( 1 );
                }else if(1 == cur_index)
                {
                    //AT+SPSETGRRC 
                    RRENG_Delay_CSFB_Enable( 2 );
                }
#endif
            }
            MMK_SendMsg(win_id,MSG_FULL_PAINT,PNULL);
        }
            break;
        case MSG_CTL_CANCEL:
        case MSG_APP_CANCEL:
            MMK_CloseWin( win_id );
            break;
        case MSG_CLOSE_WINDOW:
            break;
        default:
            recode = MMI_RESULT_FALSE;
            break;
    }
    return recode;
}

LOCAL MMI_RESULT_E EngFactoryResetWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E ret_value     = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id      = MMIENG_COMMON_EDIT_CTRL2_ID;
    uint16       cur_selection = 0;

    switch(msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            GUILIST_ITEM_T  item_t = {0};
            GUILIST_ITEM_DATA_T item_data = {0};

            GUILIST_SetMaxItem(ctrl_id,2, FALSE );//max item 2 normal and deep factory reset
            GUILIST_SetOwnSofterKey( ctrl_id, FALSE );

            item_t.item_style    = GUIITEM_STYLE_1RADIO_ENG;
            item_t.item_data_ptr = &item_data;

            item_data.item_content[0].item_data_type  = GUIITEM_DATA_TEXT_ID;

            item_data.item_content[0].item_data.text_id = TXT_ENG_NORMAL_FACTORY_RESET;
            GUILIST_AppendItem( ctrl_id, &item_t );
            item_data.item_content[0].item_data.text_id = TXT_ENG_DEEP_FACTORY_RESET;
            GUILIST_AppendItem( ctrl_id, &item_t );

            //set selected item
            GUILIST_SetSelectedItem(ctrl_id, 0, TRUE);

            //set current item
            GUILIST_SetCurItemIndex(ctrl_id,0);
            MMK_SetAtvCtrl(win_id,ctrl_id);
        }
            break;
#ifdef TOUCH_PANEL_SUPPORT
        case MSG_CTL_PENOK:
#endif
        case MSG_APP_WEB:
        case MSG_CTL_MIDSK:
        {
            cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
            if(0 == cur_selection) //normal reset
            {
                MMK_CreateWin((uint32*)MMIENG_FACTORY_RESET_INPUT_PWD_WIN_TAB,FALSE);
            }else if(1 == cur_selection) //deep reset
            {
                MMK_CreateWin((uint32*)MMIENG_FACTORY_RESET_INPUT_PWD_WIN_TAB,TRUE);
            }
        }
            break;
        case MSG_FULL_PAINT:
            break;
        case MSG_CTL_OK:
        case MSG_CTL_CANCEL:
            MMK_CloseWin(win_id);
            break;
        case MSG_CLOSE_WINDOW:
            break;
        default:
            ret_value = MMI_RESULT_FALSE;
            break;
    }
    return ret_value;
}
extern ERR_MNGPRS_CODE_E  MNGPRS_SetEnergySavingMode ( /*return whether success or failure*/
    MN_DUAL_SYS_E		dual_sys,
    BOOLEAN energy_saving_mode /* TRUE saving, FALSE not saving */
    );

LOCAL MMI_RESULT_E  EngGprsPowerSaveModeWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
        uint16 index = 0;
        MMI_RESULT_E result = MMI_RESULT_TRUE;
        uint32 list_id = MMIENG_COMMON_EDIT_CTRL2_ID ;
        static BOOLEAN power_save_flag = TRUE;

        switch (msg_id)
        {
            case MSG_OPEN_WINDOW:
            {
                GUILIST_ITEM_T      item_t = {0};
                GUILIST_ITEM_DATA_T item_data = {0};    

                GUIWIN_SetTitleTextId(win_id, TXT_ENG_GPRS_POWER_SAVE_MODE_TITLE, FALSE);

                GUILIST_SetMaxItem( list_id, 2, FALSE );
                GUILIST_SetOwnSofterKey(list_id,FALSE);

                item_t.item_style    = GUIITEM_STYLE_1RADIO_ENG;
                item_t.item_data_ptr = &item_data;

                item_data.item_content[0].item_data_type = GUIITEM_DATA_TEXT_ID;

                item_data.item_content[0].item_data.text_id = TXT_OPEN_COMN;
                GUILIST_AppendItem( list_id, &item_t );
                item_data.item_content[0].item_data.text_id = TXT_COMM_CLOSE;
                GUILIST_AppendItem( list_id, &item_t );

                SCI_TRACE_LOW("GPRS power_save_flag %d", power_save_flag);
                if(TRUE ==  power_save_flag)
                {
                    index = 0;
                }
                else
                {
                    index = 1;
                }
                GUILIST_SetSelectedItem( list_id,index, TRUE );
                GUILIST_SetCurItemIndex( list_id, index);
                MMK_SetAtvCtrl(win_id, list_id);
            }
            break;

            case MSG_FULL_PAINT:
            break;

            case MSG_KEYDOWN_CANCEL:
            case MSG_CTL_CANCEL:
            MMK_CloseWin(win_id);
            break;

            case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
            case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
            case MSG_KEYDOWN_OK:
            case MSG_CTL_OK:
            case MSG_APP_WEB:
            {
                index = GUILIST_GetCurItemIndex(list_id);
                SCI_TRACE_LOW("GPRS index %d", index);
#ifdef PLATFORM_ANTISW3

#ifndef WIN32
                if(0 == index)
                {
                    SCI_TRACE_LOW("GPRS MNGPRS_SetEnergySavingMode TRUE");
                    power_save_flag = TRUE;
                    MNGPRS_SetEnergySavingMode(MN_DUAL_SYS_1, TRUE);
                }
                else if( 1  == index)
                {
                    SCI_TRACE_LOW("GPRS MNGPRS_SetEnergySavingMode FALSE");
                    power_save_flag = FALSE;
                    MNGPRS_SetEnergySavingMode(MN_DUAL_SYS_1, FALSE);
                }
                else
                {
                    SCI_TRACE_LOW("GPRS MNGPRS_SetEnergySavingMode FALSE");
                    power_save_flag = TRUE;
                    MNGPRS_SetEnergySavingMode(MN_DUAL_SYS_1, TRUE);
                }
#endif
#endif
                MMK_CloseWin(win_id);
            }
            break;

            default:
            result = MMI_RESULT_FALSE;
            break;
        }
        return (result);
}



LOCAL MMI_RESULT_E  EngResetFactoryInputPwdHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_TEXT_ID_T               title_id                =   {0};
    MMI_STRING_T                old_pwd_value           =   {0};
    MMI_RESULT_E                result                  =   MMI_RESULT_TRUE;
    MMI_CTRL_ID_T               ctrl_id                 =   MMIENG_COMMON_EDIT_CTRL1_ID;
    uint32                      is_delete_all_data      =   FALSE;

    is_delete_all_data = (uint32)(MMK_GetWinAddDataPtr(win_id));

    switch(msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            GUI_BG_T form_bg = {0};
            GUIFORM_CHILD_HEIGHT_T form_height = {0};
            GUIFORM_CHILD_HEIGHT_T lab_height  = {0};
            GUIFORM_CHILD_HEIGHT_T edit_height = {0};

            form_height.type = GUIFORM_CHILD_HEIGHT_FIXED;
            form_height.add_data = 70;
            lab_height.type = GUIFORM_CHILD_HEIGHT_FIXED;
            lab_height.add_data = 30;
            edit_height.type = GUIFORM_CHILD_HEIGHT_FIXED;
            edit_height.add_data = 40;

            form_bg.bg_type = GUI_BG_COLOR;
            form_bg.color = MMI_BLACK_COLOR;
            GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID, MMIENG_COMMON_CTRL1_ID, &form_height);
            GUIFORM_SetChildHeight(MMIENG_COMMON_CTRL1_ID, MMIENG_COMMON_LABEL_CTRL1_ID, &lab_height);
            GUIFORM_SetChildHeight(MMIENG_COMMON_CTRL1_ID, MMIENG_COMMON_EDIT_CTRL1_ID, &edit_height);

            GUIFORM_SetBg(MMIENG_FORM_CTRL_ID,&form_bg);
            GUIFORM_SetType( MMIENG_FORM_CTRL_ID, GUIFORM_TYPE_TP );

            GUIFORM_SetStyle(MMIENG_COMMON_CTRL1_ID,GUIFORM_STYLE_UNIT);

            GUILABEL_SetTextById( MMIENG_COMMON_LABEL_CTRL1_ID, TXT_ENG_INPUT_PHONE_PASSWORD, FALSE );
            GUIEDIT_SetStyle( MMIENG_COMMON_EDIT_CTRL1_ID, GUIEDIT_STYLE_SINGLE );

            if(TRUE == is_delete_all_data) //true is deep reset
            {
                title_id = TXT_ENG_DEEP_FACTORY_RESET;
            }else  //normal reset
            {
                title_id = TXT_ENG_NORMAL_FACTORY_RESET;
            }
            GUIWIN_SetTitleTextId(win_id, title_id, FALSE);
            MMK_SetAtvCtrl(win_id,MMIENG_COMMON_EDIT_CTRL1_ID);
            break;
        } 
        case MSG_FULL_PAINT:
            break;
        case MSG_APP_OK:
        case MSG_CTL_OK:
        case MSG_APP_WEB:
        case MSG_CTL_MIDSK:
        case MSG_APP_MENU:
        {
            // get the value
            GUIEDIT_GetString(ctrl_id,&old_pwd_value);

            //密码是否正确
            if (MMISET_IsCorrectPrivacyProtectPwd( old_pwd_value.wstr_ptr,old_pwd_value.wstr_len))
            {
                if (is_delete_all_data) //deep reset
                {       
                    MMISET_CleanUserData();
                    MMISET_ResetFactorySetting();
                    MMIAPIPHONE_PowerReset();
                }
                else
                {     
                    //normal reset
                    MMISET_ResetFactorySetting();
                    MMK_CloseWin(win_id);
                }
            }
            else
            {
                //清空password
                GUIEDIT_ClearAllStr(ctrl_id);

                //提示密码错误!
                MMIPUB_OpenAlertWarningWin(TXT_KL_PSW_WRONG_PSW);
            }
        }
            break;
        case MSG_CLOSE_WINDOW:
            break;
        case MSG_APP_CANCEL:
        case MSG_CTL_CANCEL:
            MMK_CloseWin(win_id);
            break;
        default:
            result = MMI_RESULT_FALSE;
            break;
    }

    return (result);
}

LOCAL void  SMSSCSettingSelectSimCallback(uint16 dual_sys,BOOLEAN isReturnOK, DPARAM param)
{
	if(isReturnOK)
    {
        MMK_CreateWin((uint32*)MMIENG_SMS_SETSC_WIN_TAB,(uint32)dual_sys);;
    }
    else
    {
        SCI_TRACE_LOW("select fail");
    }
}
LOCAL void MMISMS_SMSCenterNumber(void)
{
    uint16 sim_sys = MN_DUAL_SYS_1;
    uint32 sim_num = 0;

    sim_num = MMIAPIPHONE_GetSimAvailableNum(&sim_sys, 1);
    if (sim_num == 0)
    {
        MMIAPIPHONE_AlertSimNorOKStatus();
    }
    else if (sim_num == 1)
    {
        MMK_CreateWin((uint32*)MMIENG_SMS_SETSC_WIN_TAB,(uint32)sim_sys);
    }
#if !defined(MMI_MULTI_SIM_SYS_SINGLE)
    else
    {
        MMISET_SelectSIMFunc(SMSSCSettingSelectSimCallback, MMISET_APPEND_SYS_OK,PNULL);
    }
#endif
}

LOCAL MMI_RESULT_E  EngSetSMSSCHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E                result                  =   MMI_RESULT_TRUE;
    MMI_CTRL_ID_T               ctrl_id                 =   MMIENG_COMMON_EDIT_CTRL1_ID;
    MN_DUAL_SYS_E               dual_sys                =   MN_DUAL_SYS_1;
    uint8                       sc_num_len              =   0;
    wchar                       sc_num_wstr[MMISMS_STRNUM_MAX_LEN + 2] = {0};
    char                        sc_num_str[MMISMS_STRNUM_MAX_LEN + 2]  = {0};

    dual_sys = (uint32)(MMK_GetWinAddDataPtr(win_id));

    switch(msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            GUI_BG_T               form_bg     = {0};
            GUIFORM_CHILD_HEIGHT_T form_height = {0};
            GUIFORM_CHILD_HEIGHT_T lab_height  = {0};
            GUIFORM_CHILD_HEIGHT_T edit_height = {0};

            form_height.type = GUIFORM_CHILD_HEIGHT_FIXED;
            form_height.add_data = 70;
            lab_height.type = GUIFORM_CHILD_HEIGHT_FIXED;
            lab_height.add_data = 30;
            edit_height.type = GUIFORM_CHILD_HEIGHT_FIXED;
            edit_height.add_data = 40;

            form_bg.bg_type = GUI_BG_COLOR;
            form_bg.color = MMI_BLACK_COLOR;

            GUIFORM_SetStyle(MMIENG_COMMON_CTRL1_ID,GUIFORM_STYLE_UNIT);
            GUIFORM_SetBg(MMIENG_FORM_CTRL_ID,&form_bg);
            GUIFORM_SetType( MMIENG_FORM_CTRL_ID, GUIFORM_TYPE_TP );
            //set sms center number
            GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID, MMIENG_COMMON_CTRL1_ID, &form_height);
            GUIFORM_SetChildHeight(MMIENG_COMMON_CTRL1_ID, MMIENG_COMMON_LABEL_CTRL1_ID, &lab_height);
            GUIFORM_SetChildHeight(MMIENG_COMMON_CTRL1_ID, MMIENG_COMMON_EDIT_CTRL1_ID, &edit_height);
            GUILABEL_SetTextById( MMIENG_COMMON_LABEL_CTRL1_ID, TXT_ENG_SET_SMS_CENTER_NUMBER, FALSE );
            GUIEDIT_SetStyle( MMIENG_COMMON_EDIT_CTRL1_ID, GUIEDIT_STYLE_SINGLE );

            if(TRUE == MMISMS_AppGetSCAddr(dual_sys,sc_num_str,&sc_num_len,MMISMS_STRNUM_MAX_LEN + 2))
            {
                if(0 < sc_num_len)
                {
                    MMI_STRNTOWSTR(sc_num_wstr,
                                   MMISMS_STRNUM_MAX_LEN,
                                   (const uint8 *)sc_num_str,
                                   MMISMS_STRNUM_MAX_LEN,
                                   sc_num_len);
                    GUIEDIT_SetString(MMIENG_COMMON_EDIT_CTRL1_ID,sc_num_wstr,(uint16)MMIAPICOM_Wstrlen(sc_num_wstr));
                }
            }

            MMK_SetAtvCtrl(win_id,MMIENG_COMMON_EDIT_CTRL1_ID);
            break;
        }
        case MSG_FULL_PAINT:
            break;
        case MSG_APP_OK:
        case MSG_CTL_OK:
        case MSG_APP_WEB:
        case MSG_CTL_MIDSK:
        case MSG_APP_MENU:
        case MSG_CLOSE_WINDOW: //关窗时，自动保存短信中心号码
        {
            //get input sc number
            MMI_STRING_T num_string = {0};
            SCI_MEMSET(&num_string, 0, sizeof (MMI_STRING_T));
            GUIEDIT_GetString(ctrl_id, &num_string);

            if (0 < MMIAPICOM_Wstrlen(num_string.wstr_ptr))
            {
                if (TRUE == IsSCAddrValid(&num_string))
                {
                    uint8 num_str[MMISMS_MAX_SC_NUMBER_LEN] = {0};

                    MMI_WSTRNTOSTR((uint8 *)num_str,
                                    MMISMS_MAX_SC_NUMBER_LEN,
                                    num_string.wstr_ptr,
                                    MMISMS_MAX_SC_NUMBER_LEN,
                                    num_string.wstr_len
                                    );

                    // set sc address
                    if (MMISMS_AppSetSCAddr(dual_sys, num_str, (uint8)num_string.wstr_len))
                    {
                        MMIPUB_OpenAlertWarningWin(TXT_ENG_TEST_SIM_RESULT1);
						MMK_CloseWin(win_id);
                    }
                    else
                    {
                        //提示输入错误
                        MMIPUB_OpenAlertWarningWin(TXT_CC_INVALID_NUM);
                    }
                }
                else
                {
                    //提示输入错误
                    MMIPUB_OpenAlertWarningWin(TXT_CC_INVALID_NUM);
                }
            }         
        }
            break;

        case MSG_APP_CANCEL:    
        case MSG_CTL_CANCEL:
            MMK_CloseWin(win_id);
            break;
        default:
            result = MMI_RESULT_FALSE;
            break;
    }

    return (result);
}


LOCAL MMI_RESULT_E  EngFastDormancyHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E                result                  =   MMI_RESULT_TRUE;
    MMI_CTRL_ID_T               ctrl_list_open          =   MMIENG_COMMON_LIST_CTRL1_ID;

    switch(msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            GUI_BG_T               form_bg     = {0};
            GUIFORM_CHILD_HEIGHT_T form_height = {0};
            GUIFORM_CHILD_HEIGHT_T list_height = {0};
            GUIFORM_CHILD_HEIGHT_T lab_height  = {0};
            GUIFORM_CHILD_HEIGHT_T edit_height = {0};

            form_height.type = GUIFORM_CHILD_HEIGHT_FIXED;
            form_height.add_data = 70;
            lab_height.type = GUIFORM_CHILD_HEIGHT_FIXED;
            lab_height.add_data = 30;
            edit_height.type = GUIFORM_CHILD_HEIGHT_FIXED;
            edit_height.add_data = 40;

            list_height.type = GUIFORM_CHILD_HEIGHT_FIXED;
            list_height.add_data = 55;

            form_bg.bg_type = GUI_BG_COLOR;
            form_bg.color = MMI_BLACK_COLOR;

            GUIFORM_SetBg(MMIENG_FORM_CTRL_ID,&form_bg);
            GUIFORM_SetType( MMIENG_FORM_CTRL_ID, GUIFORM_TYPE_TP );

            //open
            GUIFORM_SetStyle(MMIENG_COMMON_CTRL1_ID,GUIFORM_STYLE_UNIT);
            GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID, MMIENG_COMMON_CTRL1_ID, &list_height);
            GUIFORM_SetChildHeight(MMIENG_COMMON_CTRL1_ID, ctrl_list_open, &list_height);
            GUILIST_SetMaxItem(ctrl_list_open,1, FALSE );//open
            MMIAPISET_AppendListItemByTextIdExt(TXT_OPEN_COMN,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_list_open,GUIITEM_STYLE_1CHECK_ENG);
            GUILIST_SetItemTextFontColor(ctrl_list_open,MMI_WHITE_COLOR);

            //input times(s) for dormancy
            GUIFORM_SetStyle(MMIENG_COMMON_CTRL2_ID,GUIFORM_STYLE_UNIT);
            GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID, MMIENG_COMMON_CTRL2_ID, &form_height);
            GUIFORM_SetChildHeight(MMIENG_COMMON_CTRL2_ID,MMIENG_COMMON_LABEL_CTRL2_ID, &lab_height);
            GUIFORM_SetChildHeight(MMIENG_COMMON_CTRL2_ID, MMIENG_COMMON_EDIT_CTRL2_ID, &edit_height);
            GUILABEL_SetTextById( MMIENG_COMMON_LABEL_CTRL2_ID, TXT_ENG_INPUT_TIMES_DORMANCY, FALSE );
            GUILABEL_SetFont(MMIENG_COMMON_LABEL_CTRL2_ID,SONG_FONT_25,MMI_WHITE_COLOR);

            GUIEDIT_SetStyle( MMIENG_COMMON_EDIT_CTRL2_ID, GUIEDIT_STYLE_SINGLE);

            MMK_SetAtvCtrl(win_id,ctrl_list_open);
            break;
        }
        case MSG_FULL_PAINT:
        {
            MMI_HANDLE_T active_ctrl = MMK_GetActiveCtrl(win_id);
            //MMI_HANDLE_T ctrl_list_handle = MMK_GetCtrlHandleByWin(win_id, ctrl_list_open);

            if(ctrl_list_open == active_ctrl)
            {
                GUILIST_SetSelectedItem(ctrl_list_open, 0, TRUE);
                GUILIST_SetCurItemIndex(ctrl_list_open, 0);
            }

            if(TRUE == GUILIST_GetItemState(GUILIST_GetItemPtrByIndex(ctrl_list_open,0),GUIITEM_STATE_SELECTED))
            {
                GUIFORM_SetChildDisplay( MMIENG_FORM_CTRL_ID,  MMIENG_COMMON_CTRL2_ID, GUIFORM_CHILD_DISP_NORMAL);
            }else
            {
                GUIFORM_SetChildDisplay(MMIENG_FORM_CTRL_ID,  MMIENG_COMMON_CTRL2_ID, GUIFORM_CHILD_DISP_HIDE);
            }
            //MMK_UpdateScreen();
        }
            break;
#ifdef TOUCH_PANEL_SUPPORT
        case MSG_CTL_PENOK:
#endif
        case MSG_APP_OK:
        case MSG_CTL_OK:
        case MSG_APP_WEB:
        case MSG_CTL_MIDSK:
        case MSG_APP_MENU:
        {
            uint32 focus_ctrl = 0;
            MMI_STRING_T dormancy_times = {0};
            focus_ctrl = MMK_GetActiveCtrlId(win_id);

            switch(focus_ctrl)
            {
                case MMIENG_COMMON_LIST_CTRL1_ID://list open control
                {
                    SCI_TRACE_LOW("MMIENG_COMMON_LIST_CTRL1_ID");
                    if(TRUE == GUILIST_GetItemState(GUILIST_GetItemPtrByIndex(ctrl_list_open, 0), GUIITEM_STATE_SELECTED))// Open
                    {
                        CTRLLIST_SetItemStateById(ctrl_list_open,0,GUIITEM_STATE_SELECTED,FALSE);
                        GUIFORM_SetChildDisplay(MMIENG_FORM_CTRL_ID,  MMIENG_COMMON_CTRL2_ID, GUIFORM_CHILD_DISP_HIDE);
                        // TODO: set fast dormancy close
                    }
                    else // Close
                    {
                        CTRLLIST_SetItemStateById(ctrl_list_open,0,GUIITEM_STATE_SELECTED,TRUE);
                        GUIFORM_SetChildDisplay(MMIENG_FORM_CTRL_ID,  MMIENG_COMMON_CTRL2_ID, GUIFORM_CHILD_DISP_NORMAL);
                        MMK_SetAtvCtrl(win_id,MMIENG_COMMON_EDIT_CTRL2_ID);
                    }
                        MMK_SendMsg(win_id,MSG_FULL_PAINT,PNULL);
                }
                    break;
                case MMIENG_COMMON_EDIT_CTRL2_ID://edit fast dormancy time
                {
                    SCI_TRACE_LOW("MMIENG_COMMON_EDIT_CTRL2_ID");
                    GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL2_ID,&dormancy_times);
                    // TODO: set fast dormancy open and get dormancy time

                    MMK_CloseWin(win_id);
                }
                    break;
                default:
                    SCI_TRACE_LOW("default contrl id is %d",focus_ctrl);
                    break;
            }
        }
            break;
        case MSG_CLOSE_WINDOW:
            break;
        case MSG_APP_CANCEL:
        case MSG_CTL_CANCEL:
            MMK_CloseWin(win_id);
            break;
        default:
            result = MMI_RESULT_FALSE;
            break;
    }
    return result;
}

LOCAL MMI_RESULT_E EngQosSwitchWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E ret_value     = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id      = MMIENG_COMMON_EDIT_CTRL2_ID;
    uint16       cur_selection = 0;

    switch(msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            GUILIST_ITEM_T  item_t = {0};
            GUILIST_ITEM_DATA_T item_data = {0};

            GUILIST_SetMaxItem(ctrl_id,2, FALSE );//max item 2 open and close
            GUILIST_SetOwnSofterKey( ctrl_id, FALSE );

            item_t.item_style    = GUIITEM_STYLE_1RADIO_ENG;
            item_t.item_data_ptr = &item_data;

            item_data.item_content[0].item_data_type  = GUIITEM_DATA_TEXT_ID;

            item_data.item_content[0].item_data.text_id = TXT_OPEN_COMN;
            GUILIST_AppendItem( ctrl_id, &item_t );
            item_data.item_content[0].item_data.text_id = TXT_COMM_CLOSE;
            GUILIST_AppendItem( ctrl_id, &item_t );

            //set selected item 
            GUILIST_SetSelectedItem(ctrl_id, 0, TRUE);

            //set current item
            GUILIST_SetCurItemIndex(ctrl_id,0);
            MMK_SetAtvCtrl(win_id,ctrl_id);    
        }
            break;
#ifdef TOUCH_PANEL_SUPPORT
        case MSG_CTL_PENOK:
#endif
        case MSG_APP_WEB:
        case MSG_CTL_MIDSK:
        {
            cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
            if(0 == cur_selection) //close
            {
                // TODO: set Qos switch open
            }else if(1 == cur_selection) //open
            {
                // TODO: set Qos switch close
            }
        }
            break;
        case MSG_FULL_PAINT:
            break;
        case MSG_CTL_OK:
        case MSG_CTL_CANCEL:
            MMK_CloseWin(win_id);
            break;
        case MSG_CLOSE_WINDOW:
            break;
        default:
            ret_value = MMI_RESULT_FALSE;
            break;
    }
    return ret_value;
}

LOCAL MMIPB_ERROR_E MMIENG_AddContact(MMI_STRING_T *name,uint16 name_idx,uint8 photoid,uint8 *phone_num,int16 phone_num_len)
{
    MMIPB_CONTACT_T  contact_info = {0};
    uint32           pos          = 0;
    BOOLEAN          is_exist     = FALSE;
    MMI_PARTY_NUMBER_T  party_num = {0};
    MMIPB_ERROR_E  operator_error = MMIPB_ERROR_SUCCESS;

    if(PNULL == name)
    {
        SCI_TRACE_LOW("MMIENG_AddContact name is null");
        return MMIPB_ERROR_ERROR;//bug id:2056715
    }

    if(PNULL == phone_num)
    {
        SCI_TRACE_LOW("MMIENG_AddContact phonenum is null");
        return MMIPB_ERROR_ERROR;
    }

    if((!MMIPB_IsPbReady()))
    {
        SCI_TRACE_LOW("MMIPB_FillPhoneContactFull PB NOT READY");
        return MMIPB_ERROR_ERROR;
    }

    SCI_MEMSET(&contact_info, 0x0, sizeof(contact_info));

    if (MMIAPICOM_GenPartyNumber((uint8 *)(phone_num), phone_num_len, &party_num))
    {
        contact_info.number[0].npi_ton = (uint8)((party_num.number_type << 0X04) | MMIPB_DEFAULT_NPI);
        contact_info.number[0].number_len = (uint8)MIN(MMIPB_BCD_NUMBER_MAX_LEN, party_num.num_len);
        SCI_MEMCPY(contact_info.number[0].number, party_num.bcd_num, sizeof(party_num.bcd_num));
    }

    contact_info.name.wstr_len = name->wstr_len;
    contact_info.storage_id = MMIPB_GetStorageID(MMIPB_STORAGE_PHONE, MMIPB_NORMAL_PHONE_CONTACT);;
    MMIAPICOM_Wstrncpy(contact_info.name.wstr, name->wstr_ptr, contact_info.name.wstr_len);

    contact_info.contact_id = (name_idx + 1);//cintact id is from 1,save as order
    contact_info.photo_id_flag = (photoid + 1);

    //judge weather contact has existed
    is_exist = MMIPB_IsNameExist(name,contact_info.storage_id,&pos);
    if(TRUE == is_exist)
    {
       operator_error =  MMIAPIPB_ModifyContact(&contact_info);
    }else
    {
      operator_error =  MMIPB_AddContact(&contact_info);
    }

    return operator_error;
}

LOCAL MMI_RESULT_E  EngAddContactHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E ret_value      = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id       = MMIENG_COMMON_LIST_CTRL1_ID;
    MMI_STRING_T itemStr        = {0};
    char* str = PNULL;
    uint8 i = 0;
    wchar wstr[10] = {0};
    MMI_STRING_T text = {0};
#ifdef SCREEN_SHAPE_CIRCULAR
    uint32  droplist_name_id[8] = {
                                    TXT_ENG_FATHER, //father
                                    TXT_ENG_MOTHER, //mother
                                    TXT_ENG_GRANDPA,//grandpa
                                    TXT_ENG_GRANDMA,//gradma
                                    TXT_ENG_TEACHER,//teacher
                                    TXT_ENG_CLASSMATE, //classmate
                                    TXT_ENG_SISTER,  //sister
                                    TXT_ENG_BROTHER  //brother
                                  };
    uint32 droplist_imageid[8]  = {
                                    TXT_ENG_IMAGE1,//image1
                                    TXT_ENG_IMAGE2,//image2
                                    TXT_ENG_IMAGE3,//image3
                                    TXT_ENG_IMAGE4,//image4
                                    TXT_ENG_IMAGE5,//image5
                                    TXT_ENG_IMAGE6, //image6
                                    TXT_ENG_IMAGE7,//image7
                                    TXT_ENG_IMAGE8 //image8
                                  };
#else
    uint32  droplist_name_id[6] = {
                                    TXT_ENG_FATHER, //father
                                    TXT_ENG_MOTHER, //mother
                                    TXT_ENG_GRANDPA,//grandpa
                                    TXT_ENG_GRANDMA,//gradma
                                    TXT_ENG_TEACHER,//teacher
                                    TXT_ENG_CLASSMATE  //classmate
                                  };
    uint32 droplist_imageid[6]  = {
                                    TXT_ENG_IMAGE1,//image1
                                    TXT_ENG_IMAGE2,//image2
                                    TXT_ENG_IMAGE3,//image3
                                    TXT_ENG_IMAGE4,//image4
                                    TXT_ENG_IMAGE5,//image5
                                    TXT_ENG_IMAGE6 //image6
                                  };
#endif
    switch(msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            MMI_HANDLE_T form_ctrl                  = MMK_GetCtrlHandleByWin(win_id, MMIENG_FORM_CTRL_ID);
            MMI_HANDLE_T drop_list_name_ctrl        = MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_LIST_CTRL1_ID);
            MMI_HANDLE_T drop_list_icon_ctrl        = MMK_GetCtrlHandleByWin(win_id, MMIENG_DROP_LIST_ICON_ID);
            MMI_HANDLE_T form1                      = MMK_GetCtrlHandleByWin(win_id, MMIENG_FORM_NAME_ID);
            MMI_HANDLE_T form2                      = MMK_GetCtrlHandleByWin(win_id, MMIENG_FORM_ICON_ID);
            MMI_HANDLE_T form3                      = MMK_GetCtrlHandleByWin(win_id, MMIENG_FORM_PHONENUM_ID);
            GUIFORM_CHILD_HEIGHT_T height_info = {0};
            GUI_BG_T               display_bg = {0};
            GUIFORM_CHILD_HEIGHT_T form_height = {0};
            GUIFORM_CHILD_WIDTH_T form_width  = {0};

            display_bg.bg_type = GUI_BG_COLOR;
            display_bg.color   = MMI_WHITE_COLOR;

            //form
            GUIFORM_SetType(MMIENG_FORM_CTRL_ID, GUIFORM_TYPE_TP);
            GUIFORM_SetBg(MMIENG_FORM_CTRL_ID,&display_bg);
            GUIFORM_PermitChildFont(form_ctrl,FALSE);

            //set unit
            GUIFORM_SetStyle(MMIENG_FORM_NAME_ID,GUIFORM_STYLE_UNIT);
            GUIFORM_SetStyle(MMIENG_FORM_ICON_ID,GUIFORM_STYLE_UNIT);
            GUIFORM_SetStyle(MMIENG_FORM_PHONENUM_ID,GUIFORM_STYLE_UNIT);
            //height value
            form_height.type = GUIFORM_CHILD_HEIGHT_FIXED;
            form_height.add_data = 70;
            //width value
            form_width.type = GUIFORM_CHILD_WIDTH_PERCENT;
            form_width.add_data = 65;
            //set height
            GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID,MMIENG_FORM_NAME_ID,&form_height);
            GUIFORM_SetChildHeight(MMIENG_FORM_NAME_ID,MMIENG_COMMON_LABEL_CTRL1_ID,&form_height);
            GUIFORM_SetChildHeight(MMIENG_FORM_NAME_ID,MMIENG_COMMON_LIST_CTRL1_ID,&form_height);
            CTRLFORM_SetChildWidth(form1,drop_list_name_ctrl,&form_width);

            GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID,MMIENG_FORM_ICON_ID,&form_height);
            GUIFORM_SetChildHeight(MMIENG_FORM_ICON_ID,MMIENG_COMMON_LABEL_CTRL2_ID,&form_height);
            GUIFORM_SetChildHeight(MMIENG_FORM_ICON_ID,MMIENG_DROP_LIST_ICON_ID,&form_height);
            CTRLFORM_SetChildWidth(form2,drop_list_icon_ctrl,&form_width);

            GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID,MMIENG_FORM_PHONENUM_ID,&form_height);
            GUIFORM_SetChildHeight(MMIENG_FORM_PHONENUM_ID,MMIENG_COMMON_LABEL_CTRL3_ID,&form_height);
            GUIFORM_SetChildHeight(MMIENG_FORM_PHONENUM_ID,MMIENG_COMMON_EDIT_CTRL3_ID,&form_height);
            CTRLFORM_SetChildWidth(form3,MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_EDIT_CTRL3_ID),&form_width);

            str = "Name";
            text.wstr_len = strlen(str);
            text.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, 5, (uint8*)str, text.wstr_len, text.wstr_len );
            GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL1_ID, &text, TRUE);

            height_info.type = GUIFORM_CHILD_HEIGHT_AUTO;
            GUIFORM_SetChildHeight(form_ctrl, drop_list_name_ctrl, &height_info);
            GUIDROPDOWNLIST_SetVisible(drop_list_name_ctrl,TRUE,TRUE);
            GUIDROPDOWNLIST_SetMaxItem(drop_list_name_ctrl,MMIENG_PB_LIST_MAX_NUM);
            for(i=0;i<ARR_SIZE(droplist_name_id);i++)
            {
                GUIDROPDOWNLIST_AppendItemById(drop_list_name_ctrl,droplist_name_id[i]);
            }
            GUIDROPDOWNLIST_SetCurItemIndex(drop_list_name_ctrl,0);

            //icon id
            GUIFORM_SetChildHeight(form_ctrl, drop_list_icon_ctrl, &height_info);

            str = "ImageID";
            text.wstr_len = strlen(str);
            text.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, 8, (uint8*)str, text.wstr_len, text.wstr_len );
            GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL2_ID, &text, FALSE);
            GUIDROPDOWNLIST_SetMaxItem(drop_list_icon_ctrl,MMIENG_PB_LIST_MAX_NUM);
            for(i=0;i<ARR_SIZE(droplist_imageid);i++)
            {
                GUIDROPDOWNLIST_AppendItemById(drop_list_icon_ctrl,droplist_imageid[i]);
            }
            GUIDROPDOWNLIST_SetCurItemIndex(drop_list_icon_ctrl,0);

            //phone number
            str = "Number";
            text.wstr_len = strlen(str);
            text.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, 7, (uint8*)str, text.wstr_len, text.wstr_len );
            GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL3_ID, &text, FALSE);
            GUIEDIT_SetStyle(MMIENG_COMMON_EDIT_CTRL3_ID, GUIEDIT_STYLE_SINGLE);
#ifdef SCREEN_SHAPE_CIRCULAR
            GUIEDIT_SetIm( MMIENG_COMMON_EDIT_CTRL3_ID, GUIIM_TYPE_SYS, GUIIM_TYPE_SYS );
#endif
            MMK_SetAtvCtrl(win_id,ctrl_id);
        }
            break;
#ifdef TOUCH_PANEL_SUPPORT
        case MSG_CTL_PENOK:
#endif
        case MSG_APP_WEB:
        case MSG_CTL_MIDSK:
        case MSG_APP_MENU:
        case MSG_CTL_OK:
        {
            uint16 name_index = 0;
            uint16 image_index = 0;
            MMI_STRING_T name = {0};
            MMI_STRING_T phone_num = {0};
            char str_phone_num[MMIPB_BCD_NUMBER_MAX_LEN+1] = {0};//fixbug:1340385

            MMIPB_ERROR_E  add_ret = MMIPB_ERROR_SUCCESS;

            name_index = GUIDROPDOWNLIST_GetCurItemIndex(MMIENG_COMMON_LIST_CTRL1_ID);
            image_index = GUIDROPDOWNLIST_GetCurItemIndex(MMIENG_DROP_LIST_ICON_ID);
            if((0 <= name_index) && (MMIENG_PB_LIST_MAX_NUM > name_index))
            {
                MMI_GetLabelTextByLang(droplist_name_id[name_index],&name); //get name string
            }
            GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL3_ID,&phone_num); //get phone number
            if (0 < MMIAPICOM_Wstrlen(phone_num.wstr_ptr))
            {
                if (TRUE == IsSCAddrValid(&phone_num))
                {
                    MMI_WSTRNTOSTR((uint8 *)str_phone_num,
                                    20,
                                    phone_num.wstr_ptr,
                                    20,
                                    phone_num.wstr_len
                                    );          
                    add_ret = MMIENG_AddContact(&name,name_index,(uint8)image_index,str_phone_num,strlen(str_phone_num));//fix bug1640487
                    if(MMIPB_ERROR_SUCCESS == add_ret)
                    {
                        MMIPUB_OpenAlertWarningWin(TXT_COMM_SAVE_SUCCESS);
                        MMK_CloseWin(win_id);
                    }else
                    {
                         MMIPUB_OpenAlertWarningWin(TXT_MMI_SAVEFAILED);
                    }

                }
                else
                {
                    //提示输入错误
                    MMIPUB_OpenAlertWarningWin(TXT_CC_INVALID_NUM);
                }
            }else
            {
                MMIPUB_OpenAlertWarningWin(TXT_COMM_INPUT_NULL);
            }
        }
            break;
        case MSG_CTL_CANCEL:
            MMK_CloseWin(win_id);
            break;
        default:
            ret_value = MMI_RESULT_FALSE;
            break;
    }
    return ret_value;
}
PUBLIC void MMIENG_AddContactTest(void)
{
    MMK_CreateWin((uint32*)MMIENG_ADD_CONTACT_WIN_TAB, PNULL);
}

//wifi begin
#ifdef MMI_WIFI_SUPPORT
#define TX_RATE_NUM        (20)
#define TX_PREAMBLE_NUM    (3)
#define TX_MODE_NUM        (2)
#define TX_GUARD_INTERVAL  (2)
#define RX_STANDARD_NUM    (3)
#define RX_CHANNEL_NUM     (14)
#define TX_RX_CMD_RET_SIZE (128)   //  TODO: WLNPI_RESULT_BUF_LEN  Bug 1342242
MMI_TEXT_ID_T  RX_standard_id[RX_STANDARD_NUM] = {TXT_ENG_802B,TXT_ENG_G,TXT_ENG_24G};
MMI_TEXT_ID_T  RX_channel_id[RX_CHANNEL_NUM]   = {TXT_ENG_CHANNEL1,TXT_ENG_CHANNEL2,TXT_ENG_CHANNEL3,TXT_ENG_CHANNEL4,TXT_ENG_CHANNEL5,TXT_ENG_CHANNEL6,TXT_ENG_CHANNEL7,
                                                  TXT_ENG_CHANNEL8,TXT_ENG_CHANNEL9,TXT_ENG_CHANNEL10,TXT_ENG_CHANNEL11,TXT_ENG_CHANNEL12,TXT_ENG_CHANNEL13,TXT_ENG_CHANNEL1};
MMI_TEXT_ID_T  TX_rate_id[TX_RATE_NUM]         = {TXT_ENG_RATE1M,TXT_ENG_RATE2M,TXT_ENG_RATE5M,TXT_ENG_RATE11M,TXT_ENG_RATE6M,TXT_ENG_RATE9M,TXT_ENG_RATE12M,TXT_ENG_RATE18M,TXT_ENG_RATE24M,
                                                    TXT_ENG_RATE36M,TXT_ENG_RATE48M,TXT_ENG_RATE54M,TXT_ENG_RATEMCS0,TXT_ENG_RATEMCS1,
                                                    TXT_ENG_RATEMCS2,TXT_ENG_RATEMCS3,TXT_ENG_RATEMCS4,TXT_ENG_RATEMCS5,TXT_ENG_RATEMCS6,TXT_ENG_RATEMCS7};
MMI_TEXT_ID_T  TX_preamble_id[TX_PREAMBLE_NUM] = {TXT_ENG_PREAMBLE_NORMAL,TXT_ENG_PREAMBLE_CCK,TXT_ENG_PREAMBLE_MIX};
MMI_TEXT_ID_T  TX_mode_id[TX_MODE_NUM]         = {TXT_ENG_MODE_PKT,TXT_ENG_MODE_WAVE};
MMI_TEXT_ID_T  TX_guard_id[TX_GUARD_INTERVAL]  = {TXT_ENG_GUARD_INTERVAL_400,TXT_ENG_GUARD_INTERVAL_800};


LOCAL void InitWifiRXParam(uint32 win_id)
{
    MMI_HANDLE_T form_ctrl                  = MMK_GetCtrlHandleByWin(win_id, MMIENG_FORM_CTRL_ID);

    MMI_HANDLE_T form1                      = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_NUM_FORM_CTRL_ID);
    MMI_HANDLE_T form2                      = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_STANDARD_FORM_CTRL_ID);
    MMI_HANDLE_T form3                      = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_CHANNEL_FORM_CTRL_ID);
    MMI_HANDLE_T form4                      = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_RXOK_FORM_CTRL_ID);
    MMI_HANDLE_T form5                      = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_PER_FORM_CTRL_ID);

    MMI_HANDLE_T drop_list_standard_ctrl    = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_STANDARD_DROP_CTRL_ID);
    MMI_HANDLE_T drop_list_channel_ctrl     = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_CHANNEL_DROP_CTRL_ID);

    GUIFORM_CHILD_HEIGHT_T height_info = {0};
    GUI_BG_T               display_bg  = {0};
    GUIFORM_CHILD_HEIGHT_T form_height = {0};
    GUI_BORDER_T           droplist_border = {0};
    GUIFORM_CHILD_WIDTH_T  form_width  = {0};

    uint8 *str         = PNULL;
    wchar wstr[20]    = {0};
    uint8 i           = 0;
    MMI_STRING_T text = {0};

    display_bg.bg_type = GUI_BG_COLOR;
    display_bg.color   = MMI_WHITE_COLOR;

    //form
    GUIFORM_SetType(MMIENG_FORM_CTRL_ID, GUIFORM_TYPE_TP);
    GUIFORM_SetDividingLine(form_ctrl,1,MMI_BLACK_COLOR);
    GUIFORM_SetBg(MMIENG_FORM_CTRL_ID,&display_bg);
    GUIFORM_PermitChildFont(form_ctrl,FALSE);
    GUIFORM_PermitChildBorder(form_ctrl,FALSE);

    //set unit
    GUIFORM_SetStyle(MMIENG_WIFI_NUM_FORM_CTRL_ID,GUIFORM_STYLE_UNIT);
    GUIFORM_SetStyle(MMIENG_WIFI_STANDARD_FORM_CTRL_ID,GUIFORM_STYLE_UNIT);
    GUIFORM_SetStyle(MMIENG_WIFI_CHANNEL_FORM_CTRL_ID,GUIFORM_STYLE_UNIT);
    GUIFORM_SetStyle(MMIENG_WIFI_RXOK_FORM_CTRL_ID,GUIFORM_STYLE_UNIT);
    GUIFORM_SetStyle(MMIENG_WIFI_PER_FORM_CTRL_ID,GUIFORM_STYLE_UNIT);

    height_info.type     = GUIFORM_CHILD_HEIGHT_FIXED;
    height_info.add_data = MMIENG_MENU_ITEM_HEIGHT;
    form_height.type     = GUIFORM_CHILD_HEIGHT_PERCENT;
    form_height.add_data = 100;
    form_width.type      = GUIFORM_CHILD_WIDTH_PERCENT;
    form_width.add_data  = 65;

    droplist_border.color = MMI_BLACK_COLOR;
    droplist_border.width = 1;
    droplist_border.type = GUI_BORDER_ROUNDED;

    //RX Num
    GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID,MMIENG_WIFI_NUM_FORM_CTRL_ID,&height_info);
    GUIFORM_SetChildHeight(MMIENG_WIFI_NUM_FORM_CTRL_ID,MMIENG_COMMON_LABEL_CTRL1_ID,&form_height);
    GUIFORM_SetChildHeight(MMIENG_WIFI_NUM_FORM_CTRL_ID,MMIENG_COMMON_EDIT_CTRL1_ID,&form_height);
    GUIEDIT_SetBorder(MMIENG_COMMON_EDIT_CTRL1_ID,&droplist_border);
    GUIFORM_SetChildWidth(form1,MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_EDIT_CTRL1_ID),&form_width);
    //RF standard
    GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID,MMIENG_WIFI_STANDARD_FORM_CTRL_ID,&height_info);
    GUIFORM_SetChildHeight(MMIENG_WIFI_STANDARD_FORM_CTRL_ID,MMIENG_COMMON_LABEL_CTRL2_ID,&form_height);
    GUIFORM_SetChildHeight(MMIENG_WIFI_STANDARD_FORM_CTRL_ID,MMIENG_WIFI_STANDARD_DROP_CTRL_ID,&form_height);
    CTRLFORM_SetChildWidth(form2,drop_list_standard_ctrl,&form_width);
    //channel
    GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID,MMIENG_WIFI_CHANNEL_FORM_CTRL_ID,&height_info);
    GUIFORM_SetChildHeight(MMIENG_WIFI_CHANNEL_FORM_CTRL_ID,MMIENG_COMMON_LABEL_CTRL3_ID,&form_height);
    GUIFORM_SetChildHeight(MMIENG_WIFI_CHANNEL_FORM_CTRL_ID,MMIENG_WIFI_CHANNEL_DROP_CTRL_ID,&form_height);
    CTRLFORM_SetChildWidth(form3,drop_list_channel_ctrl,&form_width);
    //RXOK
    GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID,MMIENG_WIFI_RXOK_FORM_CTRL_ID,&height_info);
    GUIFORM_SetChildHeight(MMIENG_WIFI_RXOK_FORM_CTRL_ID,MMIENG_COMMON_LABEL_CTRL4_ID,&form_height);
    GUIFORM_SetChildHeight(MMIENG_WIFI_RXOK_FORM_CTRL_ID,MMIENG_COMMON_LABEL_CTRL5_ID,&form_height);
    CTRLFORM_SetChildWidth(form4,MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_LABEL_CTRL5_ID),&form_width);
    //PER
    GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID,MMIENG_WIFI_PER_FORM_CTRL_ID,&height_info);
    GUIFORM_SetChildHeight(MMIENG_WIFI_PER_FORM_CTRL_ID,MMIENG_COMMON_LABEL_CTRL6_ID,&form_height);
    GUIFORM_SetChildHeight(MMIENG_WIFI_PER_FORM_CTRL_ID,MMIENG_COMMON_LABEL_CTRL7_ID,&form_height);
    CTRLFORM_SetChildWidth(form4,MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_LABEL_CTRL7_ID),&form_width);

    str = "RX Num";
    text.wstr_len = strlen(str);
    text.wstr_ptr = wstr;
    MMI_STRNTOWSTR( wstr, 6, (uint8*)str, text.wstr_len, text.wstr_len );
    GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL1_ID, &text, TRUE);
    GUIEDIT_SetStyle(MMIENG_COMMON_EDIT_CTRL1_ID, GUIEDIT_STYLE_SINGLE);

    str = "RF\nStd";
    MMI_STRNTOWSTR( wstr, 11, (uint8*)str, strlen(str), strlen(str) );
    GUITEXT_SetString(MMIENG_COMMON_LABEL_CTRL2_ID, wstr,strlen(str), FALSE);

    height_info.type = GUIFORM_CHILD_HEIGHT_AUTO;
    GUIFORM_SetChildHeight(form2, drop_list_standard_ctrl, &height_info);
    GUIDROPDOWNLIST_SetBorder(drop_list_standard_ctrl,&droplist_border);
    GUIDROPDOWNLIST_SetVisible(drop_list_standard_ctrl,TRUE,TRUE);
    GUIDROPDOWNLIST_SetMaxItem(drop_list_standard_ctrl,RX_STANDARD_NUM);

    for(i=0;i<ARR_SIZE(RX_standard_id);i++)
    {
        GUIDROPDOWNLIST_AppendItemById(MMIENG_WIFI_STANDARD_DROP_CTRL_ID,RX_standard_id[i]);
    }
    GUIDROPDOWNLIST_SetCurItemIndex(MMIENG_WIFI_STANDARD_DROP_CTRL_ID,0);

    //channel
    str = "Channel";
    text.wstr_len = strlen(str);
    text.wstr_ptr = wstr;
    MMI_STRNTOWSTR( wstr, 7, (uint8*)str, text.wstr_len, text.wstr_len );
    GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL3_ID, &text, FALSE);
    GUIFORM_SetChildHeight(form3, drop_list_channel_ctrl, &height_info);
    GUIDROPDOWNLIST_SetBorder(drop_list_channel_ctrl,&droplist_border);
    GUIDROPDOWNLIST_SetVisible(drop_list_channel_ctrl,TRUE,TRUE);
    GUIDROPDOWNLIST_SetMaxItem(drop_list_channel_ctrl,RX_CHANNEL_NUM);
    for(i=0;i<ARR_SIZE(RX_channel_id);i++)
    {
        GUIDROPDOWNLIST_AppendItemById(MMIENG_WIFI_CHANNEL_DROP_CTRL_ID,RX_channel_id[i]);
    }
    GUIDROPDOWNLIST_SetCurItemIndex(MMIENG_WIFI_CHANNEL_DROP_CTRL_ID,0);

    //PER OK
    str = "PER OK";
    text.wstr_len = strlen(str);
    text.wstr_ptr = wstr;
    MMI_STRNTOWSTR( wstr, 6, (uint8*)str, text.wstr_len, text.wstr_len );
    GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL4_ID, &text, FALSE);

    //PER
    str = "PER";
    text.wstr_len = strlen(str);
    text.wstr_ptr = wstr;
    MMI_STRNTOWSTR( wstr, 3, (uint8*)str, text.wstr_len, text.wstr_len );
    GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL6_ID, &text, FALSE);

}

LOCAL void InitWifiPKItemParam(uint32 win_id)
{
    MMI_HANDLE_T form_ctrl                  = MMK_GetCtrlHandleByWin(win_id, MMIENG_FORM_CTRL_ID);

    GUIFORM_CHILD_HEIGHT_T height_info = {0};
    GUI_BG_T               display_bg  = {0};
    GUIFORM_CHILD_HEIGHT_T form_height = {0};
    GUI_BORDER_T           droplist_border = {0};
    GUIFORM_CHILD_WIDTH_T  form_width  = {0};

    uint8 *str         = PNULL;
    wchar wstr[20]    = {0};
    uint8 i           = 0;
    MMI_STRING_T text = {0};

    display_bg.bg_type = GUI_BG_COLOR;
    display_bg.color   = MMI_WHITE_COLOR;

    GUIFORM_SetType(MMIENG_FORM_CTRL_ID, GUIFORM_TYPE_TP);
    GUIFORM_SetDividingLine(form_ctrl,1,MMI_BLACK_COLOR);
    GUIFORM_SetBg(MMIENG_FORM_CTRL_ID,&display_bg);
    GUIFORM_PermitChildFont(form_ctrl,FALSE);
    GUIFORM_PermitChildBorder(form_ctrl,FALSE);

    height_info.type     = GUIFORM_CHILD_HEIGHT_FIXED;
    height_info.add_data = MMIENG_MENU_ITEM_HEIGHT;
    form_height.type     = GUIFORM_CHILD_HEIGHT_PERCENT;
    form_height.add_data = 100;
    form_width.type      = GUIFORM_CHILD_WIDTH_PERCENT;
    form_width.add_data  = 65;

    droplist_border.color = MMI_BLACK_COLOR;
    droplist_border.width = 1;
    droplist_border.type = GUI_BORDER_ROUNDED;

    GUIFORM_SetChildHeight(MMIENG_WIFI_NUM_FORM_CTRL_ID,MMIENG_COMMON_LABEL_CTRL1_ID,&form_height);
    GUIFORM_SetChildHeight(MMIENG_WIFI_NUM_FORM_CTRL_ID,MMIENG_COMMON_EDIT_CTRL1_ID,&form_height);
    GUIEDIT_SetBorder(MMIENG_COMMON_EDIT_CTRL1_ID,&droplist_border);
    GUIFORM_SetChildWidth(form_ctrl,MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_EDIT_CTRL1_ID),&form_width);

    str = "  T-value";
    text.wstr_len = strlen(str);
    text.wstr_ptr = wstr;
    MMI_STRNTOWSTR( wstr, 9, (uint8*)str, text.wstr_len, text.wstr_len );
    GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL1_ID, &text, TRUE);
    GUIEDIT_SetStyle(MMIENG_COMMON_EDIT_CTRL1_ID, GUIEDIT_STYLE_SINGLE);
}

LOCAL void Wifi_ExcuteModeCmd(BOOLEAN is_enter)
{
    uint8         cmd_ret[TX_RX_CMD_RET_SIZE+1] = {0};
    int           value_ret    = 0;
    char        *pArgvEnterMode[3] = {"iwnpi","wlan0","enter_mode"};
    char        *pArgvExitMode[3]  = {"iwnpi","wlan0","exit_mode"};
    if(TRUE == is_enter)
    {
#ifndef WIN32
        value_ret = iwnpi_cmd_handler(3,pArgvEnterMode,cmd_ret);
        SCI_TRACE_LOW("TX tx_stop value_ret= %d",value_ret);
#endif
    }else
    {
#ifndef WIN32
        value_ret = iwnpi_cmd_handler(3,pArgvExitMode,cmd_ret);
        SCI_TRACE_LOW("TX tx_stop value_ret= %d",value_ret);
#endif
    }
}
LOCAL void Wifi_TxStopCmd(void)
{

    uint8         stop_ret[TX_RX_CMD_RET_SIZE+1] = {0};
    int           value_ret    = 0;
    char        *pArgvStop[3]  = {"iwnpi","wlan0","tx_stop"};

    //stop cmd
#ifndef WIN32    
    value_ret = iwnpi_cmd_handler(3,pArgvStop,stop_ret);
    SCI_TRACE_LOW("TX tx_stop value_ret= %d",value_ret);
#endif
}
LOCAL void Wifi_TxStartCmd(void)
{
    MMI_STRING_T tx_text    = {0};
    uint8        tx_char[15] = {0};
    uint8        tx_ret[TX_RX_CMD_RET_SIZE+1] = {0};
    char         rate_value[3] = {0};

    uint16       rx_std_index  = 0;
    uint16       rx_test_num   = 0;
    uint16       rate_index    = 0;
    uint16       pream_index   = 0;
    uint16       guard_interval_index  = 0;

    uint16       channel_index = 0;
    uint16       mode_index      = 0;

    int          value_ret  = 0;

    uint8 i = 0;

    char *pArgvLen_Input[4] = {0};
    char *pArgvCnt_Input[4] = {0};
    char *pArgvPowerLevel_Input[4] = {0};
    char *pArgvChannel_Input[4] = {0};
    char *pArgvRate_Input[4] = {0};

    char pArgvLen[4][15] = {"iwnpi","wlan0","set_pkt_len","5"};
    char pArgvCnt[4][15] = {"iwnpi","wlan0","set_tx_count","5"};
    char pArgvPowerLevel[4][15] = {"iwnpi","wlan0","set_tx_power","5"};
    char pArgvChannel[4][15] = {"iwnpi","wlan0","set_channel","1"};
    char pArgvRate[4][15] = {"iwnpi","wlan0","set_rate","5"};

    char *pArgvStart[3] = {"iwnpi","wlan0","tx_start"};

    //pkt len
    SCI_MEMSET(&tx_text,0,sizeof(MMI_STRING_T));
    GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL1_ID, &tx_text);

    SCI_MEMSET(tx_char,0,15);
    MMI_WSTRNTOSTR((uint8*)tx_char, 15, tx_text.wstr_ptr, 15,5);
    SCI_MEMCPY(pArgvLen[3],tx_char,strlen(tx_char));

    for (i = 0; i < 4; i++)
    {
        pArgvLen_Input[i] = pArgvLen[i];
    }

#ifndef WIN32
    SCI_TRACE_LOW("lcj TX pkt len enteri wnpi_cmd_handler");
    value_ret = iwnpi_cmd_handler(4,pArgvLen_Input,tx_ret);
    SCI_TRACE_LOW("TX pkt len value_ret = %d",value_ret);
#endif
    //pkt cnt
    SCI_MEMSET(&tx_text,0,sizeof(MMI_STRING_T));
    GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL2_ID, &tx_text);
    SCI_MEMSET(tx_char,0,15);
    MMI_WSTRNTOSTR((uint8*)tx_char, 15, tx_text.wstr_ptr,15,5);
    SCI_MEMCPY(pArgvCnt[3],tx_char,strlen(tx_char));
    for (i = 0; i < 4; i++)
    {
        pArgvCnt_Input[i] = pArgvCnt[i];
    }
#ifndef WIN32
    SCI_MEMSET(tx_ret,0,TX_RX_CMD_RET_SIZE);
    value_ret = iwnpi_cmd_handler(4,pArgvCnt_Input,tx_ret);
    SCI_TRACE_LOW("TX pkt cnt value_ret = %d",value_ret);
#endif
    //power level
    SCI_MEMSET(&tx_text,0,sizeof(MMI_STRING_T));
    GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL3_ID, &tx_text);
    SCI_MEMSET(tx_char,0,15);
    MMI_WSTRNTOSTR((uint8*)tx_char, 15, tx_text.wstr_ptr,15,5);
    SCI_MEMCPY(pArgvPowerLevel[3],tx_char,strlen(tx_char));
    for (i = 0; i < 4; i++)
    {
        pArgvPowerLevel_Input[i] = pArgvPowerLevel[i];
    }
#ifndef WIN32
    SCI_MEMSET(tx_ret,0,TX_RX_CMD_RET_SIZE);
    value_ret = iwnpi_cmd_handler(4,pArgvPowerLevel_Input,tx_ret);
    SCI_TRACE_LOW("TX set_tx_power value_ret= %d",value_ret);
#endif
    //tx channel
    channel_index = GUIDROPDOWNLIST_GetCurItemIndex(MMIENG_WIFI_CHANNEL_DROP_CTRL_ID);
    MMIENG_Int2Str((channel_index + 1),tx_char,3);
    SCI_MEMCPY(pArgvChannel[3],tx_char,strlen(tx_char));
    for (i = 0; i < 4; i++)
    {
        pArgvChannel_Input[i] = pArgvChannel[i];
    }
#ifndef WIN32
    SCI_MEMSET(tx_ret,0,TX_RX_CMD_RET_SIZE);
    value_ret = iwnpi_cmd_handler(4,pArgvChannel_Input,tx_ret);
    SCI_TRACE_LOW("TX set_channelvalue_ret= %d",value_ret);
#endif
    //tx set rate 
    rate_index = GUIDROPDOWNLIST_GetCurItemIndex(MMIENG_WIFI_RATE_DROP_CTRL_ID);
    switch(rate_index)
    {
        case 0:
            sprintf(rate_value,"%d",1);// 1Mbps
            break;
         case 1:
            sprintf(rate_value,"%d",2);// 2Mbps
            break;
        case 2:
            sprintf(rate_value,"%d",5);// 5.5Mbps 
            break;
        case 3:
            sprintf(rate_value,"%d",11);// 11Mbps
            break;
        case 4:
            sprintf(rate_value,"%d",6);;// 6Mbps
            break;
        case 5:
            sprintf(rate_value,"%d",9);// 9Mbps
            break;
        case 6:
            sprintf(rate_value,"%d",12);;// 12Mbps
            break;
        case 7:
            sprintf(rate_value,"%d",18);// 18Mbps
            break;
        case 8:
            sprintf(rate_value,"%d",24);// 24Mbps
            break;
        case 9:
            sprintf(rate_value,"%d",36);// 36Mbps
            break;
        case 10:
            sprintf(rate_value,"%d",48);// 48Mbps
            break;
        case 11:
            sprintf(rate_value,"%d",54);// 54Mbps
            break;
        case 12:
            sprintf(rate_value,"%d",7);;// MCS 0
            break;
        case 13:
            sprintf(rate_value,"%d",13);// MCS 1
            break;
        case 14:
            sprintf(rate_value,"%d",19);// MCS 2
            break;
        case 15:
            sprintf(rate_value,"%d",26);//// MCS 3
            break;
        case 16:
            sprintf(rate_value,"%d",39);// MCS 4
            break;
        case 17:
            sprintf(rate_value,"%d",52);// MCS 5
            break;
        case 18:
            sprintf(rate_value,"%d",58);// MCS 6
            break;
        case 19:
            sprintf(rate_value,"%d",65);// MCS 7
            break; 
        default:
            break;
    }
    SCI_MEMCPY(pArgvRate[3],rate_value,strlen(rate_value));
    for (i = 0; i < 4; i++)
    {
        pArgvRate_Input[i] = pArgvRate[i];
    }
#ifndef WIN32
    SCI_MEMSET(tx_ret,0,TX_RX_CMD_RET_SIZE);
    value_ret = iwnpi_cmd_handler(4,pArgvRate_Input,tx_ret);
    SCI_TRACE_LOW("TX set_rate value_ret= %d",value_ret);
#endif
#if 0
    //tx set mode
    // TODO: mode = NUM?
    mode_index = GUIDROPDOWNLIST_GetCurItemIndex(MMIENG_WIFI_MODE_DROP_CTRL_ID);
    if(0 == mode_index)
    {
        MMI_GetLabelTextByLang(TXT_ENG_MODE_PKT,&tx_mode_text);
        MMI_WSTRNTOSTR(mode_value, 5, tx_mode_text.wstr_ptr, 5, tx_mode_text.wstr_len);
    }else if(1 == mode_index)
    {
        MMI_GetLabelTextByLang(TXT_ENG_MODE_WAVE,&tx_mode_text);
        MMI_WSTRNTOSTR(mode_value, 5, tx_mode_text.wstr_ptr, 5, tx_mode_text.wstr_len);
    
    }
    str_cmd = "set_tx_mode";
    SCI_MEMCPY(pArgvMode[0],npi,strlen(npi));
    SCI_MEMCPY(pArgvMode[1],wlan0,strlen(wlan0));
    SCI_MEMCPY(pArgvMode[2],str_cmd,strlen(str_cmd));
    SCI_MEMCPY(pArgvMode[3],mode_value,strlen(mode_value));
#ifndef WIN32
    iwnpi_cmd_handler(4,pArgvRate,tx_mode_ret);
    SCI_TRACE_LOW("TX set_mode = %s",tx_mode_ret,20);
#endif
    //set preambel
    // TODO: preamble =NUM?
    pream_index = GUIDROPDOWNLIST_GetCurItemIndex(MMIENG_WIFI_PREAM_DROP_CTRL_ID);
    if(0 == pream_index)
    {
        MMI_GetLabelTextByLang(TXT_ENG_PREAMBLE_NORMAL,&tx_pream_text);
        MMI_WSTRNTOSTR(pream_value, 10, tx_pream_text.wstr_ptr, 10, tx_pream_text.wstr_len);
    }else if(1 == pream_index)
    {
        MMI_GetLabelTextByLang(TXT_ENG_PREAMBLE_CCK,&tx_rate_text);
        MMI_WSTRNTOSTR(pream_value, 10, tx_pream_text.wstr_ptr, 10, tx_pream_text.wstr_len);

    }else
    {
        MMI_GetLabelTextByLang(TXT_ENG_PREAMBLE_MIX,&tx_rate_text);
        MMI_WSTRNTOSTR(pream_value, 10, tx_pream_text.wstr_ptr, 10, tx_pream_text.wstr_len);
    }
    str_cmd = "set_preamble";
    SCI_MEMCPY(pArgvPreamble[0],npi,strlen(npi));
    SCI_MEMCPY(pArgvPreamble[1],wlan0,strlen(wlan0));
    SCI_MEMCPY(pArgvPreamble[2],str_cmd,strlen(str_cmd));
    SCI_MEMCPY(pArgvPreamble[3],pream_value,strlen(pream_value));
#ifndef WIN32
    iwnpi_cmd_handler(4,pArgvPreamble,tx_pream_ret);
    SCI_TRACE_LOW("TX set_preamble = %s",tx_pream_ret,20);
#endif
    //set guard interval
    guard_interval_index = GUIDROPDOWNLIST_GetCurItemIndex(MMIENG_WIFI_GUARD_DROP_CTRL_ID);
    if(0 == guard_interval_index)
    {
        MMI_GetLabelTextByLang(TXT_ENG_GUARD_INTERVAL_400,&tx_guard_interval_text);
        MMI_WSTRNTOSTR(guard_interval_value, 10, tx_guard_interval_text.wstr_ptr, 10, tx_guard_interval_text.wstr_len);
    }else
    {
        MMI_GetLabelTextByLang(TXT_ENG_GUARD_INTERVAL_800,&tx_rate_text);
        MMI_WSTRNTOSTR(guard_interval_value, 10, tx_guard_interval_text.wstr_ptr, 10, tx_guard_interval_text.wstr_len);
    }
    str_cmd = "set_gi";
    SCI_MEMCPY(pArgvPreamble[0],npi,strlen(npi));
    SCI_MEMCPY(pArgvPreamble[1],wlan0,strlen(wlan0));
    SCI_MEMCPY(pArgvPreamble[2],str_cmd,strlen(str_cmd));
    SCI_MEMCPY(pArgvPreamble[3],pream_value,strlen(pream_value));
#ifndef WIN32
    iwnpi_cmd_handler(4,pArgvPreamble,tx_pream_ret);
    SCI_TRACE_LOW("TX set_gi = %s",tx_pream_ret,20);
#endif
#endif

#ifndef WIN32
    SCI_MEMSET(tx_ret,0,TX_RX_CMD_RET_SIZE);
    value_ret = iwnpi_cmd_handler(3,pArgvStart,tx_ret);
    SCI_TRACE_LOW("TX tx_start value_ret= %d",value_ret);
#endif
}
LOCAL void InitWifiTXParam(uint32 win_id)
{
    MMI_HANDLE_T form_ctrl                  = MMK_GetCtrlHandleByWin(win_id, MMIENG_FORM_CTRL_ID);

    MMI_HANDLE_T form1                      = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_LEN_FORM_CTRL_ID);
    MMI_HANDLE_T form2                      = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_CNT_FORM_CTRL_ID);
    MMI_HANDLE_T form3                      = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_LEVEL_FORM_CTRL_ID);
    MMI_HANDLE_T form4                      = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_STANDARD_FORM_CTRL_ID);
    MMI_HANDLE_T form5                      = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_CHANNEL_FROM_CTRL_ID);
    MMI_HANDLE_T form6                      = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_RATE_FROM_CTRL_ID);
    MMI_HANDLE_T form7                      = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_PREAM_FROM_CTRL_ID);
    MMI_HANDLE_T form8                      = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_MODE_FROM_CTRL_ID);
    MMI_HANDLE_T form9                      = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_GUARD_FROM_CTRL_ID);

    MMI_HANDLE_T drop_list_standard_ctrl    = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_STANDARD_DROP_CTRL_ID);
    MMI_HANDLE_T drop_list_channel_ctrl     = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_CHANNEL_DROP_CTRL_ID);
    MMI_HANDLE_T drop_list_rate_ctrl        = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_RATE_DROP_CTRL_ID);
    MMI_HANDLE_T drop_list_preamble_ctrl    = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_PREAM_DROP_CTRL_ID);
    MMI_HANDLE_T drop_list_mode_ctrl        = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_MODE_DROP_CTRL_ID);
    MMI_HANDLE_T drop_list_guardinterval_ctrl  = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_GUARD_DROP_CTRL_ID);

    GUIFORM_CHILD_HEIGHT_T height_info     = {0};
    GUI_BG_T               display_bg      = {0};
    GUIFORM_CHILD_HEIGHT_T form_height     = {0};
    GUI_BORDER_T           droplist_border = {0};
    GUIFORM_CHILD_WIDTH_T  form_width      = {0};
    GUI_BORDER_T           border          = {1,MMI_BLACK_COLOR,GUI_BORDER_ROUNDED};

    uint8 *str        = PNULL;
    wchar wstr[20]    = {0};
    uint8 i           = 0;
    MMI_STRING_T text = {0};

    display_bg.bg_type = GUI_BG_COLOR;
    display_bg.color   = MMI_WHITE_COLOR;

    //form
    GUIFORM_SetType(MMIENG_FORM_CTRL_ID, GUIFORM_TYPE_TP);
    GUIFORM_SetDividingLine(form_ctrl,1,MMI_BLACK_COLOR);
    GUIFORM_SetBg(MMIENG_FORM_CTRL_ID,&display_bg);
    GUIFORM_PermitChildFont(form_ctrl,FALSE);
    GUIFORM_PermitChildBorder(form_ctrl,FALSE);

    //set unit
    GUIFORM_SetStyle(MMIENG_WIFI_LEN_FORM_CTRL_ID,GUIFORM_STYLE_UNIT);
    GUIFORM_SetStyle(MMIENG_WIFI_CNT_FORM_CTRL_ID,GUIFORM_STYLE_UNIT);
    GUIFORM_SetStyle(MMIENG_WIFI_LEVEL_FORM_CTRL_ID,GUIFORM_STYLE_UNIT);
    GUIFORM_SetStyle(MMIENG_WIFI_STANDARD_FORM_CTRL_ID,GUIFORM_STYLE_UNIT);
    GUIFORM_SetStyle(MMIENG_WIFI_CHANNEL_FROM_CTRL_ID,GUIFORM_STYLE_UNIT);
    GUIFORM_SetStyle(MMIENG_WIFI_RATE_FROM_CTRL_ID,GUIFORM_STYLE_UNIT);
    GUIFORM_SetStyle(MMIENG_WIFI_PREAM_FROM_CTRL_ID,GUIFORM_STYLE_UNIT);
    GUIFORM_SetStyle(MMIENG_WIFI_MODE_FROM_CTRL_ID,GUIFORM_STYLE_UNIT);
    GUIFORM_SetStyle(MMIENG_WIFI_GUARD_FROM_CTRL_ID,GUIFORM_STYLE_UNIT);

    height_info.type     = GUIFORM_CHILD_HEIGHT_FIXED;
    height_info.add_data = MMIENG_MENU_ITEM_HEIGHT;
    form_height.type     = GUIFORM_CHILD_HEIGHT_PERCENT;
    form_height.add_data = 100;
    form_width.type      = GUIFORM_CHILD_WIDTH_PERCENT;
    form_width.add_data  = 65;

    //Pkt len
    GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID,MMIENG_WIFI_LEN_FORM_CTRL_ID,&height_info);
    GUIFORM_SetChildHeight(MMIENG_WIFI_LEN_FORM_CTRL_ID,MMIENG_COMMON_LABEL_CTRL1_ID,&form_height);
    GUIFORM_SetChildHeight(MMIENG_WIFI_LEN_FORM_CTRL_ID,MMIENG_COMMON_EDIT_CTRL1_ID,&form_height);
    GUIFORM_SetChildWidth(form1,MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_EDIT_CTRL1_ID),&form_width);
    GUIEDIT_SetBorder(MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_EDIT_CTRL1_ID),&border);
    //Pkt cnt
    GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID,MMIENG_WIFI_CNT_FORM_CTRL_ID,&height_info);
    GUIFORM_SetChildHeight(MMIENG_WIFI_CNT_FORM_CTRL_ID,MMIENG_COMMON_LABEL_CTRL2_ID,&form_height);
    GUIFORM_SetChildHeight(MMIENG_WIFI_CNT_FORM_CTRL_ID,MMIENG_COMMON_EDIT_CTRL2_ID,&form_height);
    CTRLFORM_SetChildWidth(form2,MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_EDIT_CTRL2_ID),&form_width);
    GUIEDIT_SetBorder(MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_EDIT_CTRL2_ID),&border);
    //power level
    GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID,MMIENG_WIFI_LEVEL_FORM_CTRL_ID,&height_info);
    GUIFORM_SetChildHeight(MMIENG_WIFI_LEVEL_FORM_CTRL_ID,MMIENG_COMMON_LABEL_CTRL3_ID,&form_height);
    GUIFORM_SetChildHeight(MMIENG_WIFI_LEVEL_FORM_CTRL_ID,MMIENG_COMMON_EDIT_CTRL3_ID,&form_height);
    CTRLFORM_SetChildWidth(form3,MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_EDIT_CTRL3_ID),&form_width);
    GUIEDIT_SetBorder(MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_EDIT_CTRL3_ID),&border);
    //RF standard
    GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID,MMIENG_WIFI_STANDARD_FORM_CTRL_ID,&height_info);
    GUIFORM_SetChildHeight(MMIENG_WIFI_STANDARD_FORM_CTRL_ID,MMIENG_COMMON_LABEL_CTRL4_ID,&form_height);
    GUIFORM_SetChildHeight(MMIENG_WIFI_STANDARD_FORM_CTRL_ID,MMIENG_WIFI_STANDARD_DROP_CTRL_ID,&form_height);
    CTRLFORM_SetChildWidth(form4,drop_list_standard_ctrl,&form_width);
    //Channel
    GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID,MMIENG_WIFI_CHANNEL_FROM_CTRL_ID,&height_info);
    GUIFORM_SetChildHeight(MMIENG_WIFI_CHANNEL_FROM_CTRL_ID,MMIENG_COMMON_LABEL_CTRL5_ID,&form_height);
    GUIFORM_SetChildHeight(MMIENG_WIFI_CHANNEL_FROM_CTRL_ID,MMIENG_WIFI_CHANNEL_DROP_CTRL_ID,&form_height);
    CTRLFORM_SetChildWidth(form5,drop_list_channel_ctrl,&form_width);
    //Rate
    GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID,MMIENG_WIFI_RATE_FROM_CTRL_ID,&height_info);
    GUIFORM_SetChildHeight(MMIENG_WIFI_RATE_FROM_CTRL_ID,MMIENG_COMMON_LABEL_CTRL6_ID,&form_height);
    GUIFORM_SetChildHeight(MMIENG_WIFI_RATE_FROM_CTRL_ID,MMIENG_WIFI_RATE_DROP_CTRL_ID,&form_height);
    CTRLFORM_SetChildWidth(form6,drop_list_rate_ctrl,&form_width);
    //Preamble
    GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID,MMIENG_WIFI_PREAM_FROM_CTRL_ID,&height_info);
    GUIFORM_SetChildHeight(MMIENG_WIFI_PREAM_FROM_CTRL_ID,MMIENG_COMMON_LABEL_CTRL7_ID,&form_height);
    GUIFORM_SetChildHeight(MMIENG_WIFI_PREAM_FROM_CTRL_ID,MMIENG_WIFI_PREAM_DROP_CTRL_ID,&form_height);
    CTRLFORM_SetChildWidth(form7,drop_list_preamble_ctrl,&form_width);
    //Mode
    GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID,MMIENG_WIFI_MODE_FROM_CTRL_ID,&height_info);
    GUIFORM_SetChildHeight(MMIENG_WIFI_MODE_FROM_CTRL_ID,MMIENG_COMMON_LABEL_CTRL8_ID,&form_height);
    GUIFORM_SetChildHeight(MMIENG_WIFI_MODE_FROM_CTRL_ID,MMIENG_WIFI_MODE_DROP_CTRL_ID,&form_height);
    CTRLFORM_SetChildWidth(form8,drop_list_mode_ctrl,&form_width);
    //Guard Interval
    GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID,MMIENG_WIFI_GUARD_FROM_CTRL_ID,&height_info);
    GUIFORM_SetChildHeight(MMIENG_WIFI_GUARD_FROM_CTRL_ID,MMIENG_COMMON_LABEL_CTRL9_ID,&form_height);
    GUIFORM_SetChildHeight(MMIENG_WIFI_GUARD_FROM_CTRL_ID,MMIENG_WIFI_GUARD_DROP_CTRL_ID,&form_height);
    CTRLFORM_SetChildWidth(form9,drop_list_guardinterval_ctrl,&form_width);

    str = "Pkt len";
    text.wstr_len = strlen(str);
    text.wstr_ptr = wstr;
    SCI_MEMSET(wstr,0,20*sizeof(wchar));
    MMI_STRNTOWSTR( wstr, 7, (uint8*)str, text.wstr_len, text.wstr_len );
    GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL1_ID, &text, TRUE);
    GUIEDIT_SetStyle(MMIENG_COMMON_EDIT_CTRL1_ID, GUIEDIT_STYLE_SINGLE);

    str = "Pkt cnt";
    text.wstr_len = strlen(str);
    text.wstr_ptr = wstr;
    SCI_MEMSET(wstr,0,20*sizeof(wchar));
    MMI_STRNTOWSTR( wstr, 7, (uint8*)str, text.wstr_len, text.wstr_len );
    GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL2_ID, &text, TRUE);
    GUIEDIT_SetStyle(MMIENG_COMMON_EDIT_CTRL2_ID, GUIEDIT_STYLE_SINGLE);

    str = "Power\nlevel";
    SCI_MEMSET(wstr,0,20*sizeof(wchar));
    MMI_STRNTOWSTR( wstr, strlen(str), (uint8*)str, strlen(str), strlen(str) );
    GUITEXT_SetString(MMIENG_COMMON_LABEL_CTRL3_ID, wstr,strlen(str), FALSE);
    GUIEDIT_SetStyle(MMIENG_COMMON_EDIT_CTRL3_ID, GUIEDIT_STYLE_SINGLE);

    str = "RF\nSTD";
    SCI_MEMSET(wstr,0,20*sizeof(wchar));
    MMI_STRNTOWSTR( wstr, strlen(str), (uint8*)str, strlen(str),strlen(str));
    GUITEXT_SetString(MMIENG_COMMON_LABEL_CTRL4_ID, wstr,strlen(str), FALSE);

    droplist_border.color = MMI_BLACK_COLOR;
    droplist_border.width = 1;
    droplist_border.type = GUI_BORDER_ROUNDED;

    height_info.type = GUIFORM_CHILD_HEIGHT_AUTO;
	GUIFORM_SetChildHeight(form4, drop_list_standard_ctrl, &height_info);
    GUIDROPDOWNLIST_SetBorder(drop_list_standard_ctrl,&droplist_border);
    GUIDROPDOWNLIST_SetVisible(drop_list_standard_ctrl,TRUE,TRUE);
    GUIDROPDOWNLIST_SetMaxItem(drop_list_standard_ctrl,RX_STANDARD_NUM);

    for(i=0;i<ARR_SIZE(RX_standard_id);i++)
    {
        GUIDROPDOWNLIST_AppendItemById(MMIENG_WIFI_STANDARD_DROP_CTRL_ID,RX_standard_id[i]);
    }
    GUIDROPDOWNLIST_SetCurItemIndex(MMIENG_WIFI_STANDARD_DROP_CTRL_ID,0);

    //channel
    str = "Channel";
    text.wstr_len = strlen(str);
    text.wstr_ptr = wstr;
    SCI_MEMSET(wstr,0,20*sizeof(wchar));
    MMI_STRNTOWSTR( wstr, 7, (uint8*)str, text.wstr_len, text.wstr_len );
    GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL5_ID, &text, FALSE);
    GUIFORM_SetChildHeight(form5, drop_list_channel_ctrl, &height_info);
    GUIDROPDOWNLIST_SetBorder(drop_list_channel_ctrl,&droplist_border);
    GUIDROPDOWNLIST_SetVisible(drop_list_channel_ctrl,TRUE,TRUE);
    GUIDROPDOWNLIST_SetMaxItem(drop_list_channel_ctrl,RX_CHANNEL_NUM);
    for(i=0;i<ARR_SIZE(RX_channel_id);i++)
    {
        GUIDROPDOWNLIST_AppendItemById(MMIENG_WIFI_CHANNEL_DROP_CTRL_ID,RX_channel_id[i]);
    }
    GUIDROPDOWNLIST_SetCurItemIndex(MMIENG_WIFI_CHANNEL_DROP_CTRL_ID,0);

    //Rate
    str = "Rate";
    text.wstr_len = strlen(str);
    text.wstr_ptr = wstr;
    SCI_MEMSET(wstr,0,20*sizeof(wchar));
    MMI_STRNTOWSTR( wstr, 4, (uint8*)str, text.wstr_len, text.wstr_len );
    GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL6_ID, &text, FALSE);

    GUIFORM_SetChildHeight(form6, drop_list_rate_ctrl, &height_info);
    GUIDROPDOWNLIST_SetBorder(drop_list_rate_ctrl,&droplist_border);
    GUIDROPDOWNLIST_SetVisible(drop_list_rate_ctrl,TRUE,TRUE);
    GUIDROPDOWNLIST_SetMaxItem(drop_list_rate_ctrl,TX_RATE_NUM);
    for(i=0;i<ARR_SIZE(TX_rate_id);i++)
    {
        GUIDROPDOWNLIST_AppendItemById(MMIENG_WIFI_RATE_DROP_CTRL_ID,TX_rate_id[i]);
    }
    GUIDROPDOWNLIST_SetCurItemIndex(MMIENG_WIFI_RATE_DROP_CTRL_ID,0);

    //Preamble
    str = "Preamble";
    text.wstr_len = strlen(str);
    text.wstr_ptr = wstr;
    SCI_MEMSET(wstr,0,20*sizeof(wchar));
    MMI_STRNTOWSTR( wstr, 8, (uint8*)str, text.wstr_len, text.wstr_len );
    GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL7_ID, &text, FALSE);

    GUIFORM_SetChildHeight(form7, drop_list_preamble_ctrl, &height_info);
    GUIDROPDOWNLIST_SetBorder(drop_list_preamble_ctrl,&droplist_border);
    GUIDROPDOWNLIST_SetVisible(drop_list_preamble_ctrl,TRUE,TRUE);
    GUIDROPDOWNLIST_SetMaxItem(drop_list_preamble_ctrl,TX_PREAMBLE_NUM);
    for(i=0;i<ARR_SIZE(TX_preamble_id);i++)
    {
        GUIDROPDOWNLIST_AppendItemById(MMIENG_WIFI_PREAM_DROP_CTRL_ID,TX_preamble_id[i]);
    }
     GUIDROPDOWNLIST_SetCurItemIndex(MMIENG_WIFI_PREAM_DROP_CTRL_ID,0);

    //Mode
    str = "Mode";
    text.wstr_len = strlen(str);
    text.wstr_ptr = wstr;
    SCI_MEMSET(wstr,0,20*sizeof(wchar));
    MMI_STRNTOWSTR( wstr, 4, (uint8*)str, text.wstr_len, text.wstr_len );
    GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL8_ID, &text, FALSE);

    GUIFORM_SetChildHeight(form8, drop_list_mode_ctrl, &height_info);
    GUIDROPDOWNLIST_SetBorder(drop_list_mode_ctrl,&droplist_border);
    GUIDROPDOWNLIST_SetVisible(drop_list_mode_ctrl,TRUE,TRUE);
    GUIDROPDOWNLIST_SetMaxItem(drop_list_mode_ctrl,TX_MODE_NUM);
    for(i=0;i<ARR_SIZE(TX_mode_id);i++)
    {
        GUIDROPDOWNLIST_AppendItemById(MMIENG_WIFI_MODE_DROP_CTRL_ID,TX_mode_id[i]);
    }
    GUIDROPDOWNLIST_SetCurItemIndex(MMIENG_WIFI_MODE_DROP_CTRL_ID,0);

   //guard interval
    str = "Guard\ninterval";
    SCI_MEMSET(wstr,0,20*sizeof(wchar));
    MMI_STRNTOWSTR( wstr,15,(uint8*)str, strlen(str),strlen(str));
    GUITEXT_SetString(MMIENG_COMMON_LABEL_CTRL9_ID, wstr,MMIAPICOM_Wstrlen(wstr), FALSE);

    GUIFORM_SetChildHeight(form9, drop_list_guardinterval_ctrl, &height_info);
    GUIDROPDOWNLIST_SetBorder(drop_list_guardinterval_ctrl,&droplist_border);
    GUIDROPDOWNLIST_SetVisible(drop_list_guardinterval_ctrl,TRUE,TRUE);
    GUIDROPDOWNLIST_SetMaxItem(drop_list_guardinterval_ctrl,TX_GUARD_INTERVAL);
    for(i=0;i<ARR_SIZE(TX_guard_id);i++)
    {
        GUIDROPDOWNLIST_AppendItemById(MMIENG_WIFI_GUARD_DROP_CTRL_ID,TX_guard_id[i]);
    }
    GUIDROPDOWNLIST_SetCurItemIndex(MMIENG_WIFI_GUARD_DROP_CTRL_ID,0);

}
LOCAL MMI_RESULT_E EngWifiTXHandleWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E ret_value      = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id       = MMIENG_COMMON_EDIT_CTRL1_ID;

    switch(msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            InitWifiTXParam(win_id);
            MMK_SetAtvCtrl(win_id, ctrl_id);
            Wifi_ExcuteModeCmd(TRUE);
        }
            break;
        case MSG_FULL_PAINT:
            break;
#ifdef TOUCH_PANEL_SUPPORT
        case MSG_CTL_PENOK:
#endif
        case MSG_CTL_OK:
            Wifi_TxStartCmd();
            break;
        case MSG_APP_CANCEL:
        case MSG_CTL_CANCEL://stop
            Wifi_TxStopCmd();
            MMK_CloseWin(win_id);
            break;
        case MSG_CLOSE_WINDOW:
            Wifi_ExcuteModeCmd(FALSE);
            break;
        default:
            ret_value = MMI_RESULT_FALSE;
            break;
    }
}
char rx_ok_count[4]= {0};

LOCAL void Wifi_RxStopCmd()
{
    uint8        stop_ret[TX_RX_CMD_RET_SIZE+1] = {0};
    uint8        rx_ok_ret[TX_RX_CMD_RET_SIZE+1]={0};
    int ret_value = 0;

    char *pArgvStop[3] = {"iwnpi","wlan0","rx_stop"};
    char *pArgvRxOK[3] = {"iwnpi","wlan0","get_rx_ok"};
    int i =0;
    uint16 digital_pos = 0;


    SCI_TRACE_LOW("Wifi_RxStopCmd Enter");

    //stop cmd
#ifndef WIN32
    ret_value = iwnpi_cmd_handler(3,pArgvRxOK,rx_ok_ret);
    SCI_TRACE_LOW("Wifi_RxStopCmd get_rx_ok  ret_value=%d",ret_value);
    SCI_TRACE_LOW("rx_ok_ret= %s\n",rx_ok_ret);
    for(i = 0;i<strlen(rx_ok_ret);i++)
    {
        if('=' == rx_ok_ret[i])
        {
            digital_pos = i+1;
            break;
        }
    }
    if(','== rx_ok_ret[digital_pos+3])
    {
        SCI_MEMCPY(rx_ok_count,&rx_ok_ret[digital_pos],3);
    }else
    {
        SCI_MEMCPY(rx_ok_count,&rx_ok_ret[digital_pos],4);
    }
#endif
#ifndef WIN32
    ret_value = iwnpi_cmd_handler(3,pArgvStop,stop_ret);
    SCI_TRACE_LOW("Wifi_RxStopCmd rx_stop ret_value=%d",ret_value);
#endif

}
LOCAL void Wifi_GetRXParam()
{
    MMI_STRING_T rx_num_text = {0};
    uint8        rx_num_char[5] = {0};
    uint16       rx_std_index  = 0;
    uint16       rx_test_num = 0;
    uint16       channel_index = 0;

    uint8        channel_value[15] = {0};
    uint8        set_channel_ret[TX_RX_CMD_RET_SIZE+1] = {0};

    uint8        start_ret[TX_RX_CMD_RET_SIZE+1] = {0};

    char *pArgvChannel_Input[4]= {0};
       
    char pArgvChannel[4][15] = {"iwnpi","wlan0","set_channel","1"};
    char *pArgvStart[3] = {"iwnpi","wlan0","rx_start"};

    int ret_value = 0;
    int i = 0;

    channel_index = GUIDROPDOWNLIST_GetCurItemIndex(MMIENG_WIFI_CHANNEL_DROP_CTRL_ID);
    MMIENG_Int2Str((channel_index + 1),channel_value,3);
    SCI_MEMCPY(pArgvChannel[3],channel_value,strlen(channel_value));
    for (i = 0; i < 4; i++)
    {
        pArgvChannel_Input[i] = pArgvChannel[i];
    }
#ifndef WIN32
    ret_value = iwnpi_cmd_handler(4,pArgvChannel_Input,set_channel_ret);
    SCI_TRACE_LOW("Wifi_RxStopCmd set_channel ret_value=%d",ret_value);
#endif

#ifndef WIN32
    ret_value = iwnpi_cmd_handler(3,pArgvStart,start_ret);
    SCI_TRACE_LOW("Wifi_RxStartCmd start_ret ret_value=%d",ret_value);
#endif
}
BOOLEAN flag = FALSE;
LOCAL void Wifi_DisplayRxOK()
{
    MMI_STRING_T rx_num_text= {0};
    uint8       rx_num_char[15] = {0};
    uint16      rx_test_num = 0;
    uint16      rx_get_num = 0;
    float       percent = 0.0;
    uint8       percent_value[8]={0};
    MMI_STRING_T rx_ok_value = {0};
    MMI_STRING_T rx_ok_value_percent = {0};
    wchar        wstr_count_value[4]= {0};
    wchar        wstr_count_per[8]={0};
    GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL1_ID, &rx_num_text);
    SCI_MEMSET(rx_num_char,0,3);
    if(0 < rx_num_text.wstr_len)
    {
        MMI_WSTRNTOSTR((uint8*)rx_num_char, 15, rx_num_text.wstr_ptr,15,5);
        rx_test_num = atoi(rx_num_char);  //get test number
    }
    MMI_STRNTOWSTR(wstr_count_value,4,rx_ok_count,4,4);
    rx_ok_value.wstr_ptr = wstr_count_value;
    rx_ok_value.wstr_len = MMIAPICOM_Wstrlen(wstr_count_value);
    GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL5_ID,&rx_ok_value,TRUE);
    rx_get_num = atoi(rx_ok_count);
    if(0 < rx_test_num)
    {
        percent = rx_get_num*100/rx_test_num;
    }
    sprintf(percent_value,"%.2f%s",percent,"%");
    MMI_STRNTOWSTR(wstr_count_per,8,percent_value,8,8);
    rx_ok_value_percent.wstr_ptr = wstr_count_per;
    rx_ok_value_percent.wstr_len = MMIAPICOM_Wstrlen(wstr_count_per);
    GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL7_ID,&rx_ok_value_percent,TRUE);
}
LOCAL MMI_RESULT_E EngWifiRXHandleWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E ret_value      = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id       = MMIENG_COMMON_EDIT_CTRL1_ID;

    switch(msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            flag = FALSE;
            InitWifiRXParam(win_id);
            MMK_SetAtvCtrl(win_id, ctrl_id);
            Wifi_ExcuteModeCmd(TRUE);
        }
            break;
        case MSG_FULL_PAINT:
            break;
#ifdef TOUCH_PANEL_SUPPORT
        case MSG_CTL_PENOK:
#endif
        case MSG_APP_OK:
        case MSG_CTL_OK:
        case MSG_APP_MENU:
        {
            uint16 channel_index = 0;
            channel_index = GUIDROPDOWNLIST_GetCurItemIndex(MMIENG_WIFI_CHANNEL_DROP_CTRL_ID);
            Wifi_GetRXParam(channel_index);
        }
            break;
        case MSG_APP_CANCEL:
        //case MSG_CTL_OK:
        case MSG_CTL_CANCEL://stop
           if(FALSE == flag)
            {
                Wifi_RxStopCmd();
                Wifi_DisplayRxOK();
                flag = TRUE;
                GUIWIN_SetSoftkeyTextId(win_id, TXT_COMMON_START, TXT_NULL, TXT_ENG_RETURN,TRUE);
            }else
            {
                MMK_CloseWin(win_id);
            }
            break;
        case MSG_CLOSE_WINDOW:
            Wifi_ExcuteModeCmd(FALSE);
            break;
        default:
            ret_value = MMI_RESULT_FALSE;
            break;
    }
    return ret_value;
}

LOCAL uint8 Reg_Value[8]={0};
LOCAL void Wifi_WRRegCmd(uint32 msg_id)
{

    MMI_STRING_T  type_text       = {0};
    uint16        type_index      = 0;
    uint8         str_type[5]     = {0};
    MMI_STRING_T  addr_text       = {0};
    uint8         str_addr[20]    = {0};
    MMI_STRING_T  value_text      = {0};
    uint8         str_value[20]   = {0};
    MMI_STRING_T  count_text      = {0};
    uint8         str_count[20]   = {0};

    uint8         set_reg_ret[TX_RX_CMD_RET_SIZE+1] = {0};
    uint8         get_reg_ret[TX_RX_CMD_RET_SIZE+1]= {0};

    int           ret_value       = 0;

    int           ret_reg_len     = 0;
    int           quot_pos        = 0;
    int           i               = 0;
    int           reg_value_len   = 0;


    char *pArgvSetReg[6] = {"iwnpi","wlan0","set_reg","5","5","1"};
    char *pArgvGetReg[6] = {"iwnpi","wlan0","get_reg","5","5","5"};

    type_index = GUIDROPDOWNLIST_GetCurItemIndex(MMIENG_COMMON_LIST_CTRL1_ID);
    SCI_TRACE_LOW("type_index = %d",type_index);
    switch(type_index)
    {
        case 0:
            MMI_GetLabelTextByLang(TXT_ENG_MAC,&type_text);
            MMI_WSTRNTOSTR(str_type, 5, type_text.wstr_ptr, 5, type_text.wstr_len);
            break;
        case 1:
            MMI_GetLabelTextByLang(TXT_ENG_PHY0,&type_text);
            MMI_WSTRNTOSTR(str_type, 5, type_text.wstr_ptr, 5, type_text.wstr_len);
            break;
        case 2:
            MMI_GetLabelTextByLang(TXT_ENG_PHY1,&type_text);
            MMI_WSTRNTOSTR(str_type, 5, type_text.wstr_ptr, 5, type_text.wstr_len);
            break;
        case 3:
            MMI_GetLabelTextByLang(TXT_ENG_RF,&type_text);
            MMI_WSTRNTOSTR(str_type, 5, type_text.wstr_ptr, 5, type_text.wstr_len);
            break;
        default:
            SCI_TRACE_LOW("type error");
            break;
            
    }
    GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL2_ID, &addr_text); //get addr
    if(0 < addr_text.wstr_len)
    {
        MMI_WSTRNTOSTR((uint8*)str_addr, 20, addr_text.wstr_ptr, addr_text.wstr_len,addr_text.wstr_len);
    }
    
    GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL3_ID, &value_text); //get value
    if(0 < value_text.wstr_len)
    {
        MMI_WSTRNTOSTR((uint8*)str_value, 20, value_text.wstr_ptr, value_text.wstr_len,value_text.wstr_len);
    }

    GUIEDIT_GetString(MMIENG_COMMON_EDIT_CTRL4_ID, &count_text); //get length
    if(0 < count_text.wstr_len)
    {
        MMI_WSTRNTOSTR((uint8*)str_count, 20, count_text.wstr_ptr, count_text.wstr_len,count_text.wstr_len);
    }

    if(MSG_APP_MENU == msg_id)
    {
        //set reg cmd
        //st//rncpy(pArgvSetReg[3],str_type,strlen(str_type));
        //strncpy(pArgvSetReg[4],str_addr,strlen(str_addr));
        //strncpy(pArgvSetReg[5],str_value,strlen(str_value));
        pArgvGetReg[3] = str_type;
        pArgvGetReg[4] = str_addr;
        //pArgvGetReg[5] = str_count;


#ifndef WIN32
        ret_value = iwnpi_cmd_handler(6,pArgvGetReg,get_reg_ret);
        SCI_TRACE_LOW("Wifi_ReadRegParam ret_value=%d",ret_value);

        ret_reg_len = strlen(get_reg_ret);
        for(i=0;i<ret_reg_len;i++)
        {
            if(':' == get_reg_ret[i])
            {
                quot_pos = i;
                break;
            }
        }
        SCI_MEMCPY(Reg_Value,&get_reg_ret[quot_pos+3],8);
        //MMIAPICOM_HexCharToBinary(RegValue,8,Reg_Value,&reg_value_len);
        SCI_TRACE_LOW("reg_value_len = %d",reg_value_len);
#endif
    }
    else
    {
       //get reg cmd
        //strncpy(pArgvGetReg[3],str_type,strlen(str_type));
        ///strncpy(pArgvGetReg[4],str_addr,strlen(str_addr));
        //strncpy(pArgvGetReg[5],str_count,strlen(str_count));
        pArgvSetReg[3] = str_type;
        pArgvSetReg[4] = str_addr;
        pArgvSetReg[5] = str_value;
#ifndef WIN32
        ret_value = iwnpi_cmd_handler(6,pArgvSetReg,set_reg_ret);
        SCI_TRACE_LOW("Wifi_ReadRegParam ret_value=%d",ret_value);
#endif
    }
}
LOCAL MMI_RESULT_E EngWifiRegWRHandleWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E ret_value      = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id       = MMIENG_COMMON_LIST_CTRL1_ID;
    MMI_STRING_T itemStr        = {0};
    char* str = PNULL;
    uint8 i = 0;
    wchar wstr[10] = {0};
    MMI_STRING_T text = {0};

    uint32  droplist_type_id[4] = {
                                    TXT_ENG_MAC,//mac
                                    TXT_ENG_PHY0,//phy0
                                    TXT_ENG_PHY1,//phy0
                                    TXT_ENG_RF//rf
                                  };

    switch(msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            MMI_HANDLE_T form_ctrl                  = MMK_GetCtrlHandleByWin(win_id, MMIENG_FORM_CTRL_ID);
            MMI_HANDLE_T form1                      = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_TYPE_FORM_CTRL_ID);
            MMI_HANDLE_T form2                      = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_ADDR_FORM_CTRL_ID);
            MMI_HANDLE_T form3                      = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_LEN_FORM_CTRL_ID);
            MMI_HANDLE_T form4                      = MMK_GetCtrlHandleByWin(win_id, MMIENG_WIFI_VALUE_FORM_CTRL_ID);
            MMI_HANDLE_T drop_list_type_ctrl        = MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_LIST_CTRL1_ID);
            GUIFORM_CHILD_HEIGHT_T height_info = {0};
            GUI_BG_T               display_bg = {0};
            GUIFORM_CHILD_HEIGHT_T form_height = {0};
            GUI_BORDER_T           droplist_border = {0};
            GUIFORM_CHILD_WIDTH_T form_width  = {0};

            display_bg.bg_type = GUI_BG_COLOR;
            display_bg.color   = MMI_WHITE_COLOR;

            //form
            GUIFORM_SetType(MMIENG_FORM_CTRL_ID, GUIFORM_TYPE_TP);
            GUIFORM_SetDividingLine(form_ctrl,1,MMI_WHITE_COLOR);
            GUIFORM_SetBg(MMIENG_FORM_CTRL_ID,&display_bg);
            GUIFORM_PermitChildFont(form_ctrl,FALSE);
            GUIFORM_PermitChildBorder(form_ctrl,FALSE);

            //set unit
            GUIFORM_SetStyle(MMIENG_WIFI_TYPE_FORM_CTRL_ID,GUIFORM_STYLE_UNIT);
            GUIFORM_SetStyle(MMIENG_WIFI_ADDR_FORM_CTRL_ID,GUIFORM_STYLE_UNIT);
            GUIFORM_SetStyle(MMIENG_WIFI_LEN_FORM_CTRL_ID,GUIFORM_STYLE_UNIT);
            GUIFORM_SetStyle(MMIENG_WIFI_VALUE_FORM_CTRL_ID,GUIFORM_STYLE_UNIT);

            height_info.type     = GUIFORM_CHILD_HEIGHT_FIXED;
            height_info.add_data = 55;
            form_height.type     = GUIFORM_CHILD_HEIGHT_PERCENT;
            form_height.add_data = 100;
            form_width.type      = GUIFORM_CHILD_WIDTH_PERCENT;
            form_width.add_data  = 70;

            droplist_border.color = MMI_BLACK_COLOR;
            droplist_border.width = 1;
            droplist_border.type = GUI_BORDER_ROUNDED;


            GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID,MMIENG_WIFI_TYPE_FORM_CTRL_ID,&height_info);
            GUIFORM_SetChildHeight(MMIENG_WIFI_TYPE_FORM_CTRL_ID,MMIENG_COMMON_LABEL_CTRL1_ID,&form_height);
            GUIFORM_SetChildHeight(MMIENG_WIFI_TYPE_FORM_CTRL_ID,MMIENG_COMMON_LIST_CTRL1_ID,&form_height);
            CTRLFORM_SetChildWidth(form1,drop_list_type_ctrl,&form_width);

            GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID,MMIENG_WIFI_ADDR_FORM_CTRL_ID,&height_info);
            GUIFORM_SetChildHeight(MMIENG_WIFI_ADDR_FORM_CTRL_ID,MMIENG_COMMON_LABEL_CTRL2_ID,&form_height);
            GUIFORM_SetChildHeight(MMIENG_WIFI_ADDR_FORM_CTRL_ID,MMIENG_COMMON_EDIT_CTRL2_ID,&form_height);
            GUIEDIT_SetBorder(MMIENG_COMMON_EDIT_CTRL2_ID,&droplist_border);
            CTRLFORM_SetChildWidth(form2,MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_EDIT_CTRL2_ID),&form_width);

            GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID,MMIENG_WIFI_LEN_FORM_CTRL_ID,&height_info);
            GUIFORM_SetChildHeight(MMIENG_WIFI_LEN_FORM_CTRL_ID,MMIENG_COMMON_LABEL_CTRL3_ID,&form_height);
            GUIFORM_SetChildHeight(MMIENG_WIFI_LEN_FORM_CTRL_ID,MMIENG_COMMON_EDIT_CTRL3_ID,&form_height);
            GUIEDIT_SetBorder(MMIENG_COMMON_EDIT_CTRL3_ID,&droplist_border);

            CTRLFORM_SetChildWidth(form3,MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_EDIT_CTRL3_ID),&form_width);
            GUIFORM_SetChildHeight(MMIENG_FORM_CTRL_ID,MMIENG_WIFI_VALUE_FORM_CTRL_ID,&height_info);
            GUIFORM_SetChildHeight(MMIENG_WIFI_VALUE_FORM_CTRL_ID,MMIENG_COMMON_LABEL_CTRL4_ID,&form_height);
            GUIFORM_SetChildHeight(MMIENG_WIFI_VALUE_FORM_CTRL_ID,MMIENG_COMMON_EDIT_CTRL4_ID,&form_height);
            GUIEDIT_SetBorder(MMIENG_COMMON_EDIT_CTRL4_ID,&droplist_border);
            CTRLFORM_SetChildWidth(form4,MMK_GetCtrlHandleByWin(win_id, MMIENG_COMMON_EDIT_CTRL4_ID),&form_width);

            str = "Type";
            text.wstr_len = strlen(str);
            text.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, 4, (uint8*)str, text.wstr_len, text.wstr_len );
            GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL1_ID, &text, TRUE);

            height_info.type = GUIFORM_CHILD_HEIGHT_AUTO;
            GUIFORM_SetChildHeight(form_ctrl, drop_list_type_ctrl, &height_info);
            GUIDROPDOWNLIST_SetBorder(drop_list_type_ctrl,&droplist_border);
            GUIDROPDOWNLIST_SetVisible(drop_list_type_ctrl,TRUE,TRUE);
            GUIDROPDOWNLIST_SetMaxItem(drop_list_type_ctrl,4);

            for(i=0;i<ARR_SIZE(droplist_type_id);i++)
            {
                GUIDROPDOWNLIST_AppendItemById(MMIENG_COMMON_LIST_CTRL1_ID,droplist_type_id[i]);
            }
            GUIDROPDOWNLIST_SetCurItemIndex(MMIENG_COMMON_LIST_CTRL1_ID,0);

            //addr
            str = "Addr";
            text.wstr_len = strlen(str);
            text.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, 4, (uint8*)str, text.wstr_len, text.wstr_len );
            GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL2_ID, &text, FALSE);

            //Length
            str = "Length";
            text.wstr_len = strlen(str);
            text.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, 6, (uint8*)str, text.wstr_len, text.wstr_len );
            GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL3_ID, &text, FALSE);
            GUIEDIT_SetStyle(MMIENG_COMMON_EDIT_CTRL3_ID, GUIEDIT_STYLE_SINGLE);

            //Value
            str = "Value";
            text.wstr_len = strlen(str);
            text.wstr_ptr = wstr;
            MMI_STRNTOWSTR( wstr, 5, (uint8*)str, text.wstr_len, text.wstr_len );
            GUILABEL_SetText(MMIENG_COMMON_LABEL_CTRL4_ID, &text, FALSE);
            GUIEDIT_SetStyle(MMIENG_COMMON_EDIT_CTRL4_ID, GUIEDIT_STYLE_SINGLE);

            MMK_SetAtvCtrl(win_id,ctrl_id);
            Wifi_ExcuteModeCmd(TRUE);
        }
            break;
#ifdef TOUCH_PANEL_SUPPORT
        case MSG_CTL_PENOK:
#endif
        case MSG_APP_WEB:
        case MSG_CTL_MIDSK:
        case MSG_APP_MENU:
        {
            wchar wstr_val[8]  = {0};
            Wifi_WRRegCmd(MSG_APP_MENU);
            MMI_STRNTOWSTR(wstr_val,8,Reg_Value,8,strlen(Reg_Value));
            GUIEDIT_SetString(MMIENG_COMMON_EDIT_CTRL4_ID,wstr_val,MMIAPICOM_Wstrlen(wstr_val));//get val
        }
            break;
        case MSG_FULL_PAINT:
            break;
        case MSG_APP_CANCEL:
        //case MSG_CTL_OK:
        case MSG_CTL_CANCEL:
            Wifi_WRRegCmd(MSG_APP_CANCEL);
            MMK_CloseWin(win_id);
            break;
        case MSG_CLOSE_WINDOW:
            Wifi_ExcuteModeCmd(FALSE);
            break;
        default:
            ret_value = MMI_RESULT_FALSE;
            break;
    }
    return ret_value;
}

LOCAL void Wifi_PowerSaveCmd(BOOLEAN is_open)
{
    uint8        open_ret[TX_RX_CMD_RET_SIZE+1]   = {0};
    uint8        close_ret[TX_RX_CMD_RET_SIZE+1]  = {0};
    int          ret_value      = 0;

    char *pTestOpen[3] = {"iwnpi","wlan0","lna_on"};
    char *pTestClose[3] = {"iwnpi","wlan0","lna_off"};
    SCI_TRACE_LOW("Wifi_OpenPowerSaveCmd Enter");
    if(TRUE == is_open)
    {
        //open cmd
#ifndef WIN32
        ret_value = iwnpi_cmd_handler(3,pTestOpen,open_ret);
        SCI_TRACE_LOW("pArgvOpen ret_value=%d",ret_value);
#endif
    }else
    {
        //stop cmd
#ifndef WIN32
        ret_value = iwnpi_cmd_handler(3,pTestClose,close_ret);
        SCI_TRACE_LOW("pArgvClose ret_value=%d",ret_value);
#endif
    }
}
/********************************************************************************
 NAME:          MMIENG_OpenOperatorSIMSelectWin
 AUTHOR:        chunjuan.liang
 DATE:          2020.3.21
********************************************************************************/
LOCAL MMI_RESULT_E EngEnablePowerSaveWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    int32 index = 0;
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    int32 list_id = MMIENG_LISTBOX_CTRL_ID ;
    int32 flag = 0; // 0:OFF; 1: ON 

    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            GUILIST_ITEM_T      item_t = {0};
            GUILIST_ITEM_DATA_T item_data = {0};

            GUIWIN_SetTitleTextId(win_id, TXT_ENG_WIFI_SAVE_MODE, FALSE);
            GUILIST_SetMaxItem( list_id, 2, FALSE );//open and close
            GUILIST_SetOwnSofterKey(list_id,FALSE);

            item_t.item_style    = GUIITEM_STYLE_1RADIO_ENG;
            item_t.item_data_ptr = &item_data;

            item_data.item_content[0].item_data_type    = GUIITEM_DATA_TEXT_ID;
            item_data.item_content[0].item_data.text_id = TXT_OPEN_COMN;
            GUILIST_AppendItem( list_id, &item_t );
            item_data.item_content[0].item_data.text_id = TXT_COMM_CLOSE;
            GUILIST_AppendItem( list_id, &item_t );

            GUILIST_SetSelectedItem( list_id,index, TRUE );
            GUILIST_SetCurItemIndex( list_id, index);
            MMK_SetAtvCtrl(win_id, list_id);
            Wifi_ExcuteModeCmd(TRUE);
        }
        break;
    case MSG_FULL_PAINT:
        break;
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT
    case MSG_CTL_PENOK:
#endif
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        index = GUILIST_GetCurItemIndex(list_id);  
        if(0 == index)
        {
            Wifi_PowerSaveCmd(TRUE);
        }
        else if( 1  == index)
        {
            Wifi_PowerSaveCmd(FALSE);
        }
        MMK_CloseWin(win_id);
        break;
    case MSG_CLOSE_WINDOW:
        Wifi_ExcuteModeCmd(FALSE);
        break;
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

LOCAL MMI_RESULT_E EngPacketCheckSwtichWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    uint16 index = 0;
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    int32 list_id = MMIENG_LISTBOX_CTRL_ID;

    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            GUILIST_ITEM_T      item_t = {0};
            GUILIST_ITEM_DATA_T item_data = {0};

            GUIWIN_SetTitleTextId(win_id, TXT_ENG_WIFI_PACKET_SWITCH, FALSE);
            GUILIST_SetMaxItem( list_id, MMIENG_PACKET_CHECK_MAX, FALSE );//open and close
            GUILIST_SetOwnSofterKey(list_id,FALSE);

            item_t.item_style    = GUIITEM_STYLE_1RADIO_ENG;
            item_t.item_data_ptr = &item_data;

            item_data.item_content[0].item_data_type    = GUIITEM_DATA_TEXT_ID;
            item_data.item_content[0].item_data.text_id = TXT_OPEN_COMN;
            GUILIST_AppendItem( list_id, &item_t );
            item_data.item_content[0].item_data.text_id = TXT_COMM_CLOSE;
            GUILIST_AppendItem( list_id, &item_t );
            if(FALSE == MMIAPIWIFI_GetIsMonitorWakeupPacket())
            {
                index = MMIENG_PACKET_CHECK_OFF;
            }
            else
            {
                index = MMIENG_PACKET_CHECK_ON;
            }
            GUILIST_SetSelectedItem( list_id,index, TRUE );
            GUILIST_SetCurItemIndex( list_id, index);
            MMK_SetAtvCtrl(win_id, list_id);
        }
        break;
    case MSG_FULL_PAINT:
        break;
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT
    case MSG_CTL_PENOK:
#endif
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        index = GUILIST_GetCurItemIndex(list_id);
        if(MMIENG_PACKET_CHECK_ON == index)
        {
            MMIAPIWIFI_SetIsMonitorWakeupPacket(TRUE);
        }
        else if(MMIENG_PACKET_CHECK_OFF == index)
        {
            MMIAPIWIFI_SetIsMonitorWakeupPacket(FALSE);
        }
        MMK_CloseWin(win_id);
        break;
    case MSG_CLOSE_WINDOW:
        break;
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}
LOCAL MMI_RESULT_E EngPacketCheckItemHandleWinMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E ret_value      = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id       = MMIENG_COMMON_EDIT_CTRL1_ID;
    MMI_STRING_T threshold = {0};
    uint16 threshold_len = 0;
    uint32 num_threshold = 0;
    uint8 str_threshold[MMIENG_THRESHOLD_LEN] = {0};
    wchar wstr_threshold[MMIENG_THRESHOLD_LEN] = {0};
    switch(msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            InitWifiPKItemParam(win_id);
            GUIEDIT_SetIm( MMIENG_COMMON_EDIT_CTRL1_ID, GUIIM_TYPE_SYS, GUIIM_TYPE_SYS );
            num_threshold = MMIAPIWIFI_GetWakeupPacketThreshold();
            MMIAPICOM_Int2Str(num_threshold,str_threshold,MMIENG_THRESHOLD_LEN);
            MMI_STRNTOWSTR(wstr_threshold,MMIENG_THRESHOLD_LEN,str_threshold,MMIENG_THRESHOLD_LEN,MMIENG_THRESHOLD_LEN);
            threshold_len = MMIAPICOM_Wstrlen(wstr_threshold);
            GUIEDIT_SetString(ctrl_id, wstr_threshold, threshold_len);
            MMK_SetAtvCtrl(win_id, ctrl_id);
        }
            break;
        case MSG_FULL_PAINT:
            break;
        case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT
        case MSG_CTL_PENOK:
#endif
        case MSG_KEYDOWN_OK:
        case MSG_CTL_OK:
        case MSG_APP_WEB:
            GUIEDIT_GetString(ctrl_id, &threshold);
            if (PNULL != threshold.wstr_ptr)
            {
                MMIAPICOM_WstrToNum(threshold.wstr_ptr,threshold.wstr_len,&num_threshold);
            }
            else
            {
                SCI_TRACE_LOW("EngPacketCheckItemHandleWinMsg threshold.wstr_ptr=PNULL!");
            }
            MMIAPIWIFI_SetWakeupPacketThreshold(num_threshold);
            MMK_CloseWin(win_id);
            break;
        case MSG_APP_CANCEL:
        case MSG_CTL_CANCEL:
            MMK_CloseWin(win_id);
            break;
        case MSG_CLOSE_WINDOW:
            break;
        default:
            ret_value = MMI_RESULT_FALSE;
            break;
    }
}

PUBLIC void EngWifiInfoOpenWin(uint32 u_ID_ENG_Tele)
{
    SCI_TRACE_LOW("EngWifiInfoOpenWin %d",u_ID_ENG_Tele);
    switch(u_ID_ENG_Tele)
    {
        case ID_ENG_CON_WIFI_TX://TX
            MMK_CreateWin((uint32)MMIENG_WIFI_TX_WIN_TAB,PNULL);
            break;
        case ID_ENG_CON_WIFI_RX://RX
            MMK_CreateWin((uint32)MMIENG_WIFI_RX_WIN_TAB,PNULL);
            break;
        case ID_ENG_CON_WIFI_REGWR://REGWR
            MMK_CreateWin((uint32)MMIENG_WIFI_REG_WR_WIN_TAB,PNULL);
            break;
        case ID_ENG_CON_WIFI_SAVEMODE://power save mode
            MMIENG_OpenListSelectWin((uint32)EngEnablePowerSaveWinHandleMsg);
            break;
        case ID_ENG_CON_WIFI_PACKETSWITCHMODE://packet switch
            MMIENG_OpenListSelectWin((uint32)EngPacketCheckSwtichWinHandleMsg);
            break;
        case ID_ENG_CON_WIFI_PACKETITEMMODE://packet item
            MMK_CreateWin((uint32)MMIENG_WIFI_PK_WIN_TAB,PNULL);
            break;
        default:
            break;
    }
}
//wifi end
#endif

/****************************************************************************/
//  Description : Eng Get Log Uart Is Open
//  Global resource dependence :
//  Author:xiaotong.su
//  Note:uart log是否open，返回值为TRUE,uart log打开，返回值为FALSE,uart log关闭
/****************************************************************************/
PUBLIC BOOLEAN MMIENG_GetLogUartIsOpen(void)
{
    MN_RETURN_RESULT_E   return_value = MN_RETURN_FAILURE;
#ifdef GOODIX_SUPPORT_GR5515
    BOOLEAN              is_open = FALSE;
#else
    BOOLEAN              is_open = TRUE;//goodix off default true
#endif

    MMINV_READ(MMIENG_NV_IS_UART_LOG_OPEN,&is_open,return_value);
    SCI_TRACE_LOW("MMIENG_GetLogUartIsOpen =%d",is_open);
    if (MN_RETURN_SUCCESS != return_value)
    {
        MMINV_WRITE(MMIENG_NV_IS_UART_LOG_OPEN,&is_open);
    }
    return is_open;
}

/****************************************************************************/
//  Description : Eng Set Log Uart Is Open
//  Global resource dependence :
//  Author:xiaotong.su
//  Note:uart log是否open，返回值为TRUE,uart log打开，返回值为FALSE,uart log关闭
/****************************************************************************/
PUBLIC void MMIENG_SetLogUartIsOpen(BOOLEAN is_open)
{
    MMINV_WRITE(MMIENG_NV_IS_UART_LOG_OPEN,&is_open);
}

/****************************************************************************/
//  Description : Eng init uart port,it is for sensor hub or it is for uart log
//  Global resource dependence :
//  Author:changli.jiang
//  Note:
/****************************************************************************/
PUBLIC void MMIENG_InitUartPort(void)
{
#ifndef WIN32
    BOOLEAN is_uart_open = FALSE;
    is_uart_open = MMIENG_GetLogUartIsOpen();
    if(TRUE == is_uart_open)
    {
#ifdef PLATFORM_ANTISW3
    //do nothing now,uart0 log is enable        
        UCOM_SetIsNeedUartLog(TRUE);
#endif
    }
    else
    {
#ifdef GOODIX_SUPPORT_GR5515
        UCOM_SetIsNeedUartLog(FALSE);
        //open uart1 for sensor hub
        uart_set_logmode(FALSE);//uart 1开
        //SIO_Close(COM_DEBUG);
        //init goodix
        goodix_init();
        sensor_hal_init();
#endif
    }
#endif
}
/********************************************************************************
 NAME:EngLogUartWinHandleMsg
 AUTHOR:xiaotong.su
 DATE:2021.5.24
********************************************************************************/
LOCAL MMI_RESULT_E EngLogUartWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    BOOLEAN             is_open = FALSE;
    uint16              index = 0;
    MMI_RESULT_E        result = MMI_RESULT_TRUE;
    int32               list_id = MMIENG_LISTBOX_CTRL_ID;
    MMI_TEXT_ID_T       title_text_id = 0;

    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            GUILIST_ITEM_T      item_t = {0};
            GUILIST_ITEM_DATA_T item_data = {0};

            GUILIST_SetMaxItem( list_id, 2, FALSE );//open and close
            GUILIST_SetOwnSofterKey(list_id,FALSE);

            title_text_id = TXT_ENG_LOG_UART_LOG;
            GUIWIN_SetTitleTextId(win_id, title_text_id, TRUE);

            item_t.item_style    = GUIITEM_STYLE_1RADIO_ENG;
            item_t.item_data_ptr = &item_data;

            item_data.item_content[0].item_data_type    = GUIITEM_DATA_TEXT_ID;
            item_data.item_content[0].item_data.text_id = TXT_COMM_CLOSE;
            GUILIST_AppendItem( list_id, &item_t );
            item_data.item_content[0].item_data.text_id = TXT_OPEN_COMN;
            GUILIST_AppendItem( list_id, &item_t );

            is_open = MMIENG_GetLogUartIsOpen();
            if (!is_open)
            {
                index = 0;
            }
            else
            {
                index = 1;
            }
            GUILIST_SetSelectedItem( list_id,index,TRUE );
            GUILIST_SetCurItemIndex( list_id,index);

            MMK_SetAtvCtrl(win_id, list_id);
        }
        break;
    case MSG_FULL_PAINT:
        break;
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT
    case MSG_CTL_PENOK:
#endif
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        index = GUILIST_GetCurItemIndex(list_id);
        if(0 == index)//close
        {
            is_open = FALSE;
        }
        else if( 1 == index)//open
        {
            is_open = TRUE;
        }
        MMIENG_SetLogUartIsOpen(is_open);
        MMK_CloseWin(win_id);
        break;
    case MSG_CLOSE_WINDOW:
        break;
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

/********************************************************************************
 NAME:
 AUTHOR:        chunjuan.liang
 DATE:          2020.4.24
********************************************************************************/
LOCAL MMI_RESULT_E EngLogSwitchWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{

    int32 index = 0;
    MMI_RESULT_E         result = MMI_RESULT_TRUE;
    int32               list_id = MMIENG_LISTBOX_CTRL_ID;
    MMI_TEXT_ID_T title_text_id = 0;
#ifdef  PLATFORM_ANTISW3
    SCI_TRACE_LOW("EngLogSwitchWinHandleMsg log_option=%d",s_log_option);

    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            GUILIST_ITEM_T      item_t = {0};
            GUILIST_ITEM_DATA_T item_data = {0};

            GUILIST_SetMaxItem( list_id, 2, FALSE );//open and close
            GUILIST_SetOwnSofterKey(list_id,FALSE);
            if(ULOG_AP == s_log_option)
            {
                title_text_id = TXT_ENG_APLOG;
            }else if(ULOG_MODEM == s_log_option)
            {
                title_text_id = TXT_ENG_MODEMLOG;
            }else if(ULOG_WCN == s_log_option)
            {
                title_text_id = TXT_ENG_WCNLOG;
            }
            GUIWIN_SetTitleTextId(win_id, title_text_id, TRUE);

            item_t.item_style    = GUIITEM_STYLE_1RADIO_ENG;
            item_t.item_data_ptr = &item_data;

            item_data.item_content[0].item_data_type    = GUIITEM_DATA_TEXT_ID;
            item_data.item_content[0].item_data.text_id = TXT_COMM_CLOSE;
            GUILIST_AppendItem( list_id, &item_t );
            item_data.item_content[0].item_data.text_id = TXT_OPEN_COMN;
            GUILIST_AppendItem( list_id, &item_t );
#ifndef WIN32
            index = ulog_get_log(s_log_option);
            SCI_TRACE_LOW("ulog_get_log index=%d",index);
#endif
            GUILIST_SetSelectedItem( list_id,index, TRUE );
            GUILIST_SetCurItemIndex( list_id, index);
            MMK_SetAtvCtrl(win_id, list_id);
        }
        break;
    case MSG_FULL_PAINT:
        break;
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT
    case MSG_CTL_PENOK:
#endif
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        index = GUILIST_GetCurItemIndex(list_id);  
        if(0 == index)//close
        {
#ifndef WIN32
            ulog_set_log( s_log_option,0);
#endif
        }
        else if( 1 == index)//open
        {
#ifndef WIN32
            ulog_set_log( s_log_option,1);
#endif
        }
        MMK_CloseWin(win_id);
        break;
    case MSG_CLOSE_WINDOW:
        break;
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
#endif
    return (result);
}
/********************************************************************************
 NAME:
 AUTHOR:        chunjuan.liang
 DATE:          2020.4.24
********************************************************************************/
LOCAL MMI_RESULT_E EngLogToPCWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    int32 index = 0;
    MMI_RESULT_E         result = MMI_RESULT_TRUE;
    int32               list_id = MMIENG_LISTBOX_CTRL_ID;
    MMI_TEXT_ID_T title_text_id = 0;
#ifdef  PLATFORM_ANTISW3
    SCI_TRACE_LOW("EngLogToPCWinHandleMsg s_log_option=%d",s_log_option);

    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            GUILIST_ITEM_T      item_t = {0};
            GUILIST_ITEM_DATA_T item_data = {0};

            GUILIST_SetMaxItem( list_id, 2, FALSE );//open and close
            GUILIST_SetOwnSofterKey(list_id,FALSE);
            if(ULOG_AP == s_log_option)
            {
                title_text_id = TXT_ENG_APLOG;
            }else if(ULOG_MODEM == s_log_option)
            {
                title_text_id = TXT_ENG_MODEMLOG;
            }else if(ULOG_WCN == s_log_option)
            {
                title_text_id = TXT_ENG_WCNLOG;
            }
            GUIWIN_SetTitleTextId(win_id, title_text_id, TRUE);

            item_t.item_style    = GUIITEM_STYLE_1RADIO_ENG;
            item_t.item_data_ptr = &item_data;

            item_data.item_content[0].item_data_type    = GUIITEM_DATA_TEXT_ID;
            item_data.item_content[0].item_data.text_id = TXT_ENG_LOGTOPHONE;
            GUILIST_AppendItem( list_id, &item_t );
            item_data.item_content[0].item_data.text_id = TXT_ENG_LOGTOPC;
            GUILIST_AppendItem( list_id, &item_t );

#ifndef WIN32
            index = ulog_get_log2pc(s_log_option);
            SCI_TRACE_LOW("ulog_get_log2pc index=%d",index);
#endif
            GUILIST_SetSelectedItem( list_id,index, TRUE );
            GUILIST_SetCurItemIndex( list_id, index);
            MMK_SetAtvCtrl(win_id, list_id);
        }
        break;
    case MSG_FULL_PAINT:
        break;
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT
    case MSG_CTL_PENOK:
#endif
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        index = GUILIST_GetCurItemIndex(list_id);
        if(0 == index)//to phone
        {
#ifndef WIN32
            ulog_set_log2pc( s_log_option,0);
#endif
        }
        else if( 1 == index)//to Tcard
        {
#ifndef WIN32
            ulog_set_log2pc( s_log_option,1);
#endif
        }
        MMK_CloseWin(win_id);
        break;
    case MSG_CLOSE_WINDOW:
        break;
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
#endif
    return (result);
}
WINDOW_TABLE(MMIENG_LOG_SWITCH_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngLogSwitchWinHandleMsg),
    WIN_ID(MMIENG_LOG_SWITCH_WIN_ID),
    WIN_TITLE(TXT_NULL),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_LOG_TOPC_WIN_TAB) = 
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngLogToPCWinHandleMsg),
    WIN_ID(MMIENG_LOG_TOPC_WIN_ID),
    WIN_TITLE(TXT_NULL),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};

WINDOW_TABLE(MMIENG_LOG_UART_WIN_TAB) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngLogUartWinHandleMsg),
    WIN_ID(MMIENG_LOG_UART_WIN_ID),
    WIN_TITLE(TXT_NULL),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};
PUBLIC void MMIENG_OpenSwitchLogWin(uint32 menu_id)
{
#ifdef  PLATFORM_ANTISW3
    switch(menu_id)
    {
        case ID_ENG_LOG_SWITCH_AP:
            s_log_option = ULOG_AP;
            break;
        case ID_ENG_LOG_SWITCH_MODEM:
            s_log_option = ULOG_MODEM;
            break;
        case ID_ENG_LOG_SWITCH_WCN:
            s_log_option = ULOG_WCN;
            break;
        default:
            break;
    }
    SCI_TRACE_LOW("MMIENG_OpenSwitchLogWin s_log_option=%d",s_log_option);
    MMK_CreateWin((uint32)MMIENG_LOG_SWITCH_WIN_TAB,PNULL);
#endif
}
PUBLIC void MMIENG_OpenLogToPCWin(uint32 menu_id)
{
#ifdef  PLATFORM_ANTISW3
    switch(menu_id)
    {
        case ID_ENG_LOG_TOPC_AP:
            s_log_option = ULOG_AP;
            break;
        case ID_ENG_LOG_TOPC_MODEM:
            s_log_option = ULOG_MODEM;
            break;
            case ID_ENG_LOG_TOPC_WCN:
            s_log_option = ULOG_WCN;
            break;
        default:
            break;
    }
    SCI_TRACE_LOW("MMIENG_OpenLogToPCWin s_log_option=%d",s_log_option);
    MMK_CreateWin((uint32)MMIENG_LOG_TOPC_WIN_TAB,PNULL);
#endif
}
PUBLIC void MMIENG_OpenUartLogWin(void)
{
    MMK_CreateWin((uint32)MMIENG_LOG_UART_WIN_TAB,PNULL);
}

//================================================================================================//
//================================     ENG MEM PRESS TEST START      =============================//
//================================================================================================//

#include "mem_sim_eng_data.h"
#include "mmicom_trace.h"

#define UDISK_ENG_FOLDER       "D:\\UDISKTEST"
#define UDISK_ENG_FILE_FOLDER  "D:\\UDISKTEST\\"
#define SD_ENG_FOLDER          "E:\\SDTEST"
#define SD_ENG_FILE_FOLDER     "E:\\SDTEST\\"
#define ENG_FILE_EXTENSION     "txt"

#define MEM_ENG_TIMER_OUT               (40)
#define ENG_MEM_PRESS_LIST_NUM          (2)
#define ENG_MEM_PRESS_FOLDER_NAME_LEN   (64)
#define ENG_MEM_FILE_SIZE               (300)// 单位: KB
typedef enum
{
    MEM_PRESS_TYPE_FOR_UDISK,
    MEM_PRESS_TYPE_FOR_SD,
    MEM_PRESS_TYPE_MAX
} ENG_MEM_PRESS_TEST_TYPE_E;

typedef enum
{
    MEM_ENG_MSG_DEFAULT,
    MEM_ENG_MSG_RUN,
    MEM_ENG_MSG_STOP,
    MEM_ENG_MSG_REPEAT,
    MEM_ENG_MSG_ERROR
} ENG_MEM_PRESS_TEST_MSG_E;

static uint32   s_mem_eng_file_index = 0;
static uint8    s_mem_eng_timer_id   = 0;
static uint8    s_mem_eng_stop_flag  = 0;
static ENG_MEM_PRESS_TEST_MSG_E  s_mem_eng_msg_flag= MEM_ENG_MSG_DEFAULT;
static ENG_MEM_PRESS_TEST_TYPE_E s_mem_eng_type    = MEM_PRESS_TYPE_MAX;

LOCAL SFS_ERROR_E MEM_EngCheckDeviceExist(void)
{
    MMIFILE_DEVICE_E device = MMI_DEVICE_NUM;
    SFS_ERROR_E error = SFS_ERROR_NONE;

    TRACE_APP_ENGINEERMODE("s_mem_eng_type = %d",s_mem_eng_type);
    if( s_mem_eng_type == MEM_PRESS_TYPE_FOR_UDISK)
    {
        device = MMI_DEVICE_UDISK;
    }
    else if( s_mem_eng_type == MEM_PRESS_TYPE_FOR_SD)
    {
        device = MMI_DEVICE_SDCARD;
    }
    else
    {
        TRACE_APP_ENGINEERMODE("get device path failed , s_mem_eng_type = %d",s_mem_eng_type);
    }

    if (MMIAPIFMM_GetDeviceStatus (MMIAPIFMM_GetDevicePath(device), MMIAPIFMM_GetDevicePathLen(device))) //设备已经注册了
    {
        error = SFS_ERROR_NONE;
        TRACE_APP_ENGINEERMODE("MEM is Exist");
    }
    else
    {
        MMIAPIFMM_RegisterDevice(MMIAPIFMM_GetDevicePath(device), MMIAPIFMM_GetDevicePathLen(device));
        error = MMIAPIFMM_GetDeviceStatus(MMIAPIFMM_GetDevicePath(device), MMIAPIFMM_GetDevicePathLen(device));
        if(error !=SFS_ERROR_NONE)
        {
            TRACE_APP_ENGINEERMODE("MEM is Register succeed");
        }
        else
        {
            TRACE_APP_ENGINEERMODE("MEM is Register failed,error = %d",error);
        }
    }

    return error;
}
LOCAL BOOLEAN MEM_EngCreateDirectoryDir(void)
{
    wchar full_path_name[MMIFILE_FULL_PATH_MAX_LEN+2] = {0};
    int full_path_len = 0;
    BOOLEAN result = TRUE;

    TRACE_APP_ENGINEERMODE("creat folder,s_mem_eng_type = %d",s_mem_eng_type);
    if( s_mem_eng_type == MEM_PRESS_TYPE_FOR_UDISK)
    {
        full_path_len = strlen(UDISK_ENG_FOLDER);
        MMI_STRNTOWSTR(full_path_name,MMIFILE_FULL_PATH_MAX_LEN, (char *) UDISK_ENG_FOLDER,full_path_len,full_path_len);
    }
    else if( s_mem_eng_type == MEM_PRESS_TYPE_FOR_SD)
    {
        full_path_len = strlen(SD_ENG_FOLDER);
        MMI_STRNTOWSTR(full_path_name,MMIFILE_FULL_PATH_MAX_LEN, (char *) SD_ENG_FOLDER,full_path_len,full_path_len);
    }
    else
    {
        TRACE_APP_ENGINEERMODE("MEM_EngCreateDirectoryDir failed , s_mem_eng_type = %d",s_mem_eng_type);
    }

    full_path_len = MMIAPICOM_Wstrlen(full_path_name);
    if (!MMIAPIFMM_IsFolderExist (full_path_name, full_path_len))
    {
        result = MMIAPIFMM_CreateDir (full_path_name, full_path_len);
    }

    return result;
}

LOCAL void MEM_EngDelDirectoryDir(void)
{
    wchar path_d[] = L"d:";
    wchar path_e[] = L"e:";
    int full_file_len = 0;
    wchar full_filename[MMIFILE_FULL_PATH_MAX_LEN +1]= {0};
    char strfilename[MMIFILE_FULL_PATH_MAX_LEN + 1]= {0};

    TRACE_APP_ENGINEERMODE("delete folder,s_mem_eng_type = %d",s_mem_eng_type);

    if( s_mem_eng_type == MEM_PRESS_TYPE_FOR_UDISK)
    {
        strcpy(strfilename,"UDISKTEST");
        full_file_len = strlen(strfilename);
        MMI_STRNTOWSTR(full_filename,MMIFILE_FULL_PATH_MAX_LEN, (char *) strfilename,MMIFILE_FULL_PATH_MAX_LEN,full_file_len);
        MMIAPIFMM_DeleteTree(path_d, full_filename);
    }
    else if( s_mem_eng_type == MEM_PRESS_TYPE_FOR_SD)
    {
        strcpy(strfilename,"SDTEST");
        full_file_len = strlen(strfilename);
        MMI_STRNTOWSTR(full_filename,MMIFILE_FULL_PATH_MAX_LEN, (char *) strfilename,MMIFILE_FULL_PATH_MAX_LEN,full_file_len);
        MMIAPIFMM_DeleteTree(path_e, full_filename);
    }
    else
    {
        TRACE_APP_ENGINEERMODE("delete folder failed , s_mem_eng_type = %d",s_mem_eng_type);
    }

}

LOCAL void MEM_EngGenerateFileName(char *str,uint32 index)
{
    TRACE_APP_ENGINEERMODE("s_mem_eng_type = %d",s_mem_eng_type);
    if (str == NULL)
    {
        return;
    }
    else
    {
        char date_char[20] = {0};
        char time_char[20] = {0};
        SCI_DATE_T  sys_date = {0};
        SCI_TIMEX_T time_ptr = {0};

        TM_GetSysDate(&sys_date);
        sprintf(date_char,"%02d%02d",sys_date.mon,sys_date.mday);

        TM_GetSysTimeEx(&time_ptr);
        sprintf(time_char,"%02d%02d%02d_%05d",time_ptr.hour,time_ptr.min,time_ptr.sec,index);

        if( s_mem_eng_type == MEM_PRESS_TYPE_FOR_UDISK)
        {
            sprintf(str, "%s%s%s.%s", UDISK_ENG_FILE_FOLDER,date_char,time_char,ENG_FILE_EXTENSION);
        }
        else if( s_mem_eng_type == MEM_PRESS_TYPE_FOR_SD)
        {
            sprintf(str, "%s%s%s.%s", SD_ENG_FILE_FOLDER,date_char,time_char,ENG_FILE_EXTENSION);
        }
        else
        {
            TRACE_APP_ENGINEERMODE("set file name failed , s_mem_eng_type = %d",s_mem_eng_type);
        }
    }
}

LOCAL MMIFILE_HANDLE MEM_EngCreatefile(char* strfilename, int full_file_len,BOOLEAN is_write)
{
    wchar full_filename[ENG_MEM_PRESS_FOLDER_NAME_LEN +1]= {0};
    MMIFILE_HANDLE hFile = NULL;

    TRACE_APP_ENGINEERMODE("creat file,strfilename = %s",strfilename);
    MMI_STRNTOWSTR(full_filename,ENG_MEM_PRESS_FOLDER_NAME_LEN, (char *) strfilename,ENG_MEM_PRESS_FOLDER_NAME_LEN,full_file_len);

    if(is_write)
    {
        if (!MMIAPIFMM_IsFileExist(full_filename,MMIAPICOM_Wstrlen(full_filename)))
        {
            hFile = MMIAPIFMM_CreateFile(full_filename, SFS_MODE_WRITE | SFS_MODE_CREATE_NEW, NULL, NULL);
        }
        else
        {
            TRACE_APP_ENGINEERMODE("this file has already exist!");
        }
    }
    else
    {
        if (MMIAPIFMM_IsFileExist(full_filename,MMIAPICOM_Wstrlen(full_filename)))
        {
            hFile = MMIAPIFMM_CreateFile(full_filename, SFS_MODE_READ | SFS_MODE_OPEN_EXISTING, NULL, NULL);
        }
        else
        {
            TRACE_APP_ENGINEERMODE("this file has not exist!");
        }
    }

    TRACE_APP_ENGINEERMODE("get file handle(%d),hFile = %d",is_write,hFile);
    return hFile;
}

LOCAL uint8 MEM_EngGenFile(uint32 index)
{
    uint32 data_size = MEM_SIM_ENG_DATA_SIZE;
    uint32 buf_write = 0;
    uint32 buf_read = 0;
    uint32 i = 0;
    uint8 *data_buf_ptr = NULL;
    char strfilename[ENG_MEM_PRESS_FOLDER_NAME_LEN + 1]= {0};
    int full_file_len = 0;
    MMIFILE_HANDLE hHandle = 0;

    //1.获取将要创建的文件全路径名称
    MEM_EngGenerateFileName(strfilename,index);
    full_file_len = strlen(strfilename);

    //2.创建文件并写入数据
    hHandle = MEM_EngCreatefile(strfilename,full_file_len,TRUE);
    if (hHandle == 0)
    {
        MMIAPIFMM_CloseFile(hHandle);
        return 0;
    }

    for (i = 0; i < 1000; i++)
    {
        MMIAPIFMM_WriteFile(hHandle, mem_eng_file_memo, data_size, &buf_write, NULL);
        if (buf_write == 0)
        break;
    }
    MMIAPIFMM_CloseFile(hHandle);
    if (buf_write == 0)
    {
        TRACE_APP_ENGINEERMODE("buf_write failed");
        return 0;
    }

    //3.读取文件并与指定数组比较，判断写入是否成功
    hHandle = MEM_EngCreatefile(strfilename,full_file_len,FALSE);
    if (hHandle == 0)
    {
        MMIAPIFMM_CloseFile(hHandle);
        return 0;
    }

    data_buf_ptr = SCI_ALLOCA(sizeof(uint8)*data_size);
    if(NULL == data_buf_ptr)
    {
        MMIAPIFMM_CloseFile(hHandle);
        TRACE_APP_ENGINEERMODE("alloca data_buf_ptr mem failed");
        return 0;
    }
    for (i = 0; i < 1000; i++)
    {
        SCI_MEMSET( data_buf_ptr, 0x00, data_size);
        MMIAPIFMM_ReadFile(hHandle, data_buf_ptr, data_size, &buf_read, NULL);
        if (buf_read == 0)
            break;
        if(0 != SCI_MEMCMP(mem_eng_file_memo,data_buf_ptr,data_size))
        {
            if(data_buf_ptr != PNULL)
            {
                SCI_FREE(data_buf_ptr);
                data_buf_ptr = PNULL;
            }
            MMIAPIFMM_CloseFile(hHandle);
            TRACE_APP_ENGINEERMODE("compare file failed");
            return 0;
        }
    }

    //4.释放空间，关闭文件
    if(data_buf_ptr != PNULL)
    {
        SCI_FREE(data_buf_ptr);
        data_buf_ptr = PNULL;
    }
    MMIAPIFMM_CloseFile(hHandle);
    if (buf_read == 0)
    {
        TRACE_APP_ENGINEERMODE("buf_read failed");
        return 0;
    }

    TRACE_APP_ENGINEERMODE("write and read file pass,index = %d",index);

    return 1;
}

LOCAL void MEM_EngPressTimerStart(MMI_WIN_ID_T win_id)
{
    TRACE_APP_ENGINEERMODE("start s_mem_eng_stop_flag = %d",s_mem_eng_stop_flag);
    s_mem_eng_stop_flag = 0;
    if (s_mem_eng_timer_id != 0)
    {
        MMK_StopTimer(s_mem_eng_timer_id);
        s_mem_eng_timer_id = 0;
    }

    s_mem_eng_file_index = 0;

    if( SFS_NO_ERROR != MEM_EngCheckDeviceExist())
    {
        TRACE_APP_ENGINEERMODE("device is not exist!");
    }
    if(FALSE == MEM_EngCreateDirectoryDir())
    {
        TRACE_APP_ENGINEERMODE("create folder failed!");
    }

    s_mem_eng_timer_id = MMK_CreateWinTimer(win_id, MEM_ENG_TIMER_OUT, FALSE);
    s_mem_eng_msg_flag = MEM_ENG_MSG_RUN;
    MMK_PostMsg(win_id, MSG_FULL_PAINT, PNULL,0);

}

LOCAL void MEM_EngPressTimerStop(MMI_WIN_ID_T win_id)
{
    TRACE_APP_ENGINEERMODE("stop_flag = %d, timer_id = %d",s_mem_eng_stop_flag,s_mem_eng_timer_id);

    s_mem_eng_msg_flag = MEM_ENG_MSG_STOP;

    MMK_PostMsg(win_id, MSG_FULL_PAINT, PNULL,0);

    s_mem_eng_stop_flag = 1;
    if (s_mem_eng_timer_id == 0)
    {
        s_mem_eng_msg_flag = MEM_ENG_MSG_DEFAULT;
        MMK_CloseWin(MMIENG_MEM_PRESS_TEST_WIN_ID);
    }
}

LOCAL void MEM_EngPressTimerOut(MMI_WIN_ID_T win_id)
{
    MMIFILE_DEVICE_E device = MMI_DEVICE_NUM;
    uint32 freeSpaceHigh = 0;
    uint32 freeSpaceLow = 0;
    uint32 totalFreeSpace = 0;
    BOOLEAN result =FALSE;

    TRACE_APP_ENGINEERMODE("s_mem_eng_stop_flag = %d",s_mem_eng_stop_flag);

    if (s_mem_eng_timer_id != 0)
    {
        MMK_StopTimer(s_mem_eng_timer_id);
        s_mem_eng_timer_id = 0;
    }

    // 1.判断当前是否执行cancel操作
    if (s_mem_eng_stop_flag)
    {
        MEM_EngDelDirectoryDir();
        MMK_CloseWin(MMIENG_MEM_PRESS_TEST_WIN_ID);
        s_mem_eng_msg_flag = MEM_ENG_MSG_DEFAULT;
        return;
    }

    //2.判断U盘内存剩余空间
    if( s_mem_eng_type == MEM_PRESS_TYPE_FOR_UDISK)
    {
        device = MMI_DEVICE_UDISK;
    }
    else if( s_mem_eng_type == MEM_PRESS_TYPE_FOR_SD)
    {
        device = MMI_DEVICE_SDCARD;
    }
    else
    {
        TRACE_APP_ENGINEERMODE("get device path failed , s_mem_eng_type = %d",s_mem_eng_type);
    }
    result = MMIAPIFMM_GetDeviceFreeSpace(MMIAPIFMM_GetDevicePath(device),
                                 MMIAPIFMM_GetDevicePathLen(device),
                                 &freeSpaceHigh,
                                 &freeSpaceLow);
    totalFreeSpace = (freeSpaceHigh << 22) | (freeSpaceLow >> 10);

    //3.当U盘内存剩余空间小于单个文件大小时，删除整个文件夹，重新开始新的循环
    if(totalFreeSpace < ENG_MEM_FILE_SIZE)
    {
        s_mem_eng_file_index = 0;
        s_mem_eng_msg_flag = MEM_ENG_MSG_REPEAT;

        MMK_SendMsg(win_id, MSG_FULL_PAINT, PNULL);
        MEM_EngDelDirectoryDir();
        MEM_EngPressTimerStart(win_id);
        return;
    }

    //4.创建/写入/读取/对比 文件，如有出错，则删除整个文件，结束循环；反之，创建的index++
    if (!MEM_EngGenFile(s_mem_eng_file_index))
    {
        s_mem_eng_file_index = 0;
        s_mem_eng_msg_flag = MEM_ENG_MSG_ERROR;
        MMK_SendMsg(win_id, MSG_FULL_PAINT, PNULL);
        MEM_EngDelDirectoryDir();
        return;
    }
    else
    {
        s_mem_eng_file_index++;
    }

    //5.启动下一个Timer
    s_mem_eng_timer_id = MMK_CreateWinTimer(win_id, MEM_ENG_TIMER_OUT, FALSE);
    return;

}

/********************************************************************************
 NAME:          EngMemPressTestWinHandleMsg
 DESCRIPTION:
 PARAM IN:      win_id
                msg_id
                param
 PARAM OUT:
 AUTHOR:        fangfang.yao
 DATE:          2020.04.20
********************************************************************************/
LOCAL MMI_RESULT_E EngMemPressTestWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_STRING_T text = {0};
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    wchar wstr[200]={0};
    char str[100] = {0};
    uint16 len = 0;

    TRACE_APP_ENGINEERMODE("mem press test Enter!");
    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            MMI_TEXT_ID_T title_id = 0;
            MMK_SetAtvCtrl(win_id, MMIENG_TEXTBOX1_CTRL_ID);

            if( s_mem_eng_type == MEM_PRESS_TYPE_FOR_UDISK)
            {
                title_id = TXT_ENG_UDISK_PRESS_INFO;
            }
            else if( s_mem_eng_type == MEM_PRESS_TYPE_FOR_SD)
            {
                title_id = TXT_ENG_SD_PRESS_INFO;
            }
            else
            {
                TRACE_APP_ENGINEERMODE("set win title failed , s_mem_eng_type = %d",s_mem_eng_type);
            }
            GUITITLE_SetTextId(win_id,MMITHEME_GetTitleCtrlId(),title_id, FALSE);
        }
        break;

        case MSG_CTL_OK:
        {
            MEM_EngPressTimerStart(win_id);
        }
        break;

        case MSG_CTL_MIDSK:
        case MSG_CTL_CANCEL:
        case MSG_KEYDOWN_RED:
        {
            MEM_EngPressTimerStop(win_id);
        }
        break;

        case MSG_TIMER:
        {
            MEM_EngPressTimerOut(win_id);
        }
        break;
        case MSG_FULL_PAINT:
        {
            memset(str,0,sizeof(str));
            if (s_mem_eng_msg_flag == MEM_ENG_MSG_RUN)
            {
                if( s_mem_eng_type == MEM_PRESS_TYPE_FOR_UDISK)
                {
                    strcpy(str,"UDISK test running ...");
                }
                else if( s_mem_eng_type == MEM_PRESS_TYPE_FOR_SD)
                {
                    strcpy(str,"SD test running ...");
                }
                else
                {
                    strcpy(str,"type get wrong ...");
                }
            }
            else if (s_mem_eng_msg_flag == MEM_ENG_MSG_STOP)
            {
                if( s_mem_eng_type == MEM_PRESS_TYPE_FOR_UDISK)
                {
                    strcpy(str,"Delete udisk test infor,Please wait ...");
                }
                else if( s_mem_eng_type == MEM_PRESS_TYPE_FOR_SD)
                {
                    strcpy(str,"Delete sd test infor,Please wait ...");
                }
                else
                {
                    strcpy(str,"type get wrong ...");
                }
            }
            else if(s_mem_eng_msg_flag == MEM_ENG_MSG_REPEAT)
            {
                if( s_mem_eng_type == MEM_PRESS_TYPE_FOR_UDISK)
                {
                    strcpy(str,"End of cycle,Delete udisk test infor,Please wait ...");
                }
                else if( s_mem_eng_type == MEM_PRESS_TYPE_FOR_SD)
                {
                    strcpy(str,"End of cycle,Delete sd test infor,Please wait ...");
                }
                else
                {
                    strcpy(str,"type get wrong ...");
                }
            }
            else if(s_mem_eng_msg_flag == MEM_ENG_MSG_ERROR)
            {
                if( s_mem_eng_type == MEM_PRESS_TYPE_FOR_UDISK)
                {
                    strcpy(str,"Run udisk card press test,write or read may be wrong .");
                }
                else if( s_mem_eng_type == MEM_PRESS_TYPE_FOR_SD)
                {
                    strcpy(str,"Run sd card press test,write or read may be wrong .");
                }
                else
                {
                    strcpy(str,"type get wrong ...");
                }
            }
            else
            {
                if( s_mem_eng_type == MEM_PRESS_TYPE_FOR_UDISK)
                {
                    strcpy(str,"Use left soft key to run udisk card press test,and use right soft key to stop .");
                }
                else if( s_mem_eng_type == MEM_PRESS_TYPE_FOR_SD)
                {
                    strcpy(str,"Use left soft key to run sd card press test,and use right soft key to stop .");
                }
                else
                {
                    strcpy(str,"type get wrong ...");
                }
            }

            len = strlen(str);
            text.wstr_ptr = wstr;
            text.wstr_len = len;
            MMI_STRNTOWSTR( wstr, 200, (uint8*)str, len, len );
            GUITEXT_SetString(MMIENG_TEXTBOX1_CTRL_ID, text.wstr_ptr, text.wstr_len, TRUE);
            GUIWIN_SetSoftkeyTextId(win_id,  (MMI_TEXT_ID_T)TXT_ENG_SIM_PRESS_RUN, (MMI_TEXT_ID_T)TXT_NULL, (MMI_TEXT_ID_T)TXT_ENG_SIM_PRESS_STOP, TRUE);
        }
        break;
        default:
            result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

LOCAL MMI_RESULT_E EngMemPressTestEnterWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_COMMON_CTRL1_ID;
    uint16       cur_selection = 0;

    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            MMK_SetAtvCtrl(win_id,ctrl_id);
        }
        break;

        case MSG_CTL_MIDSK:
        case MSG_CTL_OK:
        {
            cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
            if(0 == cur_selection)
            {
                // udisk
                s_mem_eng_type = MEM_PRESS_TYPE_FOR_UDISK;
                MMK_CreateWin((uint32*)MMIENG_MEM_PRESS_TEST_WIN_TAB,   PNULL);
            }else if(1 == cur_selection)
            {
                //sd
                s_mem_eng_type = MEM_PRESS_TYPE_FOR_SD;
                MMK_CreateWin((uint32*)MMIENG_MEM_PRESS_TEST_WIN_TAB,   PNULL);
            }
            else
            {
                TRACE_APP_ENGINEERMODE("get index failed, cur_selection = %d",cur_selection);
            }
        }
        break;

        case MSG_CTL_CANCEL:
        case MSG_KEYDOWN_RED:
        {
            MMK_CloseWin( win_id );
        }
        break;

        case MSG_FULL_PAINT:
        {
            GUILIST_ITEM_T  item_t = {0};
            GUILIST_ITEM_DATA_T item_data = {0};
            uint16 curIndex = GUILIST_GetCurItemIndex(ctrl_id);

            GUILIST_SetMaxItem(ctrl_id,ENG_MEM_PRESS_LIST_NUM, FALSE );//max item 2 open and close
            GUILIST_SetOwnSofterKey( ctrl_id, FALSE );

            item_t.item_style    = GUIITEM_STYLE_1STR_ENG;
            item_t.item_data_ptr = &item_data;

            item_data.item_content[0].item_data_type  = GUIITEM_DATA_TEXT_ID;

            item_data.item_content[0].item_data.text_id = TXT_ENG_UDISK_PRESS_INFO;
            GUILIST_AppendItem( ctrl_id, &item_t );
            //item_data.item_content[0].item_data.text_id = TXT_ENG_SD_PRESS_INFO;
            //GUILIST_AppendItem( ctrl_id, &item_t );

            //set selected item
            GUILIST_SetSelectedItem(ctrl_id, curIndex, TRUE);

            //set current item
            GUILIST_SetCurItemIndex(ctrl_id, curIndex);
        }
        break;
        case MSG_CLOSE_WINDOW:
        {
            s_mem_eng_type = MEM_PRESS_TYPE_MAX;
        }
        break;

        default:
            result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}
//================================================================================================//
//================================     ENG MEM PRESS TEST END      ===============================//
//================================================================================================//

#ifdef MP3_SUPPORT
/********************************************************************************/
// NAME:          EngMp3PlayWinHandleMsg
// DESCRIPTION:
// PARAM IN:
// PARAM OUT:
// AUTHOR:        chunjuan.liang
// DATE:          2004.09.08
/********************************************************************************/
LOCAL MMI_RESULT_E EngMp3PlayWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_STRING_T text = {0};
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    BOOLEAN      play_ret = FALSE;
    const wchar mp3_file_name_phone[] = {'D', ':','\\', 'A', 'u', 'd', 'i', 'o', '\\', 't', 'e', 's', 't', '.', 'm', 'p', '3', 0};
    const wchar mp3_file_name_sd[] = {'E', ':','\\', 'A', 'u', 'd', 'i',  'o', '\\', 't', 'e', 's', 't', '.', 'm', 'p', '3', 0};
    uint8       mp3_vol = MMIAPISET_GetCallRingVolume();

    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
            GUILABEL_SetFont(MMIENG_LABEL1_CTRL_ID,SONG_FONT_22,MMI_BLACK_COLOR);

            if (0 == mp3_vol)
            {
                mp3_vol = 3;
            }
            if(MMIAPIFMM_IsFileExist(mp3_file_name_phone, MMIAPICOM_Wstrlen(mp3_file_name_phone)))
            {
                text.wstr_ptr = mp3_file_name_phone;
                play_ret = MMIAPIFMM_PlayMusicFileEx(MMISET_RING_TYPE_OTHER,FALSE,FALSE,
                                           mp3_file_name_phone,MMIAPICOM_Wstrlen(mp3_file_name_phone),
                                           0xffff,0,mp3_vol,PNULL);
                text.wstr_ptr = mp3_file_name_phone;
                text.wstr_len = MMIAPICOM_Wstrlen(mp3_file_name_phone);
                SCI_TRACE_LOW("EngMp3PlayWinHandleMsg PLAY phone mp3 file ret = %d",play_ret);
            }else if(MMIAPIFMM_IsFileExist(mp3_file_name_sd, MMIAPICOM_Wstrlen(mp3_file_name_sd)))
            {
                text.wstr_ptr = mp3_file_name_sd;
                text.wstr_len = MMIAPICOM_Wstrlen(mp3_file_name_phone);
                play_ret = MMIAPIFMM_PlayMusicFileEx(MMISET_RING_TYPE_OTHER,FALSE,FALSE,
                                               mp3_file_name_sd,MMIAPICOM_Wstrlen(mp3_file_name_sd),
                               0xffff,0,mp3_vol,PNULL);
                SCI_TRACE_LOW("EngMp3PlayWinHandleMsg PLAY sd mp3 file ret = %d",play_ret);
            }
            GUILABEL_SetText(MMIENG_LABEL1_CTRL_ID, &text, FALSE);
            break;

        case MSG_FULL_PAINT:
            {
                GUI_RECT_T  client_rect = MMITHEME_GetClientRectEx(win_id);
                GUIRES_DisplayImg(PNULL, &client_rect ,  &client_rect,  win_id,
                    IMAGE_COMMON_BG, MMITHEME_GetDefaultLcdDev());
            }
            break;
        case MSG_KEYDOWN_OK:
        case MSG_CTL_OK:
            MMK_CloseWin(win_id);
            break;
        case MSG_KEYDOWN_CANCEL:
        case MSG_CTL_CANCEL:
            MMK_CloseWin(win_id);
            break;

#ifdef TOUCH_PANEL_SUPPORT
        case MSG_CTL_PENOK:
        {
#if defined MMI_PDA_SUPPORT
            MMI_CTRL_ID_T ctrl_id = ((MMI_NOTIFY_T*) param)->src_id;
            if( MMICOMMON_BUTTON_SOFTKEY_LEFT_CTRL_ID == ctrl_id)
            {
                MMK_SendMsg(win_id, MSG_APP_OK, PNULL);
            }
            else if( MMICOMMON_BUTTON_SOFTKEY_RIGHT_CTRL_ID == ctrl_id)
            {
                MMK_SendMsg(win_id, MSG_APP_CANCEL, PNULL);
            }
#endif
        }
            break;
#endif
        case MSG_KEYDOWN_UPSIDE:
            // adjust play volume
            if (mp3_vol < MMISET_VOL_MAX)
            {
                mp3_vol++;
            }
            break;
        case MSG_KEYDOWN_DOWNSIDE:
            // adjust play volume
            if (mp3_vol > MMISET_VOL_ONE)
            {
                mp3_vol--;
            }
            break;
        case MSG_KEYDOWN_RED:
            break;
        case MSG_LOSE_FOCUS:
        case MSG_CLOSE_WINDOW:
            // stop play
            MMIAPISET_StopAppRing();
            break;
        default:
            result = MMI_RESULT_FALSE;
            break;
    }
    return (result);
}
PUBLIC void MMIEng_OpenPlayMp3Win(void)
{
    MMK_CreateWin((uint32)MMIENG_MP3PLAY_TEST_TAB,PNULL);
}
#endif

WINDOW_TABLE( MMIENG_LIGHTSLEEP_WIN_TAB ) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC( (uint32)EngLightSleepWinHandleMsg),
    WIN_ID( MMIENG_LIGHTSLEEP_WIN_ID),
    END_WIN
};
PUBLIC void MMIEng_OpenLightSleepWin(void)
{
    MMK_CreateWin(MMIENG_LIGHTSLEEP_WIN_TAB, PNULL);
}
LOCAL MMI_RESULT_E EngLightSleepWinHandleMsg( MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param )
{

    MMI_RESULT_E result = MMI_RESULT_TRUE;
    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
            if(TRUE == MMIDEFAULT_IsBacklightOn())
            {
                MMIDEFAULT_TurnOffBackLight();
                MMIDEFAULT_CloseAllLight_Watch();//close LCD 
#ifndef WIN32
#ifdef  PLATFORM_ANTISW3
                SCI_DRV_EnableLightSleep(DISABLE_LIGHT_SLEEP);
#endif
#endif
            }
            break;
        case MSG_CLOSE_WINDOW:
#ifndef WIN32
#ifdef  PLATFORM_ANTISW3
             SCI_DRV_EnableLightSleep(ENABLE_LIGHT_SLEEP);
#endif
#endif
         break;
        default:
            if(TRUE == MMIDEFAULT_IsBacklightOn())
            {
                MMK_CloseWin(win_id);
            }
            break;
    }
    return (result);
}
LOCAL MMI_RESULT_E EngRegisterPsServiceWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    int32 index = 0;
    MMI_RESULT_E         result = MMI_RESULT_TRUE;
    int32               list_id = MMIENG_LISTBOX_CTRL_ID;
    MMI_TEXT_ID_T title_text_id = 0;
    BOOLEAN is_register_ps_service = FALSE;
#ifdef  PLATFORM_ANTISW3
    SCI_TRACE_LOW("EngLogSwitchWinHandleMsg log_option=%d",s_log_option);
#endif
    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            GUILIST_ITEM_T      item_t = {0};
            GUILIST_ITEM_DATA_T item_data = {0};

            GUILIST_SetMaxItem( list_id, 2, FALSE );//open and close
            GUILIST_SetOwnSofterKey(list_id,FALSE);

            title_text_id = TXT_ENG_REGISTER_PS_SERVICE;

            GUIWIN_SetTitleTextId(win_id, title_text_id, TRUE);

            item_t.item_style    = GUIITEM_STYLE_1RADIO_ENG;
            item_t.item_data_ptr = &item_data;

            item_data.item_content[0].item_data_type    = GUIITEM_DATA_TEXT_ID;
            item_data.item_content[0].item_data.text_id = TXT_ENG_IQ_DATA_ENABLE;
            GUILIST_AppendItem( list_id, &item_t );
            item_data.item_content[0].item_data.text_id = TXT_ENG_IQ_DATA_DISABLE;
            GUILIST_AppendItem( list_id, &item_t );

            is_register_ps_service = MMIAPIENG_GetRegisterPsServiceEnable();
            index = (is_register_ps_service == TRUE) ? 0 : 1;

            GUILIST_SetSelectedItem( list_id,index, TRUE );
            GUILIST_SetCurItemIndex( list_id, index);
            MMK_SetAtvCtrl(win_id, list_id);
        }
        break;
    case MSG_FULL_PAINT:
        break;
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT
    case MSG_CTL_PENOK:
#endif
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        index = GUILIST_GetCurItemIndex(list_id);
        if(0 == index)//enable Register Ps Service
        {
            MMIAPIENG_SetRegisterPsServiceEnable(TRUE);
        }
        else if( 1 == index)//disable Register Ps Service
        {
            MMIAPIENG_SetRegisterPsServiceEnable(FALSE);
        }
        MMK_CloseWin(win_id);
        break;
    case MSG_CLOSE_WINDOW:
        break;
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

WINDOW_TABLE(MMIENG_REGISTER_PS_SERVICE_WIN_TAB) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngRegisterPsServiceWinHandleMsg),
    WIN_ID(MMIENG_REGISTER_PS_SERVICE_WIN_ID),
    WIN_TITLE(TXT_NULL),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    CREATE_LISTBOX_CTRL(GUILIST_RADIOLIST_E, MMIENG_LISTBOX_CTRL_ID),
    END_WIN
};


PUBLIC void MMIENG_OpenRegisterPsServiceWin(void)
{
    MMK_CreateWin((uint32)MMIENG_REGISTER_PS_SERVICE_WIN_TAB,PNULL);
}

static BOOLEAN  s_eng_memcheck_flag = FALSE;
/********************************************************************************
 NAME:          EngMemCheckWinHandleMsg
 AUTHOR:        chunjuan.liang
 DATE:          2020.7.24
********************************************************************************/
PUBLIC MMI_RESULT_E EngMemCheckWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    uint16 index = 0;
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    int32 list_id = MMIENG_LISTBOX_CTRL_ID;

    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            GUILIST_ITEM_T      item_t = {0};
            GUILIST_ITEM_DATA_T item_data = {0};

            GUIWIN_SetTitleTextId(win_id, TXT_ENG_MEMCHECK_TEST, FALSE);
            GUILIST_SetMaxItem( list_id, 2, FALSE );//open and close
            GUILIST_SetOwnSofterKey(list_id,FALSE);

            item_t.item_style    = GUIITEM_STYLE_1RADIO_ENG;
            item_t.item_data_ptr = &item_data;

            item_data.item_content[0].item_data_type    = GUIITEM_DATA_TEXT_ID;
            item_data.item_content[0].item_data.text_id = TXT_OPEN_COMN;
            GUILIST_AppendItem( list_id, &item_t );
            item_data.item_content[0].item_data.text_id = TXT_COMM_CLOSE;
            GUILIST_AppendItem( list_id, &item_t );

            if(FALSE == s_eng_memcheck_flag)
            {
                index = 1;
            }

            GUILIST_SetSelectedItem( list_id,index, TRUE );
            GUILIST_SetCurItemIndex( list_id, index);
            MMK_SetAtvCtrl(win_id, list_id);
        }
        break;
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT
    case MSG_CTL_PENOK:
#endif
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        index = GUILIST_GetCurItemIndex(list_id);
        if(0 == index)
        {
            s_eng_memcheck_flag = TRUE;
        }
        else if( 1 == index)
        {
            s_eng_memcheck_flag = FALSE;
        }
        MMK_CloseWin(win_id);
        break;
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

PUBLIC BOOLEAN MMIAPIENG_GetMemCheckFlag(void)
{
    TRACE_APP_ENGINEERMODE("s_eng_memcheck_flag =%d",s_eng_memcheck_flag);
    return s_eng_memcheck_flag;
}

//================================================================================================//
//================================    ENG LIST PRESS TEST START    ===============================//
//================================================================================================//
#ifdef TOUCH_PANEL_SUPPORT
#define ENG_LIST_PRESS_TEST_LIST_NUM          (2)

LOCAL MMI_RESULT_E EngListPressTestHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_COMMON_CTRL1_ID;

    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            MMK_SetAtvCtrl(win_id,ctrl_id);
        }
        break;

        case MSG_CTL_MIDSK:
        case MSG_CTL_OK:
#ifdef TOUCH_PANEL_SUPPORT
        case MSG_CTL_PENOK:
#endif
        {
            uint16       cur_selection = 0;
            cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
            if(0 == cur_selection)
            {
                MMK_CreateWin((uint32*)MMIENG_LIST_NEED_HIGHBAR_WIN_TAB,   PNULL);
            }else if(1 == cur_selection)
            {
                MMK_CreateWin((uint32*)MMIENG_LIST_SUPPORT_LEFT_SLIDE_WIN_TAB,   PNULL);
            }
            else
            {
                TRACE_APP_ENGINEERMODE("get index failed, cur_selection = %d",cur_selection);
            }
        }
        break;

        case MSG_CTL_CANCEL:
        case MSG_KEYDOWN_RED:
        {
            MMK_CloseWin( win_id );
        }
        break;

        case MSG_FULL_PAINT:
        {
            GUILIST_ITEM_T  item_t = {0};
            GUILIST_ITEM_DATA_T item_data = {0};
            uint16 curIndex = GUILIST_GetCurItemIndex(ctrl_id);

            GUILIST_SetMaxItem(ctrl_id,ENG_LIST_PRESS_TEST_LIST_NUM, FALSE );
            //max item 2 open and close
            GUILIST_SetOwnSofterKey( ctrl_id, FALSE );

            item_t.item_style    = GUIITEM_STYLE_1STR;
            item_t.item_data_ptr = &item_data;

            item_data.item_content[0].item_data_type  = GUIITEM_DATA_TEXT_ID;
            item_data.item_content[0].item_data.text_id = TXT_LIST_NEED_HIGHBAR_IF_CLICK;
            GUILIST_AppendItem( ctrl_id, &item_t );
            item_data.item_content[0].item_data.text_id = TXT_LIST_SUPPORT_LEFT_SLIDE;
            GUILIST_AppendItem( ctrl_id, &item_t );

            //set selected item
            GUILIST_SetSelectedItem(ctrl_id, curIndex, TRUE);

            //set current item
            GUILIST_SetCurItemIndex(ctrl_id, curIndex);

            //set list split line
            GUILIST_SetListState( ctrl_id, GUILIST_STATE_SPLIT_LINE, FALSE );
            //set highbar
            GUILIST_SetListState( ctrl_id, GUILIST_STATE_NEED_HIGHTBAR, FALSE );
        }
        break;
        case MSG_CLOSE_WINDOW:
        break;

        default:
            result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

LOCAL MMI_RESULT_E EngListNeedHightBarHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E  result  = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_COMMON_CTRL2_ID;

    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            MMK_SetAtvCtrl(win_id,ctrl_id);
        }
        break;

        case MSG_FULL_PAINT:
        {
            GUILIST_ITEM_T  item_t = {0};
            GUILIST_ITEM_DATA_T item_data = {0};
            uint16 curIndex = GUILIST_GetCurItemIndex(ctrl_id);

            GUILIST_SetMaxItem(ctrl_id,ENG_LIST_PRESS_TEST_LIST_NUM, FALSE );
            //max item 2 open and close
            GUILIST_SetOwnSofterKey( ctrl_id, FALSE );

            item_t.item_style    = GUIITEM_STYLE_1STR;
            item_t.item_data_ptr = &item_data;

            item_data.item_content[0].item_data_type  = GUIITEM_DATA_TEXT_ID;
            item_data.item_content[0].item_data.text_id = TXT_LIST_TEST_TEXT_1;
            GUILIST_AppendItem( ctrl_id, &item_t );
            item_data.item_content[0].item_data.text_id = TXT_LIST_TEST_TEXT_2;
            GUILIST_AppendItem( ctrl_id, &item_t );

            //set selected item
            GUILIST_SetSelectedItem(ctrl_id, curIndex, TRUE);

            //set current item
            GUILIST_SetCurItemIndex(ctrl_id, curIndex);

            //set list need highbar if click
            GUILIST_SetItemIsNeedHighBarIfClick(ctrl_id,TRUE);
            //set list split line
            GUILIST_SetListState( ctrl_id, GUILIST_STATE_SPLIT_LINE, FALSE );
            //set highbar
            GUILIST_SetListState( ctrl_id, GUILIST_STATE_NEED_HIGHTBAR, FALSE );
        }
        break;

        case MSG_CTL_MIDSK:
        case MSG_CTL_OK:
        break;

        case MSG_CTL_CANCEL:
        case MSG_KEYDOWN_RED:
        {
            MMK_CloseWin( win_id );
        }
        break;

        case MSG_CLOSE_WINDOW:
        break;

        default:
            result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}

LOCAL MMI_RESULT_E EngListSupportLeftSlideHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E  result  = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_COMMON_CTRL2_ID;

    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            MMK_SetAtvCtrl(win_id,ctrl_id);
        }
        break;

        case MSG_CTL_MIDSK:
        case MSG_CTL_OK:
        break;

        case MSG_CTL_CANCEL:
        case MSG_KEYDOWN_RED:
        {
            MMK_CloseWin( win_id );
        }
        break;

        case MSG_FULL_PAINT:
        {
            GUILIST_ITEM_T  item_t = {0};
            GUILIST_ITEM_DATA_T item_data = {0};
            uint16 curIndex = GUILIST_GetCurItemIndex(ctrl_id);

            GUILIST_SetMaxItem(ctrl_id,ENG_LIST_PRESS_TEST_LIST_NUM, FALSE );
            //max item 2 open and close
            GUILIST_SetOwnSofterKey( ctrl_id, FALSE );

            item_t.item_style    = GUIITEM_STYLE_1STR;
            item_t.item_data_ptr = &item_data;

            item_data.item_content[0].item_data_type  = GUIITEM_DATA_TEXT_ID;
            item_data.item_content[0].item_data.text_id = TXT_LIST_TEST_TEXT_1;
            GUILIST_AppendItem( ctrl_id, &item_t );
            item_data.item_content[0].item_data.text_id = TXT_LIST_TEST_TEXT_2;
            GUILIST_AppendItem( ctrl_id, &item_t );

            //set selected item
            GUILIST_SetSelectedItem(ctrl_id, curIndex, TRUE);

            //set current item
            GUILIST_SetCurItemIndex(ctrl_id, curIndex);

            //set list left slide
            GUILIST_SetItemHorMove(ctrl_id,TRUE);
            CTRLLIST_SetItemLeftMove(ctrl_id,TRUE);
            //set list split line
            GUILIST_SetListState( ctrl_id, GUILIST_STATE_SPLIT_LINE, FALSE );
            //set highbar
            GUILIST_SetListState( ctrl_id, GUILIST_STATE_NEED_HIGHTBAR, FALSE );
        }
        break;
        case MSG_NOTIFY_TPCLICK_LEFT_ICON:
        {
            WATCH_SOFTKEY_TEXT_ID_T softkey_text = {0};
            MMI_TEXT_ID_T text_id = TXT_LIST_CLICK_LEFT_ICON;
            MMI_STRING_T  tip_str = {0};

            MMI_GetLabelTextByLang( text_id , &tip_str );
            WatchCOM_NoteWin_2Line_Enter(MMIENG_LIST_NOTEWIN_WIN_ID,&tip_str,0,softkey_text,PNULL);
        }
        break;
        case MSG_NOTIFY_TPCLICK_RIGHT_ICON:
        {
            WATCH_SOFTKEY_TEXT_ID_T softkey_text = {0};
            MMI_TEXT_ID_T text_id = TXT_LIST_CLICK_RIGHT_ICON;
            MMI_STRING_T  tip_str = {0};

            MMI_GetLabelTextByLang( text_id , &tip_str );
            WatchCOM_NoteWin_2Line_Enter(MMIENG_LIST_NOTEWIN_WIN_ID,&tip_str,0,softkey_text,PNULL);
        }
        break;
        case MSG_CLOSE_WINDOW:
        break;

        default:
            result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}
#endif
//================================================================================================//
//================================     ENG MEM PRESS TEST END      ===============================//
//================================================================================================//


//================================================================================================//
//================================     ENG SENSOR TEST BEGAIN      ===============================//
//================================================================================================//
#ifndef WIN32
#ifdef SENSORHUB_SUPPORT
#include "ual_cms_export.h"
#include "ual_sensorhub.h"
LOCAL MMI_RESULT_E EngSensorVersion_WinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id,DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;

    SCI_TraceLow("EngSensorVersion_WinHandleMsg msg_id = 0x%x",msg_id);
    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            char version[FW_VERSION_LEN + 1] = {0};
            wchar           unicode_cr = 0x0d;
            MMI_STRING_T    cr_s = {0};
            MMI_STRING_T    text_s = {0};
            uint16          uint16_str_len = 0;
            char*           temp_ptr = PNULL;
            uint16          temp_len = 0;
            uint16          *uint16_str = PNULL;      
#ifdef GOODIX_SUPPORT_GR5515
            BOOLEAN is_goodix_ready = FALSE;
            is_goodix_ready = goodix_is_gr5515_ready();
#endif
            cr_s.wstr_ptr = &unicode_cr;
            cr_s.wstr_len = 1;

            uint16_str = (uint16*)SCI_ALLOC_APPZ( sizeof(uint16)*(MMIENG_SENSOR_VERSION_TEXT_LEN+1));

            if(PNULL == uint16_str)
            {
                SCI_TRACE_LOW("ShowVersionInfo malloc fail");
                break;
            }
            //GR5515 V:
            temp_ptr = (char*)"GR5515 V:";
            temp_len = SCI_STRLEN((char*)temp_ptr);
            MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)temp_ptr, temp_len);
            MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行
#ifdef GOODIX_SUPPORT_GR5515
            if(TRUE == is_goodix_ready)
            {
                tx_start();
                if(APP_SUCCESS != sensor_hub_fw_version_get(version))
                {
                   SCI_TraceLow("sensor_hub_fw_version_get ERROR!!!"); 
                }
                tx_end();
            }
#endif
            temp_len = SCI_STRLEN(version);
            MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)version, temp_len);
            MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行
            //Sensor Config V:
            temp_ptr = (char*)"Sensor Config V:";
            temp_len = SCI_STRLEN((char*)temp_ptr);
            MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)temp_ptr, temp_len);
            MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行
            SCI_MEMSET(version, 0, FW_VERSION_LEN + 1);
            if(APP_SUCCESS != update_fw_version_get(version))
            {
               SCI_TraceLow("update_fw_version_get ERROR!!!"); 
            }
            temp_len = SCI_STRLEN(version);
            MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)version, temp_len);
            text_s.wstr_ptr = uint16_str;
            text_s.wstr_len = uint16_str_len;
            GUITEXT_SetString(MMIENG_SHOW_SENSOR_VERSION_CTRL_ID, text_s.wstr_ptr,text_s.wstr_len, FALSE);
            if(PNULL != uint16_str)
            {
                SCI_FREE(uint16_str);
                uint16_str = PNULL;
            }  
        }
        break;
        case MSG_APP_OK:
        case MSG_APP_CANCEL:
        case MSG_CTL_OK:
        case MSG_CTL_CANCEL:  //bug1904947
        {
            MMK_CloseWin(win_id);
        }
        break;
        default:
            result = MMI_RESULT_FALSE;
            break;
    }
    return (result);
}
#ifndef WIN32
#ifdef GOODIX_SUPPORT_GR5515
LOCAL void ENGSensorHubCB_FW(uint16 opcode, uint16 status)
{
    SENSORHUB_ENGTEST_CB_T                  *sig_ptr = PNULL;
    SCI_TRACE_LOW("[Sensor_Hub]enter ENGSensorHubCB_FW");
    MmiCreateSignal (MSG_ENG_SENSORHUB_TEST, sizeof (SENSORHUB_ENGTEST_CB_T), (MmiSignalS**)&sig_ptr);
    sig_ptr->SignalSize = sizeof (SENSORHUB_ENGTEST_CB_T);
    sig_ptr->Sender = P_APP;
    sig_ptr->opcode = opcode;
    sig_ptr->status = status;
    sig_ptr->win_id = MMIENG_SENSOR_FIRMWARE_DL_WIN_ID;
    sig_ptr->msg_id = MSG_FULL_PAINT;
    MMI_SEND_SIGNAL (sig_ptr, P_APP);
}

LOCAL void ENGSensorHubCB_Product(uint16 opcode, uint16 status)
{
    SENSORHUB_ENGTEST_CB_T                  *sig_ptr = PNULL;
    SCI_TRACE_LOW("[Sensor_Hub]enter ENGSensorHubCB_Product");
    MmiCreateSignal (MSG_ENG_SENSORHUB_TEST, sizeof (SENSORHUB_ENGTEST_CB_T), (MmiSignalS**)&sig_ptr);
    sig_ptr->SignalSize = sizeof (SENSORHUB_ENGTEST_CB_T);
    sig_ptr->Sender = P_APP;
    sig_ptr->opcode = opcode;
    sig_ptr->status = status;
    sig_ptr->win_id = MMIENG_SENSOR_PRODUCT_TEST_WIN_ID;
    sig_ptr->msg_id = MSG_FULL_PAINT;
    MMI_SEND_SIGNAL (sig_ptr, P_APP);
}
LOCAL plt_func_cfg_t sensorProductTest_cb =
{
    .plt_op_status_handler = ENGSensorHubCB_Product,
};
LOCAL plt_func_cfg_t sensorFirmwareDL_cb =
{
    .plt_op_status_handler = ENGSensorHubCB_FW,
};

#endif
#endif

LOCAL MMI_RESULT_E EngSensorFirmwareDL_WinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id,DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;

    SCI_TraceLow("EngSensorFirmwareDL_WinHandleMsg msg_id = 0x%x",msg_id);

    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            BOOLEAN is_uart_open = FALSE;
            MMIDEFAULT_AllowTurnOffBackLight(FALSE);
#ifndef WIN32
#ifdef GOODIX_SUPPORT_GR5515
            is_uart_open = MMIENG_GetLogUartIsOpen();
            if(TRUE != is_uart_open)
            {
                register_plt_cb(&sensorFirmwareDL_cb);
                app_fw_update_start();
            }
            else
            {
                SCI_TraceLow("EngSensorFirmwareDL_WinHandleMsg uart log is open,sensrohub disabled");
            }
#endif
#endif
        }
        break;
        case MSG_FULL_PAINT:
          {
            GUI_RECT_T clientRect = MMITHEME_GetClientRectEx(win_id);
            GUI_LCD_DEV_INFO lcd_dev_info = {0};
            GUI_FillRect(&lcd_dev_info, clientRect, MMI_BLACK_COLOR);
            if(PNULL != param)
            {
                GUI_LCD_DEV_INFO    lcd_dev_info   = {0};
                GUISTR_STYLE_T      text_style     = {0};
                GUISTR_STATE_T      text_state     = GUISTR_STATE_ALIGN;
                //set font param
                text_style.align      = ALIGN_HMIDDLE;
                text_style.font       = DP_FONT_24;
                text_style.font_color = MMI_WHITE_COLOR;

                //转换窗口坐标到显示坐标
                GUISTR_DrawTextToLCDInRect(
                                  (const GUI_LCD_DEV_INFO *)&lcd_dev_info,
                                  &clientRect,
                                  &clientRect,
                                  (MMI_STRING_T*)param,
                                  &text_style,
                                  text_state,
                                  GUISTR_TEXT_DIR_AUTO
                                  );
            }
          }
          break;
        case MSG_APP_OK:
        case MSG_APP_CANCEL:
        {
            MMIDEFAULT_AllowTurnOffBackLight(TRUE);
            MMK_CloseWin(win_id);
        }
        break;
        default:
            result = MMI_RESULT_FALSE;
            break;
    }
    return (result);
}

LOCAL MMI_RESULT_E EngSensorProductTest_WinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id,DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;

    SCI_TraceLow("EngSensorProductTest_WinHandleMsg msg_id = 0x%x",msg_id);

    switch (msg_id)
        {
          case MSG_OPEN_WINDOW:
            {
                BOOLEAN is_uart_open = FALSE;
                MMIDEFAULT_AllowTurnOffBackLight(FALSE);
#ifndef WIN32
#ifdef GOODIX_SUPPORT_GR5515
                is_uart_open = MMIENG_GetLogUartIsOpen();
                if(TRUE != is_uart_open)
                {
                    register_plt_cb(&sensorProductTest_cb);
                    plt_start();
                }
                else
                {
                    SCI_TraceLow("EngSensorProductTest_WinHandleMsg uart log is open,sensrohub disabled");
                }
#endif
#endif
              break;
            }
          case MSG_FULL_PAINT:
          {
            GUI_RECT_T clientRect = MMITHEME_GetClientRectEx(win_id);
            GUI_LCD_DEV_INFO lcd_dev_info = {0};
            GUI_FillRect(&lcd_dev_info, clientRect, MMI_BLACK_COLOR);
            if(PNULL != param)
            {
                GUI_LCD_DEV_INFO    lcd_dev_info   = {0};
                GUISTR_STYLE_T      text_style     = {0};
                GUISTR_STATE_T      text_state     = GUISTR_STATE_ALIGN;
                //set font param
                text_style.align      = ALIGN_HMIDDLE;
                text_style.font       = DP_FONT_24;
                text_style.font_color = MMI_WHITE_COLOR;

                //转换窗口坐标到显示坐标
                GUISTR_DrawTextToLCDInRect(
                                  (const GUI_LCD_DEV_INFO *)&lcd_dev_info,
                                  &clientRect,
                                  &clientRect,
                                  (MMI_STRING_T*)param,
                                  &text_style,
                                  text_state,
                                  GUISTR_TEXT_DIR_AUTO
                                  );
            }
          }
          break;
         case MSG_KEYDOWN_CANCEL:
         case MSG_CTL_CANCEL:
             MMK_CloseWin(win_id);
            break;
         case MSG_KEYDOWN_OK:
         case MSG_CTL_OK:
             MMK_CloseWin(win_id);
            break;
            case MSG_CLOSE_WINDOW:
             MMIDEFAULT_AllowTurnOffBackLight(TRUE);
            break;
        default:
            result = MMI_RESULT_FALSE;
            break;
         }
    return (result);
}
LOCAL uint32 s_sensor_id = 0;
LOCAL MMI_RESULT_E EngSensorHeartRateID_WinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id,DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    GUI_LCD_DEV_INFO lcd_dev_info = {0};
    GUI_RECT_T clientRect = MMITHEME_GetClientRectEx(win_id);

    SCI_TraceLow("EngSensorHeartrateID_WinHandleMsg msg_id = 0x%x",msg_id);

    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
#ifndef WIN32
#ifdef GOODIX_SUPPORT_GR5515
            BOOLEAN is_goodix_ready = FALSE;
            is_goodix_ready = goodix_is_gr5515_ready();
            if(TRUE == is_goodix_ready)
            {
                tx_start();
                s_sensor_id = get_sensor_id(HEART_RATE_SENSOR);
                tx_end();
            }
#endif
#endif
        }
        break;
        case MSG_FULL_PAINT:
        {
            wchar wstr_temp[20] = {0};
            char str_temp[20] = {0};
            uint8 len = 0;
            MMI_STRING_T data_info = {0};
            GUISTR_STYLE_T      text_style     = {0};
            GUISTR_STATE_T      text_state     = GUISTR_STATE_ALIGN;
            GUI_FillRect(&lcd_dev_info, clientRect, MMI_BLACK_COLOR);
            text_style.align      = ALIGN_HMIDDLE;
            text_style.font       = DP_FONT_24;
            text_style.font_color = MMI_WHITE_COLOR;
            //draw
            sprintf(str_temp, "Heartrate_ID: %d", s_sensor_id);
            len = strlen(str_temp);
            MMI_STRNTOWSTR(wstr_temp, len, str_temp, len, len);
            data_info.wstr_ptr = wstr_temp;
            data_info.wstr_len = len;
            GUISTR_DrawTextToLCDInRect(
                              (const GUI_LCD_DEV_INFO *)&lcd_dev_info,
                              &clientRect,
                              &clientRect,
                              &data_info,
                              &text_style,
                              text_state,
                              GUISTR_TEXT_DIR_AUTO
                              );

        }
        break;
        case MSG_APP_OK:
        case MSG_APP_CANCEL:
        {
            MMK_CloseWin(win_id);
        }
        break;
        default:
            result = MMI_RESULT_FALSE;
            break;
    }
    return (result);
}

LOCAL MMI_RESULT_E EngSensorAccID_WinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id,DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    GUI_LCD_DEV_INFO lcd_dev_info = {0};
    GUI_RECT_T clientRect = MMITHEME_GetClientRectEx(win_id);

    SCI_TraceLow("EngSensorAccID_WinHandleMsg msg_id = 0x%x",msg_id);

    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
#ifndef WIN32
#ifdef GOODIX_SUPPORT_GR5515
            BOOLEAN is_goodix_ready = FALSE;
            is_goodix_ready = goodix_is_gr5515_ready();
            if(TRUE == is_goodix_ready)
            {
                tx_start();
                s_sensor_id = get_sensor_id(A_SENSOR);
                tx_end();
            }
#endif
#endif
        }
        break;
        case MSG_FULL_PAINT:
        {
            wchar wstr_temp[20] = {0};
            char str_temp[20] = {0};
            uint8 len = 0;
            MMI_STRING_T data_info = {0};
            GUISTR_STYLE_T      text_style     = {0};
            GUISTR_STATE_T      text_state     = GUISTR_STATE_ALIGN;
            GUI_FillRect(&lcd_dev_info, clientRect, MMI_BLACK_COLOR);
            text_style.align      = ALIGN_HMIDDLE;
            text_style.font       = DP_FONT_24;
            text_style.font_color = MMI_WHITE_COLOR;
            //draw
            sprintf(str_temp, "ACC_ID: %d", s_sensor_id);
            len = strlen(str_temp);
            MMI_STRNTOWSTR(wstr_temp, len, str_temp, len, len);
            data_info.wstr_ptr = wstr_temp;
            data_info.wstr_len = len;
            GUISTR_DrawTextToLCDInRect(
                              (const GUI_LCD_DEV_INFO *)&lcd_dev_info,
                              &clientRect,
                              &clientRect,
                              &data_info,
                              &text_style,
                              text_state,
                              GUISTR_TEXT_DIR_AUTO
                              );

        }
        break;
        case MSG_APP_OK:
        case MSG_APP_CANCEL:
        {
            MMK_CloseWin(win_id);
        }
        break;
        default:
            result = MMI_RESULT_FALSE;
            break;
    }
    return (result);
}
LOCAL BOOLEAN AccCalibrationCB(ual_cms_msg_t param)
{
    ual_sensor_acc_t  *calibration_data_ptr = PNULL;
    calibration_data_ptr = (ual_sensor_acc_t*)param.p_body;
    if(PNULL == calibration_data_ptr)
    {
        return FALSE;
    }
    if(MMK_IsFocusWin(MMIENG_SENSOR_ACC_CALIBRATION_WIN_ID))
    {
        MMK_SendMsg(MMIENG_SENSOR_ACC_CALIBRATION_WIN_ID, MSG_FULL_PAINT, calibration_data_ptr);
    }
}
LOCAL MMI_RESULT_E EngSensorAccCalibration_WinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id,DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;

    GUI_LCD_DEV_INFO lcd_dev_info = {0};
    GUI_RECT_T clientRect = MMITHEME_GetClientRectEx(win_id);

    SCI_TraceLow("EngSensorAccCalibration_WinHandleMsg msg_id = 0x%x",msg_id);

    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            MMIDEFAULT_AllowTurnOffBackLight(FALSE);
            ual_sensorhub_calibrate_sensor(UAL_SENSOR_TYPE_ACCELEROMETER, AccCalibrationCB);
        }
        break;
        case MSG_FULL_PAINT:
        {
            wchar wstr_temp[20] = {0};
            char str_temp[20] = {0};
            uint8 len = 0;
            MMI_STRING_T data_info = {0};
            GUI_FillRect(&lcd_dev_info, clientRect, MMI_BLACK_COLOR);
            if(PNULL != param)
            {
                ual_sensor_acc_t  *calibration_data_ptr = PNULL;
                GUI_RECT_T x_rect = {0};
                GUI_RECT_T y_rect = {0};
                GUI_RECT_T z_rect = {0};
                GUI_RECT_T timestamp_rect = {0};
                GUISTR_STYLE_T      text_style     = {0};
                GUISTR_STATE_T      text_state     = GUISTR_STATE_ALIGN;
                //set layout
                x_rect.right = clientRect.right;
                x_rect.top = clientRect.top;
                x_rect.bottom = x_rect.top + 40;
                y_rect.right = clientRect.right;
                y_rect.top = x_rect.bottom + 10;
                y_rect.bottom = y_rect.top + 40;
                z_rect.right = clientRect.right;
                z_rect.top = y_rect.bottom + 10;
                z_rect.bottom = z_rect.top + 40;
                //set font param
                text_style.align      = ALIGN_HMIDDLE;
                text_style.font       = DP_FONT_24;
                text_style.font_color = MMI_WHITE_COLOR;
                //get data
                calibration_data_ptr = (ual_sensor_acc_t*)param;
                //draw x
                sprintf(str_temp, "x: %d", calibration_data_ptr->x);
                len = strlen(str_temp);
                MMI_STRNTOWSTR(wstr_temp, len, str_temp, len, len);
                data_info.wstr_ptr = wstr_temp;
                data_info.wstr_len = len;
                GUISTR_DrawTextToLCDInRect(
                                  (const GUI_LCD_DEV_INFO *)&lcd_dev_info,
                                  &x_rect,
                                  &x_rect,
                                  &data_info,
                                  &text_style,
                                  text_state,
                                  GUISTR_TEXT_DIR_AUTO
                                  );
                SCI_MEMSET(wstr_temp, 0, sizeof(wstr_temp));
                SCI_MEMSET(str_temp, 0, sizeof(str_temp));
                SCI_MEMSET(&data_info, 0, sizeof(data_info));
                //draw y
                sprintf(str_temp, "y: %d", calibration_data_ptr->y);
                len = strlen(str_temp);
                MMI_STRNTOWSTR(wstr_temp, len, str_temp, len, len);
                data_info.wstr_ptr = wstr_temp;
                data_info.wstr_len = len;
                GUISTR_DrawTextToLCDInRect(
                                  (const GUI_LCD_DEV_INFO *)&lcd_dev_info,
                                  &y_rect,
                                  &y_rect,
                                  &data_info,
                                  &text_style,
                                  text_state,
                                  GUISTR_TEXT_DIR_AUTO
                                  );
                SCI_MEMSET(wstr_temp, 0, sizeof(wstr_temp));
                SCI_MEMSET(str_temp, 0, sizeof(str_temp));
                SCI_MEMSET(&data_info, 0, sizeof(data_info));
                //draw z
                sprintf(str_temp, "z: %d", calibration_data_ptr->z);
                len = strlen(str_temp);
                MMI_STRNTOWSTR(wstr_temp, len, str_temp, len, len);
                data_info.wstr_ptr = wstr_temp;
                data_info.wstr_len = len;
                GUISTR_DrawTextToLCDInRect(
                                  (const GUI_LCD_DEV_INFO *)&lcd_dev_info,
                                  &z_rect,
                                  &z_rect,
                                  &data_info,
                                  &text_style,
                                  text_state,
                                  GUISTR_TEXT_DIR_AUTO
                                  );
            }

        }
        break;
        case MSG_APP_OK:
        case MSG_APP_CANCEL:
        {
            MMK_CloseWin(win_id);
            MMIDEFAULT_AllowTurnOffBackLight(TRUE);
        }
        break;
        default:
            result = MMI_RESULT_FALSE;
            break;
    }
    return (result);
}

#ifndef UAL_BT_BLE_DEV_SUPPORT_NONE
#include "ual_cms_export.h"
#include "ual_bt_ble_dev.h"
#include "ual_bt_ble_private.h"
LOCAL boolean HandleBleMsg(ual_cms_msg_t param);

int app_adv_param_set_api_test(void)
{
    ual_bt_ble_result_e status = UAL_BT_BLE_RESULT_MAX;
    ual_bt_ble_adv_param_t adv_param = {0};
    adv_param.adv_adv_filter_policy = UAL_BT_BLE_ALLOW_SCAN_CONNECT_ANY;
    adv_param.adv_display_mode = UAL_BT_BLE_NORMAL_DISCOVERABLE_MODE;
    adv_param.adv_mode = UAL_BT_BLE_UNDIRECT_SCAN_CONNET_MODE;
    adv_param.adv_interval_min = 32;
    adv_param.adv_interval_max = 32;
    status = ual_bt_ble_config_adv_param(&adv_param);

    return status;
}

int app_adv_data_set_api_test(void)
{
    ual_bt_ble_result_e status;
    uint8 device_name[8] = {'O', 'K', 'o', 'k', 't', 'i', 'n', 'g'};
    ual_bt_ble_set_adv_content_t adv_content = {0};
    adv_content.content_type = 0x09;
    SCI_MEMCPY(adv_content.content,device_name,8);
    adv_content.content_len = 8;

    status = ual_bt_ble_set_adv_content(&adv_content);

    return status;
}

int app_adv_start_api_test(void)
{
    ual_bt_ble_result_e status;

    status = ual_bt_ble_start_adv(0);

    return status;
}

LOCAL boolean HandleBleMsg(ual_cms_msg_t param)
{
    TRACE_APP_SENSOR(" HandleBleMsg! smg_id:%d\n",param.msg_id);

    switch(param.msg_id)
    {
        case UAL_BT_BLE_DEV_MSG_CONFIG_ADV_PARAM_CNF:
            app_adv_data_set_api_test();
            break;
        case UAL_BT_BLE_DEV_MSG_SET_ADV_CONTENT_CNF:
            app_adv_start_api_test();
            break;
        case UAL_BT_BLE_DEV_MSG_START_ADV_CNF:
            TRACE_APP_SENSOR(" ble start adv sucess!\n");
            break;
        case UAL_BT_BLE_DEV_MSG_PASSIVE_CONNECT_CNF:
            TRACE_APP_SENSOR(" handle ble msg connect cnf");
            break;
        default:
            break;
    }
}
LOCAL boolean HandleBlePrivateMsg(ual_cms_msg_t param)
{
    TRACE_APP_SENSOR("HandleBleMsg! smg_id:%d\n",param.msg_id);
    switch(param.msg_id)
    {
    case UAL_BT_BLE_PRIVATE_MSG_RECEIVE_DATA_CNF:
    {
        uint32 i=0;
        ual_bt_ble_private_message_data_t* private_message = (ual_bt_ble_private_message_data_t*)param.p_body;
        TRACE_APP_SENSOR("HandleBleMsg! msgtype:%x",private_message->msg_type);
        if( UAL_BT_BLE_PRIVATE_INCALL == private_message->msg_type)
        {
            TRACE_APP_SENSOR("cur private data is incomming call!\n");
            // TODO:
            MMIDEFAULT_TurnOnBackLight();
        }
        else
        {
            //SCI_ASSERT(0);
        }
        TRACE_APP_SENSOR("cur private data msg_len:%d\n",private_message->msg_len);
        for(i=0;i<private_message->msg_len;i++)
        {
            TRACE_APP_SENSOR(":msg_data[%d]:%x\n",i,private_message->msg_data[i]);
        }
    }
    break;
    default:
    break;
	}
}
#endif

#ifndef UAL_BT_BLE_DEV_SUPPORT_NONE
    uint32 ble_dev_handle = 0;
    uint32 ble_handle = 0;
#endif
LOCAL MMI_RESULT_E EngSensorBleBroadcast_WinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id,DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    GUI_LCD_DEV_INFO lcd_dev_info = {0};
    GUI_RECT_T clientRect = MMITHEME_GetClientRectEx(win_id);

    SCI_TraceLow("EngSensorBleBroadcast_WinHandleMsg msg_id = 0x%x",msg_id);

    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
#ifndef UAL_BT_BLE_DEV_SUPPORT_NONE
            ual_bt_ble_dev_register(HandleBleMsg,&ble_dev_handle);
            ual_bt_ble_private_register(HandleBlePrivateMsg,&ble_handle);
            app_adv_param_set_api_test();
#endif
        }
        break;
        case MSG_FULL_PAINT:
            GUI_FillRect(&lcd_dev_info, clientRect, MMI_BLACK_COLOR);
            break;
        case MSG_APP_OK:
        case MSG_APP_CANCEL:
        {
            MMK_CloseWin(win_id);
        }
        break;
        case MSG_CLOSE_WINDOW:
        {
#ifndef UAL_BT_BLE_DEV_SUPPORT_NONE
            ual_bt_ble_dev_unregister(ble_dev_handle);
            ual_bt_ble_private_unregister(ble_handle);
#endif
        }
        break;
        default:
            result = MMI_RESULT_FALSE;
            break;
    }
    return (result);
}
// window table for sensor ble brodcast window
WINDOW_TABLE(MMIENG_SENSOR_BLE_BROADCAST_TAB) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngSensorBleBroadcast_WinHandleMsg),
    WIN_ID(MMIENG_SENSOR_BLE_BROADCAST_WIN_ID),
    WIN_TITLE(TXT_ENG_SENSOR_BLE_BROADCAST),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    END_WIN
};
// window table for sensor product test window
WINDOW_TABLE(MMIENG_SENSOR_PRODUCT_TEST_TAB) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngSensorProductTest_WinHandleMsg),
    WIN_ID(MMIENG_SENSOR_PRODUCT_TEST_WIN_ID),
    WIN_TITLE(TXT_ENG_SENSOR_PRODUCTTEST_DL),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    END_WIN
};
// window table for sensor firmware download window
WINDOW_TABLE(MMIENG_SENSOR_FIRMWARE_DL_TAB) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngSensorFirmwareDL_WinHandleMsg),
    WIN_ID(MMIENG_SENSOR_FIRMWARE_DL_WIN_ID),
    WIN_TITLE(TXT_ENG_SENSOR_FIRMWARE_DL),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    END_WIN
};
// window table for sensor version window
WINDOW_TABLE(MMIENG_SENSOR_VERSION_TAB) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngSensorVersion_WinHandleMsg),
    WIN_ID(MMIENG_SENSOR_VERSION_WIN_ID),
    WIN_TITLE(TXT_ENG_SENSOR_VERSION),
    CREATE_TEXT_CTRL(MMIENG_SHOW_SENSOR_VERSION_CTRL_ID),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    END_WIN
};
// window table for sensor acc calibration window
WINDOW_TABLE(MMIENG_SENSOR_ACC_CALIBRATION_TAB) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngSensorAccCalibration_WinHandleMsg),
    WIN_ID(MMIENG_SENSOR_ACC_CALIBRATION_WIN_ID),
    WIN_TITLE(TXT_ENG_SENSOR_ACC_CALIBRATION),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    END_WIN
};
// window table for sensor acceleration id window
WINDOW_TABLE(MMIENG_SENSOR_ACC_ID_TAB) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngSensorAccID_WinHandleMsg),
    WIN_ID(MMIENG_SENSOR_ACC_ID_WIN_ID),
    WIN_TITLE(TXT_ENG_SENSOR_ACC_ID),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    END_WIN
};
// window table for sensor heartrate ID window
WINDOW_TABLE(MMIENG_SENSOR_HEARTRATE_ID_TAB) =
{
    WIN_HIDE_STATUS,
    WIN_FUNC((uint32)EngSensorHeartRateID_WinHandleMsg),
    WIN_ID(MMIENG_SENSOR_HEARTRATE_ID_WIN_ID),
    WIN_TITLE(TXT_ENG_SENSOR_HEARTRATE_ID),
    WIN_SOFTKEY(TXT_COMMON_OK, TXT_NULL, STXT_RETURN),
    END_WIN
};

/*****************************************************************************/
//  Description : open sensor ble brodcast window
//  Parameter: [In] None
//             [Out] int32
//             [Return] None
//  Author: longwei.qiao
//  Note:
/*****************************************************************************/
PUBLIC int32 MMIENG_OpenSensorBleBroadcastWin(void)
{
    MMK_CreateWin((uint32 * )MMIENG_SENSOR_BLE_BROADCAST_TAB, PNULL);
}
/*****************************************************************************/
//  Description : open sensor version window
//  Parameter: [In] None
//             [Out] int32
//             [Return] None
//  Author: longwei.qiao
//  Note:
/*****************************************************************************/
PUBLIC int32 MMIENG_OpenSensorVersionWin(void)
{
    MMK_CreateWin((uint32 * )MMIENG_SENSOR_VERSION_TAB, PNULL);
}
/*****************************************************************************/
//  Description : open sensor acc calibration window
//  Parameter: [In] None
//             [Out] int32
//             [Return] None
//  Author: longwei.qiao
//  Note:
/*****************************************************************************/
PUBLIC int32 MMIENG_OpenSensorAccCalibrationWin(void)
{
    MMK_CreateWin((uint32 * )MMIENG_SENSOR_ACC_CALIBRATION_TAB, PNULL);
}
/*****************************************************************************/
//  Description : open sensor acceleration id window
//  Parameter: [In] None
//             [Out] int32
//             [Return] None
//  Author: longwei.qiao
//  Note:
/*****************************************************************************/
PUBLIC int32 MMIENG_OpenSensorAccIDWin(void)
{
    MMK_CreateWin((uint32 * )MMIENG_SENSOR_ACC_ID_TAB, PNULL);
}
/*****************************************************************************/
//  Description : open sensor heartrate ID window
//  Parameter: [In] None
//             [Out] int32
//             [Return] None
//  Author: longwei.qiao
//  Note:
/*****************************************************************************/
PUBLIC int32 MMIENG_OpenSensorHeartRateIDWin(void)
{
    MMK_CreateWin((uint32 * )MMIENG_SENSOR_HEARTRATE_ID_TAB, PNULL);
}
/*****************************************************************************/
//  Description : open sensor product test window
//  Parameter: [In] None
//             [Out] int32
//             [Return] None
//  Author: longwei.qiao
//  Note:
/*****************************************************************************/
PUBLIC int32 MMIENG_OpenSensorProductTestWin(void)
{
    MMK_CreateWin((uint32 * )MMIENG_SENSOR_PRODUCT_TEST_TAB, PNULL);
}
/*****************************************************************************/
//  Description : open sensor firmware download window
//  Parameter: [In] None
//             [Out] int32
//             [Return] None
//  Author: longwei.qiao
//  Note:
/*****************************************************************************/
PUBLIC int32 MMIENG_OpenSensorFirmwareDLWin(void)
{
    MMK_CreateWin((uint32 * )MMIENG_SENSOR_FIRMWARE_DL_TAB, PNULL);
}
#endif
#endif

/********************************************************************************
 NAME:          MMIAPIENG_OpenIMS_NV_PARAM_ShowWin
 DESCRIPTION:
 PARAM IN:
 PARAM OUT:
 AUTHOR:        songbin.zeng
 DATE:          2006.10.11
********************************************************************************/
LOCAL MMI_RESULT_E Open_OpenIMS_NV_PARAM_Win(uint32 dual_sys, BOOLEAN isReturnOK, DPARAM param)
{
    if (isReturnOK)
    {
        return MMK_CreateWin((uint32 *) MMIENG_IMS_NV_PARAM_ID_WIN_TAB, (ADD_DATA)dual_sys);
    }
    else
    {
        return MMI_RESULT_FALSE;
    }
}

/********************************************************************************
 NAME:          MMIAPIENG_OpenIMS_NV_PARAM_ShowWin
 DESCRIPTION:
 PARAM IN:
 PARAM OUT:
 AUTHOR:        songbin.zeng
 DATE:          2006.10.11
********************************************************************************/
PUBLIC BOOLEAN MMIAPIENG_OpenIMS_NV_PARAM_ShowWin(void)
{
#ifndef MMI_DUALMODE_ENABLE
    uint16  sim_ok[2] = {0};
    uint32  sim_num = 0;

    sim_num = MMIAPIPHONE_GetSimAvailableNum(sim_ok, 1);
    SCI_TRACE_LOW("[ENG] func[%s] line[%d] sim %d",__FUNCTION__,__LINE__,sim_ok[0]);
    if (0 == sim_num)
    {
        MMIAPIPHONE_AlertSimNorOKStatus();
        return 0;
    }
    else if (1 == sim_num)
    {
        MMK_CreateWin((uint32 *) MMIENG_IMS_NV_PARAM_ID_WIN_TAB, (ADD_DATA)sim_ok[0]);
        return 1;
    }
    else
    {
        MMI_WIN_ID_T    selectSimWinID = MMIENG_SIM_SELECT_WIN_ID;
        MMIPHONE_SELECT_SIM_DATA_T  caller_data={0};
        caller_data.append_type = (uint32)MMISET_APPEND_SYS_OK;
        caller_data.callback_func = Open_OpenIMS_NV_PARAM_Win ;
        caller_data.select_type= MMIPHONE_SELECTION_SIM_ONLY;
        caller_data.publist_id = MMIENG_LISTBOX_CTRL_ID;
        caller_data.win_id_ptr = &selectSimWinID;
        caller_data.user_data  = PNULL;
        caller_data.extra_data = PNULL;
        return MMIAPIPHONE_OpenSelectSimWin(&caller_data);
    }
#else

    return MMK_CreateWin((uint32 *) MMIENG_IMS_NV_PARAM_ID_WIN_TAB, PNULL);
#endif
}

//================================================================================================//
//================================     ENG SENSOR TEST END         ===============================//
//================================================================================================//
//================================================================================================//
//================================     ENG ADULT TEST END         ===============================//
//================================================================================================//

#ifdef ADULT_WATCH_SUPPORT
LOCAL BOOLEAN s_call_forward_enable = FALSE;
LOCAL BOOLEAN    s_bbm_view_visible = FALSE;
/*****************************************************************************/
//  Description : get call forward enable
//  Parameter: [In] None
//             [Out] BOOLEAN
//             [Return] None
//  Author: chunjuan.liang
//  Note:TRUE:enable;FALSE:disable
/*****************************************************************************/
PUBLIC BOOLEAN MMIAPIENG_GetCallForwardEnable(void)
{
    SCI_TRACE_LOW("MMIAPIENG_GetCallForwardEnable,s_call_forward_enable= %d",s_call_forward_enable);
    return s_call_forward_enable;
}
/*****************************************************************************/
//  Description : MMIEng_CallForwardWinHandleMsg
//  Parameter: [In] win_id ,msg_id
//             [Out] None
//             [Return] None
//  Author: chunjuan.liang
//  Note:
/*****************************************************************************/
PUBLIC MMI_RESULT_E MMIEng_CallForwardWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    int16 index = 0;
    MMI_RESULT_E         result = MMI_RESULT_TRUE;
    int32               list_id = MMIENG_LISTBOX_CTRL_ID;
    BOOLEAN forward_enable = FALSE;

    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            GUILIST_ITEM_T      item_t = {0};
            GUILIST_ITEM_DATA_T item_data = {0};

            GUILIST_SetMaxItem(list_id, 2, FALSE );//open and close
            GUILIST_SetOwnSofterKey(list_id,FALSE);

            item_t.item_style    = GUIITEM_STYLE_1RADIO_ENG;
            item_t.item_data_ptr = &item_data;

            item_data.item_content[0].item_data_type    = GUIITEM_DATA_TEXT_ID;
            item_data.item_content[0].item_data.text_id = TXT_OPEN_COMN;
            GUILIST_AppendItem( list_id, &item_t );
            item_data.item_content[0].item_data.text_id = TXT_COMM_CLOSE;
            GUILIST_AppendItem( list_id, &item_t );

            forward_enable = MMIAPIENG_GetCallForwardEnable();
            index = (forward_enable == TRUE) ? 0 : 1;

            GUILIST_SetSelectedItem( list_id,index, TRUE );
            GUILIST_SetCurItemIndex( list_id, index);
            MMK_SetAtvCtrl(win_id, list_id);
        }
        break;
    case MSG_FULL_PAINT:
        break;
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT
    case MSG_CTL_PENOK:
#endif
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        index = GUILIST_GetCurItemIndex(list_id);
        if(0 == index)//enable call forward
        {
           s_call_forward_enable = TRUE;
        }
        else if( 1 == index)//disable call forward
        {
            s_call_forward_enable = FALSE;
        }
        MMK_CloseWin(win_id);
        break;
    case MSG_CLOSE_WINDOW:
        break;
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}
/*****************************************************************************/
//  Description : get bbm view visible
//  Parameter: [In] None
//             [Out] BOOLEAN
//             [Return] None
//  Author: chunjuan.liang
//  Note:TRUE:visible;FALSE:not visible
/*****************************************************************************/
PUBLIC BOOLEAN MMIAPIENG_GetBBMViewVisible(void)
{
    SCI_TRACE_LOW("MMIAPIENG_GetBBMViewVisible,s_bbm_view_visible= %d",s_bbm_view_visible);
    return s_bbm_view_visible;
}
/*****************************************************************************/
//  Description : MMIEng_BBMViewWinHandleMsg
//  Parameter: [In] win_id ,msg_id
//             [Out] None
//             [Return] None
//  Author: chunjuan.liang
//  Note:
/*****************************************************************************/
PUBLIC MMI_RESULT_E MMIEng_BBMViewWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    uint16 index = 0;
    MMI_RESULT_E         result = MMI_RESULT_TRUE;
    int32               list_id = MMIENG_LISTBOX_CTRL_ID;
    BOOLEAN bbm_visible = FALSE;

    switch (msg_id)
    {
        case MSG_OPEN_WINDOW:
        {
            GUILIST_ITEM_T      item_t = {0};
            GUILIST_ITEM_DATA_T item_data = {0};

            GUILIST_SetMaxItem( list_id, 2, FALSE );//open and close
            GUILIST_SetOwnSofterKey(list_id,FALSE);

            item_t.item_style    = GUIITEM_STYLE_1RADIO_ENG;
            item_t.item_data_ptr = &item_data;

            item_data.item_content[0].item_data_type    = GUIITEM_DATA_TEXT_ID;
            item_data.item_content[0].item_data.text_id = TXT_OPEN_COMN;
            GUILIST_AppendItem( list_id, &item_t );
            item_data.item_content[0].item_data.text_id = TXT_COMM_CLOSE;
            GUILIST_AppendItem( list_id, &item_t );

            bbm_visible = MMIAPIENG_GetBBMViewVisible();
            index = (bbm_visible == TRUE) ? 0 : 1;

            GUILIST_SetSelectedItem( list_id,index, TRUE );
            GUILIST_SetCurItemIndex( list_id, index);
            MMK_SetAtvCtrl(win_id, list_id);
        }
        break;
    case MSG_FULL_PAINT:
        break;
    case MSG_KEYDOWN_CANCEL:
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT
    case MSG_CTL_PENOK:
#endif
    case MSG_KEYDOWN_OK:
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        index = GUILIST_GetCurItemIndex(list_id);
        if(0 == index)//visible bbm view
        {
           s_bbm_view_visible = TRUE;
        }
        else if( 1 == index)//disvisible bbm view
        {
            s_bbm_view_visible = FALSE;
        }
        MMK_CloseWin(win_id);
        break;
    case MSG_CLOSE_WINDOW:
        break;
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}


/********************************************************************************
 NAME:          GetCSConInfoStr
 DESCRIPTION:   instead the AT-CMD CSCON,show mode,state,type,coreNetwork of rra
 PARAM IN:      p_cscon_buf -
                buf_len -
 PARAM OUT:     CScon string len
 AUTHOR:        bin.xie
 DATE:          2022.04.29
********************************************************************************/
LOCAL uint32 GetCSConInfoStr(uint8* p_cscon_buf, uint32 buf_len)
{
    MN_DUAL_SYS_E     dual_sys = MN_DUAL_SYS_1;
    // CSCON 端的数据
    MN_PHONE_RRC_CONN_INFO    rrc_conn_info={0};
    // 核心网基础数据
    MN_CORE_NETWORK_E    core_network=MN_CORE_EPC;
    uint8 temStr[2] ={0};
	// 偏移量
    uint32 offset = 0;
    // 默认核心网
    core_network = MN_CORE_EPC;
    // 参数校验
    if(PNULL == p_cscon_buf)
    {
        SCI_TRACE_LOW("mmieng_win.c GetCSConInfoStr p_cscon_buf == null");
        return 0;
    }
    // buf_len 校验
    if(2 > buf_len)
    {
        SCI_TRACE_LOW("mmieng_win.c GetCSConInfoStr buf_len is %d",buf_len);
        return 0;
    }
    // 暂时只在,增加宏定义，为了确保模拟器工作正常
#ifndef WIN32
    rrc_conn_info = MNPHONE_GetRrcConnInfoEx(dual_sys);
#endif
    // mode
    MMI_MEMCPY(p_cscon_buf, buf_len, "<MODE>: ", 8, 8);
    offset = 8;
    p_cscon_buf[offset] = CR_CHAR;
    offset += 1;
    // 模式 (uint16)rrc_conn_info.mode
    sprintf((char *)temStr, "%d",(uint16)rrc_conn_info.mode);
    // 参考结构：
    switch( (uint16)rrc_conn_info.mode )
    {
        case MN_IDEL:
            MMI_MEMCPY(p_cscon_buf + offset, buf_len - offset, " IDLE .", 7, 7);
            offset += 7;
            break;
        case MN_CONNECT:
            MMI_MEMCPY(p_cscon_buf + offset, buf_len - offset, " CONNECT .", 10, 10);
            offset += 10;
            break;
        default:
        {
            //MMI_MEMCPY(cscon_buf + offset, buf_len - offset, " UNKNOWN .", 10, 10);
            //offset += 10;
            MMI_MEMCPY(p_cscon_buf + offset, buf_len - offset, temStr, 1, 1);
            offset += 1;
            break;
        }
    }
    // 换行符号
    p_cscon_buf[offset] = CR_CHAR;
    offset += 1;
    // state
    MMI_MEMCPY(p_cscon_buf + offset, buf_len - offset, "<STATE>: ", 9, 9);
    offset += 9;
    p_cscon_buf[offset] = CR_CHAR;
    offset += 1;
    sprintf((char *)temStr, "%d",(uint16)rrc_conn_info.rrc_state);
    // 设置state
    SCI_TRACE_LOW("mmieng_win.c GetCSConInfoStr rrc_state is %d",(uint16)rrc_conn_info.rrc_state);
    switch( (uint16)rrc_conn_info.rrc_state )
    {
        case MN_RRC_CONN_STATE_URA_PCH:
            MMI_MEMCPY(p_cscon_buf + offset, buf_len - offset, " URA_PCH .", 10, 10);
            offset += 10;
            break;
        case MN_RRC_CONN_STATE_CELL_PCH:
            MMI_MEMCPY(p_cscon_buf + offset, buf_len - offset, " CELL_PCH .", 11, 11);
            offset += 11;
            break;
        case MN_RRC_CONN_STATE_CELL_FACH:
            MMI_MEMCPY(p_cscon_buf + offset, buf_len - offset, " CELL_FACH .", 12, 12);
            offset += 12;
            break;
        case MN_RRC_CONN_STATE_CELL_DCH:
            MMI_MEMCPY(p_cscon_buf + offset, buf_len - offset, " CELL_DCH .", 11, 11);
            offset += 11;
            break;
        default:
        {
            MMI_MEMCPY(p_cscon_buf + offset, buf_len - offset, temStr, 1, 1);
            offset += 1;
            //MMI_MEMCPY(cscon_buf + offset, buf_len - offset, " UNKNOWN .", 10, 10);
            //offset += 10;
            break;
        }
    }
    // 换行符号
    p_cscon_buf[offset] = CR_CHAR;
    offset += 1;
    // type
    MMI_MEMCPY(p_cscon_buf + offset, buf_len - offset, "<TYPE>: ", 8, 8);
    offset += 8;
    p_cscon_buf[offset] = CR_CHAR;
    offset += 1;
    //设置TYPE
    sprintf((char *)temStr, "%d",(uint16)rrc_conn_info.access_rat);
    SCI_TRACE_LOW("mmieng_win.c GetCSConInfoStr rrc_rat is %d",(uint16)rrc_conn_info.access_rat);
    switch( (uint16)rrc_conn_info.access_rat )
    {
        case MN_ACCESS_GERAN:
            MMI_MEMCPY(p_cscon_buf + offset, buf_len - offset, " GERAN .", 8, 8);
            offset += 8;
            break;
        case MN_UTRAN_TDD:
            MMI_MEMCPY(p_cscon_buf + offset, buf_len - offset, " UTRAN_TDD .", 12, 12);
            offset += 12;
            break;
        case MN_UTRAN_FDD:
            MMI_MEMCPY(p_cscon_buf + offset, buf_len - offset, " UTRAN_FDD .", 12, 12);
            offset += 12;
            break;
        case MN_EUTRAN_TDD:
            MMI_MEMCPY(p_cscon_buf + offset, buf_len - offset, " EUTRAN_TDD .", 13, 13);
            offset += 13;
            break;
        case MN_EUTRAN_FDD:
            MMI_MEMCPY(p_cscon_buf + offset, buf_len - offset, " EUTRAN_FDD .", 13, 13);
            offset += 13;
            break;
        default:
        {
            MMI_MEMCPY(p_cscon_buf + offset, buf_len - offset, temStr, 1, 1);
            offset += 1;
            //MMI_MEMCPY(cscon_buf + offset, buf_len - offset, " UNKNOWN .", 10, 10);
            //offset += 10;
            break;
        }
    }
    // 换行符号
    p_cscon_buf[offset] = CR_CHAR;
    offset += 1;
    // CORE NETWORK
    MMI_MEMCPY(p_cscon_buf + offset, buf_len - offset, "<CORE NETWORK>: ", 16, 16);
    offset += 16;
    p_cscon_buf[offset] = CR_CHAR;
    offset += 1;
    // 核心网数据判断,参考ATC的实现
    if(MN_CONNECT==rrc_conn_info.mode && (MN_EUTRAN_TDD == rrc_conn_info.access_rat || MN_EUTRAN_FDD == rrc_conn_info.access_rat))
    {
        MMI_MEMCPY(p_cscon_buf + offset, buf_len - offset, "EPC .", 5, 5);
        offset += 5;
        // 换行符号
        p_cscon_buf[offset] = CR_CHAR;
    }
    else
    {
        MMI_MEMCPY(p_cscon_buf + offset, buf_len - offset, "UNKNOWN .", 9, 9);
        offset += 9;
        // 换行符号
        p_cscon_buf[offset] = CR_CHAR;
    }

    offset += 1;

    return (offset);
}
#endif

/********************************************************************************
 NAME:          EngShowCsonWinHandleMsg
 DESCRIPTION:
 PARAM IN:      win_id
                msg_id
                param
 PARAM OUT:     CScon Win msg
 AUTHOR:        bin.xie
 DATE:          2022.04.29
********************************************************************************/
LOCAL MMI_RESULT_E EngShowCsonWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    uint8 buf[MMIENG_SHOW_STR_MAX_LEN + 1] = {0};
    wchar wstr[MMIENG_SHOW_STR_MAX_LEN + 1] = {0};
    char* p_str = PNULL;
    MMI_STRING_T text = {0};
    MMI_RESULT_E result = MMI_RESULT_TRUE;

    switch (msg_id)
    {
       case MSG_OPEN_WINDOW:
           p_str = (char*)buf;
#ifdef ADULT_WATCH_SUPPORT
           text.wstr_len = GetCSConInfoStr(buf, MMIENG_SHOW_STR_MAX_LEN);
#endif
           text.wstr_ptr = wstr;
           MMI_STRNTOWSTR( wstr, MMIENG_SHOW_STR_MAX_LEN, (uint8*)p_str, text.wstr_len, text.wstr_len );
           GUITEXT_SetString(MMIENG_TEXTBOX1_CTRL_ID, text.wstr_ptr,text.wstr_len, FALSE);
           MMK_SetAtvCtrl(MMIENG_SHOWCSCON_WIN_ID, MMIENG_TEXTBOX1_CTRL_ID);
           break;

       case MSG_CTL_MIDSK:
       case MSG_CTL_OK:
       case MSG_CTL_CANCEL:
           MMK_CloseWin(MMIENG_SHOWCSCON_WIN_ID);
           break;
       default:
           result = MMI_RESULT_FALSE;
           break;
     }
     return (result);
}


#ifdef DATA_ROAMING_SUPPORT    
/********************************************************************************
 NAME:          EngDataRoamingWinHandleMsg
 DESCRIPTION:
 PARAM IN:      win_id
                msg_id
                param
 PARAM OUT:     CScon Win msg
 AUTHOR:        bin.xie
 DATE:          2022.04.29
********************************************************************************/
LOCAL MMI_RESULT_E EngDataRoamingWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E result = MMI_RESULT_TRUE;
    MMI_CTRL_ID_T ctrl_id = MMIENG_LISTBOX_CTRL_ID;
    uint16 cur_selection = 0;
    MMICONNECTION_SETTING_DATA_ROAMING_E roaming_status = MMICONNECTION_SETTING_DATA_ROAMING_MAX ; 
    switch (msg_id) 
    {
    case MSG_OPEN_WINDOW:
        GUILIST_SetMaxItem(ctrl_id,MMISET_OPEN_CLOSE_ITEM, FALSE );//max item 2
        //GUILIST_SetOwnSofterKey(ctrl_id,TRUE);
        MMIAPISET_AppendListItemByTextIdExt(TXT_OPEN_COMN,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);
        MMIAPISET_AppendListItemByTextIdExt(TXT_COMM_CLOSE,TXT_ENG_OK,TXT_NULL,TXT_ENG_RETURN,ctrl_id,GUIITEM_STYLE_1RADIO_ENG);  
        roaming_status = MMAPIICONNECTION_Setting_GetDataRoamingStatus() ; 
		
        if (roaming_status == MMICONNECTION_SETTING_DATA_ROAMING_DISABLE)
        {
            cur_selection =1;
        }
        else
        {
            cur_selection = 0;
        }
        
        //set selected item
        GUILIST_SetSelectedItem(ctrl_id, cur_selection, TRUE);
        
        //set current item
        GUILIST_SetCurItemIndex(ctrl_id,cur_selection);
        MMK_SetAtvCtrl(win_id,ctrl_id);
        break;    
    case MSG_CTL_CANCEL:
        MMK_CloseWin(win_id);
        break;
    case MSG_CTL_MIDSK:
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_PENOK:
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_CTL_OK:
    case MSG_APP_WEB:
        cur_selection = GUILIST_GetCurItemIndex(ctrl_id);
        if (0 == cur_selection) //open
        {
            	MMIAPICONNECTION_Setting_SetDataRoamingStatus(MMICONNECTION_SETTING_DATA_ROAMING_ENABLE);
        }
        else
        {
		MMIAPICONNECTION_Setting_SetDataRoamingStatus(MMICONNECTION_SETTING_DATA_ROAMING_DISABLE);
        }
        MMK_CloseWin(win_id);
        break;        
    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}  
#endif  

/*****************************************************************************/
//  Description : GetNetId
//  Global resource dependence :
//  Author:shuting.ma
//  Note:
/*****************************************************************************/
LOCAL uint32 GetNetId(MN_DUAL_SYS_E dual_sys)
{
#ifdef MMI_GPRS_SUPPORT
#ifndef WIN32
    MN_GPRS_CON_STATE_T     *ret_state_ptr = PNULL;
    uint32                  pdp_context_num = 0;
    uint32                  i = 0;
    uint8                   net_id = 0;

    MNGPRS_ReadPdpContextStateEx(dual_sys, &ret_state_ptr, &pdp_context_num);
    SCI_TRACE_LOW("GetNetId pdp_context_num %d", pdp_context_num);

    for(i=0; i<pdp_context_num; i++)
    {
        if(MN_CONTEXT_ACTIVATED == ret_state_ptr[i].pdp_state)
        {
            net_id = MNGPRS_GetNsapiByCidEx(dual_sys, ret_state_ptr[i].pdp_id);
            SCI_TRACE_LOW("GetNetId net_id %d", net_id);
            return (uint32)net_id;
        }
    }
    return 0;
#else
    return 0;
#endif
#else
    return 0;
#endif
}

/*****************************************************************************/
//  Description : GetFlowRate
//  Global resource dependence :
//  Author:shuting.ma
//  Note:
/*****************************************************************************/
LOCAL BOOLEAN GetFlowRate(uint64 *send_flowrate_ptr, uint64 *recv_flowrate_ptr)
{
    TCPIP_NETID_T net_id = 0;
    MN_DUAL_SYS_E sim_id = MN_DUAL_SYS_1;

#ifdef MMI_GPRS_SUPPORT
    if(0 == send_flowrate_ptr || 0 == recv_flowrate_ptr)
    {
        SCI_TRACE_LOW("GetFlowRate flowrate is PNULL");
        return FALSE;
    }
    sim_id = MMIAPISET_GetDataSimFromNV();
    SCI_TRACE_LOW("GetFlowRate sim_id %d", sim_id);

    net_id = GetNetId(sim_id);
    SCI_TRACE_LOW("GetFlowRate net_id %d", net_id);
    if(0==sci_getthroughput_ext(send_flowrate_ptr,recv_flowrate_ptr, net_id))
    {
        SCI_TRACE_LOW("PsGetFlowRate send_flowrate_ptr %d,recv_flowrate_ptr %d", *send_flowrate_ptr, *recv_flowrate_ptr);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
#else
    return FALSE;
#endif
}

/*****************************************************************************/
//  Description : 显示上下行流量
//  Global resource dependence :
//  Author:shuting.ma
//  Note:
/*****************************************************************************/
LOCAL void ShowFlowrateInfo(
                            BOOLEAN   need_update
                            )
{
    wchar               unicode_cr = 0x0d;  //'\r'
    MMI_STRING_T        cr_s = {0};
    MMI_STRING_T        text_s = {0};
    uint16              uint16_str[MMIENG_FLOWRATE_TEXT_LEN + 1] = {0};
    uint16              uint16_str_len = 0;
    char                temp_ptr[MMIENG_FLOWRATE_TEXT_LEN + 1] = {0};
    uint16              temp_len = 0;
    char                donwlink[MMIENG_FLOWRATE_BUFFER_LENGTH] = {0};
    char                uplink[MMIENG_FLOWRATE_BUFFER_LENGTH] = {0};
    uint64              total_send = 0;
    uint64              total_recv = 0;

    cr_s.wstr_ptr = &unicode_cr;
    cr_s.wstr_len = 1;
    SCI_MEMSET(temp_ptr, 0, MMIENG_FLOWRATE_TEXT_LEN);

    sprintf(temp_ptr, "Flow Rate");
    temp_len = SCI_STRLEN((char*)temp_ptr);
    MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行

    GetFlowRate(&total_send, &total_recv);
    SCI_TRACE_LOW("GetNetId total_send %d, total_recv %d", total_send, total_recv);

    sci_itoa(total_send, uplink, MMIENG_FLOWRATE_BUFFER_LENGTH, 10);
    SCI_TRACE_LOW("GetNetId display_send_str %s", uplink);

#ifndef _WIN32
    sprintf(temp_ptr, "total send: %sByte", uplink);
    SCI_TRACE_LOW("GetNetId 1 temp_len %d, uint16_str_len  %d" ,temp_len, uint16_str_len);
#else
    sprintf(temp_ptr, "total send: 0Byte");
#endif

    temp_len = SCI_STRLEN((char*)temp_ptr);
    SCI_TRACE_LOW("GetNetId 2 temp_len %d, uint16_str_len  %d" ,temp_len, uint16_str_len);

    MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行
    SCI_TRACE_LOW("GetNetId  3 temp_len %d, uint16_str_len  %d" ,temp_len, uint16_str_len);

    sci_itoa(total_recv, donwlink, MMIENG_FLOWRATE_BUFFER_LENGTH, 10);
    SCI_TRACE_LOW("GetNetId display_recv_str %s", donwlink);

#ifndef _WIN32
    sprintf(temp_ptr, "total receive: %sByte", donwlink);
    SCI_TRACE_LOW("GetNetId  4 temp_len %d, uint16_str_len  %d" ,temp_len, uint16_str_len);
#else
    sprintf(temp_ptr, "total receive: 0Byte");
#endif

    temp_len = SCI_STRLEN((char*)temp_ptr);
    SCI_TRACE_LOW("GetNetId  5 temp_len %d, uint16_str_len  %d" ,temp_len, uint16_str_len);
    MMIAPICOM_StrcatFromStrToUCS2(uint16_str, &uint16_str_len, (uint8*)temp_ptr, temp_len );
    MMIAPICOM_StrcatFromSTRINGToUCS2(uint16_str, &uint16_str_len, &cr_s);//换行

    text_s.wstr_ptr = uint16_str;
    text_s.wstr_len = uint16_str_len;
    SCI_TRACE_LOW("GetNetId temp_len %d, text_s.wstr_len  %d" ,temp_len, text_s.wstr_len);

    GUITEXT_SetString(MMIENG_FLOWRATE_TEXT_CTRL_ID, text_s.wstr_ptr, text_s.wstr_len, need_update);
}
/*****************************************************************************/
//  Description :   EngShowFlowrateWinHandleMsg
//  Global resource dependence :
//  Author:shuting.ma
//  Note:
/*****************************************************************************/
LOCAL MMI_RESULT_E EngShowFlowrateWinHandleMsg(MMI_WIN_ID_T win_id, MMI_MESSAGE_ID_E msg_id, DPARAM param)
{
    MMI_RESULT_E        result = MMI_RESULT_TRUE;

    switch (msg_id)
    {
    case MSG_OPEN_WINDOW:
        MMK_SetAtvCtrl(win_id, MMIENG_FLOWRATE_TEXT_CTRL_ID);
        ShowFlowrateInfo(FALSE);
        break;

    case MSG_CTL_OK:
    case MSG_CTL_CANCEL:
    case MSG_CTL_MIDSK:
        MMK_CloseWin(win_id);
        break;

    default:
        result = MMI_RESULT_FALSE;
        break;
    }
    return (result);
}


/*Edit by script, ignore 3 case. Thu Apr 26 19:00:53 2012*/ //IGNORE9527


/*Edit by script, ignore 88 case. Fri Apr 27 09:38:50 2012*/ //IGNORE9527
