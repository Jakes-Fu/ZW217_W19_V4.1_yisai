/*****************************************************************************
** File Name:      mmiim_tp_ui.c                                             *
** Author:                                                                   *
** Date:           2010/08/14                                                *
** Copyright:      2006 Spreadtrum, Incorporated. All Rights Reserved.       *
** Description:                                                              *
******************************************************************************
**                         Important Edit History                            *
** --------------------------------------------------------------------------*
** DATE           NAME             DESCRIPTION                               *
** 2010/08/14    jian.ma           Create                                    *
******************************************************************************/

/**--------------------------------------------------------------------------*
**                         Include Files                                    *
**--------------------------------------------------------------------------*/
#if (defined (TOUCH_PANEL_SUPPORT) && (!defined MMI_IM_PDA_SUPPORT))

#include "mmi_app_im_trc.h"
#include "mmiim_tp_ui.h"
#include "mmiim_tp_cstar_position.h"
#include "mmk_type.h"
#include "mmitheme_pos.h"
#include "guistring.h"
#include "guiblock.h"
#include "ui_layer.h"
#include "mmiim_image.h"
#include "guires.h"
#include "mmi_theme.h"
#include "mmk_timer.h"
#include "mmiim_internal.h"
//#include "mmiset.h"
#include "mmiset_export.h"
#include "mmiim_base.h"
#include "mmiim_sp_ml26key_data.h"
/**--------------------------------------------------------------------------*
**                         MACRO DEFINITION                                 *
**--------------------------------------------------------------------------*/


/**--------------------------------------------------------------------------*
**                         STATIC DEFINITION                                *
**--------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/*                          TYPE AND CONSTANT                                */
/*---------------------------------------------------------------------------*/




/**-------------------------------------------------------------------------*
**                         GLOBAL DEFINITION                                *
**--------------------------------------------------------------------------*/
#ifdef IM_ENGINE_SOGOU
#include "wd_def.h"
#endif
#ifdef IM_ENGINE_SOGOU
extern void MMIMLS9_SetLastDisp(uint16 n);
extern uint8 MMIMLS9_GetLastDisp(void);
extern WD_imeResult* WD_GetImeResult(void);
#endif

extern MMIIM_TP_CSTAR_STATE_T g_keyboard_state[MMIIM_TP_CSTAR_STATE_MAX - MMIIM_TP_CSTAR_KB_START_ID];

//一些画画常用的一些设置
LOCAL MMIIM_TP_CSTAR_TEXT_BAR_THEME_T s_text_bar_theme =
{
    IMG_IMSP_CAND_BAR,
    {0, IMG_IMSP_ARROW_UP_DIS, IMG_IMSP_ARROW_UP_OFF, IMG_IMSP_ARROW_UP_ON},
    {0, IMG_IMSP_ARROW_DOWN_DIS, IMG_IMSP_ARROW_DOWN_OFF, IMG_IMSP_ARROW_DOWN_ON},

    MMIIM_TP_CSTAR_TEXT_BAR_FONT_TEXT,
    MMIIM_TP_CSTAR_TEXT_BAR_FONT_LABEL,
    MMIIM_TP_CSTAR_TEXT_BAR_COLOR_TEXT,
    MMIIM_TP_CSTAR_TEXT_BAR_COLOR_LABEL,
    MMIIM_TP_CSTAR_TEXT_BAR_COLOR_HOT,
};

static MMIIM_METHOD_KEYBOARD_RELATION_T const g_method_keyboard_relation_list[] =
{
    //物理9键
    {GUIIM_M_TP_123,                            MMIIM_TP_CSTAR_STATE_DIG},
    {GUIIM_M_TPQ_123,                           MMIIM_TP_CSTAR_STATE_DIG},
    {GUIIM_M_TP_ENGLISH_ABC_LEAD_UPPER,         MMIIM_TP_CSTAR_STATE_ABC_9KEY_LEAD},
    {GUIIM_M_TP_ENGLISH_ABC_LOWER,              MMIIM_TP_CSTAR_STATE_ABC_9KEY_LOWER},
    {GUIIM_M_TP_ENGLISH_ABC_UPPER,              MMIIM_TP_CSTAR_STATE_ABC_9KEY_UPPER},
    {GUIIM_M_TPQ_ENGLISH_ABC_LEAD_UPPER,        MMIIM_TP_CSTAR_STATE_ABC_26KEY_LEAD},
    {GUIIM_M_TPQ_ENGLISH_ABC_LOWER,             MMIIM_TP_CSTAR_STATE_ABC_26KEY_LOWER},
    {GUIIM_M_TPQ_ENGLISH_ABC_UPPER,             MMIIM_TP_CSTAR_STATE_ABC_26KEY_UPPER},

#ifdef IM_SIMP_CHINESE_SUPPORT
    {GUIIM_M_TP_PINYIN,                         MMIIM_TP_CSTAR_STATE_PY_9KEY},
    {GUIIM_M_TP_STROKE,                         MMIIM_TP_CSTAR_STATE_STROKE},
    {GUIIM_M_TPQ_PINYIN,                        MMIIM_TP_CSTAR_STATE_PY_26KEY},
    {GUIIM_M_TPQ_STROKE,                        MMIIM_TP_CSTAR_STATE_STROKE},
#endif    
        
#ifdef IM_ENGLISH_SUPPORT
    {GUIIM_M_TP_ENGLISH_LEAD_UPPER,             MMIIM_TP_CSTAR_STATE_EN_9KEY_LEAD},
    {GUIIM_M_TP_ENGLISH_LOWER,                  MMIIM_TP_CSTAR_STATE_EN_9KEY_LOWER},
    {GUIIM_M_TP_ENGLISH_UPPER,                  MMIIM_TP_CSTAR_STATE_EN_9KEY_UPPER},
    {GUIIM_M_TP_ENGLISH,                        MMIIM_TP_CSTAR_STATE_EN_9KEY_LEAD},
    {GUIIM_M_TPQ_ENGLISH_LEAD_UPPER,            MMIIM_TP_CSTAR_STATE_EN_26KEY_LEAD},
    {GUIIM_M_TPQ_ENGLISH_LOWER,                 MMIIM_TP_CSTAR_STATE_EN_26KEY_LOWER},
    {GUIIM_M_TPQ_ENGLISH_UPPER,                 MMIIM_TP_CSTAR_STATE_EN_26KEY_UPPER},
    {GUIIM_M_TPQ_ENGLISH,                       MMIIM_TP_CSTAR_STATE_EN_26KEY_LEAD},
#endif

#ifdef IM_TRAD_CHINESE_SUPPORT
    {GUIIM_M_TP_ZHUYIN,                         MMIIM_TP_CSTAR_STATE_TRAD_PY_9KEY},
    {GUIIM_M_TP_STROKE_CHT,                     MMIIM_TP_CSTAR_STATE_TRAD_STROKE},
    {GUIIM_M_TPQ_ZHUYIN,                        MMIIM_TP_CSTAR_STATE_TRAD_PY_26KEY},
    {GUIIM_M_TPQ_STROKE_CHT,                    MMIIM_TP_CSTAR_STATE_TRAD_STROKE},
#endif

#ifdef IM_FRENCH_SUPPORT
    {GUIIM_M_TP_FRENCH_LEAD_UPPER,              MMIIM_TP_CSTAR_STATE_FRENCH_9KEY_LEAD},
    {GUIIM_M_TP_FRENCH_LOWER,                   MMIIM_TP_CSTAR_STATE_FRENCH_9KEY_LOWER},
    {GUIIM_M_TP_FRENCH_UPPER,                   MMIIM_TP_CSTAR_STATE_FRENCH_9KEY_UPPER},
    {GUIIM_M_TP_FRENCH,                         MMIIM_TP_CSTAR_STATE_FRENCH_9KEY_LEAD},
    {GUIIM_M_TPQ_FRENCH_LEAD_UPPER,             MMIIM_TP_CSTAR_STATE_FRENCH_26KEY_LEAD},
    {GUIIM_M_TPQ_FRENCH_LOWER,                  MMIIM_TP_CSTAR_STATE_FRENCH_26KEY_LOWER},
    {GUIIM_M_TPQ_FRENCH_UPPER,                  MMIIM_TP_CSTAR_STATE_FRENCH_26KEY_UPPER},
    {GUIIM_M_TPQ_FRENCH,                        MMIIM_TP_CSTAR_STATE_FRENCH_26KEY_LEAD},
    
    {GUIIM_M_TP_FRENCH_ABC_LEAD_UPPER,          MMIIM_TP_CSTAR_STATE_FRENCH_ABC_9KEY_LEAD},
    {GUIIM_M_TP_FRENCH_ABC_LOWER,               MMIIM_TP_CSTAR_STATE_FRENCH_ABC_9KEY_LOWER},
    {GUIIM_M_TP_FRENCH_ABC_UPPER,               MMIIM_TP_CSTAR_STATE_FRENCH_ABC_9KEY_UPPER},
    {GUIIM_M_TP_FRENCH_ABC,                     MMIIM_TP_CSTAR_STATE_FRENCH_ABC_9KEY_LEAD},
    {GUIIM_M_TPQ_FRENCH_ABC_LEAD_UPPER,         MMIIM_TP_CSTAR_STATE_FRENCH_ABC_26KEY_LEAD},
    {GUIIM_M_TPQ_FRENCH_ABC_LOWER,              MMIIM_TP_CSTAR_STATE_FRENCH_ABC_26KEY_LOWER},
    {GUIIM_M_TPQ_FRENCH_ABC_UPPER,              MMIIM_TP_CSTAR_STATE_FRENCH_ABC_26KEY_UPPER},
    {GUIIM_M_TPQ_FRENCH_ABC,                    MMIIM_TP_CSTAR_STATE_FRENCH_ABC_26KEY_LEAD},
#endif

#ifdef IM_ARABIC_SUPPORT
    {GUIIM_M_TP_ARABIC,                         MMIIM_TP_CSTAR_STATE_ARABIC_9KEY},
    {GUIIM_M_TPQ_ARABIC,                        MMIIM_TP_CSTAR_STATE_ARABIC_26KEY},
    {GUIIM_M_TP_ARABIC_ABC,                     MMIIM_TP_CSTAR_STATE_ARABIC_ABC_9KEY},
    {GUIIM_M_TPQ_ARABIC_ABC,                    MMIIM_TP_CSTAR_STATE_ARABIC_ABC_26KEY},
#endif

#ifdef IM_TURKISH_SUPPORT
    {GUIIM_M_TP_TURKISH_LEAD_UPPER,             MMIIM_TP_CSTAR_STATE_TURKISH_9KEY_LEAD},
    {GUIIM_M_TP_TURKISH_LOWER,                  MMIIM_TP_CSTAR_STATE_TURKISH_9KEY_LOWER},
    {GUIIM_M_TP_TURKISH_UPPER,                  MMIIM_TP_CSTAR_STATE_TURKISH_9KEY_UPPER},
    {GUIIM_M_TP_TURKISH,                        MMIIM_TP_CSTAR_STATE_TURKISH_9KEY_LEAD},
    {GUIIM_M_TPQ_TURKISH_LEAD_UPPER,            MMIIM_TP_CSTAR_STATE_TURKISH_26KEY_LEAD},
    {GUIIM_M_TPQ_TURKISH_LOWER,                 MMIIM_TP_CSTAR_STATE_TURKISH_26KEY_LOWER},
    {GUIIM_M_TPQ_TURKISH_UPPER,                 MMIIM_TP_CSTAR_STATE_TURKISH_26KEY_UPPER},
    {GUIIM_M_TPQ_TURKISH,                       MMIIM_TP_CSTAR_STATE_TURKISH_26KEY_LEAD},
    
    {GUIIM_M_TP_TURKISH_ABC_LEAD_UPPER,         MMIIM_TP_CSTAR_STATE_TURKISH_ABC_9KEY_LEAD},
    {GUIIM_M_TP_TURKISH_ABC_LOWER,              MMIIM_TP_CSTAR_STATE_TURKISH_ABC_9KEY_LOWER},
    {GUIIM_M_TP_TURKISH_ABC_UPPER,              MMIIM_TP_CSTAR_STATE_TURKISH_ABC_9KEY_UPPER},
    {GUIIM_M_TP_TURKISH_ABC,                    MMIIM_TP_CSTAR_STATE_TURKISH_ABC_9KEY_LEAD},
    {GUIIM_M_TPQ_TURKISH_ABC_LEAD_UPPER,        MMIIM_TP_CSTAR_STATE_TURKISH_ABC_26KEY_LEAD},
    {GUIIM_M_TPQ_TURKISH_ABC_LOWER,             MMIIM_TP_CSTAR_STATE_TURKISH_ABC_26KEY_LOWER},
    {GUIIM_M_TPQ_TURKISH_ABC_UPPER,             MMIIM_TP_CSTAR_STATE_TURKISH_ABC_26KEY_UPPER},
    {GUIIM_M_TPQ_TURKISH_ABC,                   MMIIM_TP_CSTAR_STATE_TURKISH_ABC_26KEY_LEAD},
#endif

#ifdef IM_PERSIAN_SUPPORT
    {GUIIM_M_TP_PERSIAN,                        MMIIM_TP_CSTAR_STATE_PERSIAN_9KEY},
    {GUIIM_M_TPQ_PERSIAN,                       MMIIM_TP_CSTAR_STATE_PERSIAN_26KEY},
    {GUIIM_M_TP_PERSIAN_ABC,                    MMIIM_TP_CSTAR_STATE_PERSIAN_ABC_9KEY},
    {GUIIM_M_TPQ_PERSIAN_ABC,                   MMIIM_TP_CSTAR_STATE_PERSIAN_ABC_26KEY},
#endif

#ifdef IM_PORTUGUESE_SUPPORT
    {GUIIM_M_TP_PORTUGUESE_LEAD_UPPER,          MMIIM_TP_CSTAR_STATE_PORTUGUESE_9KEY_LEAD},
    {GUIIM_M_TP_PORTUGUESE_LOWER,               MMIIM_TP_CSTAR_STATE_PORTUGUESE_9KEY_LOWER},
    {GUIIM_M_TP_PORTUGUESE_UPPER,               MMIIM_TP_CSTAR_STATE_PORTUGUESE_9KEY_UPPER},
    {GUIIM_M_TP_PORTUGUESE,                     MMIIM_TP_CSTAR_STATE_PORTUGUESE_9KEY_LEAD},
    {GUIIM_M_TPQ_PORTUGUESE_LEAD_UPPER,         MMIIM_TP_CSTAR_STATE_PORTUGUESE_26KEY_LEAD},
    {GUIIM_M_TPQ_PORTUGUESE_LOWER,              MMIIM_TP_CSTAR_STATE_PORTUGUESE_26KEY_LOWER},
    {GUIIM_M_TPQ_PORTUGUESE_UPPER,              MMIIM_TP_CSTAR_STATE_PORTUGUESE_26KEY_UPPER},
    {GUIIM_M_TPQ_PORTUGUESE,                    MMIIM_TP_CSTAR_STATE_PORTUGUESE_26KEY_LEAD},
    
    {GUIIM_M_TP_PORTUGUESE_ABC_LEAD_UPPER,      MMIIM_TP_CSTAR_STATE_PORTUGUESE_ABC_9KEY_LEAD},
    {GUIIM_M_TP_PORTUGUESE_ABC_LOWER,           MMIIM_TP_CSTAR_STATE_PORTUGUESE_ABC_9KEY_LOWER},
    {GUIIM_M_TP_PORTUGUESE_ABC_UPPER,           MMIIM_TP_CSTAR_STATE_PORTUGUESE_ABC_9KEY_UPPER},
    {GUIIM_M_TP_PORTUGUESE_ABC,                 MMIIM_TP_CSTAR_STATE_PORTUGUESE_ABC_9KEY_LEAD},
    {GUIIM_M_TPQ_PORTUGUESE_ABC_LEAD_UPPER,     MMIIM_TP_CSTAR_STATE_PORTUGUESE_ABC_26KEY_LEAD},
    {GUIIM_M_TPQ_PORTUGUESE_ABC_LOWER,          MMIIM_TP_CSTAR_STATE_PORTUGUESE_ABC_26KEY_LOWER},
    {GUIIM_M_TPQ_PORTUGUESE_ABC_UPPER,          MMIIM_TP_CSTAR_STATE_PORTUGUESE_ABC_26KEY_UPPER},
    {GUIIM_M_TPQ_PORTUGUESE_ABC,                MMIIM_TP_CSTAR_STATE_PORTUGUESE_ABC_26KEY_LEAD},
#endif

#ifdef IM_SPANISH_SUPPORT
    {GUIIM_M_TP_SPANISH_LEAD_UPPER,             MMIIM_TP_CSTAR_STATE_SPANISH_9KEY_LEAD},
    {GUIIM_M_TP_SPANISH_LOWER,                  MMIIM_TP_CSTAR_STATE_SPANISH_9KEY_LOWER},
    {GUIIM_M_TP_SPANISH_UPPER,                  MMIIM_TP_CSTAR_STATE_SPANISH_9KEY_UPPER},
    {GUIIM_M_TP_SPANISH,                        MMIIM_TP_CSTAR_STATE_SPANISH_9KEY_LEAD},
    {GUIIM_M_TPQ_SPANISH_LEAD_UPPER,            MMIIM_TP_CSTAR_STATE_SPANISH_26KEY_LEAD},
    {GUIIM_M_TPQ_SPANISH_LOWER,                 MMIIM_TP_CSTAR_STATE_SPANISH_26KEY_LOWER},
    {GUIIM_M_TPQ_SPANISH_UPPER,                 MMIIM_TP_CSTAR_STATE_SPANISH_26KEY_UPPER},
    {GUIIM_M_TPQ_SPANISH,                       MMIIM_TP_CSTAR_STATE_SPANISH_26KEY_LEAD},
    
    {GUIIM_M_TP_SPANISH_ABC_LEAD_UPPER,         MMIIM_TP_CSTAR_STATE_SPANISH_ABC_9KEY_LEAD},
    {GUIIM_M_TP_SPANISH_ABC_LOWER,              MMIIM_TP_CSTAR_STATE_SPANISH_ABC_9KEY_LOWER},
    {GUIIM_M_TP_SPANISH_ABC_UPPER,              MMIIM_TP_CSTAR_STATE_SPANISH_ABC_9KEY_UPPER},
    {GUIIM_M_TP_SPANISH_ABC,                    MMIIM_TP_CSTAR_STATE_SPANISH_ABC_9KEY_LEAD},
    {GUIIM_M_TPQ_SPANISH_ABC_LEAD_UPPER,        MMIIM_TP_CSTAR_STATE_SPANISH_ABC_26KEY_LEAD},
    {GUIIM_M_TPQ_SPANISH_ABC_LOWER,             MMIIM_TP_CSTAR_STATE_SPANISH_ABC_26KEY_LOWER},
    {GUIIM_M_TPQ_SPANISH_ABC_UPPER,             MMIIM_TP_CSTAR_STATE_SPANISH_ABC_26KEY_UPPER},
    {GUIIM_M_TPQ_SPANISH_ABC,                   MMIIM_TP_CSTAR_STATE_SPANISH_ABC_26KEY_LEAD},
#endif

//他加诺multitap虚拟键盘部分	
#ifdef IM_TAGALOG_SUPPORT
    //multitap
    {GUIIM_M_TP_TAGALOG_ABC, MMIIM_TP_CSTAR_STATE_TAGALOG_ABC_9KEY_UPPER},
    {GUIIM_M_TPQ_TAGALOG_ABC, MMIIM_TP_CSTAR_STATE_TAGALOG_ABC_26KEY_UPPER},
#endif

#ifdef IM_RUSSIAN_SUPPORT
    {GUIIM_M_TP_RUSSIAN_LEAD_UPPER,             MMIIM_TP_CSTAR_STATE_RUSSIAN_9KEY_LEAD},
    {GUIIM_M_TP_RUSSIAN_LOWER,                  MMIIM_TP_CSTAR_STATE_RUSSIAN_9KEY_LOWER},
    {GUIIM_M_TP_RUSSIAN_UPPER,                  MMIIM_TP_CSTAR_STATE_RUSSIAN_9KEY_UPPER},
    {GUIIM_M_TP_RUSSIAN,                        MMIIM_TP_CSTAR_STATE_RUSSIAN_9KEY_LEAD},
    {GUIIM_M_TPQ_RUSSIAN_LEAD_UPPER,            MMIIM_TP_CSTAR_STATE_RUSSIAN_26KEY_LEAD},
    {GUIIM_M_TPQ_RUSSIAN_LOWER,                 MMIIM_TP_CSTAR_STATE_RUSSIAN_26KEY_LOWER},
    {GUIIM_M_TPQ_RUSSIAN_UPPER,                 MMIIM_TP_CSTAR_STATE_RUSSIAN_26KEY_UPPER},
    {GUIIM_M_TPQ_RUSSIAN,                       MMIIM_TP_CSTAR_STATE_RUSSIAN_26KEY_LEAD},
    
    {GUIIM_M_TP_RUSSIAN_ABC_LEAD_UPPER,         MMIIM_TP_CSTAR_STATE_RUSSIAN_ABC_9KEY_LEAD},
    {GUIIM_M_TP_RUSSIAN_ABC_LOWER,              MMIIM_TP_CSTAR_STATE_RUSSIAN_ABC_9KEY_LOWER},
    {GUIIM_M_TP_RUSSIAN_ABC_UPPER,              MMIIM_TP_CSTAR_STATE_RUSSIAN_ABC_9KEY_UPPER},
    {GUIIM_M_TP_RUSSIAN_ABC,                    MMIIM_TP_CSTAR_STATE_RUSSIAN_ABC_9KEY_LEAD},
    {GUIIM_M_TPQ_RUSSIAN_ABC_LEAD_UPPER,        MMIIM_TP_CSTAR_STATE_RUSSIAN_ABC_26KEY_LEAD},
    {GUIIM_M_TPQ_RUSSIAN_ABC_LOWER,             MMIIM_TP_CSTAR_STATE_RUSSIAN_ABC_26KEY_LOWER},
    {GUIIM_M_TPQ_RUSSIAN_ABC_UPPER,             MMIIM_TP_CSTAR_STATE_RUSSIAN_ABC_26KEY_UPPER},
    {GUIIM_M_TPQ_RUSSIAN_ABC,                   MMIIM_TP_CSTAR_STATE_RUSSIAN_ABC_26KEY_LEAD},
#endif

#ifdef IM_INDONESIAN_SUPPORT
    {GUIIM_M_TP_INDONESIAN_LEAD_UPPER,          MMIIM_TP_CSTAR_STATE_INDONESIAN_9KEY_LEAD},
    {GUIIM_M_TP_INDONESIAN_LOWER,               MMIIM_TP_CSTAR_STATE_INDONESIAN_9KEY_LOWER},
    {GUIIM_M_TP_INDONESIAN_UPPER,               MMIIM_TP_CSTAR_STATE_INDONESIAN_9KEY_UPPER},
    {GUIIM_M_TP_INDONESIAN,                     MMIIM_TP_CSTAR_STATE_INDONESIAN_9KEY_LEAD},
    {GUIIM_M_TPQ_INDONESIAN_LEAD_UPPER,         MMIIM_TP_CSTAR_STATE_INDONESIAN_26KEY_LEAD},
    {GUIIM_M_TPQ_INDONESIAN_LOWER,              MMIIM_TP_CSTAR_STATE_INDONESIAN_26KEY_LOWER},
    {GUIIM_M_TPQ_INDONESIAN_UPPER,              MMIIM_TP_CSTAR_STATE_INDONESIAN_26KEY_UPPER},
    {GUIIM_M_TPQ_INDONESIAN,                    MMIIM_TP_CSTAR_STATE_INDONESIAN_26KEY_LEAD},
    
    {GUIIM_M_TP_INDONESIAN_ABC_LEAD_UPPER,      MMIIM_TP_CSTAR_STATE_INDONESIAN_ABC_9KEY_LEAD},
    {GUIIM_M_TP_INDONESIAN_ABC_LOWER,           MMIIM_TP_CSTAR_STATE_INDONESIAN_ABC_9KEY_LOWER},
    {GUIIM_M_TP_INDONESIAN_ABC_UPPER,           MMIIM_TP_CSTAR_STATE_INDONESIAN_ABC_9KEY_UPPER},
    {GUIIM_M_TP_INDONESIAN_ABC,                 MMIIM_TP_CSTAR_STATE_INDONESIAN_ABC_9KEY_LEAD},
    {GUIIM_M_TPQ_INDONESIAN_ABC_LEAD_UPPER,     MMIIM_TP_CSTAR_STATE_INDONESIAN_ABC_26KEY_LEAD},
    {GUIIM_M_TPQ_INDONESIAN_ABC_LOWER,          MMIIM_TP_CSTAR_STATE_INDONESIAN_ABC_26KEY_LOWER},
    {GUIIM_M_TPQ_INDONESIAN_ABC_UPPER,          MMIIM_TP_CSTAR_STATE_INDONESIAN_ABC_26KEY_UPPER},
    {GUIIM_M_TPQ_INDONESIAN_ABC,                MMIIM_TP_CSTAR_STATE_INDONESIAN_ABC_26KEY_LEAD},
#endif

#ifdef IM_MALAY_SUPPORT
    {GUIIM_M_TP_MALAY_LEAD_UPPER,               MMIIM_TP_CSTAR_STATE_MALAY_9KEY_LEAD},
    {GUIIM_M_TP_MALAY_LOWER,                    MMIIM_TP_CSTAR_STATE_MALAY_9KEY_LOWER},
    {GUIIM_M_TP_MALAY_UPPER,                    MMIIM_TP_CSTAR_STATE_MALAY_9KEY_UPPER},
    {GUIIM_M_TP_MALAY,                          MMIIM_TP_CSTAR_STATE_MALAY_9KEY_LEAD},
    {GUIIM_M_TPQ_MALAY_LEAD_UPPER,              MMIIM_TP_CSTAR_STATE_MALAY_26KEY_LEAD},
    {GUIIM_M_TPQ_MALAY_LOWER,                   MMIIM_TP_CSTAR_STATE_MALAY_26KEY_LOWER},
    {GUIIM_M_TPQ_MALAY_UPPER,                   MMIIM_TP_CSTAR_STATE_MALAY_26KEY_UPPER},
    {GUIIM_M_TPQ_MALAY,                         MMIIM_TP_CSTAR_STATE_MALAY_26KEY_LEAD},
    
    {GUIIM_M_TP_MALAY_ABC_LEAD_UPPER,           MMIIM_TP_CSTAR_STATE_MALAY_ABC_9KEY_LEAD},
    {GUIIM_M_TP_MALAY_ABC_LOWER,                MMIIM_TP_CSTAR_STATE_MALAY_ABC_9KEY_LOWER},
    {GUIIM_M_TP_MALAY_ABC_UPPER,                MMIIM_TP_CSTAR_STATE_MALAY_ABC_9KEY_UPPER},
    {GUIIM_M_TP_MALAY_ABC,                      MMIIM_TP_CSTAR_STATE_MALAY_ABC_9KEY_LEAD},
    {GUIIM_M_TPQ_MALAY_ABC_LEAD_UPPER,          MMIIM_TP_CSTAR_STATE_MALAY_ABC_26KEY_LEAD},
    {GUIIM_M_TPQ_MALAY_ABC_LOWER,               MMIIM_TP_CSTAR_STATE_MALAY_ABC_26KEY_LOWER},
    {GUIIM_M_TPQ_MALAY_ABC_UPPER,               MMIIM_TP_CSTAR_STATE_MALAY_ABC_26KEY_UPPER},
    {GUIIM_M_TPQ_MALAY_ABC,                     MMIIM_TP_CSTAR_STATE_MALAY_ABC_26KEY_LEAD},
#endif

#ifdef IM_HUNGARIAN_SUPPORT
    {GUIIM_M_TP_HUNGARIAN_LEAD_UPPER,           MMIIM_TP_CSTAR_STATE_HUNGARIAN_9KEY_LEAD},
    {GUIIM_M_TP_HUNGARIAN_LOWER,                MMIIM_TP_CSTAR_STATE_HUNGARIAN_9KEY_LOWER},
    {GUIIM_M_TP_HUNGARIAN_UPPER,                MMIIM_TP_CSTAR_STATE_HUNGARIAN_9KEY_UPPER},
    {GUIIM_M_TP_HUNGARIAN,                      MMIIM_TP_CSTAR_STATE_HUNGARIAN_9KEY_LEAD},
    {GUIIM_M_TPQ_HUNGARIAN_LEAD_UPPER,          MMIIM_TP_CSTAR_STATE_HUNGARIAN_26KEY_LEAD},
    {GUIIM_M_TPQ_HUNGARIAN_LOWER,               MMIIM_TP_CSTAR_STATE_HUNGARIAN_26KEY_LOWER},
    {GUIIM_M_TPQ_HUNGARIAN_UPPER,               MMIIM_TP_CSTAR_STATE_HUNGARIAN_26KEY_UPPER},
    {GUIIM_M_TPQ_HUNGARIAN,                     MMIIM_TP_CSTAR_STATE_HUNGARIAN_26KEY_LEAD},
    
    {GUIIM_M_TP_HUNGARIAN_ABC_LEAD_UPPER,       MMIIM_TP_CSTAR_STATE_HUNGARIAN_ABC_9KEY_LEAD},
    {GUIIM_M_TP_HUNGARIAN_ABC_LOWER,            MMIIM_TP_CSTAR_STATE_HUNGARIAN_ABC_9KEY_LOWER},
    {GUIIM_M_TP_HUNGARIAN_ABC_UPPER,            MMIIM_TP_CSTAR_STATE_HUNGARIAN_ABC_9KEY_UPPER},
    {GUIIM_M_TP_HUNGARIAN_ABC,                  MMIIM_TP_CSTAR_STATE_HUNGARIAN_ABC_9KEY_LEAD},
    {GUIIM_M_TPQ_HUNGARIAN_ABC_LEAD_UPPER,      MMIIM_TP_CSTAR_STATE_HUNGARIAN_ABC_26KEY_LEAD},
    {GUIIM_M_TPQ_HUNGARIAN_ABC_LOWER,           MMIIM_TP_CSTAR_STATE_HUNGARIAN_ABC_26KEY_LOWER},
    {GUIIM_M_TPQ_HUNGARIAN_ABC_UPPER,           MMIIM_TP_CSTAR_STATE_HUNGARIAN_ABC_26KEY_UPPER},
    {GUIIM_M_TPQ_HUNGARIAN_ABC,                 MMIIM_TP_CSTAR_STATE_HUNGARIAN_ABC_26KEY_LEAD},
#endif
    
#ifdef IM_GERMAN_SUPPORT
    {GUIIM_M_TP_GERMAN_LEAD_UPPER,              MMIIM_TP_CSTAR_STATE_GERMAN_9KEY_LEAD},
    {GUIIM_M_TP_GERMAN_LOWER,                   MMIIM_TP_CSTAR_STATE_GERMAN_9KEY_LOWER},
    {GUIIM_M_TP_GERMAN_UPPER,                   MMIIM_TP_CSTAR_STATE_GERMAN_9KEY_UPPER},
    {GUIIM_M_TP_GERMAN,                         MMIIM_TP_CSTAR_STATE_GERMAN_9KEY_LEAD},
    {GUIIM_M_TPQ_GERMAN_LEAD_UPPER,             MMIIM_TP_CSTAR_STATE_GERMAN_26KEY_LEAD},
    {GUIIM_M_TPQ_GERMAN_LOWER,                  MMIIM_TP_CSTAR_STATE_GERMAN_26KEY_LOWER},
    {GUIIM_M_TPQ_GERMAN_UPPER,                  MMIIM_TP_CSTAR_STATE_GERMAN_26KEY_UPPER},
    {GUIIM_M_TPQ_GERMAN,                        MMIIM_TP_CSTAR_STATE_GERMAN_26KEY_LEAD},
    
    {GUIIM_M_TP_GERMAN_ABC_LEAD_UPPER,          MMIIM_TP_CSTAR_STATE_GERMAN_ABC_9KEY_LEAD},
    {GUIIM_M_TP_GERMAN_ABC_LOWER,               MMIIM_TP_CSTAR_STATE_GERMAN_ABC_9KEY_LOWER},
    {GUIIM_M_TP_GERMAN_ABC_UPPER,               MMIIM_TP_CSTAR_STATE_GERMAN_ABC_9KEY_UPPER},
    {GUIIM_M_TP_GERMAN_ABC,                     MMIIM_TP_CSTAR_STATE_GERMAN_ABC_9KEY_LEAD},
    {GUIIM_M_TPQ_GERMAN_ABC_LEAD_UPPER,         MMIIM_TP_CSTAR_STATE_GERMAN_ABC_26KEY_LEAD},
    {GUIIM_M_TPQ_GERMAN_ABC_LOWER,              MMIIM_TP_CSTAR_STATE_GERMAN_ABC_26KEY_LOWER},
    {GUIIM_M_TPQ_GERMAN_ABC_UPPER,              MMIIM_TP_CSTAR_STATE_GERMAN_ABC_26KEY_UPPER},
    {GUIIM_M_TPQ_GERMAN_ABC,                    MMIIM_TP_CSTAR_STATE_GERMAN_ABC_26KEY_LEAD},
#endif

#ifdef IM_GREEK_SUPPORT
    {GUIIM_M_TP_GREEK_LEAD_UPPER,               MMIIM_TP_CSTAR_STATE_GREEK_9KEY_LEAD},
    {GUIIM_M_TP_GREEK_LOWER,                    MMIIM_TP_CSTAR_STATE_GREEK_9KEY_LOWER},
    {GUIIM_M_TP_GREEK_UPPER,                    MMIIM_TP_CSTAR_STATE_GREEK_9KEY_UPPER},
    {GUIIM_M_TP_GREEK,                          MMIIM_TP_CSTAR_STATE_GREEK_9KEY_LEAD},
    {GUIIM_M_TPQ_GREEK_LEAD_UPPER,              MMIIM_TP_CSTAR_STATE_GREEK_26KEY_LEAD},
    {GUIIM_M_TPQ_GREEK_LOWER,                   MMIIM_TP_CSTAR_STATE_GREEK_26KEY_LOWER},
    {GUIIM_M_TPQ_GREEK_UPPER,                   MMIIM_TP_CSTAR_STATE_GREEK_26KEY_UPPER},
    {GUIIM_M_TPQ_GREEK,                         MMIIM_TP_CSTAR_STATE_GREEK_26KEY_LEAD},
    
    {GUIIM_M_TP_GREEK_ABC_LEAD_UPPER,           MMIIM_TP_CSTAR_STATE_GREEK_ABC_9KEY_LEAD},
    {GUIIM_M_TP_GREEK_ABC_LOWER,                MMIIM_TP_CSTAR_STATE_GREEK_ABC_9KEY_LOWER},
    {GUIIM_M_TP_GREEK_ABC_UPPER,                MMIIM_TP_CSTAR_STATE_GREEK_ABC_9KEY_UPPER},
    {GUIIM_M_TP_GREEK_ABC,                      MMIIM_TP_CSTAR_STATE_GREEK_ABC_9KEY_LEAD},
    {GUIIM_M_TPQ_GREEK_ABC_LEAD_UPPER,          MMIIM_TP_CSTAR_STATE_GREEK_ABC_26KEY_LEAD},
    {GUIIM_M_TPQ_GREEK_ABC_LOWER,               MMIIM_TP_CSTAR_STATE_GREEK_ABC_26KEY_LOWER},
    {GUIIM_M_TPQ_GREEK_ABC_UPPER,               MMIIM_TP_CSTAR_STATE_GREEK_ABC_26KEY_UPPER},
    {GUIIM_M_TPQ_GREEK_ABC,                     MMIIM_TP_CSTAR_STATE_GREEK_ABC_26KEY_LEAD},
#endif

#ifdef IM_HINDI_SUPPORT
    {GUIIM_M_TP_HINDI,                          MMIIM_TP_CSTAR_STATE_HINDI_9KEY},
    {GUIIM_M_TPQ_HINDI,                         MMIIM_TP_CSTAR_STATE_HINDI_26KEY},
    {GUIIM_M_TP_HINDI_ABC,                      MMIIM_TP_CSTAR_STATE_HINDI_ABC_9KEY},
    {GUIIM_M_TPQ_HINDI_ABC,                     MMIIM_TP_CSTAR_STATE_HINDI_ABC_26KEY},
#endif

#ifdef IM_THAI_SUPPORT
    {GUIIM_M_TP_THAI,                           MMIIM_TP_CSTAR_STATE_THAI_9KEY},
    {GUIIM_M_TPQ_THAI,                          MMIIM_TP_CSTAR_STATE_THAI_26KEY},
    {GUIIM_M_TP_THAI_ABC,                       MMIIM_TP_CSTAR_STATE_THAI_ABC_9KEY},
    {GUIIM_M_TPQ_THAI_ABC,                      MMIIM_TP_CSTAR_STATE_THAI_ABC_26KEY},
#endif

#ifdef IM_ITALIAN_SUPPORT
    {GUIIM_M_TP_ITALIAN_LEAD_UPPER,             MMIIM_TP_CSTAR_STATE_ITALIAN_9KEY_LEAD},
    {GUIIM_M_TP_ITALIAN_LOWER,                  MMIIM_TP_CSTAR_STATE_ITALIAN_9KEY_LOWER},
    {GUIIM_M_TP_ITALIAN_UPPER,                  MMIIM_TP_CSTAR_STATE_ITALIAN_9KEY_UPPER},
    {GUIIM_M_TP_ITALIAN,                        MMIIM_TP_CSTAR_STATE_ITALIAN_9KEY_LEAD},
    {GUIIM_M_TPQ_ITALIAN_LEAD_UPPER,            MMIIM_TP_CSTAR_STATE_ITALIAN_26KEY_LEAD},
    {GUIIM_M_TPQ_ITALIAN_LOWER,                 MMIIM_TP_CSTAR_STATE_ITALIAN_26KEY_LOWER},
    {GUIIM_M_TPQ_ITALIAN_UPPER,                 MMIIM_TP_CSTAR_STATE_ITALIAN_26KEY_UPPER},
    {GUIIM_M_TPQ_ITALIAN,                       MMIIM_TP_CSTAR_STATE_ITALIAN_26KEY_LEAD},
    
    {GUIIM_M_TP_ITALIAN_ABC_LEAD_UPPER,         MMIIM_TP_CSTAR_STATE_ITALIAN_ABC_9KEY_LEAD},
    {GUIIM_M_TP_ITALIAN_ABC_LOWER,              MMIIM_TP_CSTAR_STATE_ITALIAN_ABC_9KEY_LOWER},
    {GUIIM_M_TP_ITALIAN_ABC_UPPER,              MMIIM_TP_CSTAR_STATE_ITALIAN_ABC_9KEY_UPPER},
    {GUIIM_M_TP_ITALIAN_ABC,                    MMIIM_TP_CSTAR_STATE_ITALIAN_ABC_9KEY_LEAD},
    {GUIIM_M_TPQ_ITALIAN_ABC_LEAD_UPPER,        MMIIM_TP_CSTAR_STATE_ITALIAN_ABC_26KEY_LEAD},
    {GUIIM_M_TPQ_ITALIAN_ABC_LOWER,             MMIIM_TP_CSTAR_STATE_ITALIAN_ABC_26KEY_LOWER},
    {GUIIM_M_TPQ_ITALIAN_ABC_UPPER,             MMIIM_TP_CSTAR_STATE_ITALIAN_ABC_26KEY_UPPER},
    {GUIIM_M_TPQ_ITALIAN_ABC,                   MMIIM_TP_CSTAR_STATE_ITALIAN_ABC_26KEY_LEAD},
#endif

//哈萨克斯坦multitap关于虚拟键盘部分	add. 
#ifdef IM_KAZAKH_SUPPORT
    //multitap
    {GUIIM_M_TP_KAZAKH_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_KAZAKH_ABC_9KEY_LEAD}, 
    {GUIIM_M_TP_KAZAKH_ABC_LOWER, MMIIM_TP_CSTAR_STATE_KAZAKH_ABC_9KEY_LOWER}, 
    {GUIIM_M_TP_KAZAKH_ABC_UPPER, MMIIM_TP_CSTAR_STATE_KAZAKH_ABC_9KEY_UPPER}, 

    {GUIIM_M_TPQ_KAZAKH_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_KAZAKH_ABC_26KEY_LEAD}, 
    {GUIIM_M_TPQ_KAZAKH_ABC_LOWER, MMIIM_TP_CSTAR_STATE_KAZAKH_ABC_26KEY_LOWER}, 
    {GUIIM_M_TPQ_KAZAKH_ABC_UPPER, MMIIM_TP_CSTAR_STATE_KAZAKH_ABC_26KEY_UPPER}, 
#endif

//拉脱维亚语multitap关于虚拟键盘部分	add. 
#ifdef IM_LATVIAN_SUPPORT
    //multitap
    {GUIIM_M_TP_LATVIAN_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_LATVIAN_ABC_9KEY_LEAD}, 
    {GUIIM_M_TP_LATVIAN_ABC_LOWER, MMIIM_TP_CSTAR_STATE_LATVIAN_ABC_9KEY_LOWER}, 
    {GUIIM_M_TP_LATVIAN_ABC_UPPER, MMIIM_TP_CSTAR_STATE_LATVIAN_ABC_9KEY_UPPER}, 

    {GUIIM_M_TPQ_LATVIAN_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_LATVIAN_ABC_26KEY_LEAD}, 
    {GUIIM_M_TPQ_LATVIAN_ABC_LOWER, MMIIM_TP_CSTAR_STATE_LATVIAN_ABC_26KEY_LOWER}, 
    {GUIIM_M_TPQ_LATVIAN_ABC_UPPER, MMIIM_TP_CSTAR_STATE_LATVIAN_ABC_26KEY_UPPER}, 
#endif


#ifdef IM_URDU_SUPPORT
    {GUIIM_M_TP_URDU,                           MMIIM_TP_CSTAR_STATE_URDU_9KEY},
    {GUIIM_M_TPQ_URDU,                          MMIIM_TP_CSTAR_STATE_URDU_26KEY},
    {GUIIM_M_TP_URDU_ABC,                       MMIIM_TP_CSTAR_STATE_URDU_ABC_9KEY},
    {GUIIM_M_TPQ_URDU_ABC,                      MMIIM_TP_CSTAR_STATE_URDU_ABC_26KEY},
#endif

#ifdef IM_VIETNAMESE_SUPPORT
    {GUIIM_M_TP_VIETNAMESE_LEAD_UPPER,          MMIIM_TP_CSTAR_STATE_VIETNAMESE_9KEY_LEAD},
    {GUIIM_M_TP_VIETNAMESE_LOWER,               MMIIM_TP_CSTAR_STATE_VIETNAMESE_9KEY_LOWER},
    {GUIIM_M_TP_VIETNAMESE_UPPER,               MMIIM_TP_CSTAR_STATE_VIETNAMESE_9KEY_UPPER},
    {GUIIM_M_TP_VIETNAMESE,                     MMIIM_TP_CSTAR_STATE_VIETNAMESE_9KEY_LEAD},
    {GUIIM_M_TPQ_VIETNAMESE_LEAD_UPPER,         MMIIM_TP_CSTAR_STATE_VIETNAMESE_26KEY_LEAD},
    {GUIIM_M_TPQ_VIETNAMESE_LOWER,              MMIIM_TP_CSTAR_STATE_VIETNAMESE_26KEY_LOWER},
    {GUIIM_M_TPQ_VIETNAMESE_UPPER,              MMIIM_TP_CSTAR_STATE_VIETNAMESE_26KEY_UPPER},
    {GUIIM_M_TPQ_VIETNAMESE,                    MMIIM_TP_CSTAR_STATE_VIETNAMESE_26KEY_LEAD},
    
    {GUIIM_M_TP_VIETNAMESE_ABC_LEAD_UPPER,      MMIIM_TP_CSTAR_STATE_VIETNAMESE_ABC_9KEY_LEAD},
    {GUIIM_M_TP_VIETNAMESE_ABC_LOWER,           MMIIM_TP_CSTAR_STATE_VIETNAMESE_ABC_9KEY_LOWER},
    {GUIIM_M_TP_VIETNAMESE_ABC_UPPER,           MMIIM_TP_CSTAR_STATE_VIETNAMESE_ABC_9KEY_UPPER},
    {GUIIM_M_TP_VIETNAMESE_ABC,                 MMIIM_TP_CSTAR_STATE_VIETNAMESE_ABC_9KEY_LEAD},
    {GUIIM_M_TPQ_VIETNAMESE_ABC_LEAD_UPPER,     MMIIM_TP_CSTAR_STATE_VIETNAMESE_ABC_26KEY_LEAD},
    {GUIIM_M_TPQ_VIETNAMESE_ABC_LOWER,          MMIIM_TP_CSTAR_STATE_VIETNAMESE_ABC_26KEY_LOWER},
    {GUIIM_M_TPQ_VIETNAMESE_ABC_UPPER,          MMIIM_TP_CSTAR_STATE_VIETNAMESE_ABC_26KEY_UPPER},
    {GUIIM_M_TPQ_VIETNAMESE_ABC,                MMIIM_TP_CSTAR_STATE_VIETNAMESE_ABC_26KEY_LEAD},
#endif

#ifdef IM_HEBREW_SUPPORT
    {GUIIM_M_TP_HEBREW,                         MMIIM_TP_CSTAR_STATE_HEBREW_9KEY},
    {GUIIM_M_TPQ_HEBREW,                        MMIIM_TP_CSTAR_STATE_HEBREW_26KEY},
    {GUIIM_M_TP_HEBREW_ABC,                     MMIIM_TP_CSTAR_STATE_HEBREW_ABC_9KEY},
    {GUIIM_M_TPQ_HEBREW_ABC,                    MMIIM_TP_CSTAR_STATE_HEBREW_ABC_26KEY},
#endif

#ifdef IM_BENGALI_SUPPORT
    {GUIIM_M_TP_BENGALI,                        MMIIM_TP_CSTAR_STATE_BENGALI_9KEY},
    {GUIIM_M_TPQ_BENGALI,                       MMIIM_TP_CSTAR_STATE_BENGALI_26KEY},
    {GUIIM_M_TP_BENGALI_ABC,                    MMIIM_TP_CSTAR_STATE_BENGALI_ABC_9KEY},
    {GUIIM_M_TPQ_BENGALI_ABC,                   MMIIM_TP_CSTAR_STATE_BENGALI_ABC_26KEY},
#endif

#ifdef IM_CZECH_SUPPORT
    {GUIIM_M_TP_CZECH_LEAD_UPPER,               MMIIM_TP_CSTAR_STATE_CZECH_9KEY_LEAD},
    {GUIIM_M_TP_CZECH_LOWER,                    MMIIM_TP_CSTAR_STATE_CZECH_9KEY_LOWER},
    {GUIIM_M_TP_CZECH_UPPER,                    MMIIM_TP_CSTAR_STATE_CZECH_9KEY_UPPER},
    {GUIIM_M_TP_CZECH,                          MMIIM_TP_CSTAR_STATE_CZECH_9KEY_LEAD},
    {GUIIM_M_TPQ_CZECH_LEAD_UPPER,              MMIIM_TP_CSTAR_STATE_CZECH_26KEY_LEAD},
    {GUIIM_M_TPQ_CZECH_LOWER,                   MMIIM_TP_CSTAR_STATE_CZECH_26KEY_LOWER},
    {GUIIM_M_TPQ_CZECH_UPPER,                   MMIIM_TP_CSTAR_STATE_CZECH_26KEY_UPPER},
    {GUIIM_M_TPQ_CZECH,                         MMIIM_TP_CSTAR_STATE_CZECH_26KEY_LEAD},
    
    {GUIIM_M_TP_CZECH_ABC_LEAD_UPPER,           MMIIM_TP_CSTAR_STATE_CZECH_ABC_9KEY_LEAD},
    {GUIIM_M_TP_CZECH_ABC_LOWER,                MMIIM_TP_CSTAR_STATE_CZECH_ABC_9KEY_LOWER},
    {GUIIM_M_TP_CZECH_ABC_UPPER,                MMIIM_TP_CSTAR_STATE_CZECH_ABC_9KEY_UPPER},
    {GUIIM_M_TP_CZECH_ABC,                      MMIIM_TP_CSTAR_STATE_CZECH_ABC_9KEY_LEAD},
    {GUIIM_M_TPQ_CZECH_ABC_LEAD_UPPER,          MMIIM_TP_CSTAR_STATE_CZECH_ABC_26KEY_LEAD},
    {GUIIM_M_TPQ_CZECH_ABC_LOWER,               MMIIM_TP_CSTAR_STATE_CZECH_ABC_26KEY_LOWER},
    {GUIIM_M_TPQ_CZECH_ABC_UPPER,               MMIIM_TP_CSTAR_STATE_CZECH_ABC_26KEY_UPPER},
    {GUIIM_M_TPQ_CZECH_ABC,                     MMIIM_TP_CSTAR_STATE_CZECH_ABC_26KEY_LEAD},
#endif

#ifdef IM_SLOVENIAN_SUPPORT
    {GUIIM_M_TP_SLOVENIAN_LEAD_UPPER,           MMIIM_TP_CSTAR_STATE_SLOVENIAN_9KEY_LEAD},
    {GUIIM_M_TP_SLOVENIAN_LOWER,                MMIIM_TP_CSTAR_STATE_SLOVENIAN_9KEY_LOWER},
    {GUIIM_M_TP_SLOVENIAN_UPPER,                MMIIM_TP_CSTAR_STATE_SLOVENIAN_9KEY_UPPER},
    {GUIIM_M_TP_SLOVENIAN,                      MMIIM_TP_CSTAR_STATE_SLOVENIAN_9KEY_LEAD},
    {GUIIM_M_TPQ_SLOVENIAN_LEAD_UPPER,          MMIIM_TP_CSTAR_STATE_SLOVENIAN_26KEY_LEAD},
    {GUIIM_M_TPQ_SLOVENIAN_LOWER,               MMIIM_TP_CSTAR_STATE_SLOVENIAN_26KEY_LOWER},
    {GUIIM_M_TPQ_SLOVENIAN_UPPER,               MMIIM_TP_CSTAR_STATE_SLOVENIAN_26KEY_UPPER},
    {GUIIM_M_TPQ_SLOVENIAN,                     MMIIM_TP_CSTAR_STATE_SLOVENIAN_26KEY_LEAD},
    
    {GUIIM_M_TP_SLOVENIAN_ABC_LEAD_UPPER,       MMIIM_TP_CSTAR_STATE_SLOVENIAN_ABC_9KEY_LEAD},
    {GUIIM_M_TP_SLOVENIAN_ABC_LOWER,            MMIIM_TP_CSTAR_STATE_SLOVENIAN_ABC_9KEY_LOWER},
    {GUIIM_M_TP_SLOVENIAN_ABC_UPPER,            MMIIM_TP_CSTAR_STATE_SLOVENIAN_ABC_9KEY_UPPER},
    {GUIIM_M_TP_SLOVENIAN_ABC,                  MMIIM_TP_CSTAR_STATE_SLOVENIAN_ABC_9KEY_LEAD},
    {GUIIM_M_TPQ_SLOVENIAN_ABC_LEAD_UPPER,      MMIIM_TP_CSTAR_STATE_SLOVENIAN_ABC_26KEY_LEAD},
    {GUIIM_M_TPQ_SLOVENIAN_ABC_LOWER,           MMIIM_TP_CSTAR_STATE_SLOVENIAN_ABC_26KEY_LOWER},
    {GUIIM_M_TPQ_SLOVENIAN_ABC_UPPER,           MMIIM_TP_CSTAR_STATE_SLOVENIAN_ABC_26KEY_UPPER},
    {GUIIM_M_TPQ_SLOVENIAN_ABC,                 MMIIM_TP_CSTAR_STATE_SLOVENIAN_ABC_26KEY_LEAD},
#endif

#ifdef IM_ROMANIAN_SUPPORT
    {GUIIM_M_TP_ROMANIAN_LEAD_UPPER,            MMIIM_TP_CSTAR_STATE_ROMANIAN_9KEY_LEAD},
    {GUIIM_M_TP_ROMANIAN_LOWER,                 MMIIM_TP_CSTAR_STATE_ROMANIAN_9KEY_LOWER},
    {GUIIM_M_TP_ROMANIAN_UPPER,                 MMIIM_TP_CSTAR_STATE_ROMANIAN_9KEY_UPPER},
    {GUIIM_M_TP_ROMANIAN,                       MMIIM_TP_CSTAR_STATE_ROMANIAN_9KEY_LEAD},
    {GUIIM_M_TPQ_ROMANIAN_LEAD_UPPER,           MMIIM_TP_CSTAR_STATE_ROMANIAN_26KEY_LEAD},
    {GUIIM_M_TPQ_ROMANIAN_LOWER,                MMIIM_TP_CSTAR_STATE_ROMANIAN_26KEY_LOWER},
    {GUIIM_M_TPQ_ROMANIAN_UPPER,                MMIIM_TP_CSTAR_STATE_ROMANIAN_26KEY_UPPER},
    {GUIIM_M_TPQ_ROMANIAN,                      MMIIM_TP_CSTAR_STATE_ROMANIAN_26KEY_LEAD},
    
    {GUIIM_M_TP_ROMANIAN_ABC_LEAD_UPPER,        MMIIM_TP_CSTAR_STATE_ROMANIAN_ABC_9KEY_LEAD},
    {GUIIM_M_TP_ROMANIAN_ABC_LOWER,             MMIIM_TP_CSTAR_STATE_ROMANIAN_ABC_9KEY_LOWER},
    {GUIIM_M_TP_ROMANIAN_ABC_UPPER,             MMIIM_TP_CSTAR_STATE_ROMANIAN_ABC_9KEY_UPPER},
    {GUIIM_M_TP_ROMANIAN_ABC,                   MMIIM_TP_CSTAR_STATE_ROMANIAN_ABC_9KEY_LEAD},
    {GUIIM_M_TPQ_ROMANIAN_ABC_LEAD_UPPER,       MMIIM_TP_CSTAR_STATE_ROMANIAN_ABC_26KEY_LEAD},
    {GUIIM_M_TPQ_ROMANIAN_ABC_LOWER,            MMIIM_TP_CSTAR_STATE_ROMANIAN_ABC_26KEY_LOWER},
    {GUIIM_M_TPQ_ROMANIAN_ABC_UPPER,            MMIIM_TP_CSTAR_STATE_ROMANIAN_ABC_26KEY_UPPER},
    {GUIIM_M_TPQ_ROMANIAN_ABC,                  MMIIM_TP_CSTAR_STATE_ROMANIAN_ABC_26KEY_LEAD},
#endif

//泰卢固语multitap关于虚拟键盘部分	
#ifdef IM_TELUGU_SUPPORT
    //multitap
    {GUIIM_M_TP_TELUGU_ABC, MMIIM_TP_CSTAR_STATE_TELUGU_ABC_9KEY_UPPER},
    {GUIIM_M_TPQ_TELUGU_ABC, MMIIM_TP_CSTAR_STATE_TELUGU_ABC_26KEY_UPPER},
#endif

//马拉地语multitap关于虚拟键盘部分	
#ifdef IM_MARATHI_SUPPORT
    //multitap
    {GUIIM_M_TP_MARATHI_ABC, MMIIM_TP_CSTAR_STATE_MARATHI_ABC_9KEY_UPPER},
    {GUIIM_M_TPQ_MARATHI_ABC, MMIIM_TP_CSTAR_STATE_MARATHI_ABC_26KEY_UPPER},
#endif

//泰米尔语multitap关于虚拟键盘部分	
#ifdef IM_TAMIL_SUPPORT
    //multitap
    {GUIIM_M_TP_TAMIL_ABC, MMIIM_TP_CSTAR_STATE_TAMIL_ABC_9KEY_UPPER},
    {GUIIM_M_TPQ_TAMIL_ABC, MMIIM_TP_CSTAR_STATE_TAMIL_ABC_26KEY_UPPER},
#endif

//古吉拉特语multitap关于虚拟键盘部分	
#ifdef IM_GUJARATI_SUPPORT
    //multitap
    {GUIIM_M_TP_GUJARATI_ABC, MMIIM_TP_CSTAR_STATE_GUJARATI_ABC_9KEY_UPPER},
    {GUIIM_M_TPQ_GUJARATI_ABC, MMIIM_TP_CSTAR_STATE_GUJARATI_ABC_26KEY_UPPER},
#endif

//卡纳达语multitap关于虚拟键盘部分	
#ifdef IM_KANNADA_SUPPORT
    //multitap
    {GUIIM_M_TP_KANNADA_ABC, MMIIM_TP_CSTAR_STATE_KANNADA_ABC_9KEY_UPPER},
    {GUIIM_M_TPQ_KANNADA_ABC, MMIIM_TP_CSTAR_STATE_KANNADA_ABC_26KEY_UPPER},
#endif

//马拉亚拉姆语multitap关于虚拟键盘部分	
#ifdef IM_MALAYALAM_SUPPORT
    //multitap
    {GUIIM_M_TP_MALAYALAM_ABC, MMIIM_TP_CSTAR_STATE_MALAYALAM_ABC_9KEY_UPPER},
    {GUIIM_M_TPQ_MALAYALAM_ABC, MMIIM_TP_CSTAR_STATE_MALAYALAM_ABC_26KEY_UPPER},
#endif

//缅甸语multitap关于虚拟键盘部分	
#ifdef IM_MYANMAR_SUPPORT
    //multitap
    {GUIIM_M_TP_MYANMAR_ABC, MMIIM_TP_CSTAR_STATE_MYANMAR_ABC_9KEY_UPPER},
    {GUIIM_M_TPQ_MYANMAR_ABC, MMIIM_TP_CSTAR_STATE_MYANMAR_ABC_26KEY_UPPER},
#endif

//奥里亚multitap关于虚拟键盘部分	
#ifdef IM_ORIYA_SUPPORT
    //multitap
    {GUIIM_M_TP_ORIYA_ABC, MMIIM_TP_CSTAR_STATE_ORIYA_ABC_9KEY_UPPER},
    {GUIIM_M_TPQ_ORIYA_ABC, MMIIM_TP_CSTAR_STATE_ORIYA_ABC_26KEY_UPPER},
#endif

//旁遮普multitap关于虚拟键盘部分	
#ifdef IM_PUNJABI_SUPPORT
    //multitap
    {GUIIM_M_TP_PUNJABI_ABC, MMIIM_TP_CSTAR_STATE_PUNJABI_ABC_9KEY_UPPER},
    {GUIIM_M_TPQ_PUNJABI_ABC, MMIIM_TP_CSTAR_STATE_PUNJABI_ABC_26KEY_UPPER},
#endif

//南非荷兰语multitap关于虚拟键盘部分	
#ifdef IM_AFRIKAANS_SUPPORT
	//smart
    {GUIIM_M_TP_AFRIKAANS_LEAD_UPPER,            MMIIM_TP_CSTAR_STATE_AFRIKAANS_9KEY_LEAD},
    {GUIIM_M_TP_AFRIKAANS_LOWER,                 MMIIM_TP_CSTAR_STATE_AFRIKAANS_9KEY_LOWER},
    {GUIIM_M_TP_AFRIKAANS_UPPER,                 MMIIM_TP_CSTAR_STATE_AFRIKAANS_9KEY_UPPER},
    {GUIIM_M_TPQ_AFRIKAANS_LEAD_UPPER,           MMIIM_TP_CSTAR_STATE_AFRIKAANS_26KEY_LEAD},
    {GUIIM_M_TPQ_AFRIKAANS_LOWER,                MMIIM_TP_CSTAR_STATE_AFRIKAANS_26KEY_LOWER},
    {GUIIM_M_TPQ_AFRIKAANS_UPPER,                MMIIM_TP_CSTAR_STATE_AFRIKAANS_26KEY_UPPER},

    //multitap
    {GUIIM_M_TP_AFRIKAANS_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_AFRIKAANS_ABC_9KEY_LEAD}, 
    {GUIIM_M_TP_AFRIKAANS_ABC_LOWER, MMIIM_TP_CSTAR_STATE_AFRIKAANS_ABC_9KEY_LOWER}, 
    {GUIIM_M_TP_AFRIKAANS_ABC_UPPER, MMIIM_TP_CSTAR_STATE_AFRIKAANS_ABC_9KEY_UPPER}, 

    {GUIIM_M_TPQ_AFRIKAANS_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_AFRIKAANS_ABC_26KEY_LEAD}, 
    {GUIIM_M_TPQ_AFRIKAANS_ABC_LOWER, MMIIM_TP_CSTAR_STATE_AFRIKAANS_ABC_26KEY_LOWER}, 
    {GUIIM_M_TPQ_AFRIKAANS_ABC_UPPER, MMIIM_TP_CSTAR_STATE_AFRIKAANS_ABC_26KEY_UPPER}, 
#endif

//阿尔巴尼亚multitap关于虚拟键盘部分	add. 
#ifdef IM_ALBANIAN_SUPPORT
    //multitap
    {GUIIM_M_TP_ALBANIAN_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_ALBANIAN_ABC_9KEY_LEAD}, 
    {GUIIM_M_TP_ALBANIAN_ABC_LOWER, MMIIM_TP_CSTAR_STATE_ALBANIAN_ABC_9KEY_LOWER}, 
    {GUIIM_M_TP_ALBANIAN_ABC_UPPER, MMIIM_TP_CSTAR_STATE_ALBANIAN_ABC_9KEY_UPPER}, 

    {GUIIM_M_TPQ_ALBANIAN_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_ALBANIAN_ABC_26KEY_LEAD}, 
    {GUIIM_M_TPQ_ALBANIAN_ABC_LOWER, MMIIM_TP_CSTAR_STATE_ALBANIAN_ABC_26KEY_LOWER}, 
    {GUIIM_M_TPQ_ALBANIAN_ABC_UPPER, MMIIM_TP_CSTAR_STATE_ALBANIAN_ABC_26KEY_UPPER}, 
#endif

//亚美加multitap关于虚拟键盘部分	add. 
#ifdef IM_ARMENIAN_SUPPORT
    //multitap
    {GUIIM_M_TP_ARMENIAN_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_ARMENIAN_ABC_9KEY_LEAD}, 
    {GUIIM_M_TP_ARMENIAN_ABC_LOWER, MMIIM_TP_CSTAR_STATE_ARMENIAN_ABC_9KEY_LOWER}, 
    {GUIIM_M_TP_ARMENIAN_ABC_UPPER, MMIIM_TP_CSTAR_STATE_ARMENIAN_ABC_9KEY_UPPER}, 

    {GUIIM_M_TPQ_ARMENIAN_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_ARMENIAN_ABC_26KEY_LEAD}, 
    {GUIIM_M_TPQ_ARMENIAN_ABC_LOWER, MMIIM_TP_CSTAR_STATE_ARMENIAN_ABC_26KEY_LOWER}, 
    {GUIIM_M_TPQ_ARMENIAN_ABC_UPPER, MMIIM_TP_CSTAR_STATE_ARMENIAN_ABC_26KEY_UPPER}, 
#endif


//阿塞拜疆语(属阿尔泰语系土耳其语族)multitap关于虚拟键盘部分	add. 
#ifdef IM_AZERBAIJANI_SUPPORT
    //multitap
    {GUIIM_M_TP_AZERBAIJANI_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_AZERBAIJANI_ABC_9KEY_LEAD}, 
    {GUIIM_M_TP_AZERBAIJANI_ABC_LOWER, MMIIM_TP_CSTAR_STATE_AZERBAIJANI_ABC_9KEY_LOWER}, 
    {GUIIM_M_TP_AZERBAIJANI_ABC_UPPER, MMIIM_TP_CSTAR_STATE_AZERBAIJANI_ABC_9KEY_UPPER}, 

    {GUIIM_M_TPQ_AZERBAIJANI_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_AZERBAIJANI_ABC_26KEY_LEAD}, 
    {GUIIM_M_TPQ_AZERBAIJANI_ABC_LOWER, MMIIM_TP_CSTAR_STATE_AZERBAIJANI_ABC_26KEY_LOWER}, 
    {GUIIM_M_TPQ_AZERBAIJANI_ABC_UPPER, MMIIM_TP_CSTAR_STATE_AZERBAIJANI_ABC_26KEY_UPPER}, 
#endif

//巴斯克语multitap关于虚拟键盘部分	add. 
#ifdef IM_BASQUE_SUPPORT
    //multitap
    {GUIIM_M_TP_BASQUE_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_BASQUE_ABC_9KEY_LEAD}, 
    {GUIIM_M_TP_BASQUE_ABC_LOWER, MMIIM_TP_CSTAR_STATE_BASQUE_ABC_9KEY_LOWER}, 
    {GUIIM_M_TP_BASQUE_ABC_UPPER, MMIIM_TP_CSTAR_STATE_BASQUE_ABC_9KEY_UPPER}, 

    {GUIIM_M_TPQ_BASQUE_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_BASQUE_ABC_26KEY_LEAD}, 
    {GUIIM_M_TPQ_BASQUE_ABC_LOWER, MMIIM_TP_CSTAR_STATE_BASQUE_ABC_26KEY_LOWER}, 
    {GUIIM_M_TPQ_BASQUE_ABC_UPPER, MMIIM_TP_CSTAR_STATE_BASQUE_ABC_26KEY_UPPER}, 
#endif

#ifdef IM_CROATIAN_SUPPORT
    {GUIIM_M_TP_CROATIAN_LEAD_UPPER,            MMIIM_TP_CSTAR_STATE_CROATIAN_9KEY_LEAD},
    {GUIIM_M_TP_CROATIAN_LOWER,                 MMIIM_TP_CSTAR_STATE_CROATIAN_9KEY_LOWER},
    {GUIIM_M_TP_CROATIAN_UPPER,                 MMIIM_TP_CSTAR_STATE_CROATIAN_9KEY_UPPER},
    {GUIIM_M_TPQ_CROATIAN_LEAD_UPPER,           MMIIM_TP_CSTAR_STATE_CROATIAN_26KEY_LEAD},
    {GUIIM_M_TPQ_CROATIAN_LOWER,                MMIIM_TP_CSTAR_STATE_CROATIAN_26KEY_LOWER},
    {GUIIM_M_TPQ_CROATIAN_UPPER,                MMIIM_TP_CSTAR_STATE_CROATIAN_26KEY_UPPER},

    {GUIIM_M_TP_CROATIAN_ABC_LEAD_UPPER,        MMIIM_TP_CSTAR_STATE_CROATIAN_ABC_9KEY_LEAD},
    {GUIIM_M_TP_CROATIAN_ABC_LOWER,             MMIIM_TP_CSTAR_STATE_CROATIAN_ABC_9KEY_LOWER},
    {GUIIM_M_TP_CROATIAN_ABC_UPPER,             MMIIM_TP_CSTAR_STATE_CROATIAN_ABC_9KEY_UPPER},
    {GUIIM_M_TPQ_CROATIAN_ABC_LEAD_UPPER,       MMIIM_TP_CSTAR_STATE_CROATIAN_ABC_26KEY_LEAD},
    {GUIIM_M_TPQ_CROATIAN_ABC_LOWER,            MMIIM_TP_CSTAR_STATE_CROATIAN_ABC_26KEY_LOWER},
    {GUIIM_M_TPQ_CROATIAN_ABC_UPPER,            MMIIM_TP_CSTAR_STATE_CROATIAN_ABC_26KEY_UPPER},   
#endif

#ifdef IM_DUTCH_SUPPORT
    {GUIIM_M_TP_DUTCH_LEAD_UPPER,               MMIIM_TP_CSTAR_STATE_DUTCH_9KEY_LEAD},
    {GUIIM_M_TP_DUTCH_LOWER,                    MMIIM_TP_CSTAR_STATE_DUTCH_9KEY_LOWER},
    {GUIIM_M_TP_DUTCH_UPPER,                    MMIIM_TP_CSTAR_STATE_DUTCH_9KEY_UPPER},
    {GUIIM_M_TPQ_DUTCH_LEAD_UPPER,              MMIIM_TP_CSTAR_STATE_DUTCH_26KEY_LEAD},
    {GUIIM_M_TPQ_DUTCH_LOWER,                   MMIIM_TP_CSTAR_STATE_DUTCH_26KEY_LOWER},
    {GUIIM_M_TPQ_DUTCH_UPPER,                   MMIIM_TP_CSTAR_STATE_DUTCH_26KEY_UPPER},

    {GUIIM_M_TP_DUTCH_ABC_LEAD_UPPER,           MMIIM_TP_CSTAR_STATE_DUTCH_ABC_9KEY_LEAD},
    {GUIIM_M_TP_DUTCH_ABC_LOWER,                MMIIM_TP_CSTAR_STATE_DUTCH_ABC_9KEY_LOWER},
    {GUIIM_M_TP_DUTCH_ABC_UPPER,                MMIIM_TP_CSTAR_STATE_DUTCH_ABC_9KEY_UPPER},
    {GUIIM_M_TPQ_DUTCH_ABC_LEAD_UPPER,          MMIIM_TP_CSTAR_STATE_DUTCH_ABC_26KEY_LEAD},
    {GUIIM_M_TPQ_DUTCH_ABC_LOWER,               MMIIM_TP_CSTAR_STATE_DUTCH_ABC_26KEY_LOWER},
    {GUIIM_M_TPQ_DUTCH_ABC_UPPER,               MMIIM_TP_CSTAR_STATE_DUTCH_ABC_26KEY_UPPER},   
#endif

//爱沙尼亚multitap关于虚拟键盘部分	add. 
#ifdef IM_ESTONIAN_SUPPORT
    //multitap
    {GUIIM_M_TP_ESTONIAN_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_ESTONIAN_ABC_9KEY_LEAD}, 
    {GUIIM_M_TP_ESTONIAN_ABC_LOWER, MMIIM_TP_CSTAR_STATE_ESTONIAN_ABC_9KEY_LOWER}, 
    {GUIIM_M_TP_ESTONIAN_ABC_UPPER, MMIIM_TP_CSTAR_STATE_ESTONIAN_ABC_9KEY_UPPER}, 

    {GUIIM_M_TPQ_ESTONIAN_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_ESTONIAN_ABC_26KEY_LEAD}, 
    {GUIIM_M_TPQ_ESTONIAN_ABC_LOWER, MMIIM_TP_CSTAR_STATE_ESTONIAN_ABC_26KEY_LOWER}, 
    {GUIIM_M_TPQ_ESTONIAN_ABC_UPPER, MMIIM_TP_CSTAR_STATE_ESTONIAN_ABC_26KEY_UPPER}, 
#endif

//菲律宾multitap关于虚拟键盘部分	add. 
#ifdef IM_FILIPINO_SUPPORT
    //multitap
    {GUIIM_M_TP_FILIPINO_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_FILIPINO_ABC_9KEY_LEAD}, 
    {GUIIM_M_TP_FILIPINO_ABC_LOWER, MMIIM_TP_CSTAR_STATE_FILIPINO_ABC_9KEY_LOWER}, 
    {GUIIM_M_TP_FILIPINO_ABC_UPPER, MMIIM_TP_CSTAR_STATE_FILIPINO_ABC_9KEY_UPPER}, 

    {GUIIM_M_TPQ_FILIPINO_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_FILIPINO_ABC_26KEY_LEAD}, 
    {GUIIM_M_TPQ_FILIPINO_ABC_LOWER, MMIIM_TP_CSTAR_STATE_FILIPINO_ABC_26KEY_LOWER}, 
    {GUIIM_M_TPQ_FILIPINO_ABC_UPPER, MMIIM_TP_CSTAR_STATE_FILIPINO_ABC_26KEY_UPPER}, 
#endif

//芬兰
#ifdef IM_FINNISH_SUPPORT
    {GUIIM_M_TP_FINNISH_LEAD_UPPER,              MMIIM_TP_CSTAR_STATE_FINNISH_9KEY_LEAD},
    {GUIIM_M_TP_FINNISH_LOWER,                   MMIIM_TP_CSTAR_STATE_FINNISH_9KEY_LOWER},
    {GUIIM_M_TP_FINNISH_UPPER,                   MMIIM_TP_CSTAR_STATE_FINNISH_9KEY_UPPER},
    {GUIIM_M_TPQ_FINNISH_LEAD_UPPER,             MMIIM_TP_CSTAR_STATE_FINNISH_26KEY_LEAD},
    {GUIIM_M_TPQ_FINNISH_LOWER,                  MMIIM_TP_CSTAR_STATE_FINNISH_26KEY_LOWER},
    {GUIIM_M_TPQ_FINNISH_UPPER,                  MMIIM_TP_CSTAR_STATE_FINNISH_26KEY_UPPER},

    {GUIIM_M_TP_FINNISH_ABC_LEAD_UPPER,          MMIIM_TP_CSTAR_STATE_FINNISH_ABC_9KEY_LEAD},
    {GUIIM_M_TP_FINNISH_ABC_LOWER,               MMIIM_TP_CSTAR_STATE_FINNISH_ABC_9KEY_LOWER},
    {GUIIM_M_TP_FINNISH_ABC_UPPER,               MMIIM_TP_CSTAR_STATE_FINNISH_ABC_9KEY_UPPER},
    {GUIIM_M_TPQ_FINNISH_ABC_LEAD_UPPER,         MMIIM_TP_CSTAR_STATE_FINNISH_ABC_26KEY_LEAD},
    {GUIIM_M_TPQ_FINNISH_ABC_LOWER,              MMIIM_TP_CSTAR_STATE_FINNISH_ABC_26KEY_LOWER},
    {GUIIM_M_TPQ_FINNISH_ABC_UPPER,              MMIIM_TP_CSTAR_STATE_FINNISH_ABC_26KEY_UPPER},   
#endif

//加利西亚语multitap关于虚拟键盘部分	
#ifdef IM_GALICIAN_SUPPORT
    //multitap
    {GUIIM_M_TP_GALICIAN_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_GALICIAN_ABC_9KEY_LEAD}, 
    {GUIIM_M_TP_GALICIAN_ABC_LOWER, MMIIM_TP_CSTAR_STATE_GALICIAN_ABC_9KEY_LOWER}, 
    {GUIIM_M_TP_GALICIAN_ABC_UPPER, MMIIM_TP_CSTAR_STATE_GALICIAN_ABC_9KEY_UPPER}, 

    {GUIIM_M_TPQ_GALICIAN_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_GALICIAN_ABC_26KEY_LEAD}, 
    {GUIIM_M_TPQ_GALICIAN_ABC_LOWER, MMIIM_TP_CSTAR_STATE_GALICIAN_ABC_26KEY_LOWER}, 
    {GUIIM_M_TPQ_GALICIAN_ABC_UPPER, MMIIM_TP_CSTAR_STATE_GALICIAN_ABC_26KEY_UPPER}, 
#endif

//格鲁吉亚multitap关于虚拟键盘部分	
#ifdef IM_GEORGIAN_SUPPORT
    //multitap
    {GUIIM_M_TP_GEORGIAN_ABC, MMIIM_TP_CSTAR_STATE_GEORGIAN_ABC_9KEY_UPPER},
    {GUIIM_M_TPQ_GEORGIAN_ABC, MMIIM_TP_CSTAR_STATE_GEORGIAN_ABC_26KEY_UPPER},
#endif

//豪萨语(西非语系中的斯瓦西里语multitap关于虚拟键盘部分	add. 
#ifdef IM_HAUSA_SUPPORT
    //multitap
    {GUIIM_M_TP_HAUSA_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_HAUSA_ABC_9KEY_LEAD}, 
    {GUIIM_M_TP_HAUSA_ABC_LOWER, MMIIM_TP_CSTAR_STATE_HAUSA_ABC_9KEY_LOWER}, 
    {GUIIM_M_TP_HAUSA_ABC_UPPER, MMIIM_TP_CSTAR_STATE_HAUSA_ABC_9KEY_UPPER}, 

    {GUIIM_M_TPQ_HAUSA_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_HAUSA_ABC_26KEY_LEAD}, 
    {GUIIM_M_TPQ_HAUSA_ABC_LOWER, MMIIM_TP_CSTAR_STATE_HAUSA_ABC_26KEY_LOWER}, 
    {GUIIM_M_TPQ_HAUSA_ABC_UPPER, MMIIM_TP_CSTAR_STATE_HAUSA_ABC_26KEY_UPPER}, 
#endif

//冰岛语multitap关于虚拟键盘部分	add. 
#ifdef IM_ICELANDIC_SUPPORT
    //multitap
    {GUIIM_M_TP_ICELANDIC_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_ICELANDIC_ABC_9KEY_LEAD}, 
    {GUIIM_M_TP_ICELANDIC_ABC_LOWER, MMIIM_TP_CSTAR_STATE_ICELANDIC_ABC_9KEY_LOWER}, 
    {GUIIM_M_TP_ICELANDIC_ABC_UPPER, MMIIM_TP_CSTAR_STATE_ICELANDIC_ABC_9KEY_UPPER}, 

    {GUIIM_M_Q_ICELANDIC_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_ICELANDIC_ABC_26KEY_LEAD}, 
    {GUIIM_M_Q_ICELANDIC_ABC_LOWER, MMIIM_TP_CSTAR_STATE_ICELANDIC_ABC_26KEY_LOWER}, 
    {GUIIM_M_TPQ_ICELANDIC_ABC_UPPER, MMIIM_TP_CSTAR_STATE_ICELANDIC_ABC_26KEY_UPPER}, 
#endif

//伊博语multitap关于虚拟键盘部分	add. 
#ifdef IM_IGBO_SUPPORT
    //multitap
    {GUIIM_M_TP_IGBO_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_IGBO_ABC_9KEY_LEAD}, 
    {GUIIM_M_TP_IGBO_ABC_LOWER, MMIIM_TP_CSTAR_STATE_IGBO_ABC_9KEY_LOWER}, 
    {GUIIM_M_TP_IGBO_ABC_UPPER, MMIIM_TP_CSTAR_STATE_IGBO_ABC_9KEY_UPPER}, 

    {GUIIM_M_TPQ_IGBO_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_IGBO_ABC_26KEY_LEAD}, 
    {GUIIM_M_TPQ_IGBO_ABC_LOWER, MMIIM_TP_CSTAR_STATE_IGBO_ABC_26KEY_LOWER}, 
    {GUIIM_M_TPQ_IGBO_ABC_UPPER, MMIIM_TP_CSTAR_STATE_IGBO_ABC_26KEY_UPPER}, 
#endif

//爱尔兰语multitap关于虚拟键盘部分	add. 
#ifdef IM_IRISH_SUPPORT
    //multitap
    {GUIIM_M_TP_IRISH_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_IRISH_ABC_9KEY_LEAD}, 
    {GUIIM_M_TP_IRISH_ABC_LOWER, MMIIM_TP_CSTAR_STATE_IRISH_ABC_9KEY_LOWER}, 
    {GUIIM_M_TP_IRISH_ABC_UPPER, MMIIM_TP_CSTAR_STATE_IRISH_ABC_9KEY_UPPER}, 

    {GUIIM_M_TPQ_IRISH_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_IRISH_ABC_26KEY_LEAD}, 
    {GUIIM_M_TPQ_IRISH_ABC_LOWER, MMIIM_TP_CSTAR_STATE_IRISH_ABC_26KEY_LOWER}, 
    {GUIIM_M_TPQ_IRISH_ABC_UPPER, MMIIM_TP_CSTAR_STATE_IRISH_ABC_26KEY_UPPER}, 
#endif

#ifdef IM_BULGARIAN_SUPPORT
    {GUIIM_M_TP_BULGARIAN_LEAD_UPPER,           MMIIM_TP_CSTAR_STATE_BULGARIAN_9KEY_LEAD},
    {GUIIM_M_TP_BULGARIAN_LOWER,                MMIIM_TP_CSTAR_STATE_BULGARIAN_9KEY_LOWER},
    {GUIIM_M_TP_BULGARIAN_UPPER,                MMIIM_TP_CSTAR_STATE_BULGARIAN_9KEY_UPPER},
    {GUIIM_M_TPQ_BULGARIAN_LEAD_UPPER,          MMIIM_TP_CSTAR_STATE_BULGARIAN_26KEY_LEAD},
    {GUIIM_M_TPQ_BULGARIAN_LOWER,               MMIIM_TP_CSTAR_STATE_BULGARIAN_26KEY_LOWER},
    {GUIIM_M_TPQ_BULGARIAN_UPPER,               MMIIM_TP_CSTAR_STATE_BULGARIAN_26KEY_UPPER},

    {GUIIM_M_TP_BULGARIAN_ABC_LEAD_UPPER,       MMIIM_TP_CSTAR_STATE_BULGARIAN_ABC_9KEY_LEAD},
    {GUIIM_M_TP_BULGARIAN_ABC_LOWER,            MMIIM_TP_CSTAR_STATE_BULGARIAN_ABC_9KEY_LOWER},
    {GUIIM_M_TP_BULGARIAN_ABC_UPPER,            MMIIM_TP_CSTAR_STATE_BULGARIAN_ABC_9KEY_UPPER},
    {GUIIM_M_TPQ_BULGARIAN_ABC_LEAD_UPPER,      MMIIM_TP_CSTAR_STATE_BULGARIAN_ABC_26KEY_LEAD},
    {GUIIM_M_TPQ_BULGARIAN_ABC_LOWER,           MMIIM_TP_CSTAR_STATE_BULGARIAN_ABC_26KEY_LOWER},
    {GUIIM_M_TPQ_BULGARIAN_ABC_UPPER,           MMIIM_TP_CSTAR_STATE_BULGARIAN_ABC_26KEY_UPPER},   
#endif

//加泰罗尼亚语multitap关于虚拟键盘部分	add. 
#ifdef IM_CATALAN_SUPPORT
    {GUIIM_M_TP_CATALAN_ABC_LEAD_UPPER,       MMIIM_TP_CSTAR_STATE_CATALAN_ABC_9KEY_LEAD},
    {GUIIM_M_TP_CATALAN_ABC_LOWER,            MMIIM_TP_CSTAR_STATE_CATALAN_ABC_9KEY_LOWER},
    {GUIIM_M_TP_CATALAN_ABC_UPPER,            MMIIM_TP_CSTAR_STATE_CATALAN_ABC_9KEY_UPPER},
    {GUIIM_M_TPQ_CATALAN_ABC_LEAD_UPPER,      MMIIM_TP_CSTAR_STATE_CATALAN_ABC_26KEY_LEAD},
    {GUIIM_M_TPQ_CATALAN_ABC_LOWER,           MMIIM_TP_CSTAR_STATE_CATALAN_ABC_26KEY_LOWER},
    {GUIIM_M_TPQ_CATALAN_ABC_UPPER,           MMIIM_TP_CSTAR_STATE_CATALAN_ABC_26KEY_UPPER},   
#endif


#ifdef IM_POLISH_SUPPORT
    {GUIIM_M_TP_POLISH_LEAD_UPPER,              MMIIM_TP_CSTAR_STATE_POLISH_9KEY_LEAD},
    {GUIIM_M_TP_POLISH_LOWER,                   MMIIM_TP_CSTAR_STATE_POLISH_9KEY_LOWER},
    {GUIIM_M_TP_POLISH_UPPER,                   MMIIM_TP_CSTAR_STATE_POLISH_9KEY_UPPER},
    {GUIIM_M_TPQ_POLISH_LEAD_UPPER,             MMIIM_TP_CSTAR_STATE_POLISH_26KEY_LEAD},
    {GUIIM_M_TPQ_POLISH_LOWER,                  MMIIM_TP_CSTAR_STATE_POLISH_26KEY_LOWER},
    {GUIIM_M_TPQ_POLISH_UPPER,                  MMIIM_TP_CSTAR_STATE_POLISH_26KEY_UPPER},

    {GUIIM_M_TP_POLISH_ABC_LEAD_UPPER,          MMIIM_TP_CSTAR_STATE_POLISH_ABC_9KEY_LEAD},
    {GUIIM_M_TP_POLISH_ABC_LOWER,               MMIIM_TP_CSTAR_STATE_POLISH_ABC_9KEY_LOWER},
    {GUIIM_M_TP_POLISH_ABC_UPPER,               MMIIM_TP_CSTAR_STATE_POLISH_ABC_9KEY_UPPER},
    {GUIIM_M_TPQ_POLISH_ABC_LEAD_UPPER,         MMIIM_TP_CSTAR_STATE_POLISH_ABC_26KEY_LEAD},
    {GUIIM_M_TPQ_POLISH_ABC_LOWER,              MMIIM_TP_CSTAR_STATE_POLISH_ABC_26KEY_LOWER},
    {GUIIM_M_TPQ_POLISH_ABC_UPPER,              MMIIM_TP_CSTAR_STATE_POLISH_ABC_26KEY_UPPER},   
#endif

//塞尔维亚语multitap关于虚拟键盘部分	add. 
#ifdef IM_SERBIAN_SUPPORT
    {GUIIM_M_TP_SERBIAN_ABC_LEAD_UPPER,       MMIIM_TP_CSTAR_STATE_SERBIAN_ABC_9KEY_LEAD},
    {GUIIM_M_TP_SERBIAN_ABC_LOWER,            MMIIM_TP_CSTAR_STATE_SERBIAN_ABC_9KEY_LOWER},
    {GUIIM_M_TP_SERBIAN_ABC_UPPER,            MMIIM_TP_CSTAR_STATE_SERBIAN_ABC_9KEY_UPPER},
    {GUIIM_M_TPQ_SERBIAN_ABC_LEAD_UPPER,      MMIIM_TP_CSTAR_STATE_SERBIAN_ABC_26KEY_LEAD},
    {GUIIM_M_TPQ_SERBIAN_ABC_LOWER,           MMIIM_TP_CSTAR_STATE_SERBIAN_ABC_26KEY_LOWER},
    {GUIIM_M_TPQ_SERBIAN_ABC_UPPER,           MMIIM_TP_CSTAR_STATE_SERBIAN_ABC_26KEY_UPPER},   
#endif

//塞索托语(属班图语系) multitap关于虚拟键盘部分	add. 
#ifdef IM_SESOTHO_SUPPORT
    {GUIIM_M_TP_SESOTHO_ABC_LEAD_UPPER,       MMIIM_TP_CSTAR_STATE_SESOTHO_ABC_9KEY_LEAD},
    {GUIIM_M_TP_SESOTHO_ABC_LOWER,            MMIIM_TP_CSTAR_STATE_SESOTHO_ABC_9KEY_LOWER},
    {GUIIM_M_TP_SESOTHO_ABC_UPPER,            MMIIM_TP_CSTAR_STATE_SESOTHO_ABC_9KEY_UPPER},
    {GUIIM_M_TPQ_SESOTHO_ABC_LEAD_UPPER,      MMIIM_TP_CSTAR_STATE_SESOTHO_ABC_26KEY_LEAD},
    {GUIIM_M_TPQ_SESOTHO_ABC_LOWER,           MMIIM_TP_CSTAR_STATE_SESOTHO_ABC_26KEY_LOWER},
    {GUIIM_M_TPQ_SESOTHO_ABC_UPPER,           MMIIM_TP_CSTAR_STATE_SESOTHO_ABC_26KEY_UPPER},   
#endif

#ifdef IM_DANISH_SUPPORT
    {GUIIM_M_TP_DANISH_LEAD_UPPER,              MMIIM_TP_CSTAR_STATE_DANISH_9KEY_LEAD},
    {GUIIM_M_TP_DANISH_LOWER,                   MMIIM_TP_CSTAR_STATE_DANISH_9KEY_LOWER},
    {GUIIM_M_TP_DANISH_UPPER,                   MMIIM_TP_CSTAR_STATE_DANISH_9KEY_UPPER},
    {GUIIM_M_TPQ_DANISH_LEAD_UPPER,             MMIIM_TP_CSTAR_STATE_DANISH_26KEY_LEAD},
    {GUIIM_M_TPQ_DANISH_LOWER,                  MMIIM_TP_CSTAR_STATE_DANISH_26KEY_LOWER},
    {GUIIM_M_TPQ_DANISH_UPPER,                  MMIIM_TP_CSTAR_STATE_DANISH_26KEY_UPPER},

    {GUIIM_M_TP_DANISH_ABC_LEAD_UPPER,          MMIIM_TP_CSTAR_STATE_DANISH_ABC_9KEY_LEAD},
    {GUIIM_M_TP_DANISH_ABC_LOWER,               MMIIM_TP_CSTAR_STATE_DANISH_ABC_9KEY_LOWER},
    {GUIIM_M_TP_DANISH_ABC_UPPER,               MMIIM_TP_CSTAR_STATE_DANISH_ABC_9KEY_UPPER},
    {GUIIM_M_TPQ_DANISH_ABC_LEAD_UPPER,         MMIIM_TP_CSTAR_STATE_DANISH_ABC_26KEY_LEAD},
    {GUIIM_M_TPQ_DANISH_ABC_LOWER,              MMIIM_TP_CSTAR_STATE_DANISH_ABC_26KEY_LOWER},
    {GUIIM_M_TPQ_DANISH_ABC_UPPER,              MMIIM_TP_CSTAR_STATE_DANISH_ABC_26KEY_UPPER},   
#endif

#ifdef IM_SLOVAK_SUPPORT 
    {GUIIM_M_TP_SLOVAK_LEAD_UPPER,              MMIIM_TP_CSTAR_STATE_SLOVAK_9KEY_LEAD},
    {GUIIM_M_TP_SLOVAK_LOWER,                   MMIIM_TP_CSTAR_STATE_SLOVAK_9KEY_LOWER},
    {GUIIM_M_TP_SLOVAK_UPPER,                   MMIIM_TP_CSTAR_STATE_SLOVAK_9KEY_UPPER},
    {GUIIM_M_TPQ_SLOVAK_LEAD_UPPER,             MMIIM_TP_CSTAR_STATE_SLOVAK_26KEY_LEAD},
    {GUIIM_M_TPQ_SLOVAK_LOWER,                  MMIIM_TP_CSTAR_STATE_SLOVAK_26KEY_LOWER},
    {GUIIM_M_TPQ_SLOVAK_UPPER,                  MMIIM_TP_CSTAR_STATE_SLOVAK_26KEY_UPPER},

    {GUIIM_M_TP_SLOVAK_ABC_LEAD_UPPER,          MMIIM_TP_CSTAR_STATE_SLOVAK_ABC_9KEY_LEAD},
    {GUIIM_M_TP_SLOVAK_ABC_LOWER,               MMIIM_TP_CSTAR_STATE_SLOVAK_ABC_9KEY_LOWER},
    {GUIIM_M_TP_SLOVAK_ABC_UPPER,               MMIIM_TP_CSTAR_STATE_SLOVAK_ABC_9KEY_UPPER},
    {GUIIM_M_TPQ_SLOVAK_ABC_LEAD_UPPER,         MMIIM_TP_CSTAR_STATE_SLOVAK_ABC_26KEY_LEAD},
    {GUIIM_M_TPQ_SLOVAK_ABC_LOWER,              MMIIM_TP_CSTAR_STATE_SLOVAK_ABC_26KEY_LOWER},
    {GUIIM_M_TPQ_SLOVAK_ABC_UPPER,              MMIIM_TP_CSTAR_STATE_SLOVAK_ABC_26KEY_UPPER},   
#endif

#ifdef IM_LITHUANIAN_SUPPORT
    {GUIIM_M_TP_LITHUANIAN_LEAD_UPPER,          MMIIM_TP_CSTAR_STATE_LITHUANIAN_9KEY_LEAD},
    {GUIIM_M_TP_LITHUANIAN_LOWER,               MMIIM_TP_CSTAR_STATE_LITHUANIAN_9KEY_LOWER},
    {GUIIM_M_TP_LITHUANIAN_UPPER,               MMIIM_TP_CSTAR_STATE_LITHUANIAN_9KEY_UPPER},
    {GUIIM_M_TPQ_LITHUANIAN_LEAD_UPPER,         MMIIM_TP_CSTAR_STATE_LITHUANIAN_26KEY_LEAD},
    {GUIIM_M_TPQ_LITHUANIAN_LOWER,              MMIIM_TP_CSTAR_STATE_LITHUANIAN_26KEY_LOWER},
    {GUIIM_M_TPQ_LITHUANIAN_UPPER,              MMIIM_TP_CSTAR_STATE_LITHUANIAN_26KEY_UPPER},

    {GUIIM_M_TP_LITHUANIAN_ABC_LEAD_UPPER,      MMIIM_TP_CSTAR_STATE_LITHUANIAN_ABC_9KEY_LEAD},
    {GUIIM_M_TP_LITHUANIAN_ABC_LOWER,           MMIIM_TP_CSTAR_STATE_LITHUANIAN_ABC_9KEY_LOWER},
    {GUIIM_M_TP_LITHUANIAN_ABC_UPPER,           MMIIM_TP_CSTAR_STATE_LITHUANIAN_ABC_9KEY_UPPER},
    {GUIIM_M_TPQ_LITHUANIAN_ABC_LEAD_UPPER,     MMIIM_TP_CSTAR_STATE_LITHUANIAN_ABC_26KEY_LEAD},
    {GUIIM_M_TPQ_LITHUANIAN_ABC_LOWER,          MMIIM_TP_CSTAR_STATE_LITHUANIAN_ABC_26KEY_LOWER},
    {GUIIM_M_TPQ_LITHUANIAN_ABC_UPPER,          MMIIM_TP_CSTAR_STATE_LITHUANIAN_ABC_26KEY_UPPER},   
#endif

//马其顿语multitap关于虚拟键盘部分	add. 
#ifdef IM_MACEDONIAN_SUPPORT
    //multitap
    {GUIIM_M_TP_MACEDONIAN_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_MACEDONIAN_ABC_9KEY_LEAD}, 
    {GUIIM_M_TP_MACEDONIAN_ABC_LOWER, MMIIM_TP_CSTAR_STATE_MACEDONIAN_ABC_9KEY_LOWER}, 
    {GUIIM_M_TP_MACEDONIAN_ABC_UPPER, MMIIM_TP_CSTAR_STATE_MACEDONIAN_ABC_9KEY_UPPER}, 

    {GUIIM_M_TPQ_MACEDONIAN_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_MACEDONIAN_ABC_26KEY_LEAD}, 
    {GUIIM_M_TPQ_MACEDONIAN_ABC_LOWER, MMIIM_TP_CSTAR_STATE_MACEDONIAN_ABC_26KEY_LOWER}, 
    {GUIIM_M_TPQ_MACEDONIAN_ABC_UPPER, MMIIM_TP_CSTAR_STATE_MACEDONIAN_ABC_26KEY_UPPER}, 
#endif

// 摩尔多瓦语multitap关于虚拟键盘部分	add. 
#ifdef IM_MOLDOVAN_SUPPORT
    //multitap
    {GUIIM_M_TP_MOLDOVAN_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_MOLDOVAN_ABC_9KEY_LEAD}, 
    {GUIIM_M_TP_MOLDOVAN_ABC_LOWER, MMIIM_TP_CSTAR_STATE_MOLDOVAN_ABC_9KEY_LOWER}, 
    {GUIIM_M_TP_MOLDOVAN_ABC_UPPER, MMIIM_TP_CSTAR_STATE_MOLDOVAN_ABC_9KEY_UPPER}, 

    {GUIIM_M_TPQ_MOLDOVAN_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_MOLDOVAN_ABC_26KEY_LEAD}, 
    {GUIIM_M_TPQ_MOLDOVAN_ABC_LOWER, MMIIM_TP_CSTAR_STATE_MOLDOVAN_ABC_26KEY_LOWER}, 
    {GUIIM_M_TPQ_MOLDOVAN_ABC_UPPER, MMIIM_TP_CSTAR_STATE_MOLDOVAN_ABC_26KEY_UPPER}, 
#endif

#ifdef IM_NORWEGIAN_SUPPORT 
    {GUIIM_M_TP_NORWEGIAN_LEAD_UPPER,           MMIIM_TP_CSTAR_STATE_NORWEGIAN_9KEY_LEAD},
    {GUIIM_M_TP_NORWEGIAN_LOWER,                MMIIM_TP_CSTAR_STATE_NORWEGIAN_9KEY_LOWER},
    {GUIIM_M_TP_NORWEGIAN_UPPER,                MMIIM_TP_CSTAR_STATE_NORWEGIAN_9KEY_UPPER},
    {GUIIM_M_TPQ_NORWEGIAN_LEAD_UPPER,          MMIIM_TP_CSTAR_STATE_NORWEGIAN_26KEY_LEAD},
    {GUIIM_M_TPQ_NORWEGIAN_LOWER,               MMIIM_TP_CSTAR_STATE_NORWEGIAN_26KEY_LOWER},
    {GUIIM_M_TPQ_NORWEGIAN_UPPER,               MMIIM_TP_CSTAR_STATE_NORWEGIAN_26KEY_UPPER},

    {GUIIM_M_TP_NORWEGIAN_ABC_LEAD_UPPER,       MMIIM_TP_CSTAR_STATE_NORWEGIAN_ABC_9KEY_LEAD},
    {GUIIM_M_TP_NORWEGIAN_ABC_LOWER,            MMIIM_TP_CSTAR_STATE_NORWEGIAN_ABC_9KEY_LOWER},
    {GUIIM_M_TP_NORWEGIAN_ABC_UPPER,            MMIIM_TP_CSTAR_STATE_NORWEGIAN_ABC_9KEY_UPPER},
    {GUIIM_M_TPQ_NORWEGIAN_ABC_LEAD_UPPER,      MMIIM_TP_CSTAR_STATE_NORWEGIAN_ABC_26KEY_LEAD},
    {GUIIM_M_TPQ_NORWEGIAN_ABC_LOWER,           MMIIM_TP_CSTAR_STATE_NORWEGIAN_ABC_26KEY_LOWER},
    {GUIIM_M_TPQ_NORWEGIAN_ABC_UPPER,           MMIIM_TP_CSTAR_STATE_NORWEGIAN_ABC_26KEY_UPPER},   
#endif

#ifdef IM_SWEDISH_SUPPORT 
    {GUIIM_M_TP_SWEDISH_LEAD_UPPER,             MMIIM_TP_CSTAR_STATE_SWEDISH_9KEY_LEAD},
    {GUIIM_M_TP_SWEDISH_LOWER,                  MMIIM_TP_CSTAR_STATE_SWEDISH_9KEY_LOWER},
    {GUIIM_M_TP_SWEDISH_UPPER,                  MMIIM_TP_CSTAR_STATE_SWEDISH_9KEY_UPPER},
    {GUIIM_M_TPQ_SWEDISH_LEAD_UPPER,            MMIIM_TP_CSTAR_STATE_SWEDISH_26KEY_LEAD},
    {GUIIM_M_TPQ_SWEDISH_LOWER,                 MMIIM_TP_CSTAR_STATE_SWEDISH_26KEY_LOWER},
    {GUIIM_M_TPQ_SWEDISH_UPPER,                 MMIIM_TP_CSTAR_STATE_SWEDISH_26KEY_UPPER},

    {GUIIM_M_TP_SWEDISH_ABC_LEAD_UPPER,         MMIIM_TP_CSTAR_STATE_SWEDISH_ABC_9KEY_LEAD},
    {GUIIM_M_TP_SWEDISH_ABC_LOWER,              MMIIM_TP_CSTAR_STATE_SWEDISH_ABC_9KEY_LOWER},
    {GUIIM_M_TP_SWEDISH_ABC_UPPER,              MMIIM_TP_CSTAR_STATE_SWEDISH_ABC_9KEY_UPPER},
    {GUIIM_M_TPQ_SWEDISH_ABC_LEAD_UPPER,        MMIIM_TP_CSTAR_STATE_SWEDISH_ABC_26KEY_LEAD},
    {GUIIM_M_TPQ_SWEDISH_ABC_LOWER,             MMIIM_TP_CSTAR_STATE_SWEDISH_ABC_26KEY_LOWER},
    {GUIIM_M_TPQ_SWEDISH_ABC_UPPER,             MMIIM_TP_CSTAR_STATE_SWEDISH_ABC_26KEY_UPPER},   
#endif

#ifdef IM_UKRAINIAN_SUPPORT
    {GUIIM_M_TP_UKRAINIAN_LEAD_UPPER,           MMIIM_TP_CSTAR_STATE_UKRAINIAN_9KEY_LEAD},
    {GUIIM_M_TP_UKRAINIAN_LOWER,                MMIIM_TP_CSTAR_STATE_UKRAINIAN_9KEY_LOWER},
    {GUIIM_M_TP_UKRAINIAN_UPPER,                MMIIM_TP_CSTAR_STATE_UKRAINIAN_9KEY_UPPER},
    {GUIIM_M_TPQ_UKRAINIAN_LEAD_UPPER,          MMIIM_TP_CSTAR_STATE_UKRAINIAN_26KEY_LEAD},
    {GUIIM_M_TPQ_UKRAINIAN_LOWER,               MMIIM_TP_CSTAR_STATE_UKRAINIAN_26KEY_LOWER},
    {GUIIM_M_TPQ_UKRAINIAN_UPPER,               MMIIM_TP_CSTAR_STATE_UKRAINIAN_26KEY_UPPER},

    {GUIIM_M_TP_UKRAINIAN_ABC_LEAD_UPPER,       MMIIM_TP_CSTAR_STATE_UKRAINIAN_ABC_9KEY_LEAD},
    {GUIIM_M_TP_UKRAINIAN_ABC_LOWER,            MMIIM_TP_CSTAR_STATE_UKRAINIAN_ABC_9KEY_LOWER},
    {GUIIM_M_TP_UKRAINIAN_ABC_UPPER,            MMIIM_TP_CSTAR_STATE_UKRAINIAN_ABC_9KEY_UPPER},
    {GUIIM_M_TPQ_UKRAINIAN_ABC_LEAD_UPPER,      MMIIM_TP_CSTAR_STATE_UKRAINIAN_ABC_26KEY_LEAD},
    {GUIIM_M_TPQ_UKRAINIAN_ABC_LOWER,           MMIIM_TP_CSTAR_STATE_UKRAINIAN_ABC_26KEY_LOWER},
    {GUIIM_M_TPQ_UKRAINIAN_ABC_UPPER,           MMIIM_TP_CSTAR_STATE_UKRAINIAN_ABC_26KEY_UPPER},   
#endif

// 约鲁巴语 multitap关于虚拟键盘部分	add. 
#ifdef IM_YORUBA_SUPPORT
    //multitap
    {GUIIM_M_TP_YORUBA_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_YORUBA_ABC_9KEY_LEAD}, 
    {GUIIM_M_TP_YORUBA_ABC_LOWER, MMIIM_TP_CSTAR_STATE_YORUBA_ABC_9KEY_LOWER}, 
    {GUIIM_M_TP_YORUBA_ABC_UPPER, MMIIM_TP_CSTAR_STATE_YORUBA_ABC_9KEY_UPPER}, 

    {GUIIM_M_TPQ_YORUBA_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_YORUBA_ABC_26KEY_LEAD}, 
    {GUIIM_M_TPQ_YORUBA_ABC_LOWER, MMIIM_TP_CSTAR_STATE_YORUBA_ABC_26KEY_LOWER}, 
    {GUIIM_M_TPQ_YORUBA_ABC_UPPER, MMIIM_TP_CSTAR_STATE_YORUBA_ABC_26KEY_UPPER}, 
#endif

//科萨语	 multitap关于虚拟键盘部分	add. 
#ifdef IM_XHOSA_SUPPORT
    //multitap
    {GUIIM_M_TP_XHOSA_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_XHOSA_ABC_9KEY_LEAD}, 
    {GUIIM_M_TP_XHOSA_ABC_LOWER, MMIIM_TP_CSTAR_STATE_XHOSA_ABC_9KEY_LOWER}, 
    {GUIIM_M_TP_XHOSA_ABC_UPPER, MMIIM_TP_CSTAR_STATE_XHOSA_ABC_9KEY_UPPER}, 

    {GUIIM_M_TPQ_XHOSA_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_XHOSA_ABC_26KEY_LEAD}, 
    {GUIIM_M_TPQ_XHOSA_ABC_LOWER, MMIIM_TP_CSTAR_STATE_XHOSA_ABC_26KEY_LOWER}, 
    {GUIIM_M_TPQ_XHOSA_ABC_UPPER, MMIIM_TP_CSTAR_STATE_XHOSA_ABC_26KEY_UPPER}, 
#endif

//祖鲁语multitap关于虚拟键盘部分	add. 
#ifdef IM_ZULU_SUPPORT
    //multitap
    {GUIIM_M_TP_ZULU_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_ZULU_ABC_9KEY_LEAD}, 
    {GUIIM_M_TP_ZULU_ABC_LOWER, MMIIM_TP_CSTAR_STATE_ZULU_ABC_9KEY_LOWER}, 
    {GUIIM_M_TP_ZULU_ABC_UPPER, MMIIM_TP_CSTAR_STATE_ZULU_ABC_9KEY_UPPER}, 

    {GUIIM_M_TPQ_ZULU_ABC_LEAD_UPPER, MMIIM_TP_CSTAR_STATE_ZULU_ABC_26KEY_LEAD}, 
    {GUIIM_M_TPQ_ZULU_ABC_LOWER, MMIIM_TP_CSTAR_STATE_ZULU_ABC_26KEY_LOWER}, 
    {GUIIM_M_TPQ_ZULU_ABC_UPPER, MMIIM_TP_CSTAR_STATE_ZULU_ABC_26KEY_UPPER}, 
#endif

//印度语支的阿萨姆语	multitap关于虚拟键盘部分	add. 
#ifdef IM_ASSAMESE_SUPPORT
    //multitap
    {GUIIM_M_TP_ASSAMESE_ABC, MMIIM_TP_CSTAR_STATE_ASSAMESE_ABC_9KEY_UPPER},
    {GUIIM_M_TPQ_ASSAMESE_ABC, MMIIM_TP_CSTAR_STATE_ASSAMESE_ABC_26KEY_UPPER},
#endif

//斯瓦西里语	multitap关于虚拟键盘部分	add. 
#ifdef IM_SWAHILI_SUPPORT 
    {GUIIM_M_TP_SWAHILI_LEAD_UPPER,              MMIIM_TP_CSTAR_STATE_SWAHILI_9KEY_LEAD},
    {GUIIM_M_TP_SWAHILI_LOWER,                   MMIIM_TP_CSTAR_STATE_SWAHILI_9KEY_LOWER},
    {GUIIM_M_TP_SWAHILI_UPPER,                   MMIIM_TP_CSTAR_STATE_SWAHILI_9KEY_UPPER},
    {GUIIM_M_TPQ_SWAHILI_LEAD_UPPER,             MMIIM_TP_CSTAR_STATE_SWAHILI_26KEY_LEAD},
    {GUIIM_M_TPQ_SWAHILI_LOWER,                  MMIIM_TP_CSTAR_STATE_SWAHILI_26KEY_LOWER},
    {GUIIM_M_TPQ_SWAHILI_UPPER,                  MMIIM_TP_CSTAR_STATE_SWAHILI_26KEY_UPPER},

    {GUIIM_M_TP_SWAHILI_ABC_LEAD_UPPER,          MMIIM_TP_CSTAR_STATE_SWAHILI_ABC_9KEY_LEAD},
    {GUIIM_M_TP_SWAHILI_ABC_LOWER,               MMIIM_TP_CSTAR_STATE_SWAHILI_ABC_9KEY_LOWER},
    {GUIIM_M_TP_SWAHILI_ABC_UPPER,               MMIIM_TP_CSTAR_STATE_SWAHILI_ABC_9KEY_UPPER},
    {GUIIM_M_TPQ_SWAHILI_ABC_LEAD_UPPER,         MMIIM_TP_CSTAR_STATE_SWAHILI_ABC_26KEY_LEAD},
    {GUIIM_M_TPQ_SWAHILI_ABC_LOWER,              MMIIM_TP_CSTAR_STATE_SWAHILI_ABC_26KEY_LOWER},
    {GUIIM_M_TPQ_SWAHILI_ABC_UPPER,              MMIIM_TP_CSTAR_STATE_SWAHILI_ABC_26KEY_UPPER},   
#endif

};


extern MMIIM_TP_KEY_DISPLAY_TEXT*  const s_mul_text_26kb_def_data[MMIIM_TP_CSTAR_ABC_VNUM * MMIIM_TP_CSTAR_ABC_HNUM];
extern MMIIM_TP_KEY_DISPLAY_TEXT*  const s_mul_text_9kb_def_data[MMIIM_TP_CSTAR_9KEY_ABC_VNUM * MMIIM_TP_CSTAR_9KEY_ABC_HNUM];
extern const uint16 s_mul_text_26kb_def_data_map[MMIIM_TP_CSTAR_ABC_VNUM * MMIIM_TP_CSTAR_ABC_HNUM];
extern const uint16 s_mul_text_9kb_def_data_map[MMIIM_TP_CSTAR_9KEY_ABC_VNUM * MMIIM_TP_CSTAR_9KEY_ABC_HNUM];

//虚拟键盘字符显示风格
LOCAL GUISTR_STYLE_T s_kb_normal_text_style = 
{
    SONG_FONT_16, 
    IMUI_KB_DEFAULT_NORMAL_TEXT_COLOR, 
    ALIGN_HVMIDDLE, 
    ANGLE_0,
    FONT_EFFECT_NONE
};

LOCAL GUISTR_STYLE_T s_kb_highlight_text_style = 
{
    SONG_FONT_16, 
    IMUI_KB_DEFAULT_HIGHLIGHT_TEXT_COLOR, 
    ALIGN_HVMIDDLE, 
    ANGLE_0,
    FONT_EFFECT_NONE
};


//虚拟键盘按键后，tips显示字符串风格
typedef enum _MMIIM_KEY_TIPS_STYLE_E
{
    MMIIM_KTS_ALL_DATA,     //显示按键对应的所有字符信息
    MMIIM_KTS_FIRST_DATA,       //显示按键对应的首个字符信息

    MMIIM_KTS_MAX
}MMIIM_KEY_TIPS_STYLE_E;

LOCAL MMIIM_KEY_TIPS_STYLE_E s_kts_def = MMIIM_KTS_ALL_DATA;

/*---------------------------------------------------------------------------*/
/*                          LOCAL FUNCTION DECLARE                           */
/*---------------------------------------------------------------------------*/

/******************************************************************************/
// Description:
// Global resource dependence: NONE
// Author: haiwu.chen
// Note:由func中配置的state决定是否显示tips
/******************************************************************************/
LOCAL BOOLEAN IsDisplayTips(
    MMIIM_TP_CSTAR_HANDLE_T* handle_ptr
);

/*****************************************************************************/
//  Description : 通过水平垂直偏移，取得对应可替换键的图片ID
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note: 检查按键是否按住可替换键
/*****************************************************************************/
LOCAL BOOLEAN GetReplaceKeyImgID(
    MMIIM_TP_CSTAR_HANDLE_T* handle_ptr,
    uint16 x_idx,
    uint16 y_idx,
    const MMIIM_TP_CSTAR_REPLACE_KEY_T **replace_key_pptr,
    MMIIM_TP_CSTAR_KEY_STATE_T img_state
);

/******************************************************************************/
// Description: 显示按键的tips
// Global resource dependence: NONE
// Author: haiwu.chen
// Note:
/******************************************************************************/
LOCAL void DrawKeyTips(
    MMIIM_TP_CSTAR_HANDLE_T* handle_ptr,
    MMI_STRING_T string,
    GUI_POINT_T pt_src
);

/******************************************************************************/
// Description: 显示按键的tips
// Global resource dependence: NONE
// Author: haiwu.chen
// Note:
/******************************************************************************/
LOCAL void DrawKeyTipsEx(
    MMIIM_TP_CSTAR_HANDLE_T* handle_ptr,
    MMI_STRING_T string,
    GUI_POINT_T pt_src
);

/******************************************************************************/
// Description: 显示按键的tips
// Global resource dependence: NONE
// Author: haiwu.chen
// Note:
/******************************************************************************/
LOCAL BOOLEAN GetTipsRect(
    MMIIM_TP_CSTAR_HANDLE_T* handle_ptr,
    MMI_STRING_T string,
    GUI_POINT_T pt_src,
    MMIIM_TP_CSTSR_TIPS_DATA_T* tips_data_ptr
);

/*****************************************************************************/
//  Description : 画键盘上方需要替换的小图标，考虑文本的情况
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note:
/*****************************************************************************/
LOCAL void DrawReplaceKeyInRect(
    MMIIM_TP_CSTAR_HANDLE_T* handle_ptr, 
    MMIIM_TP_CSTAR_REPLACE_KEY_T replace_key,
    GUI_RECT_T key_rect,
    MMIIM_TP_CSTAR_KEY_STATE_T image_state
);

/*****************************************************************************/
//  Description : 设置需要提示的tips按键内容
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note:
/*****************************************************************************/
LOCAL void SetDisplayTipsChar(
    MMIIM_TP_CSTAR_HANDLE_T *data_ptr, 
    uint32 char_idx, 
    MMI_STRING_T *string_ptr
);

//////////////////////////////////////////////////////////////////////////
///////////////////         Replace     //////////////////////////////////
//////////////////////////////////////////////////////////////////////////


/*****************************************************************************/
//  Description : 初始化显示数据
//  Global resource dependence : none
//  Author: jian.ma
//  Note:
/*****************************************************************************/
PUBLIC void MMIIMUI_InitDisplayData(
    MMIIM_TP_CSTAR_HANDLE_T *handle_ptr
)
{
    GUI_RECT_T client_rect = {0};
    uint16 width = 0;
    uint16 height = 0;

    //SCI_ASSERT(PNULL != handle_ptr); /*assert verified*/
    if(PNULL == handle_ptr)
    {
        return;
    }
        
    //根据设置的图片取出图片的宽度、高度
    MMIIMUI_GetImageWidthHeight(handle_ptr->init_param.win_id, g_keyboard_state[handle_ptr->stateId].normal_image_id, &width, &height);

    //设置一开始按键索引为无效的-1
    handle_ptr->tp_last_msg_param.idx = -1;

	client_rect = MMITHEME_GetClientRectEx(handle_ptr->init_param.win_handle);

    //键盘放置绝对区域，只有这里会存放相对LCD零点的绝对区域，已经是横竖屏了
    g_keyboard_state[handle_ptr->stateId].rect.left  = client_rect.left;
    g_keyboard_state[handle_ptr->stateId].rect.top = client_rect.bottom - height + 1;
    g_keyboard_state[handle_ptr->stateId].rect.right = client_rect.right;
    g_keyboard_state[handle_ptr->stateId].rect.bottom = client_rect.bottom;

    //显示图片相对区域[如果键盘图片都不采用拉伸的显示方式的话，下面这个图片区域看来就是有点多余]
    g_keyboard_state[handle_ptr->stateId].img_rect.left = 0;
    g_keyboard_state[handle_ptr->stateId].img_rect.top = 0;
    g_keyboard_state[handle_ptr->stateId].img_rect.right = width;
    g_keyboard_state[handle_ptr->stateId].img_rect.bottom = height;

    //混淆拼写区相对区域
    MMIIMUI_InitChoiceBarData(handle_ptr);
}

/*****************************************************************************/
//  Description : 重置UI句柄相关变量
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note:
/*****************************************************************************/
PUBLIC void MMIIMUI_InitUIHandleData(
    MMIIM_TP_CSTAR_HANDLE_T *handle_ptr,
    MMIIM_TP_CSTAR_STATE_ID_T kb_state
)
{
    handle_ptr->bak_stateIdii = handle_ptr->bak_stateId;
    handle_ptr->bak_stateId = handle_ptr->stateId;
    handle_ptr->stateId = kb_state;
    handle_ptr->index = 0;
    handle_ptr->result_len = 0;
    handle_ptr->is_need_lock = FALSE;

    MMIIMUI_ClearChoiceBarData(&handle_ptr->choice_bar);
}

/*****************************************************************************/
//  Description : 初始化9键的pychoicebar数据
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note: 一些不受内核返回数据的数据都要在此一次初始化完成
/*****************************************************************************/
PUBLIC void MMIIMUI_InitChoiceBarData(
    MMIIM_TP_CSTAR_HANDLE_T *handle_ptr
)
{
    uint16 width = 0;
    uint16 height = 0;
    uint16 font_height = 0;
    uint16 avarage_pix = 0;
    uint16 y_offset = 0;
    uint16 y_offset_per = 0;
    uint16 i = 0;

    //SCI_ASSERT(PNULL != handle_ptr); /*assert verified*/
    if(PNULL == handle_ptr)
    {
        return;
    }
    
    SCI_MEMSET(&handle_ptr->choice_bar, 0, sizeof(MMIIM_TP_CSTAR_CHOICE_BAR_T));
    handle_ptr->choice_bar.win_id = handle_ptr->init_param.win_id;
    handle_ptr->choice_bar.lcd_info_ptr = handle_ptr->init_param.lcd_info_ptr;
    handle_ptr->choice_bar.bg_img[MMIIM_TP_CSTAR_KEY_STATE_ACTIVE] = g_keyboard_state[handle_ptr->stateId].normal_image_id;
    handle_ptr->choice_bar.bg_img[MMIIM_TP_CSTAR_KEY_STATE_PRESS] = g_keyboard_state[handle_ptr->stateId].press_image_id;

    //set rect
    /*[下面这一步待以后把键盘的宽度都只要初始化时计算一次并保存好，则下面就直接去取即可]*/
    MMIIMUI_GetImageWidthHeight(handle_ptr->init_param.win_id, g_keyboard_state[handle_ptr->stateId].normal_image_id, &width, &height);
    handle_ptr->choice_bar.rect = g_keyboard_state[handle_ptr->stateId].rect;
    handle_ptr->choice_bar.rect.right = (uint16)(width / g_keyboard_state[handle_ptr->stateId].hnum);   //在左边，只需要修改右边值

    //set up arrow rect
    handle_ptr->choice_bar.idc_up_img[MMIIM_TP_CSTAR_KEY_STATE_INACTIVE] = IMG_IMSP_IDC_UP_DIS;
    handle_ptr->choice_bar.idc_up_img[MMIIM_TP_CSTAR_KEY_STATE_ACTIVE] = IMG_IMSP_IDC_UP_OFF;
    handle_ptr->choice_bar.idc_up_img[MMIIM_TP_CSTAR_KEY_STATE_PRESS] = IMG_IMSP_IDC_UP_ON;
    MMIIMUI_GetImageWidthHeight(handle_ptr->init_param.win_id, handle_ptr->choice_bar.idc_up_img[MMIIM_TP_CSTAR_KEY_STATE_ACTIVE], &width, &height);
    handle_ptr->choice_bar.idc_up_rect.left = handle_ptr->choice_bar.rect.left + MMIIM_TP_CSTAR_CHOICE_UP_LEFT_X_V;
    handle_ptr->choice_bar.idc_up_rect.top = handle_ptr->choice_bar.rect.top + MMIIM_TP_CSTAR_CHOICE_UP_TOP_X_V;
    handle_ptr->choice_bar.idc_up_rect.right = handle_ptr->choice_bar.idc_up_rect.left + width;
    handle_ptr->choice_bar.idc_up_rect.bottom = handle_ptr->choice_bar.idc_up_rect.top + height;
    handle_ptr->choice_bar.idc_up_state = MMIIM_TP_CSTAR_KEY_STATE_INACTIVE;

    //set down arrow rect
    handle_ptr->choice_bar.idc_down_img[MMIIM_TP_CSTAR_KEY_STATE_INACTIVE] = IMG_IMSP_IDC_DOWN_DIS;
    handle_ptr->choice_bar.idc_down_img[MMIIM_TP_CSTAR_KEY_STATE_ACTIVE] = IMG_IMSP_IDC_DOWN_OFF;
    handle_ptr->choice_bar.idc_down_img[MMIIM_TP_CSTAR_KEY_STATE_PRESS] = IMG_IMSP_IDC_DOWN_ON;
    MMIIMUI_GetImageWidthHeight(handle_ptr->init_param.win_id, handle_ptr->choice_bar.idc_down_img[MMIIM_TP_CSTAR_KEY_STATE_ACTIVE], &width, &height);
    handle_ptr->choice_bar.idc_down_rect.left = handle_ptr->choice_bar.idc_up_rect.left;
    handle_ptr->choice_bar.idc_down_rect.right = handle_ptr->choice_bar.idc_down_rect.left + width;
    handle_ptr->choice_bar.idc_down_rect.bottom = handle_ptr->choice_bar.rect.bottom - MMIIM_TP_CSTAR_CHOICE_DOWN_BOTTOM_X_V;
    handle_ptr->choice_bar.idc_down_rect.top = handle_ptr->choice_bar.idc_down_rect.bottom - height + 1;
    handle_ptr->choice_bar.idc_down_state = MMIIM_TP_CSTAR_KEY_STATE_INACTIVE;

    //calculate max display line
    font_height = GUIFONT_GetHeight(MMIIM_TP_CSTAR_CHOICE_BAR_FONT_TEXT);
    handle_ptr->choice_bar.choice_line_cnt =
        (handle_ptr->choice_bar.idc_down_rect.top - handle_ptr->choice_bar.idc_up_rect.bottom) / (font_height + MMIIM_TP_CSTAR_CHOICE_BAR_SPACE_HEIGHT); //加两个像素作中行间隔

    if (0 == handle_ptr->choice_bar.choice_line_cnt)
    {
        handle_ptr->choice_bar.choice_line_cnt = 1;
    }

    //并一定能整除，可能还会剩下几行像素，值一定小于行数，算法就是每行后面加一个像素，直接加完为止，有可能后面的行，就可能没有加到，毕竟近水楼台嘛
    avarage_pix = (handle_ptr->choice_bar.idc_down_rect.top - handle_ptr->choice_bar.idc_up_rect.bottom) % (font_height + MMIIM_TP_CSTAR_CHOICE_BAR_SPACE_HEIGHT);
    avarage_pix /= handle_ptr->choice_bar.choice_line_cnt;

    y_offset = handle_ptr->choice_bar.idc_up_rect.bottom;

    for (i = 0; i < handle_ptr->choice_bar.choice_line_cnt && i < MMIIM_CHOICE_STR_MAX_SHOW_NUM; i++)
    {
        y_offset_per = font_height + MMIIM_TP_CSTAR_CHOICE_BAR_SPACE_HEIGHT + avarage_pix;   //每行占的高度

        handle_ptr->choice_bar.choice_str_rect[i].left = handle_ptr->choice_bar.idc_up_rect.left;
        handle_ptr->choice_bar.choice_str_rect[i].right = handle_ptr->choice_bar.idc_up_rect.right - 1;//微调是有必要的，不必那么紧凑
        handle_ptr->choice_bar.choice_str_rect[i].top = y_offset;
        handle_ptr->choice_bar.choice_str_rect[i].bottom = handle_ptr->choice_bar.choice_str_rect[i].top + y_offset_per;

        y_offset += y_offset_per;
    }

    //reset choice
    MMIIMUI_ClearChoiceBarData(&handle_ptr->choice_bar);
}


/*****************************************************************************/
//  Description : 重新设置键盘图片
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note: 由于multitap首字符大写造成的, multitap，lead要求配大写后变小写
/*****************************************************************************/
PUBLIC BOOLEAN MMIIMUI_ResetKbImageByLeadCape(
    MMIIM_TP_CSTAR_HANDLE_T *handle_ptr
)
{
    BOOLEAN result = FALSE;

//    if (PNULL != handle_ptr)
//    {
//        //只有配了首字母大写的键盘，需要重新修改一下，变成大写
//        if (GUIIM_MODE_LEAD_UPPER == handle_ptr->init_param.method_param_ptr->im_def_ptr->capital)
//        {
//            if (handle_ptr->is_full_keypad)
//            {
//                g_keyboard_state[handle_ptr->stateId].normal_image_id = IMG_IMSP_EN26_UPPER_OFF;
//                g_keyboard_state[handle_ptr->stateId].press_image_id = IMG_IMSP_EN26_UPPER_ON;
//            }
//            else
//            {
//                g_keyboard_state[handle_ptr->stateId].normal_image_id = IMG_IMSP_EN9_UPPER_OFF;
//                g_keyboard_state[handle_ptr->stateId].press_image_id = IMG_IMSP_EN9_UPPER_ON;
//
//            }
//
//            result = TRUE;
//        }
//     }

    return  result;
}

/*****************************************************************************/
//  Description : 获得图片的宽高
//  Global resource dependence : none
//  Author: jian.ma
//  Note:
/*****************************************************************************/
PUBLIC void MMIIMUI_GetImageWidthHeight(MMI_WIN_ID_T win_id, MMI_IMAGE_ID_T image_id, uint16* width_ptr, uint16* height_ptr)
{
    BOOLEAN is_image = FALSE;

    //SCI_ASSERT(PNULL != width_ptr); /*assert verified*/
    //SCI_ASSERT(PNULL != height_ptr); /*assert verified*/
    //SCI_ASSERT(0 < win_id); /*assert verified*/
    //SCI_ASSERT(0 < image_id); /*assert verified*/

    is_image = GUIRES_GetImgWidthHeight(width_ptr, height_ptr, image_id, win_id);
    //SCI_ASSERT(0 <= *width_ptr); /*assert verified*/
    //SCI_ASSERT(0 <= *height_ptr); /*assert verified*/
}

/*****************************************************************************/
//  Description : 画整张键盘，注意根据UI状态来写，可能只显示部分
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note:
/*****************************************************************************/
PUBLIC void MMIIMUI_DrawAllBoard(
    MMIIM_TP_CSTAR_HANDLE_T* handle_ptr //in:输入法句柄
)
{
    //SCI_TRACE_LOW:"[MMIIM] DrawAllBoard:%d"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIIM_TP_UI_1333_112_2_18_2_29_19_273,(uint8*)"d", handle_ptr->stateId);
    //SCI_ASSERT(PNULL != handle_ptr); /*assert verified*/
    //SCI_ASSERT(handle_ptr->stateId < MMIIM_TP_CSTAR_STATE_MAX); /*assert verified*/
    if(PNULL == handle_ptr ||handle_ptr->stateId >= MMIIM_TP_CSTAR_STATE_MAX )
    {
        return;
    }
    
    handle_ptr->is_rect_change = FALSE;
    handle_ptr->is_kb_dirty = FALSE;
    handle_ptr->is_bar_cand_dirty = FALSE;
    handle_ptr->is_bar_edit_dirty = FALSE;

    switch (handle_ptr->ui_state)
    {
    case MMIIM_TP_CSTAR_STATE_INPUTING:
    case MMIIM_TP_CSTAR_STATE_USER:
        
    #ifdef INPUT_METHOD_CSTAR_COMMON_MINI
        if(GUIIM_M_TP_PINYIN != handle_ptr->init_param.method_param_ptr->im_set.method)
    #endif
        {
            if(g_keyboard_state[handle_ptr->stateId].priv_data&MMIIM_TP_CSTAR_ED)
            {
                MMIIMUI_DrawEditBar(handle_ptr);
            }
        }    
    
        //lint -fallthrough
    case MMIIM_TP_CSTAR_STATE_ASSOCIATE:

        if (g_keyboard_state[handle_ptr->stateId].priv_data&MMIIM_TP_CSTAR_CAND)
        {
            MMIIMUI_DrawCandBar(handle_ptr);
        }

        //lint -fallthrough
    case MMIIM_TP_CSTAR_STATE_NOINPUT:
        {
            //注意我们是要从下往上画
            MMIIMUI_DrawKeyBoard(handle_ptr);

            //画重复的图标
            MMIIMUI_DrawReplaceKey(handle_ptr);

            //如果是9键，则需要画出混淆区
            if (!handle_ptr->is_full_keypad && !MMIIMUI_IsCommonKeyBoardState(handle_ptr))
                MMIIMUI_DrawChoiceBar(&handle_ptr->choice_bar);
        }
        break;

    default:
        break;
    }

    return;
}


//获取multitap虚拟键盘26键各个按键对应的multitap默认数据，该数据保存在指针数组中对应的结构体中，
//输入法每次切换的时候，会重新设置该数据内容，故此处获取的为当前使用的输入法multitap按键数据
PUBLIC const MMIIM_TP_KEY_DISPLAY_TEXT** MMIIMUI_MulKb26KeyGetDefData(void)
{
    return (const MMIIM_TP_KEY_DISPLAY_TEXT **)&s_mul_text_26kb_def_data;
}


//获取multitap虚拟键盘9键各个按键对应的multitap默认数据，该数据保存在指针数组中对应的结构体中，
//输入法每次切换的时候，会重新设置该数据内容，故此处获取的为当前使用的输入法multitap按键数据
PUBLIC const MMIIM_TP_KEY_DISPLAY_TEXT** MMIIMUI_MulKb9KeyGetDefData(void)
{
    return (const MMIIM_TP_KEY_DISPLAY_TEXT**)&s_mul_text_9kb_def_data;
}

//清除掉语言中的26键数据，其他特殊按键不清除
//因虚拟键盘中的数据内容长度不一致，当前是根据长度设置对应的数据，故如果
//原始程序中存在较长的数据，而后来copy的数据相对较短，则易出现问题，虽然首个
//元素表示存在的数据个数，但程序还是应该严密的好，故每次在设置multitap数据前，会
//重新清除掉原数据(仅仅清除a,b,c等英文字符按键数据，其他数据不可清空，原因是，某些
//定制数据也在里面)
PUBLIC int32 MMIIMUI_ClearKB26KeyTextDefData(const MMIIM_TP_KEY_DISPLAY_TEXT **p_kb_key)
{
    int iloop = 0;
    MMIIM_TP_KEY_DISPLAY_TEXT *p_cur_key = NULL;

    //SCI_ASSERT(p_kb_key);    /*assert verified*/
    
    for(iloop = 0; iloop < MMIIM_TP_CSTAR_ABC_VNUM * MMIIM_TP_CSTAR_ABC_HNUM; iloop ++)
    {       
            //(s_mul_text_26kb_def_data_map[iloop] >= MMIIM_SP_26KEY_INDEX_A)，PC LINT报警去掉该条件
        if(s_mul_text_26kb_def_data_map[iloop] <= MMIIM_SP_26KEY_INDEX_Z)   
        {
            if(PNULL != p_kb_key)
            {
                p_cur_key = (MMIIM_TP_KEY_DISPLAY_TEXT *)(*(p_kb_key + iloop)); //键盘对应的字符按键
            }
            //SCI_ASSERT(p_cur_key);       /*assert verified*/
            if(PNULL != p_cur_key)
            {
                SCI_MEMSET(p_cur_key, 0, sizeof(MMIIM_TP_KEY_DISPLAY_TEXT));
            }
        }
    }   

    return 0;
}


/*-------------------------------------------------------------------------------------
Name:   MMIIMUI_SetKbMul26KeyTextData

Func:   设置某种对应输入法的multitap按键数据

Input:  method :设置该种输入法的multitap按键数据
            p_kb_key:   指针输入，该数组指针的内容为需要写的数据，即根据输入法
            获取multitap数据，并写在p_kb_key所指向的二维数组中的变量中

Output:
            p_kb_key:   指针数组，该数组指针的内容为需要写的数据，即根据输入法
            获取multitap数据，并写在p_kb_key所指向的二维数组中的变量中

Return:
            < 0 失败，== 0成功
            
Thoughtway:
            1.因虚拟键盘显示按键需要使用字符显示，这样可以减少图片资源及程序的
                维护工作量，每张键盘因语言或输入法的不同而不同，故需要设置键盘
                数据；
            2.因multitap按键数据对应的是multitap输入法，当method非multitap输入法,则获取数据
                失败，不会将该数据写入键盘配置表p_kb_key对应的数据中
            
Create: yaoguangchen@spread. 2011-06-09
        
Modify:

-------------------------------------------------------------------------------------*/
PUBLIC int32 MMIIMUI_SetKbMul26KeyTextData(
    GUIIM_METHOD_T method, 
    const MMIIM_TP_KEY_DISPLAY_TEXT **p_kb_key)
{
    MMIIM_SP_26KEY_KEYCHAR_T *pkey_table_26 = NULL;
    uint32 iloop = 0;
    uint32 data_index = 0;  //对应字符在字符数据表中的下标
    MMIIM_TP_KEY_DISPLAY_TEXT *p_cur_key = NULL;

    //SCI_ASSERT(p_kb_key != NULL);    /*assert verified*/
    if(PNULL == p_kb_key)
    {
        return -1;
    }
    MMIIMUI_ClearKB26KeyTextDefData(p_kb_key);
    
    pkey_table_26 = MMIIM_SP_ML26KEY_GetKeyTable(method);
    if(pkey_table_26 == NULL)
    {
        return -1;
    }
    
    for(iloop = 0; iloop < MMIIM_TP_CSTAR_ABC_VNUM * MMIIM_TP_CSTAR_ABC_HNUM; iloop ++)
    {
        data_index = s_mul_text_26kb_def_data_map[iloop] - MMIIM_SP_26KEY_INDEX_A;
        if(data_index <= MMIIM_SP_26KEY_INDEX_Z - MMIIM_SP_26KEY_INDEX_A)   //有效字符值
        {
            p_cur_key = (MMIIM_TP_KEY_DISPLAY_TEXT *)(*(p_kb_key + iloop)); //键盘对应的字符按键
            if(p_cur_key != NULL)// && s_mul_text_26kb_def_data_map[iloop] == pkey_table_26[data_index].key_index)
            {
                SCI_MEMCPY(&p_cur_key->disp_data.key_chars[0], &pkey_table_26[data_index].key_chars[0], 
                    (pkey_table_26[data_index].key_chars[0] + 1) * sizeof(wchar));  //将数据copy到键盘数据表中
            }
        }
    }
    
    return 0;
}



/*-------------------------------------------------------------------------------------
Name:   MMIIMUI_SetSmartKb26KeyTextData

Func:   设置某种智能输入法的smart按键数据，通过该数据配置虚拟键盘按键
            字符显示

Input:  method :设置该种输入法的smart按键数据
            p_kb_key:   指针输入，该数组指针的内容为需要写的数据，即根据输入法
            获取smart数据，并写在p_kb_key所指向的二维数组中的变量中

Output:
            p_kb_key:   指针数组，该数组指针的内容为需要写的数据，即根据输入法
            获取smart数据，并写在p_kb_key所指向的二维数组中的变量中

Return:
            < 0 失败，== 0成功
            
Thoughtway:
            1.因虚拟键盘显示按键需要使用字符显示，这样可以减少图片资源及程序的
                维护工作量，每张键盘因语言或输入法的不同而不同，故需要设置键盘
                数据；
            2.因smart按键数据对应的是smart输入法，当method非smart输入法,则获取数据
                失败，不会将该数据写入键盘配置表p_kb_key对应的数据中
            3.此函数没有与函数MMIIMUI_SetKbMul26KeyTextData合并，原因是，他们虽然数据相同，
                但是合并后，会导致程序灵活性降低，一旦需要修改某个输入法，则会
                互相影响，故分离处理
            
Create: yaoguangchen@spread. 2011-06-09
        
Modify:

-------------------------------------------------------------------------------------*/
PUBLIC int32 MMIIMUI_SetSmartKb26KeyTextData(
    GUIIM_METHOD_T method, 
    const MMIIM_TP_KEY_DISPLAY_TEXT **p_kb_key)
{
    MMIIM_SP_26KEY_KEYCHAR_T *pkey_table_26 = PNULL;
    uint32 iloop = 0;
    uint32 data_index = 0;  //对应字符在字符数据表中的下标
    MMIIM_TP_KEY_DISPLAY_TEXT *p_cur_key = PNULL;

    //SCI_ASSERT(p_kb_key != NULL);    /*assert verified*/
    if(PNULL == p_kb_key)
    {
        return -1;
    }
    MMIIMUI_ClearKB26KeyTextDefData(p_kb_key);
    
    pkey_table_26 = MMIIM_SP_SMART26KEY_GetKeyTable(method);
    if(pkey_table_26 == NULL)
    {
        return -1;
    }
    
    for(iloop = 0; iloop < MMIIM_TP_CSTAR_ABC_VNUM * MMIIM_TP_CSTAR_ABC_HNUM; iloop ++)
    {
        data_index = s_mul_text_26kb_def_data_map[iloop] - MMIIM_SP_26KEY_INDEX_A;
        if(data_index <= MMIIM_SP_26KEY_INDEX_Z - MMIIM_SP_26KEY_INDEX_A)   //有效字符值
        {
            p_cur_key = (MMIIM_TP_KEY_DISPLAY_TEXT *)(*(p_kb_key + iloop)); //键盘对应的字符按键
            if(p_cur_key != NULL)// && s_mul_text_26kb_def_data_map[iloop] == pkey_table_26[data_index].key_index)
            {
                SCI_MEMCPY(&p_cur_key->disp_data.key_chars[0], &pkey_table_26[data_index].key_chars[0], 
                    ((uint16)pkey_table_26[data_index].key_chars[0] + 1) * sizeof(wchar));  //将数据copy到键盘数据表中
            }
        }
    }
    
    return 0;
}


//清除掉语言中的8(2~9)键数据，其他特殊按键不清除
//因虚拟键盘中的数据内容长度不一致，当前是根据长度设置对应的数据，故如果
//原始程序中存在较长的数据，而后来copy的数据相对较短，则易出现问题，虽然首个
//元素表示存在的数据个数，但程序还是应该严密的好，故每次在设置multitap数据前，会
//重新清除掉原数据(仅仅清除2~9键数据，其他数据不可清空，原因是，某些定制数据
//也在里面)
PUBLIC int32 MMIIMUI_ClearKB9KeyTextDefData(const MMIIM_TP_KEY_DISPLAY_TEXT **p_kb_key)
{
    int iloop = 0;
    MMIIM_TP_KEY_DISPLAY_TEXT *p_cur_key = NULL;
    
    for(iloop = 0; iloop < MMIIM_TP_CSTAR_9KEY_ABC_VNUM * MMIIM_TP_CSTAR_9KEY_ABC_HNUM; iloop ++)
    {
        if(s_mul_text_9kb_def_data_map[iloop] >= MMIIM_SP_26KEY_INDEX_2
            && s_mul_text_9kb_def_data_map[iloop] <= MMIIM_SP_26KEY_INDEX_9)    
        {
            p_cur_key = (MMIIM_TP_KEY_DISPLAY_TEXT *)(*(p_kb_key + iloop)); //键盘对应的字符按键
            SCI_MEMSET(&p_cur_key->disp_data, 0, sizeof(MMIIM_KEY_TEXT_DISPLAY_DATA_T));
        }
    }   

    return 0;
}


/*-------------------------------------------------------------------------------------
Name:   MMIIMUI_SetKbMul9KeyTextData

Func:   设置某种multitap输入法的smart按键数据，通过该数据配置虚拟键盘按键
            字符显示

Input:  method :设置该种输入法的smart按键数据
            p_kb_key:   指针输入，该数组指针的内容为需要写的数据，即根据输入法
            获取smart数据，并写在p_kb_key所指向的二维数组中的变量中

Output:
            p_kb_key:   指针数组，该数组指针的内容为需要写的数据，即根据输入法
            获取smart数据，并写在p_kb_key所指向的二维数组中的变量中

Return:
            < 0 失败，== 0成功
            
Thoughtway:
            1.因虚拟键盘显示按键需要使用字符显示，这样可以减少图片资源及程序的
                维护工作量，每张键盘因语言或输入法的不同而不同，故需要设置键盘
                数据；
            2.因smart按键数据对应的是smart输入法，当method非smart输入法,则获取数据
                失败，不会将该数据写入键盘配置表p_kb_key对应的数据中
            3.此函数没有与函数MMIIMUI_SetKbMul26KeyTextData合并，原因是，他们虽然数据相同，
                但是合并后，会导致程序灵活性降低，一旦需要修改某个输入法，则会
                互相影响，故分离处理
            4.此函数会在清除掉原始的数据，重新写入新的数据，如果失败，则不作
                写入操作
            
Create: yaoguangchen@spread. 2011-06-09
        
Modify:

-------------------------------------------------------------------------------------*/

PUBLIC int32 MMIIMUI_SetKbMul9KeyTextData(
    GUIIM_METHOD_T method, 
    const MMIIM_TP_KEY_DISPLAY_TEXT **p_kb_key)
{
    MMIIM_SP_9KEY_TABLE_DEF_T *pkey_table_9 = NULL;     //二维数组指针
    uint32 iloop = 0;
    uint32 data_index = 0;
    MMIIM_TP_KEY_DISPLAY_TEXT *p_cur_key = NULL;

    //SCI_ASSERT(p_kb_key != NULL);        /*assert verified*/
    if(PNULL == p_kb_key)
    {
        return -1;
    }
    
    pkey_table_9 = MMIIM_SP_ML9KEY_GetKeyTable(method);
    if(pkey_table_9 == NULL)
    {
        return -1;
    }

    MMIIMUI_ClearKB9KeyTextDefData(p_kb_key);   //先清除掉原有数据，放置语言切换或输入法切换后，数据异常
    
    for(iloop = 0; iloop < MMIIM_TP_CSTAR_9KEY_ABC_VNUM * MMIIM_TP_CSTAR_9KEY_ABC_HNUM; iloop ++)
    {
        if(s_mul_text_9kb_def_data_map[iloop] <= MMIIM_SP_26KEY_INDEX_9
            && s_mul_text_9kb_def_data_map[iloop] >= MMIIM_SP_26KEY_INDEX_2)    //有效字符值
        {
            data_index = s_mul_text_9kb_def_data_map[iloop] - MMIIM_SP_26KEY_INDEX_1;
            p_cur_key = (MMIIM_TP_KEY_DISPLAY_TEXT *)(*(p_kb_key + iloop)); //键盘对应的字符按键
            if(p_cur_key != NULL)
            {
                p_cur_key->disp_index = MMIIM_KB_KEY_DISP_TEXT_WITHOUT_DIGIT;        //默认以如此方式显示
                SCI_MEMCPY(&p_cur_key->disp_data.key_chars[0], &((*pkey_table_9)[data_index][0]), 
                    (uint16)(((*pkey_table_9)[data_index][0]) + 1) * sizeof(wchar));    //将数据copy到键盘数据表中
            }
        }
    }
    
    return 0;
}


/*-------------------------------------------------------------------------------------
Name:   MMIIMUI_SetSmartKb9KeyTextData

Func:   设置某种智能输入法的smart按键数据，通过该数据配置虚拟键盘按键
            字符显示

Input:  method :设置该种输入法的smart按键数据
            p_kb_key:   指针输入，该数组指针的内容为需要写的数据，即根据输入法
            获取smart数据，并写在p_kb_key所指向的二维数组中的变量中

Output:
            p_kb_key:   指针数组，该数组指针的内容为需要写的数据，即根据输入法
            获取smart数据，并写在p_kb_key所指向的二维数组中的变量中

Return:
            < 0 失败，== 0成功
            
Thoughtway:
            1.因虚拟键盘显示按键需要使用字符显示，这样可以减少图片资源及程序的
                维护工作量，每张键盘因语言或输入法的不同而不同，故需要设置键盘
                数据；
            2.因smart按键数据对应的是smart输入法，当method非smart输入法,则获取数据
                失败，不会将该数据写入键盘配置表p_kb_key对应的数据中
            3.此函数没有与函数MMIIMUI_SetKbMul26KeyTextData合并，原因是，他们虽然数据相同，
                但是合并后，会导致程序灵活性降低，一旦需要修改某个输入法，则会
                互相影响，故分离处理
            4.此函数会在清除掉原始的数据，重新写入新的数据，如果失败，则不作
                写入操作
            
Create: yaoguangchen@spread. 2011-06-09
        
Modify:

-------------------------------------------------------------------------------------*/

PUBLIC int32 MMIIMUI_SetSmartKb9KeyTextData(
    GUIIM_METHOD_T method, 
    const MMIIM_TP_KEY_DISPLAY_TEXT **p_kb_key)
{
    MMIIM_SP_9KEY_TABLE_DEF_T *pkey_table_9 = NULL;     //二维数组指针
    uint32 iloop = 0;
    uint32 data_index = 0;
    MMIIM_TP_KEY_DISPLAY_TEXT *p_cur_key = NULL;

    //SCI_ASSERT(p_kb_key != NULL);    /*assert verified*/
    if(PNULL == p_kb_key)
    {
        return -1;
    }
    
    pkey_table_9 = MMIIM_SP_Smart9Key_GetKeyTable(method);
    if(pkey_table_9 == NULL)
    {
        return -1;
    }

    MMIIMUI_ClearKB9KeyTextDefData(p_kb_key);   //先清除掉原有数据，放置语言切换或输入法切换后，数据异常

    for(iloop = 0; iloop < MMIIM_TP_CSTAR_9KEY_ABC_VNUM * MMIIM_TP_CSTAR_9KEY_ABC_HNUM; iloop ++)
    {
        if(s_mul_text_9kb_def_data_map[iloop] <= MMIIM_SP_26KEY_INDEX_9
            && s_mul_text_9kb_def_data_map[iloop] >= MMIIM_SP_26KEY_INDEX_2)    //有效字符值
        {
            data_index = s_mul_text_9kb_def_data_map[iloop] - MMIIM_SP_26KEY_INDEX_1;
            p_cur_key = (MMIIM_TP_KEY_DISPLAY_TEXT *)(*(p_kb_key + iloop)); //键盘对应的字符按键
            if(p_cur_key != NULL)
            {
                p_cur_key->disp_index = MMIIM_KB_KEY_DISP_TEXT_WITHOUT_DIGIT;        //默认以如此方式显示
                SCI_MEMCPY(&p_cur_key->disp_data.key_chars[0], &((*pkey_table_9)[data_index][0]), 
                    (uint16)(((*pkey_table_9)[data_index][0]) + 1) * sizeof(wchar));    //将数据copy到键盘数据表中
            }
        }
    }
    
    return 0;
}


//根据按键对应的multitap结构体，获取按键当前应该显示的字符串
LOCAL int32 MMIIMUI_GetKbKeyText(
    const MMIIM_TP_KEY_DISPLAY_TEXT *pcur_disp_text,
    wchar *psave_str,   //max_len为该指针buf的长度，切忌越界，使用时
    uint16 *psave_str_len,
    uint16 max_len)
{
    uint16 key_num = 0;
    int16 key_index = 0;

    //SCI_ASSERT(pcur_disp_text != NULL);      /*assert verified*/
    //SCI_ASSERT(psave_str_len != NULL);       /*assert verified*/
    //SCI_ASSERT(psave_str != NULL);           /*assert verified*/
    if(PNULL == pcur_disp_text || NULL == psave_str_len || PNULL == psave_str)
    {
        return -1;
    }
    
    key_num = pcur_disp_text->disp_data.key_chars[0];
    key_index = pcur_disp_text->disp_index;

    //某些语言的个别键可能被配置为空白，即没有数据 ，添加一个校验
    if(key_num == 0)
    {
        *psave_str_len = 0;
        *psave_str = 0;   
        return -1;
    }

    //显示全部字符
    if(key_index == MMIIM_KB_KEY_DISP_TEXT_ALL)
    {
        *psave_str_len = key_num < max_len?
        key_num : max_len;
        SCI_MEMSET(psave_str, 0, max_len);
        SCI_MEMCPY(psave_str, &(pcur_disp_text->disp_data.key_chars[1]), *psave_str_len);   // 首个字符被用作字符个数
    }
    //因区域不够，显示前两个字符和一个点号及最后一个字符
    else if(key_index == MMIIM_KB_KEY_DISP_TEXT_CHAR_AND_DOT)
    {
        //超过4个字符
        if(key_num > 4)     
        {
            uint index = 0;
            SCI_MEMSET(psave_str, 0, max_len);
            psave_str[index] = (pcur_disp_text->disp_data.key_chars[1]);    // 首个字符被用作字符个数，后续为字符编码
            index++;
            //psave_str[1] = ' ';
            psave_str[index] = (pcur_disp_text->disp_data.key_chars[2]);
            index++;
            //psave_str[3] = ' ';
            psave_str[index] = '.';
            index++;
            //psave_str[5] = ' ';
            psave_str[index] = (pcur_disp_text->disp_data.key_chars[key_num]);  //不要 -1, 首个字符被作为个数来，显示最后一个字符
            index++;
            *psave_str_len = index;
        }
        else    //全部显示
        {
            SCI_MEMSET(psave_str, 0, max_len);
            SCI_MEMCPY(psave_str, &(pcur_disp_text->disp_data.key_chars[1]), 
            key_num * sizeof(wchar));
            *psave_str_len = key_num;
        }
    }
    else if(key_index == MMIIM_KB_KEY_DISP_TEXT_WITHOUT_DIGIT)   //不需要显示数字
    {
        uint32 index = 0;
        uint32 iloop = 0;
        SCI_MEMSET(psave_str, 0, max_len);
        for(iloop = 0; iloop < key_num; iloop ++)
        {
            if(index > 3)   //字符个数超标，先检查
                break;
            if(pcur_disp_text->disp_data.key_chars[1 + iloop] < '0' || pcur_disp_text->disp_data.key_chars[1 + iloop] > '9')     //非数字字符
            {
                psave_str[index] = pcur_disp_text->disp_data.key_chars[1 + iloop];
                index ++;
            }
        }
        *psave_str_len = index;
    }
    //显示一个字符，正常字符显示
    else if(key_index  >= 0 && key_index < key_num)     //如果配置时不小心越界了，做一个检查
    {
        SCI_MEMSET(psave_str, 0, max_len);
        psave_str[0] = pcur_disp_text->disp_data.key_chars[key_index + 1];  //+1首个字符被用作字符个数，后续为字符编码
        *psave_str_len = 1;
    }

    return 0;
}



/*------------------------------------------------------------------------------------
Func:  绘制虚拟键盘

Input:  
    data_ptr:   当前输入法句柄

Output: None
    
Return: success:    0
        < 0:参数异常等

Thoughtway: 
    1. 根据当前输入法对应虚拟键盘表，绘制当前键盘；键盘表
        数据中初始化全局变量g_keyboard_state时设置完成
    2. 虚拟键盘采用绘制一张空白图的方式作为背景，然后在各个
        按键上，绘制对应的字符

Creator:

Modify: 

------------------------------------------------------------------------------------*/
PUBLIC int32 MMIIMUI_DrawKeyBoardWithText(
    MMIIM_TP_CSTAR_HANDLE_T* handle_ptr //in:输入法句柄
    )
{
    int iloop = 0;

    const MMIIM_TP_CSTAR_FUNC_T * pcur_functab = NULL;
    const MMIIM_TP_KEY_DISPLAY_TEXT **pcur_disp_text = NULL;

    wchar show_str[2 * MMIIM_SP_26KEY_CHAR_MAX + 1] = {0};
    uint16 show_str_len = 0;
    MMI_STRING_T text = {0};
    GUISTR_STATE_T          text_state = 0;

    int16 cur_rect_index = 0;       //指向当前按钮区域索引
    int16 rect_width = 0, rect_height = 0;  //每个单元格的宽度
    GUI_RECT_T disp_rect =  {0, 0, 0, 0};

    uint16 TOP_SPACE_WIDTH = 0, TOP_SPACE_HEIGHT = 0;
    uint16 BOTTOM_SPACE_WIDTH = 0;
    uint16 KEY_HOR_COL = 0;
    uint16 KEY_VER_COL = 0;


    //按钮信息指针
    //SCI_ASSERT(PNULL != handle_ptr);     /*assert verified*/
    if(PNULL == handle_ptr)
        return -1;

    pcur_functab = g_keyboard_state[handle_ptr->stateId].functab;   //借用区域坐标信息
    if(PNULL == pcur_functab)
        return -1;

    pcur_disp_text = g_keyboard_state[handle_ptr->stateId].p_disp_text;     //没有配置，采用默认数据
    if(pcur_disp_text == NULL)
        return -2;
    
    //背景图片
        GUIRES_DisplayImg(PNULL, (GUI_RECT_T*) &g_keyboard_state[handle_ptr->stateId].rect, 
        (GUI_RECT_T*) &g_keyboard_state[handle_ptr->stateId].img_rect,
                      handle_ptr->init_param.win_handle, g_keyboard_state[handle_ptr->stateId].normal_image_id, handle_ptr->lcd_info_ptr);
    
    //按钮间隔值
    if (MMITHEME_IsMainScreenLandscape())
    {
        TOP_SPACE_WIDTH = TOP_SPACE_WIDTH_H;
        TOP_SPACE_HEIGHT = TOP_SPACE_HEIGHT_H;
        BOTTOM_SPACE_WIDTH = BOTTOM_SPACE_WIDTH_H;
        KEY_HOR_COL = KEY_HOR_COL_H;
        KEY_VER_COL = KEY_VER_COL_H;
    }
    else
    {
        TOP_SPACE_WIDTH = TOP_SPACE_WIDTH_V;
        TOP_SPACE_HEIGHT = TOP_SPACE_HEIGHT_V;
        BOTTOM_SPACE_WIDTH = BOTTOM_SPACE_WIDTH_V;
        KEY_HOR_COL = KEY_HOR_COL_V;
        KEY_VER_COL = KEY_VER_COL_V;
    }

    //按钮大小
    rect_width = MMIIMUI_GetKeyButtonWidth(g_keyboard_state[handle_ptr->stateId]);  //每个单元格的宽度
    rect_height = MMIIMUI_GetKeyButtonHeight(g_keyboard_state[handle_ptr->stateId]);

    //绘制字符
    for(iloop = 0; iloop < g_keyboard_state[handle_ptr->stateId].vnum * g_keyboard_state[handle_ptr->stateId].hnum; iloop ++)
    {
        //异常，没有配置，则不做处理
        if(*pcur_disp_text == NULL || (*pcur_disp_text)->disp_index == MMIIM_KB_KEY_DISP_TEXT_NONE)
        {
            cur_rect_index += pcur_functab->rect_num;   //得到下一个按钮区域索引
            pcur_functab ++;    //下一个按钮指针
            pcur_disp_text ++;

            continue;
        }

        MMIIMUI_GetKbKeyText((*pcur_disp_text), (wchar *)&show_str, &show_str_len, MMIIM_SP_26KEY_CHAR_MAX);
        if(show_str_len == 0 || show_str_len > MMIIM_SP_26KEY_CHAR_MAX)
        {
            cur_rect_index += pcur_functab->rect_num;   //得到下一个按钮区域索引
            pcur_functab ++;    //下一个按钮指针
            pcur_disp_text ++;

            text.wstr_ptr = 0;    
            text.wstr_len = 0;  
        
            continue;
        }

        text.wstr_ptr = show_str;
        text.wstr_len = show_str_len;

        //显示坐标区域
        {
            disp_rect.left =  (cur_rect_index % g_keyboard_state[handle_ptr->stateId].hnum) * (rect_width + KEY_HOR_COL)
                + TOP_SPACE_WIDTH + g_keyboard_state[handle_ptr->stateId].rect.left;
            disp_rect.top = (cur_rect_index / g_keyboard_state[handle_ptr->stateId].hnum) * (rect_height + KEY_VER_COL)
                + TOP_SPACE_HEIGHT + g_keyboard_state[handle_ptr->stateId].rect.top;

            disp_rect.right = disp_rect.left + (pcur_functab->rect_num * rect_width);
            disp_rect.bottom = disp_rect.top + rect_height;
        }

//定义了繁体中文输入法，不采用计算宽度的方式，是因为每次显示键盘字符前，并
//不知道哪一个按键显示不下，除非先统计一下所有按键是否能够显示下，再设置字符大小，
//这样的方案太繁琐；
//也可以根据屏幕尺寸设置字符大小，但某些语言或某些输入法对应的字符要多些，也会有
//影响；
//暂且使用如此不佳的办法吧
#ifdef IM_TRAD_CHINESE_SUPPORT
	if(handle_ptr->init_param.method_param_ptr->im_set.method == GUIIM_M_TP_ZHUYIN)
	{
		s_kb_normal_text_style.font = SONG_FONT_12;
	}
	else
	{
		s_kb_normal_text_style.font = SONG_FONT_16;
	}
#endif
        
        GUISTR_DrawTextToLCDInRect( 
                                   handle_ptr->lcd_info_ptr,
                                   (const GUI_RECT_T*)&disp_rect,       //the fixed display area
                                   (const GUI_RECT_T*)&disp_rect,       //用户要剪切的实际区域
                                   (const MMI_STRING_T*)&text,
                                   &s_kb_normal_text_style,
                                   text_state,
                                   GUISTR_TEXT_DIR_AUTO
                                   );

        cur_rect_index += pcur_functab->rect_num;   //得到下一个按钮区域索引
        pcur_functab ++;    //下一个按钮指针
        pcur_disp_text ++;
    }

    return 0;
}



/*------------------------------------------------------------------------------------
Func:  multitap键盘，根据按键中的数据，显示字符，而不是采用前期的
    图片显示字符方式

Input:  
    data_ptr:   当前输入法句柄
    rect_index:  按钮在键盘单元格中的索引值，根据此索引值查找
        对应的按键
    highlight:  按钮是否高亮，以备按下或恢复时使用

Output: None
    
Return: success:    0
        < 0:没有绘制指定索引的按键字符或参数不合法等情况

Thoughtway: 
    1.  根据当前输入法对应虚拟键盘表和键盘表中的单元格索引，
        得出需要绘制的按键；同时根据按键multitap数据信息，绘制multitap
        中的某个字符或多个字符，因9键虚拟键盘按键需要绘制多个字符。
        故每个按键在绘制前，一定会初始化过，该按键绘制字符状态需要
        根据初始化值获取。初始化数据存在于全局变量g_keyboard_state中
    2.  小心9键choice区域的上下按钮，导致越界
    3.  因写该函数的时候，没有注意到rect_index参数传入时，需要计算，比较麻烦
        应该修改为传入点坐标，但时间原因，暂且不修改该函数
Creator:

Modify: 

------------------------------------------------------------------------------------*/
PUBLIC int32 MMIIMUI_DrawVituralButtonWithText(
    MMIIM_TP_CSTAR_HANDLE_T* data_ptr,
    BOOLEAN highlight       //高亮显示
    )
{
    wchar show_str[2 * MMIIM_SP_26KEY_CHAR_MAX + 1] = {0};
    uint16 show_str_len = 0;
    MMI_STRING_T text = {0};
    GUISTR_STYLE_T          text_style = {0};        
    GUISTR_STATE_T          text_state = 0;
    int16 key_nums = 0;

    GUI_RECT_T disp_rect =  {0, 0, 0, 0}, img_rect = {0, 0, 0, 0};

    const MMIIM_TP_CSTAR_FUNC_T * pcur_functab = NULL;
    const MMIIM_TP_KEY_DISPLAY_TEXT **pcur_disp_text = NULL;
    uint32 IMGID_bground = 0;
    const MMIIM_TP_CSTAR_REPLACE_KEY_T *replace_key_ptr = PNULL;
    
    //SCI_ASSERT(data_ptr != NULL);        /*assert verified*/
    if(PNULL == data_ptr)
        return -1;

//定义了繁体中文输入法，不采用计算宽度的方式，是因为每次显示键盘字符前，并
//不知道哪一个按键显示不下，除非先统计一下所有按键是否能够显示下，再设置字符大小，
//这样的方案太繁琐；
//也可以根据屏幕尺寸设置字符大小，但某些语言或某些输入法对应的字符要多些，也会有
//影响；
//暂且使用如此不佳的办法吧
#ifdef IM_TRAD_CHINESE_SUPPORT
	if(data_ptr->init_param.method_param_ptr->im_set.method == GUIIM_M_TP_ZHUYIN)
	{
		s_kb_normal_text_style.font = SONG_FONT_12;
	}
	else
	{
		s_kb_normal_text_style.font = SONG_FONT_16;
	}
#endif

    s_kb_normal_text_style.font_color = MMITHEME_GetCurThemeFontColor(MMI_THEME_VKB_KEY_FONT_COLOR);
    text_style = s_kb_normal_text_style ; //以 默认状态配置，需要高亮配置的再重新配置一次
    pcur_functab = g_keyboard_state[data_ptr->stateId].functab;
    pcur_disp_text = g_keyboard_state[data_ptr->stateId].p_disp_text;
    if(pcur_functab == NULL || pcur_disp_text == NULL)
        return -1;

    //替换键
    if(GetReplaceKeyImgID(data_ptr, data_ptr->tp_last_msg_param.h_idx, data_ptr->tp_last_msg_param.v_idx, &replace_key_ptr, MMIIM_TP_CSTAR_KEY_STATE_PRESS))
        return -2;

    //防止传入值非法
    key_nums = g_keyboard_state[data_ptr->stateId].vnum * g_keyboard_state[data_ptr->stateId].hnum;
    if(key_nums <= data_ptr->tp_last_msg_param.idx || data_ptr->tp_last_msg_param.idx < 0)
    {
        return -3;
    }
    
    pcur_disp_text +=  data_ptr->tp_last_msg_param.idx;

    //非字符按键
    if(*pcur_disp_text && (*pcur_disp_text)->disp_index == MMIIM_KB_KEY_DISP_TEXT_NONE)
        return -4;
    
    MMIIMUI_GetKbKeyText(*pcur_disp_text, (wchar *)&show_str, &show_str_len, MMIIM_SP_26KEY_CHAR_MAX);
    if(show_str_len == 0 || show_str_len > MMIIM_SP_26KEY_CHAR_MAX)
    {
        return -5;
    }
    
    text.wstr_ptr = show_str;
    text.wstr_len = show_str_len;

    SCI_MEMCPY(&disp_rect, &data_ptr->press_rect, sizeof(disp_rect));
    //绘制
    if(highlight)   //高亮，图片显示高亮按键图片，否则显示背景图片
    {
        s_kb_highlight_text_style.font_color = MMITHEME_GetCurThemeFontColor(MMI_THEME_VKB_KEY_FONT_COLOR_HIGHLIGHT);
        text_style = s_kb_highlight_text_style;

        if(data_ptr->is_full_keypad)
            IMGID_bground = IMG_IMSP_EN26_KEY_HIGHLIGHT;
        else
            IMGID_bground = IMG_IMSP_EN9_KEY_HIGHLIGHT;
    }
    else
    {
        if(data_ptr->is_full_keypad)
            IMGID_bground = IMG_IMSP_EN26_KEY_BACKGROUND;
        else
            IMGID_bground = IMG_IMSP_EN9_KEY_BACKGROUND;
    }

    //背景图片
    img_rect.right = disp_rect.right - disp_rect.left;
    img_rect.bottom = disp_rect.bottom - disp_rect.top;
        GUIRES_DisplayImg(PNULL, &disp_rect, &img_rect,
                      data_ptr->init_param.win_handle, IMGID_bground, data_ptr->lcd_info_ptr);

    GUISTR_DrawTextToLCDInRect( 
                                   data_ptr->lcd_info_ptr,
                                   (const GUI_RECT_T*)&disp_rect,       
                                   (const GUI_RECT_T*)&disp_rect,       
                                   (const MMI_STRING_T*)&text,
                                   &text_style,
                                   text_state,
                                   GUISTR_TEXT_DIR_AUTO
                                   );

    return 0;
}

//获取当前虚拟键盘输入法，某个按键对应的tips字符串
LOCAL void MMIIM_GetTipsText(
    MMIIM_TP_CSTAR_HANDLE_T* data_ptr, 
    int32 key_idx,
    wchar   *psave_wstr,       //buffer地址
    uint16   *psave_wstr_len)

{
    int32 iloop = 0;
    const MMIIM_TP_KEY_DISPLAY_TEXT **pcur_disp_text = NULL;
    
    //SCI_ASSERT(data_ptr != NULL);    /*assert verified*/
    //SCI_ASSERT(psave_wstr != NULL);      /*assert verified*/
    //SCI_ASSERT(psave_wstr_len != NULL);      /*assert verified*/
    if(PNULL == data_ptr || PNULL == psave_wstr||NULL == psave_wstr_len )
        return;

    pcur_disp_text  = g_keyboard_state[data_ptr->stateId].p_disp_text;
    if(pcur_disp_text == NULL)
        return;

    if(key_idx >= g_keyboard_state[data_ptr->stateId].hnum * g_keyboard_state[data_ptr->stateId].vnum)
        return;
    
    pcur_disp_text += key_idx;  
    if(pcur_disp_text != NULL && (*pcur_disp_text) != NULL && (*pcur_disp_text)->disp_index != MMIIM_KB_KEY_DISP_TEXT_NONE)     /*lint  !e774 !e831 */ 
    {
        if(s_kts_def == MMIIM_KTS_ALL_DATA)     //显示所有字符
        {
            uint16 char_num = 0;

            char_num = (*pcur_disp_text)->disp_data.key_chars[0] < MMIIM_SP_26KEY_CHAR_MAX? 
                (*pcur_disp_text)->disp_data.key_chars[0] : MMIIM_SP_26KEY_CHAR_MAX;
            
            //某些语言的个别键可能被配置为空白，即没有数据 ，添加一个校验
            if(char_num == 0)
            {
                *psave_wstr_len = 0;
                *psave_wstr = 0;
                return;
            }

            for(iloop = 0; iloop < char_num; iloop ++)
            {
                *(psave_wstr + 2 * iloop) = (*pcur_disp_text)->disp_data.key_chars[iloop + 1];    //+1 首个表示字符个数，从后一个字符
                *(psave_wstr + 2 * iloop + 1) = ' ';
            }
        
            *psave_wstr_len = char_num * 2 -1; //-1最后一个空格不显示
        }
        else
        {
            *psave_wstr = (*pcur_disp_text)->disp_data.key_chars[(*pcur_disp_text)->disp_index];
            *psave_wstr_len = 1;
        }
    }
}


/*****************************************************************************/
//  Description : 画键盘
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note: 要根据当前键盘状态刷图，注意大小写要画对
/*****************************************************************************/
PUBLIC void MMIIMUI_DrawKeyBoard(
    MMIIM_TP_CSTAR_HANDLE_T* handle_ptr //in:输入法句柄
)
{
    //SCI_TRACE_LOW:"[MMIIM] MMIIMUI_DrawKeyBoard"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIIM_TP_UI_2224_112_2_18_2_29_21_274,(uint8*)"");

    //SCI_ASSERT(PNULL != handle_ptr); /*assert verified*/
    //SCI_ASSERT(PNULL != handle_ptr->lcd_info_ptr); /*assert verified*/
    //SCI_ASSERT(PNULL != handle_ptr->init_param.method_param_ptr); /*assert verified*/
    //SCI_ASSERT(handle_ptr->stateId < MMIIM_TP_CSTAR_STATE_MAX); /*assert verified*/
    if(PNULL == handle_ptr || PNULL == handle_ptr->lcd_info_ptr||PNULL == handle_ptr->init_param.method_param_ptr||handle_ptr->stateId >= MMIIM_TP_CSTAR_STATE_MAX)
        return;


//虚拟键盘按键字符显示方式
//#if 1   //def MMIIM_VIRTUAL_KB_TEXT_SUPPORT     //强制打开，部分程序宏未完全控制，不打开，将导致虚拟键盘背景图为空白
{
    //如果配置了按键数据，则以配置的按键数据显示，否则按默认方式显示
    if(g_keyboard_state[handle_ptr->stateId].p_disp_text == NULL)
    {
        if(handle_ptr->is_full_keypad)
            g_keyboard_state[handle_ptr->stateId].p_disp_text = MMIIMUI_MulKb26KeyGetDefData();
        else
            g_keyboard_state[handle_ptr->stateId].p_disp_text = MMIIMUI_MulKb9KeyGetDefData();    
    }

    MMIIMUI_DrawKeyBoardWithText(handle_ptr);

    //是否需要画锁键
    if (handle_ptr->is_need_lock)
    {
        GUI_RECT_T rect_locked = {0, 0, 0, 0};

        rect_locked.right = handle_ptr->lock_rect.right - handle_ptr->lock_rect.left;
        rect_locked.bottom = handle_ptr->lock_rect.bottom - handle_ptr->lock_rect.top;
        GUIRES_DisplayImg(PNULL, (GUI_RECT_T*) &handle_ptr->lock_rect, (GUI_RECT_T*) &rect_locked,
                          handle_ptr->init_param.win_handle, IMG_IMSP_NUM_SYMB_LOCKED, handle_ptr->lcd_info_ptr);
    }
}
//#else
//    //加一个不等0的检查，防止没有键盘表没有配好
//    if (0 != g_keyboard_state[handle_ptr->stateId].normal_image_id)
//    {
//        GUIRES_DisplayImg(PNULL, (GUI_RECT_T*) &g_keyboard_state[handle_ptr->stateId].rect, (GUI_RECT_T*) &g_keyboard_state[handle_ptr->stateId].img_rect,
//                          handle_ptr->init_param.win_handle, g_keyboard_state[handle_ptr->stateId].normal_image_id, handle_ptr->lcd_info_ptr);
//
//        //是否需要画锁键
//        if (handle_ptr->is_need_lock)
//        {
//            GUIRES_DisplayImg(PNULL, (GUI_RECT_T*) &handle_ptr->lock_rect, (GUI_RECT_T*) &handle_ptr->lock_img_rect,
//                              handle_ptr->init_param.win_handle, g_keyboard_state[handle_ptr->stateId].press_image_id, handle_ptr->lcd_info_ptr);
//        }
//    }
// #endif
}

/*****************************************************************************/
//  Description : 画键盘上方需要替换的小图标
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note:
/*****************************************************************************/
PUBLIC void MMIIMUI_DrawReplaceKey(
    MMIIM_TP_CSTAR_HANDLE_T* handle_ptr //in:输入法句柄
)
{
    int i = 0;
    GUI_RECT_T key_rect = {0};
    GUI_RECT_T key_img_rect = {0};
    uint16 button_w = 0;//按钮宽
    uint16 button_h = 0;
    uint16 img_w = 0;
    uint16 img_h = 0;
    MMIIM_TP_CSTAR_REPLACE_KEY_T replace_key = {0};
    MMIIM_TP_CSTAR_STATE_T state = {0};
    uint16 TOP_SPACE_WIDTH = 0;
    uint16 TOP_SPACE_HEIGHT = 0;
    uint16 KEY_HOR_COL = 0;
    uint16 KEY_VER_COL = 0;

    //SCI_TRACE_LOW:"[MMIIM] MMIIMUI_DrawReplaceKey"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIIM_TP_UI_2298_112_2_18_2_29_21_275,(uint8*)"");

    //SCI_ASSERT(PNULL != handle_ptr); /*assert verified*/
    if(PNULL == handle_ptr)
        return;
    
    /*画正常的替换键*/
    if (PNULL == g_keyboard_state[handle_ptr->stateId].replace_key_tab ||
            0 == g_keyboard_state[handle_ptr->stateId].replace_key_cnt)
        return;

    if (MMITHEME_IsMainScreenLandscape())
    {
        TOP_SPACE_WIDTH = TOP_SPACE_WIDTH_H;
        TOP_SPACE_HEIGHT = TOP_SPACE_HEIGHT_H;
        KEY_HOR_COL = KEY_HOR_COL_H;
        KEY_VER_COL = KEY_VER_COL_H;
    }
    else
    {
        TOP_SPACE_WIDTH = TOP_SPACE_WIDTH_V;
        TOP_SPACE_HEIGHT = TOP_SPACE_HEIGHT_V;
        KEY_HOR_COL = KEY_HOR_COL_V;
        KEY_VER_COL = KEY_VER_COL_V;
    }

    state = g_keyboard_state[handle_ptr->stateId];
    button_w = MMIIMUI_GetKeyButtonWidth(state);
    button_h = MMIIMUI_GetKeyButtonHeight(state);

    for (i = 0; i < g_keyboard_state[handle_ptr->stateId].replace_key_cnt; i++)
    {
        replace_key = g_keyboard_state[handle_ptr->stateId].replace_key_tab[i];
        key_rect.left = g_keyboard_state[handle_ptr->stateId].rect.left + TOP_SPACE_WIDTH + replace_key.hor_index * (button_w + KEY_HOR_COL);
        key_rect.top = g_keyboard_state[handle_ptr->stateId].rect.top + TOP_SPACE_HEIGHT + replace_key.ver_index * (button_h + KEY_VER_COL);
        img_w = replace_key.rect_cnt * button_w + (replace_key.rect_cnt - 1) * KEY_HOR_COL;
        img_h = button_h;

        key_rect.right = key_rect.left + img_w;
        key_rect.bottom = key_rect.top + img_h;
        key_img_rect.left = 0;
        key_img_rect.top = 0;
        key_img_rect.right = key_img_rect.left + img_w;
        key_img_rect.bottom = key_img_rect.top + img_h;

        DrawReplaceKeyInRect(handle_ptr, replace_key, key_rect, MMIIM_TP_CSTAR_KEY_STATE_ACTIVE);
    }
}

/*****************************************************************************/
//  Description : 画键盘上方需要替换的小图标，考虑文本的情况
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note:
/*****************************************************************************/
LOCAL void DrawReplaceKeyInRect(
    MMIIM_TP_CSTAR_HANDLE_T* handle_ptr, 
    MMIIM_TP_CSTAR_REPLACE_KEY_T replace_key,
    GUI_RECT_T key_rect,
    MMIIM_TP_CSTAR_KEY_STATE_T image_state
)
{
    if (PNULL == handle_ptr)
    {
        return;
    }
    
    if (MMIIM_TP_KEY_DISPLAY_TYPE_IMAGE == replace_key.display_key_type)
    {
        //纯图片
        GUIRES_DisplayImg(PNULL, &key_rect, PNULL, handle_ptr->init_param.win_handle, 
            replace_key.img[image_state], handle_ptr->lcd_info_ptr);
    }
    else if (MMIIM_TP_KEY_DISPLAY_TYPE_TEXT == replace_key.display_key_type)
    {
        //纯文本
        //do something, but not now...
    }
    else if (MMIIM_TP_KEY_DISPLAY_TYPE_IMAGEANDTEXT == replace_key.display_key_type)
    {
        //图片+文本
        //理论上，此函数应该是不必去关心内容什么来的，只管用户配什么内容就显示什么的
        //但是目前替换键且文本+图片的形式只有输入法切换图标才有，然后我们可以通过method去im_swicth中去取文本ID
        MMI_STRING_T string = {0};
        GUISTR_STYLE_T style = {0};        
        GUI_FONT_T font = {0};
        GUI_COLOR_T font_color = {0}; 
        int i = 0;

        if (MMITHEME_IsMainScreenLandscape())
        {
            font = MMIIM_TP_KEY_DISPLAY_FONT_H;
            font_color = MMIIM_TP_KEY_DISPLAY_FONT_COLOR_H;
        }
        else
        {
            font = MMIIM_TP_KEY_DISPLAY_FONT_V;
            font_color = MMIIM_TP_KEY_DISPLAY_FONT_COLOR_V;
        }
        
        GUIRES_DisplayImg(PNULL, &key_rect, PNULL, handle_ptr->init_param.win_handle, 
            replace_key.img[image_state], handle_ptr->lcd_info_ptr);
        
        //draw text
        while (replace_key.text[i++] != '\0' && i < MMIIM_TP_KEY_DISPLAY_TEXT_LEN)
            NULL;
        
        string.wstr_len = i;
        string.wstr_ptr = replace_key.text;
        
        //画文字
        style.font = font;
        style.font_color = font_color;
        style.align = ALIGN_HVMIDDLE;
        
        GUISTR_DrawTextToLCDInRect(handle_ptr->lcd_info_ptr,
            &key_rect,
            &key_rect,
            &string,
            &style,
            GUISTR_STATE_ALIGN | GUISTR_STATE_SINGLE_LINE,
            GUISTR_TEXT_DIR_AUTO
            );
    }
}

/*****************************************************************************/
//  Description : 画编辑框
//  Global resource dependence : none
//  Author: rui.xu
//  Note:
/*****************************************************************************/
PUBLIC void MMIIMUI_DrawEditBar(MMIIM_TP_CSTAR_HANDLE_T* handle_ptr)
{
    uint16 bar_img_width = 0;
    uint16 bar_img_height = 0;    
    MMI_STRING_T string = {0};
    GUISTR_STYLE_T text_style = {0};
    GUI_FONT_T font = {0};
    wchar buffer[CAND_MAX_NUM] = {0};
    wchar const *item_ptr = PNULL;
    int32 wchar_count = 0;
    int32 count = 0;
    int32 loop = 0;
    int32 index = 0;
    wchar space[] = L" "; //空格
    GUI_RECT_T edit_font_rect = {0};

    //SCI_TRACE_LOW:"[MMIIM] MMIIMUI_DrawEditBar"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIIM_TP_UI_2442_112_2_18_2_29_21_276,(uint8*)"");

    //SCI_ASSERT(PNULL != handle_ptr); /*assert verified*/
    //SCI_ASSERT(PNULL != handle_ptr->lcd_info_ptr); /*assert verified*/
    //SCI_ASSERT(handle_ptr->stateId < MMIIM_TP_CSTAR_STATE_MAX); /*assert verified*/
    if(PNULL == handle_ptr ||PNULL == handle_ptr->lcd_info_ptr ||handle_ptr->stateId >= MMIIM_TP_CSTAR_STATE_MAX)
        return;


    MMIIMUI_GetImageWidthHeight(handle_ptr->init_param.win_id, s_text_bar_theme.img_bg, &bar_img_width, &bar_img_height);

    if (g_keyboard_state[handle_ptr->stateId].priv_data & MMIIM_TP_CSTAR_CAND) //是不是指这逻辑：具有候选写的，则一定有拼写区呢？待进一步验证
    {
        handle_ptr->edit_rect.bottom = handle_ptr->cand_rect.top - 1;
        handle_ptr->edit_rect.top = handle_ptr->edit_rect.bottom - bar_img_height + 1;
    }
    else
    {
        handle_ptr->edit_rect.bottom = g_keyboard_state[handle_ptr->stateId].rect.top - 1;
        handle_ptr->edit_rect.top = (int16)(handle_ptr->edit_rect.bottom - bar_img_height + 1);
    }

    handle_ptr->edit_rect.left = g_keyboard_state[handle_ptr->stateId].rect.left;
    handle_ptr->edit_rect.right = g_keyboard_state[handle_ptr->stateId].rect.right;

    //画编辑区背景
    MMITHEME_DisplayCommonBg(&handle_ptr->edit_rect,handle_ptr->init_param.win_handle,handle_ptr->lcd_info_ptr);

    GUIRES_DisplayImg(PNULL, &handle_ptr->edit_rect, PNULL, handle_ptr->init_param.win_handle, s_text_bar_theme.img_bg, handle_ptr->lcd_info_ptr);

    item_ptr = handle_ptr->pPreBuffer;

    while (loop < CAND_MAX_NUM)
    {
        if (0 == item_ptr[loop])
        {
            count++;
        }
        else
        {
            count = 0;
        }

        if (2 <= count) //连续2个0时不用找了
        {
            break;
        }

        wchar_count++;
        loop++;
    }

    if (0 == item_ptr[wchar_count-1])
    {
        wchar_count--;//最后一个0去掉；
    }

    item_ptr = handle_ptr->pPreBuffer;
    loop = 0;

    while (0 == item_ptr[loop] && wchar_count > 0) //把最前面的0去掉
    {
        loop++;
        wchar_count--;
    }

    if (wchar_count > 0)
    {
        for (index = 0; index < wchar_count; index++)
        {
            buffer[index] = item_ptr[loop+index];

            if (0 == buffer[index]) //0显示成空格
            {
                MMIAPICOM_Wstrncpy(&buffer[index], space, 1);
            }
        }
    }

    string.wstr_ptr = buffer;
    string.wstr_len = MMIAPICOM_Wstrlen(buffer);
    font = s_text_bar_theme.font_text;
    text_style.font_color = s_text_bar_theme.color_text;
    text_style.font = font;
    text_style.align = ALIGN_LVMIDDLE;
    edit_font_rect = handle_ptr->edit_rect;
    edit_font_rect.left = handle_ptr->edit_rect.left + 8;
#ifdef IM_ENGINE_SOGOU
    {
        uint16 str_width = GUI_GetStringWidth(font, string.wstr_ptr, string.wstr_len);
        GUI_RECT_T disp_rect = edit_font_rect;
        // 超长
        if (str_width > (disp_rect.right - disp_rect.left))
        {
            uint8 i = 0;
            while (i < string.wstr_len && string.wstr_ptr[i] > 0x4DFF)
            {
                i++;
            }
            // 显示前半部分
            if (!(i > 0 && GUI_GetStringWidth(font, string.wstr_ptr, i) < (disp_rect.right - disp_rect.left)))
            {
                disp_rect.left = disp_rect.right - str_width;
            }
        }
        GUISTR_DrawTextToLCDInRect(handle_ptr->lcd_info_ptr,
            &disp_rect,
            &edit_font_rect,
            &string,
            &text_style,
            GUISTR_STATE_ALIGN | GUISTR_STATE_SINGLE_LINE,
            GUISTR_TEXT_DIR_LTR
            );
    }
#else
    {
        int iloop = 0;
        uint16 str_width = GUI_GetStringWidth(font, string.wstr_ptr, string.wstr_len);
        GUI_RECT_T disp_rect = edit_font_rect;
        
        // 超长
        if (str_width > (disp_rect.right - disp_rect.left))
        {
            //取后半截字符串
            for(iloop = 0; iloop < string.wstr_len; iloop ++)
            {
                str_width = GUI_GetStringWidth(font, string.wstr_ptr, string.wstr_len - iloop);
                if(str_width < disp_rect.right - disp_rect.left)
                {
                    string.wstr_len -= iloop;
                    break;
                }

                string.wstr_ptr ++;
            }
        }
            
        GUISTR_DrawTextToLCDInRect(handle_ptr->lcd_info_ptr,
                                   &edit_font_rect,
                                   &edit_font_rect,
                                   &string,
                                   &text_style,
                                   GUISTR_STATE_ALIGN | GUISTR_STATE_SINGLE_LINE,
                                   GUISTR_TEXT_DIR_LTR
                                  );
    }
#endif
}

/*****************************************************************************/
//  Description : 设置choice bar的正常状态
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note:
/*****************************************************************************/
PUBLIC void MMIIMUI_SetNormalStateOnChoiceBar(
    MMIIM_TP_CSTAR_CHOICE_BAR_T *bar_ptr
)
{
    if (PNULL == bar_ptr)
    {
        return;
    }

    bar_ptr->hot_index = -1;
    if (bar_ptr->page_index > 0)
    {
        bar_ptr->idc_up_state = MMIIM_TP_CSTAR_KEY_STATE_ACTIVE;
    }
    else
    {
        bar_ptr->idc_up_state = MMIIM_TP_CSTAR_KEY_STATE_INACTIVE;
    }

    if (bar_ptr->page_index < bar_ptr->page_cnt - 1)
    {
        bar_ptr->idc_down_state = MMIIM_TP_CSTAR_KEY_STATE_ACTIVE;
    }
    else
    {
        bar_ptr->idc_down_state = MMIIM_TP_CSTAR_KEY_STATE_INACTIVE;
    }   
}

/*****************************************************************************/
//  Description : 当触笔点击在choice bar上的时候显示焦点等
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note:
/*****************************************************************************/
PUBLIC void MMIIMUI_TpDownOnChoiceBar(
    MMIIM_TP_CSTAR_CHOICE_BAR_T *bar_ptr,
    int32 idx,
    BOOLEAN *dirty_flg_ptr
)
{
    if (PNULL == bar_ptr)
    {
        return;
    }
    
    //注意此三个状态本身具有排他性、唯一可选性，决定设置一个时，需要恢复另两个的原来值
    if (CAND_LEFT_ARROW_IDX == idx)
    {
        if (MMIIM_TP_CSTAR_KEY_STATE_ACTIVE == bar_ptr->idc_up_state)
        {
            MMIIMUI_SetNormalStateOnChoiceBar(bar_ptr);

            //reset idc up state
            bar_ptr->idc_up_state = MMIIM_TP_CSTAR_KEY_STATE_PRESS;
            *dirty_flg_ptr = TRUE;
        }
    }
    else if (CAND_RIGHT_ARROW_IDX == idx)
    {
        if (MMIIM_TP_CSTAR_KEY_STATE_ACTIVE == bar_ptr->idc_down_state)
        {
            MMIIMUI_SetNormalStateOnChoiceBar(bar_ptr);

            //reset idc down state        
            bar_ptr->idc_down_state = MMIIM_TP_CSTAR_KEY_STATE_PRESS;
            *dirty_flg_ptr = TRUE;
        }
    }
    else if (0 <= idx
             && bar_ptr->hot_index != idx
             && idx < bar_ptr->choice_line_cnt
             && idx < bar_ptr->cur_page_line_cnt)
    {
        MMIIMUI_SetNormalStateOnChoiceBar(bar_ptr);
        
        //按住了对应区域位置，但有可能那区域就没有内容，也不必高亮
        bar_ptr->hot_index = idx;
        bar_ptr->choice_index = idx;
        
        *dirty_flg_ptr = TRUE;
    }
    
    return;
}

/*****************************************************************************/
//  Description : 触笔down点击候选筐操作，只是准备数据，焦点位置等
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note:
/*****************************************************************************/
PUBLIC void MMIIMUI_SetTpOnCandBarIdx(
    MMIIM_TP_CSTAR_HANDLE_T* handle_ptr,
    GUI_POINT_T tp_point,
    GUIIM_EVENT_DATA_U* event_data_ptr,
    MMIIM_TP_CSTAR_MSG_PARA_TP_T *para_ptr
)
{
    GUI_RECT_T font_rect = {0};
    uint16 iLoop = 0;
    uint16 jLoop = 0;
    uint16 pos = 0;
    GUI_FONT_T font = {0};
    uint16 word_width = 0;
    uint16 label_width = 0;
    GUI_RECT_T text_rect = {0};                         //文本区区域
    uint16 nMMIIM_TP_CSTAR_CAND_UP_LEFT_X = 0;
    uint16 nMMIIM_TP_CSTAR_CAND_IDC_SPACE_X = 0;
    uint8  direction  =  0;
    

    uint8 iCandTips = 0;
    MMIIM_TP_CSTAR_TEXT_BAR_THEME_T* text_bar_theme = MMIIMUI_GetTextBarThemeIfo();
    //SCI_TRACE_LOW:"[MMIIM] TpCandPressDown"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIIM_TP_UI_2705_112_2_18_2_29_22_277,(uint8*)"");

    //SCI_ASSERT(PNULL != handle_ptr); /*assert verified*/
    //SCI_ASSERT(PNULL != handle_ptr->lcd_info_ptr); /*assert verified*/
    //SCI_ASSERT(PNULL != event_data_ptr); /*assert verified*/
    if(PNULL == handle_ptr ||PNULL == handle_ptr->lcd_info_ptr ||PNULL == event_data_ptr)
        return;
  
    if (MMITHEME_IsMainScreenLandscape())
    {
        nMMIIM_TP_CSTAR_CAND_UP_LEFT_X = MMIIM_TP_CSTAR_CAND_UP_LEFT_X_H;
        nMMIIM_TP_CSTAR_CAND_IDC_SPACE_X = MMIIM_TP_CSTAR_CAND_IDC_SPACE_X_H;
    }
    else
    {
        nMMIIM_TP_CSTAR_CAND_UP_LEFT_X = MMIIM_TP_CSTAR_CAND_UP_LEFT_X_V;
        nMMIIM_TP_CSTAR_CAND_IDC_SPACE_X = MMIIM_TP_CSTAR_CAND_IDC_SPACE_X_V;
    }
    direction = MMIIM_TPGetAligntype(handle_ptr->init_param.method_param_ptr->im_set.method);

    text_rect.left = handle_ptr->cand_rect.left + nMMIIM_TP_CSTAR_CAND_IDC_SPACE_X;
    text_rect.right = nMMIIM_TP_CSTAR_CAND_UP_LEFT_X - nMMIIM_TP_CSTAR_CAND_IDC_SPACE_X;
    text_rect.top = handle_ptr->cand_rect.top;
    text_rect.bottom = handle_ptr->cand_rect.bottom;

    para_ptr->idx = -1;

    if (GUI_PointIsInRect(tp_point, text_rect))
    {
        if (MMIIM_TP_CSTAR_STATE_USER == handle_ptr->ui_state)
        {
            if (g_keyboard_state[handle_ptr->stateId].priv_data&MMIIM_TP_CSTAR_PY)
            {
                font = text_bar_theme->font_text;
                font_rect.top = handle_ptr->cand_rect.top;
                font_rect.bottom = handle_ptr->cand_rect.bottom;
                font_rect.left = handle_ptr->cand_rect.left;
                label_width = GUI_GetFontWidth(text_bar_theme->font_label, UNICODE_ASCII) + 2;
                iLoop = 0;

                do
                {
                    iLoop++;
                    jLoop = 0;

                    while (handle_ptr->pUserWordBuffer[pos+ (jLoop++)] != '\0')
                        NULL;

                    word_width = GUI_GetStringWidth(font, &handle_ptr->pUserWordBuffer[pos], jLoop);
                    font_rect.right = font_rect.left + word_width;

                    //找到当前point所在位置后，直接跳出
                    if (GUI_PointIsInRect(tp_point, font_rect))
                    {
                        //找到了当前点击的文本，并记住索引
                        para_ptr->idx = (iLoop - 1);

                        //下面这个操作是为了实现tips的效果，把字符串保存起来
                        for (iCandTips = 0; iCandTips < jLoop && iCandTips < TIPS_CHAR_MAX_NUM; iCandTips++)
                        {
                            handle_ptr->pCandTipsBuffer[iCandTips] = handle_ptr->pUserWordBuffer[pos+iCandTips];
                        }

                        handle_ptr->nCandTips = iCandTips - 1;

                        return;
                    }

                    pos += jLoop;
                    font_rect.left = (int16)(font_rect.right + label_width);
                } while(0);
            }
        }
        else if (handle_ptr->result_len > 0)
        {
            if (g_keyboard_state[handle_ptr->stateId].priv_data&MMIIM_TP_CSTAR_PY)
            {
                font = text_bar_theme->font_text;
                font_rect.top = handle_ptr->cand_rect.top;
                font_rect.bottom = handle_ptr->cand_rect.bottom;
                if(MMIIM_DRAW_RIGHT2LEFT == direction)
                {
                    font_rect.right = text_rect.right - 2;
                }
                font_rect.left = handle_ptr->cand_rect.left;
#ifdef IM_ENGINE_SOGOU
                font_rect.left = handle_ptr->cand_rect.left + MMIIM_TP_CSTAR_CAND_IDC_SPACE_X_H;
#endif
                label_width = GUI_GetFontWidth(text_bar_theme->font_label, UNICODE_ASCII) + 2;
                iLoop = 0;

                while (iLoop++ < handle_ptr->result_len)
                {
                    jLoop = 0;

                    while (handle_ptr->result[pos+ (jLoop++)] != '\0')
                        NULL;

                    word_width = GUI_GetStringWidth(font, &handle_ptr->result[pos], jLoop);
                    if(MMIIM_DRAW_RIGHT2LEFT == direction)
                    {
                        font_rect.left = font_rect.right - word_width;
#ifdef IM_ENGINE_SOGOU
						// 超出文本备选区域范围，直接跳出
						if (font_rect.left < text_rect.left && iLoop > 1)
						{
							break;
						}
#endif
                    }
                    else
                    {
                        font_rect.right = font_rect.left + word_width;
#ifdef IM_ENGINE_SOGOU
						// 超出文本备选区域范围，直接跳出
						if (font_rect.right > text_rect.right && iLoop > 1)
						{
							break;
						}
#endif
                    }

                    //找到当前point所在位置后，直接跳出
                    if (GUI_PointIsInRect(tp_point, font_rect))
                    {
                        //找到了当前点击的文本，并记住索引
                        para_ptr->idx = (iLoop - 1);

                        //下面这个操作是为了实现tips的效果，把字符串保存起来
                        for (iCandTips = 0; iCandTips < jLoop && iCandTips < TIPS_CHAR_MAX_NUM; iCandTips++)
                        {
                            handle_ptr->pCandTipsBuffer[iCandTips] = handle_ptr->result[pos+iCandTips];
                        }

                        handle_ptr->nCandTips = iCandTips - 1;

                        return;
                    }

                    pos += jLoop;
                    if(MMIIM_DRAW_RIGHT2LEFT == direction)
                    {
                        font_rect.right = (int16)(font_rect.left - label_width);
                    }

                    else
                    {
                        font_rect.left = (int16)(font_rect.right + label_width);
                    }
                }
            }
        }
    }

    if (GUI_PointIsInRect(tp_point, handle_ptr->up_rect))
    {
#if defined MMIIM_CORE_USE_CSTAR
        if (!(handle_ptr->pageflag&MMIIM_TP_CSTAR_PAGEFLAG_PREVIOUS))
        {
            return;
        }
#endif
#ifdef IM_ENGINE_SOGOU
		if(WD_GetImeResult()->curPage == 0 && WD_GetImeResult()->imeStatus != WD_STATUS_FOREIGN_SELECTLETTER)//首页
		{
			return;
		}
#endif
        para_ptr->idx = CAND_LEFT_ARROW_IDX;
    }
    else if (GUI_PointIsInRect(tp_point, handle_ptr->down_rect))
    {
#if defined MMIIM_CORE_USE_CSTAR
        if (!(handle_ptr->pageflag&MMIIM_TP_CSTAR_PAGEFLAG_NEXT))
        {
            return;
        }
#endif
#ifdef IM_ENGINE_SOGOU
		if (0 == (WD_GetImeResult()->selecting[MMIMLS9_GetLastDisp()][0] ) && WD_GetImeResult()->imeStatus != WD_STATUS_FOREIGN_SELECTLETTER //lastdisplay = iLoop-1;
			|| (WD_GetImeResult()->imeType < WDI_FOREIGN_BEGIN && WD_GetImeResult()->curPage == MAX_PAGE_FOR_SOGOU - 1)
			|| (WD_GetImeResult()->imeType > WDI_FOREIGN_BEGIN && WD_GetImeResult()->curPage == 19 )
			|| (WD_GetImeResult()->imeType < WDI_FOREIGN_BEGIN && WD_GetImeResult()->imeType > WDI_DIGIT
            && MMIMLS9_GetLastDisp() >= WD_GetImeResult()->selectingCount  
            && WD_GetImeResult()->imeStatus != WD_STATUS_HOTKEY_SYMBOL && WD_GetImeResult()->imeStatus != WD_STATUS_DIGIT_INPUT ) 
			)
		{
			return;
		} 
#endif
        para_ptr->idx = CAND_RIGHT_ARROW_IDX;
    }
    else
    {
        return;
    }
}

/*****************************************************************************/
//  Description : 画候选框
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note:
/*****************************************************************************/
PUBLIC void MMIIMUI_DrawCandBar(
    MMIIM_TP_CSTAR_HANDLE_T* handle_ptr
)
{
    uint16 bar_img_width = 0;
    uint16 bar_img_height = 0;
    uint16 arrow_img_width = 0;
    uint16 arrow_img_height = 0;
    GUI_RECT_T font_rect = {0};
    GUI_RECT_T font_draw_rect = {0};
    GUI_RECT_T font_hot_rect = {0};
    GUI_RECT_T cand_font_rect = {0};
    GUI_FONT_T font = {0};
    uint16 word_width = 0;
    uint16 label_width = 0;
    uint16 str[64] = {0};
    uint16 iLoop = 0;
    uint16 jLoop = 0;
    uint16 offset = 0;
    GUISTR_STYLE_T text_style = {0};
    GUISTR_STATE_T state = GUISTR_STATE_SINGLE_LINE | GUISTR_STATE_ALIGN;
    MMI_STRING_T string = {0};
    uint16 nMMIIM_TP_CSTAR_CAND_UP_LEFT_X = 0;
    uint16 nMMIIM_TP_CSTAR_CAND_DOWN_LEFT_X = 0;
    uint16 nMMIIM_TP_CSTAR_CAND_IDC_TOP_Y = 0;
    uint16 nMMIIM_TP_CSTAR_CAND_IDC_SPACE_X = 0;
    uint8  draw_direction = 0;

    //SCI_TRACE_LOW:"[MMIIM] MMIIMUI_DrawCandBar"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIIM_TP_UI_2935_112_2_18_2_29_22_278,(uint8*)"");

    //SCI_ASSERT(PNULL != handle_ptr); /*assert verified*/
    //SCI_ASSERT(PNULL != handle_ptr->lcd_info_ptr); /*assert verified*/
    //SCI_ASSERT(handle_ptr->stateId < MMIIM_TP_CSTAR_STATE_MAX); /*assert verified*/
    if(PNULL == handle_ptr ||PNULL == handle_ptr->lcd_info_ptr ||handle_ptr->stateId >= MMIIM_TP_CSTAR_STATE_MAX)
        return;

    if (MMITHEME_IsMainScreenLandscape())
    {
        nMMIIM_TP_CSTAR_CAND_UP_LEFT_X = MMIIM_TP_CSTAR_CAND_UP_LEFT_X_H;
        nMMIIM_TP_CSTAR_CAND_DOWN_LEFT_X = MMIIM_TP_CSTAR_CAND_DOWN_LEFT_X_H;
        nMMIIM_TP_CSTAR_CAND_IDC_TOP_Y = MMIIM_TP_CSTAR_CAND_IDC_TOP_Y_H;
        nMMIIM_TP_CSTAR_CAND_IDC_SPACE_X = MMIIM_TP_CSTAR_CAND_IDC_SPACE_X_H;
    }
    else
    {
        nMMIIM_TP_CSTAR_CAND_UP_LEFT_X = MMIIM_TP_CSTAR_CAND_UP_LEFT_X_V;
        nMMIIM_TP_CSTAR_CAND_DOWN_LEFT_X = MMIIM_TP_CSTAR_CAND_DOWN_LEFT_X_V;
        nMMIIM_TP_CSTAR_CAND_IDC_TOP_Y = MMIIM_TP_CSTAR_CAND_IDC_TOP_Y_V;
        nMMIIM_TP_CSTAR_CAND_IDC_SPACE_X = MMIIM_TP_CSTAR_CAND_IDC_SPACE_X_V;
    }    

    //得到候选区的区域
    MMIIMUI_GetImageWidthHeight(handle_ptr->init_param.win_id, s_text_bar_theme.img_bg, &bar_img_width, &bar_img_height);
    MMIIMUI_GetImageWidthHeight(handle_ptr->init_param.win_id, s_text_bar_theme.img_idc_left[MMIIM_TP_CSTAR_IDC_INACTIVE], &arrow_img_width, &arrow_img_height);

    handle_ptr->cand_rect.bottom = g_keyboard_state[handle_ptr->stateId].rect.top - 1;
    handle_ptr->cand_rect.top = (int16)(handle_ptr->cand_rect.bottom - bar_img_height + 1);
    handle_ptr->cand_rect.left = g_keyboard_state[handle_ptr->stateId].rect.left;
    handle_ptr->cand_rect.right = g_keyboard_state[handle_ptr->stateId].rect.right;
    MMITHEME_DisplayCommonBg(&handle_ptr->cand_rect,handle_ptr->init_param.win_handle,handle_ptr->lcd_info_ptr);

    //画候选区背景
    cand_font_rect.left = handle_ptr->cand_rect.left;
    cand_font_rect.right = nMMIIM_TP_CSTAR_CAND_UP_LEFT_X - nMMIIM_TP_CSTAR_CAND_IDC_SPACE_X;    
    cand_font_rect.top = handle_ptr->cand_rect.top;
    cand_font_rect.bottom = handle_ptr->cand_rect.bottom;
    GUIRES_DisplayImg(PNULL, &cand_font_rect, PNULL, handle_ptr->init_param.win_handle, s_text_bar_theme.img_bg, handle_ptr->lcd_info_ptr);

    draw_direction = MMIIM_TPGetAligntype(handle_ptr->init_param.method_param_ptr->im_set.method);
    if (MMIIM_TP_CSTAR_STATE_USER == handle_ptr->ui_state)
    {
        /*写自造词*/
        font = s_text_bar_theme.font_text;
        label_width = GUI_GetFontWidth(s_text_bar_theme.font_label, UNICODE_ASCII) + 2;
        
        font_rect.top = handle_ptr->cand_rect.top;
        font_rect.bottom = handle_ptr->cand_rect.bottom;
        font_rect.left = cand_font_rect.left + nMMIIM_TP_CSTAR_CAND_IDC_SPACE_X;
        iLoop = handle_ptr->nUserWord;

        iLoop = 0;

        //while (iLoop++ < handle_ptr->nUserWord)
        do
        {
            iLoop++;
            jLoop = 0;

            while (handle_ptr->pUserWordBuffer[offset] != '\0')
            {
                str[jLoop++] = handle_ptr->pUserWordBuffer[offset++];
            }

            offset++;
            string.wstr_len = jLoop;
            string.wstr_ptr = str;
            word_width = GUI_GetStringWidth(font, string.wstr_ptr, string.wstr_len);
            text_style.font_color = s_text_bar_theme.color_text;
            text_style.font = font;
            text_style.align = ALIGN_HVMIDDLE;

            font_draw_rect = font_rect;
            if (font_rect.left + word_width > cand_font_rect.right)
            {
                //修正显示区域，如果画出的字符超过可显示的区域，则要修正显示的字符串
                font_draw_rect.left -= (font_rect.left + word_width + 1 - cand_font_rect.right);
                
                font_rect.right = cand_font_rect.right - 2;
                font_draw_rect.right = font_rect.right;
            }
            else
            {
                font_rect.right = font_rect.left + word_width;
                font_draw_rect.right = font_rect.right;
            }

            //draw hot
            if (MMIIM_TP_CSTAR_MSG_TP_CAND == handle_ptr->tp_last_msg_param.area &&
                    handle_ptr->tp_last_msg_param.idx == iLoop - 1 &&
                    -1 != handle_ptr->tp_last_msg_param.idx)
            {
                font_hot_rect.top = font_draw_rect.top + 3; //由于有阴影效果，所以上下各减去3px
                font_hot_rect.bottom = font_draw_rect.bottom - 3;
                font_hot_rect.left = font_rect.left;
                font_hot_rect.right = font_draw_rect.right;

                GUI_FillRect(handle_ptr->lcd_info_ptr, font_hot_rect, s_text_bar_theme.color_hot);
            }

            GUISTR_DrawTextToLCDInRect(handle_ptr->lcd_info_ptr,
                                       &font_draw_rect,
                                       &font_rect,
                                       &string,
                                       &text_style,
                                       state,
                                       GUISTR_TEXT_DIR_AUTO
                                      );
            font_rect.left = (int16)(font_rect.right + label_width);
        }
        while (0);
    }    
    else if (handle_ptr->result_len > 0)
    {
        /*写候选字*/
        font = s_text_bar_theme.font_text;
        label_width = GUI_GetFontWidth(s_text_bar_theme.font_label, UNICODE_ASCII) + 2;
        
        font_rect.top = handle_ptr->cand_rect.top;
        font_rect.bottom = handle_ptr->cand_rect.bottom;
        if(MMIIM_DRAW_RIGHT2LEFT == draw_direction)
        {
            font_rect.right = cand_font_rect.right - nMMIIM_TP_CSTAR_CAND_IDC_SPACE_X;
        }
        else
        {
            font_rect.left = cand_font_rect.left + nMMIIM_TP_CSTAR_CAND_IDC_SPACE_X;
        }
        iLoop = handle_ptr->result_len;

        iLoop = 0;

        while (iLoop++ < handle_ptr->result_len)
        {
            jLoop = 0;

            while (handle_ptr->result[offset] != '\0')
            {
                str[jLoop++] = handle_ptr->result[offset++];
            }

            offset++;
            string.wstr_len = jLoop;
            string.wstr_ptr = str;
            if(*string.wstr_ptr == ' ')     //空格字符宽度
                word_width = 8;
            else
            word_width = GUI_GetStringWidth(font, string.wstr_ptr, string.wstr_len);
            text_style.font_color = s_text_bar_theme.color_text;
            text_style.font = font;
            text_style.align = ALIGN_HVMIDDLE;

            font_draw_rect = font_rect;
            if(MMIIM_DRAW_RIGHT2LEFT == draw_direction)
            {
                font_rect.left = font_rect.right - word_width;
                if (font_rect.left < 0)
                {
                    //修正显示区域，如果画出的字符超过可显示的区域，则要修正显示的字符串
                    font_draw_rect.right = word_width;
                    
                    font_rect.left = cand_font_rect.left + 2;
                    font_draw_rect.left = font_rect.left;
#ifdef IM_ENGINE_SOGOU
                    if (iLoop > 1)
                    {
                break;
                    }
#endif
                }
                else
                {
                    font_draw_rect.left = font_rect.left;
                }
            }

            else
            {
                if (font_rect.left + word_width > cand_font_rect.right)
                {
                    //修正显示区域，如果画出的字符超过可显示的区域，则要修正显示的字符串
                    font_draw_rect.left -= (font_rect.left + word_width + 1 - cand_font_rect.right);
                    
                    font_rect.right = cand_font_rect.right - 2;
                    font_draw_rect.right = font_rect.right;
#ifdef IM_ENGINE_SOGOU
                    if (iLoop > 1)
                    {
                break;
                    }
#endif
                }
                else
                {
                    font_rect.right = font_rect.left + word_width;
                    font_draw_rect.right = font_rect.right;
                }
            }
            //draw hot
            if (MMIIM_TP_CSTAR_MSG_TP_CAND == handle_ptr->tp_last_msg_param.area &&
                    handle_ptr->tp_last_msg_param.idx == iLoop - 1 &&
                    -1 != handle_ptr->tp_last_msg_param.idx)
            {
                font_hot_rect.top = font_draw_rect.top + 3; //由于有阴影效果，所以上下各减去3px
                font_hot_rect.bottom = font_draw_rect.bottom - 3;
                font_hot_rect.left = font_rect.left;
                font_hot_rect.right = font_draw_rect.right;

#ifdef IM_ENGINE_SOGOU
				if (font_hot_rect.right > font_hot_rect.left)
#endif
                GUI_FillRect(handle_ptr->lcd_info_ptr, font_hot_rect, s_text_bar_theme.color_hot);
            }

            if(*string.wstr_ptr == ' ')    //空格字符
            {
                MMIIM_DrawSpace(handle_ptr->lcd_info_ptr, &font_rect, text_style.font_color);
            }
            else
            {
            GUISTR_DrawTextToLCDInRect(handle_ptr->lcd_info_ptr,
                                       &font_draw_rect,
                                       &font_rect,
                                       &string,
                                       &text_style,
                                       state,
                                       GUISTR_TEXT_DIR_AUTO
                                      );
            }
            if(MMIIM_DRAW_RIGHT2LEFT == draw_direction)
            {
                font_rect.right= (int16)(font_rect.left - label_width);
            }
            else
            {
                font_rect.left = (int16)(font_rect.right + label_width);
            }
        }
    }
    
#ifdef IM_ENGINE_SOGOU
    MMIMLS9_SetLastDisp(iLoop-1);
#endif
    //画向上下翻页按钮
    handle_ptr->up_rect.left = nMMIIM_TP_CSTAR_CAND_UP_LEFT_X;
    handle_ptr->up_rect.right = handle_ptr->up_rect.left + (arrow_img_width);
    handle_ptr->up_rect.top = handle_ptr->cand_rect.top + nMMIIM_TP_CSTAR_CAND_IDC_TOP_Y;
    handle_ptr->up_rect.bottom = handle_ptr->up_rect.top + (arrow_img_height);

    handle_ptr->down_rect.left = nMMIIM_TP_CSTAR_CAND_DOWN_LEFT_X;
    handle_ptr->down_rect.right = handle_ptr->down_rect.left + (arrow_img_width);
    handle_ptr->down_rect.top = handle_ptr->cand_rect.top + nMMIIM_TP_CSTAR_CAND_IDC_TOP_Y;
    handle_ptr->down_rect.bottom = handle_ptr->down_rect.top + (arrow_img_height);    

    if (handle_ptr->result_len == 0)
    {
        handle_ptr->pageflag = 0;
    }

#ifdef IM_ENGINE_SOGOU
    if (WD_GetImeResult()->curPage == 0)
    {
        GUIRES_DisplayImg(PNULL, &handle_ptr->up_rect, PNULL, handle_ptr->init_param.win_handle, s_text_bar_theme.img_idc_left[MMIIM_TP_CSTAR_IDC_INACTIVE],
            handle_ptr->lcd_info_ptr);
    }
    else
    {
        if (MMIIM_TP_CSTAR_MSG_TP_CAND == handle_ptr->tp_last_msg_param.area &&
            CAND_LEFT_ARROW_IDX == handle_ptr->tp_last_msg_param.idx)
        {
            GUIRES_DisplayImg(PNULL, &handle_ptr->up_rect, PNULL, handle_ptr->init_param.win_handle, s_text_bar_theme.img_idc_left[MMIIM_TP_CSTAR_IDC_PRESSED],
                handle_ptr->lcd_info_ptr);
        }
        else
        {
            GUIRES_DisplayImg(PNULL, &handle_ptr->up_rect, PNULL, handle_ptr->init_param.win_handle, s_text_bar_theme.img_idc_left[MMIIM_TP_CSTAR_IDC_ACTIVE],
                handle_ptr->lcd_info_ptr);
        }
    }

    if (0 == (WD_GetImeResult()->selecting[MMIMLS9_GetLastDisp()][0] )
        || (WD_GetImeResult()->imeType < WDI_FOREIGN_BEGIN && WD_GetImeResult()->curPage == MAX_PAGE_FOR_SOGOU - 1)
        || (WD_GetImeResult()->imeType > WDI_FOREIGN_BEGIN && WD_GetImeResult()->curPage == 19 )
        || (WD_GetImeResult()->imeType < WDI_FOREIGN_BEGIN && WD_GetImeResult()->imeType > WDI_DIGIT
            && MMIMLS9_GetLastDisp() >= WD_GetImeResult()->selectingCount  
            && WD_GetImeResult()->imeStatus != WD_STATUS_HOTKEY_SYMBOL && WD_GetImeResult()->imeStatus != WD_STATUS_DIGIT_INPUT ) 
        )
    {
        GUIRES_DisplayImg(PNULL, &handle_ptr->down_rect, PNULL, handle_ptr->init_param.win_handle, s_text_bar_theme.img_idc_right[MMIIM_TP_CSTAR_IDC_INACTIVE],
            handle_ptr->lcd_info_ptr);
    } 
    else
    {
        if (MMIIM_TP_CSTAR_MSG_TP_CAND == handle_ptr->tp_last_msg_param.area &&
            CAND_RIGHT_ARROW_IDX == handle_ptr->tp_last_msg_param.idx)
        {
            GUIRES_DisplayImg(PNULL, &handle_ptr->down_rect, PNULL, handle_ptr->init_param.win_handle, s_text_bar_theme.img_idc_right[MMIIM_TP_CSTAR_IDC_PRESSED],
                handle_ptr->lcd_info_ptr);
        }
        else
        {
            GUIRES_DisplayImg(PNULL, &handle_ptr->down_rect, PNULL, handle_ptr->init_param.win_handle, s_text_bar_theme.img_idc_right[MMIIM_TP_CSTAR_IDC_ACTIVE],
                handle_ptr->lcd_info_ptr);
        }
    }
#else
#if defined MMIIM_CORE_USE_CSTAR
    if (handle_ptr->pageflag & MMIIM_TP_CSTAR_PAGEFLAG_PREVIOUS)
    {
        if (MMIIM_TP_CSTAR_MSG_TP_CAND == handle_ptr->tp_last_msg_param.area &&
                CAND_LEFT_ARROW_IDX == handle_ptr->tp_last_msg_param.idx)
        {
            GUIRES_DisplayImg(PNULL, &handle_ptr->up_rect, PNULL, handle_ptr->init_param.win_handle, s_text_bar_theme.img_idc_left[MMIIM_TP_CSTAR_IDC_PRESSED],
                              handle_ptr->lcd_info_ptr);
        }
        else
        {
            GUIRES_DisplayImg(PNULL, &handle_ptr->up_rect, PNULL, handle_ptr->init_param.win_handle, s_text_bar_theme.img_idc_left[MMIIM_TP_CSTAR_IDC_ACTIVE],
                              handle_ptr->lcd_info_ptr);
        }
    }
    else
    {
        GUIRES_DisplayImg(PNULL, &handle_ptr->up_rect, PNULL, handle_ptr->init_param.win_handle, s_text_bar_theme.img_idc_left[MMIIM_TP_CSTAR_IDC_INACTIVE],
                          handle_ptr->lcd_info_ptr);
    }

    if (handle_ptr->pageflag & MMIIM_TP_CSTAR_PAGEFLAG_NEXT)
    {
        if (MMIIM_TP_CSTAR_MSG_TP_CAND == handle_ptr->tp_last_msg_param.area &&
                CAND_RIGHT_ARROW_IDX == handle_ptr->tp_last_msg_param.idx)
        {
            GUIRES_DisplayImg(PNULL, &handle_ptr->down_rect, PNULL, handle_ptr->init_param.win_handle, s_text_bar_theme.img_idc_right[MMIIM_TP_CSTAR_IDC_PRESSED],
                              handle_ptr->lcd_info_ptr);
        }
        else
        {
            GUIRES_DisplayImg(PNULL, &handle_ptr->down_rect, PNULL, handle_ptr->init_param.win_handle, s_text_bar_theme.img_idc_right[MMIIM_TP_CSTAR_IDC_ACTIVE],
                              handle_ptr->lcd_info_ptr);
        }
    }
    else
    {
        GUIRES_DisplayImg(PNULL, &handle_ptr->down_rect, PNULL, handle_ptr->init_param.win_handle, s_text_bar_theme.img_idc_right[MMIIM_TP_CSTAR_IDC_INACTIVE],
                          handle_ptr->lcd_info_ptr);
    }
#endif
#endif    
}


/*****************************************************************************/
//  Description : 有按键按下，或者移动弹起时重绘键盘
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note:
/*****************************************************************************/
PUBLIC void MMIIMUI_ReDrawAllBoard(MMIIM_TP_CSTAR_HANDLE_T *data_ptr)
{
    GUI_RECT_T focus_rect = {0};
    MMIIM_TP_CSTAR_STATE_T state = {0};
    int char_cnt = 0;
    uint32 char_id = 0;
    uint16 bar_img_width = 0;
    uint16 bar_img_height = 0;

    //tips相关
    MMI_STRING_T string = {0};
    wchar tips_text[2 * MMIIM_SP_26KEY_CHAR_MAX + 1];
    uint16 tips_length = 0;
    GUI_POINT_T pt_top = {0};

    //SCI_ASSERT(PNULL != data_ptr); /*assert verified*/

    if (PNULL == data_ptr || MMIIMUI_ChangeRect(data_ptr))
    {
        return;
    }

    switch (data_ptr->ui_state)
    {
    case MMIIM_TP_CSTAR_STATE_INPUTING:
    case MMIIM_TP_CSTAR_STATE_USER:
        {
        #ifdef INPUT_METHOD_CSTAR_COMMON_MINI
            if(GUIIM_M_TP_PINYIN != data_ptr->init_param.method_param_ptr->im_set.method)
        #endif
            {
                if (data_ptr->is_bar_edit_dirty &&
                        g_keyboard_state[data_ptr->stateId].priv_data&MMIIM_TP_CSTAR_ED)
                {
                    MMIIMUI_DrawEditBar(data_ptr);
                }
            }
                
            if (data_ptr->is_bar_choice_dirty &&
                    g_keyboard_state[data_ptr->stateId].priv_data&MMIIM_TP_CSTAR_ED)
            {
                MMIIMUI_DrawChoiceBar(&data_ptr->choice_bar);
            }
        }

        //lint -fallthrough
    case MMIIM_TP_CSTAR_STATE_ASSOCIATE:
        {
            if (data_ptr->is_bar_cand_dirty &&
                    g_keyboard_state[data_ptr->stateId].priv_data&MMIIM_TP_CSTAR_CAND)
            {
                MMIIMUI_DrawCandBar(data_ptr);

                //画出candbar的tips效果
                if (0 <= data_ptr->tp_last_msg_param.idx
                        && CAND_LEFT_ARROW_IDX != data_ptr->tp_last_msg_param.idx
                        && CAND_RIGHT_ARROW_IDX != data_ptr->tp_last_msg_param.idx
                        && data_ptr->nCandTips > 0)
                {
                    string.wstr_ptr = data_ptr->pCandTipsBuffer;
                    string.wstr_len = data_ptr->nCandTips;

                    //要取统一的起点高度
                    MMIIMUI_GetImageWidthHeight(data_ptr->init_param.win_id, s_text_bar_theme.img_bg, &bar_img_width, &bar_img_height);
                    pt_top.y = g_keyboard_state[data_ptr->stateId].rect.top - bar_img_height;
                    pt_top.x = data_ptr->tp_last_msg_param.point.x;
                    DrawKeyTips(data_ptr, string, pt_top);
                }
            }
        }

        //lint -fallthrough
    case MMIIM_TP_CSTAR_STATE_NOINPUT:
        {
            if (data_ptr->is_kb_dirty)
            {
                //注意我们是要从下往上画
                MMIIMUI_DrawKeyBoard(data_ptr);
                
                //画重复的图标
                MMIIMUI_DrawReplaceKey(data_ptr);
                
                //如果是9键，则需要画出混淆区
                if (!data_ptr->is_full_keypad && !MMIIMUI_IsCommonKeyBoardState(data_ptr))
                    MMIIMUI_DrawChoiceBar(&data_ptr->choice_bar);
                
                
                //画被按下的键
                if (0 <= data_ptr->tp_last_msg_param.idx)
                {
                    const MMIIM_TP_CSTAR_REPLACE_KEY_T *replace_key_ptr = PNULL;
                        
                    focus_rect = data_ptr->tp_last_msg_param.rect;
                    state = g_keyboard_state[data_ptr->stateId];

                    data_ptr->press_img_rect.left = (int16)(focus_rect.left + state.img_rect.left);
                    data_ptr->press_img_rect.top = (int16)(focus_rect.top + state.img_rect.top);
                    data_ptr->press_img_rect.right = (int16)(data_ptr->press_img_rect.left + focus_rect.right - focus_rect.left);
                    data_ptr->press_img_rect.bottom = (int16)(data_ptr->press_img_rect.top + focus_rect.bottom - focus_rect.top);

                    data_ptr->press_rect.left = (int16)(focus_rect.left + state.rect.left);
                    data_ptr->press_rect.top = (int16)(focus_rect.top + state.rect.top);
                    data_ptr->press_rect.right = (int16)(data_ptr->press_rect.left + focus_rect.right - focus_rect.left);
                    data_ptr->press_rect.bottom = (int16)(data_ptr->press_rect.top + focus_rect.bottom - focus_rect.top);

// #if 1   //def MMIIM_VIRTUAL_KB_TEXT_SUPPORT     //强制打开，部分程序宏未完全控制，不打开，将导致虚拟键盘背景图为空白
{           
            //替换键显示
            if (GetReplaceKeyImgID(data_ptr, data_ptr->tp_last_msg_param.h_idx, data_ptr->tp_last_msg_param.v_idx, &replace_key_ptr, MMIIM_TP_CSTAR_KEY_STATE_PRESS))
            {
                if (PNULL != replace_key_ptr && 0 != replace_key_ptr->img[MMIIM_TP_CSTAR_KEY_STATE_PRESS])
                {
                    DrawReplaceKeyInRect(data_ptr, *replace_key_ptr, data_ptr->press_rect, MMIIM_TP_CSTAR_KEY_STATE_PRESS);
                }
            }
            else    
            {
                int32 ret_value = 0;

                //全键盘状态
                if(data_ptr->is_full_keypad)    
                {
                    ret_value = MMIIMUI_DrawVituralButtonWithText(data_ptr, TRUE);  //字符按键，直接写字符
                    if(ret_value < 0)   //非字符按键，则需要使用高亮图片
                    {
                                    GUIRES_DisplayImg(PNULL, &data_ptr->press_rect, &data_ptr->press_img_rect,
                                                      data_ptr->init_param.win_handle, state.press_image_id, data_ptr->lcd_info_ptr);
                    }
                }
                else 
                {
                    if(MMIIMUI_IsCommonKeyBoardState(data_ptr))     //非9键or26键，如笔画输入等
                    {
                        ret_value = MMIIMUI_DrawVituralButtonWithText(data_ptr, TRUE);  //字符按键，直接写字符
                        if(ret_value < 0)   //非字符按键，则需要使用高亮图片
                        {
                            GUIRES_DisplayImg(PNULL, &data_ptr->press_rect, &data_ptr->press_img_rect, 
                                data_ptr->init_param.win_handle, state.press_image_id, data_ptr->lcd_info_ptr);
                        }
                    }
                    else if(!GUI_PointIsInRect(data_ptr->tp_last_msg_param.point, data_ptr->choice_bar.rect)
                        && !GUI_PointIsInRect(data_ptr->tp_last_msg_param.point, data_ptr->cand_rect)
                        && !GUI_PointIsInRect(data_ptr->tp_last_msg_param.point, data_ptr->edit_rect))    //9键非choice区域
                    {
                        ret_value = MMIIMUI_DrawVituralButtonWithText(data_ptr, TRUE);  //字符按键，直接写字符
                        if(ret_value < 0)   //非字符按键，则需要使用高亮图片
                        {
                            GUIRES_DisplayImg(PNULL, &data_ptr->press_rect, &data_ptr->press_img_rect, 
                                data_ptr->init_param.win_handle, state.press_image_id, data_ptr->lcd_info_ptr);
                        }
                    }   
                    else //9键choice区域
                    {
                        ;
                    }
                }
            }
}
// #else
//                    if (GetReplaceKeyImgID(data_ptr, data_ptr->tp_last_msg_param.h_idx, data_ptr->tp_last_msg_param.v_idx, &replace_key_ptr, MMIIM_TP_CSTAR_KEY_STATE_PRESS))
//                    {
//                        if (PNULL != replace_key_ptr && 0 != replace_key_ptr->img[MMIIM_TP_CSTAR_KEY_STATE_PRESS])
//                        {
//                            DrawReplaceKeyInRect(data_ptr, *replace_key_ptr, data_ptr->press_rect, MMIIM_TP_CSTAR_KEY_STATE_PRESS);
//
//                            /*
//                            GUIRES_DisplayImg(PNULL, &data_ptr->press_rect, PNULL, data_ptr->init_param.win_handle,
//                                              replace_img_id, data_ptr->lcd_info_ptr);
//                                              */
//                        }
//                    }
//                    else
//                    {
//                        GUIRES_DisplayImg(PNULL, &data_ptr->press_rect, &data_ptr->press_img_rect,
//                                          data_ptr->init_param.win_handle, state.press_image_id, data_ptr->lcd_info_ptr);
//                    }
// #endif
                    //画tips
                    //超过可显示字符总数，则不必显示
                    char_id = g_keyboard_state[data_ptr->stateId].functab[data_ptr->tp_last_msg_param.idx].id;

                    if (IsDisplayTips(data_ptr) && MMIIM_TP_CSTAR_MSG_TP_KB == data_ptr->tp_last_msg_param.area)
                    {
                        char_cnt = g_keyboard_state[data_ptr->stateId].char_tab[data_ptr->tp_last_msg_param.idx][0];

                        if (0 < char_cnt)
                        {
//#if 1   //def MMIIM_VIRTUAL_KB_TEXT_SUPPORT     //强制打开，部分程序宏未完全控制，不打开，将导致虚拟键盘背景图为空白
                            SCI_MEMSET(tips_text, 0, sizeof(tips_text));
		            MMIIM_GetTipsText(data_ptr, data_ptr->tp_last_msg_param.idx, (wchar   *)tips_text, &tips_length);
		            string.wstr_ptr = tips_text;
		            string.wstr_len = tips_length;
//#else
//                            string.wstr_ptr = str;
//                            string.wstr_len = 0;
//                            SetDisplayTipsChar(data_ptr, char_id, &string);
//#endif							

                            if (0 < string.wstr_len)
                            {
                                pt_top.x = data_ptr->press_rect.left;
                                pt_top.y = data_ptr->press_rect.top;
                                DrawKeyTips(data_ptr, string, pt_top);
                            }
                        }
                    }
                }
            }
        }
        break;

    default:
        break;
    }

    data_ptr->is_kb_dirty = FALSE;
    data_ptr->is_bar_cand_dirty = FALSE;
    data_ptr->is_bar_edit_dirty = FALSE;
    data_ptr->is_bar_choice_dirty = FALSE;

    return;
}

/*****************************************************************************/
//  Description : 设置需要提示的tips按键内容
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note:
/*****************************************************************************/
LOCAL void SetDisplayTipsChar(
    MMIIM_TP_CSTAR_HANDLE_T *data_ptr, 
    uint32 char_idx, 
    MMI_STRING_T *string_ptr
)
{
    wchar ch = 0;
    
    if (PNULL == data_ptr)
    {
        return;
    }
    
    if (g_keyboard_state[data_ptr->stateId].char_tab[char_idx][0] < 1)
    {
        return;
    }

    ch = g_keyboard_state[data_ptr->stateId].char_tab[char_idx][1];

    //下面这些逻辑是用来修改提示的内容

    //1：只针对a~z的范围内的字符进行有选择性的修改
    if (0x61 <= ch && 0x7a >= ch)
    {
        GUIIM_CAPITAL_MODE_T capital = GUIIM_MODE_MAX;
        
        if (PNULL == data_ptr->init_param.method_param_ptr
            || PNULL == data_ptr->init_param.method_param_ptr->im_def_ptr)
        {
            return;
        }
        
        capital = data_ptr->init_param.method_param_ptr->im_def_ptr->capital;
        
        //如果当前是大写模式，则不管是smart还是multitap都必须修改
        if (GUIIM_MODE_UPPER == capital)
        {
            ch = ch - 32;
        }
        else if (GUIIM_MODE_LEAD_UPPER == capital 
            && GUIIM_TYPE_SMART != data_ptr->init_param.method_param_ptr->im_def_ptr->type)
        {            
            //如果当前是首字符大写模式，则需要分成smart和multitap，
            //因为智能的键盘是小写，multitap的键盘是大写
            ch = ch - 32;
        }
    }
    
    string_ptr->wstr_ptr[0] = ch;
    string_ptr->wstr_len = 1;
}

/*****************************************************************************/
//  Description : 输入法区域发生变成
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note:
/*****************************************************************************/
PUBLIC BOOLEAN MMIIMUI_ChangeRect(MMIIM_TP_CSTAR_HANDLE_T *data_ptr)
{
    GUIIM_NOTIFY_PACK_T notify_pack = {0};

    if (PNULL == data_ptr)
    {
        //SCI_TRACE_LOW:"[MMIIM] MMIIMUI_ChangeRect: data_ptr is null."
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIIM_TP_UI_3579_112_2_18_2_29_23_279,(uint8*)"");
        return FALSE;
    }

    if (data_ptr->is_rect_change)
    {
        notify_pack.notify = GUIIM_NOTIFY_CHANGE_RECT;
        GUIIM_SetNotify(data_ptr->init_param.im_handle, &notify_pack);
    }

    return data_ptr->is_rect_change;
}

/*****************************************************************************/
//  Description : get text bar theme info
//  Global resource dependence : none
//  Author: jian.ma
//  Note:
/*****************************************************************************/
PUBLIC MMIIM_TP_CSTAR_TEXT_BAR_THEME_T* MMIIMUI_GetTextBarThemeIfo(void)
{
    return &s_text_bar_theme;
}

/*****************************************************************************/
//  Description : 画混淆区
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note:
/*****************************************************************************/
PUBLIC int MMIIMUI_DrawChoiceBar(MMIIM_TP_CSTAR_CHOICE_BAR_T *choice_bar_ptr)
{
    /*[这里只传入choice bar的指针，力争从UI应用句柄中脱离，方便之后的显示脱离]*/

    BOOLEAN is_ret = FALSE;
    GUI_RECT_T bar_img_rect = {0};
    uint16 choice_index = 0;        //在总行数中的第几行
    MMI_STRING_T text_info = {0};
    GUISTR_STYLE_T text_style = {0};
    wchar buffer[MMIIM_MAX_PYCHOICE_CHAR_NUM] = {0};
    uint16 i = 0;
    uint16 j = 0;

    if (PNULL == choice_bar_ptr)
    {
        return 1;
    }

    if (PNULL == choice_bar_ptr->lcd_info_ptr)
    {
        return 1;
    }

    if (0 == choice_bar_ptr->total_choice_cnt)
    {
        return 0;
    }

    bar_img_rect.top = 0;
    bar_img_rect.left = 0;
    bar_img_rect.right = choice_bar_ptr->rect.right - choice_bar_ptr->rect.left;
    bar_img_rect.bottom = choice_bar_ptr->rect.bottom - choice_bar_ptr->rect.top;

    // 1 draw bg
    is_ret = GUIRES_DisplayImg(PNULL, &choice_bar_ptr->rect, &bar_img_rect, choice_bar_ptr->win_id,
                               choice_bar_ptr->bg_img[MMIIM_TP_CSTAR_KEY_STATE_ACTIVE], choice_bar_ptr->lcd_info_ptr);

    if (!is_ret)
    {
        return 1;
    }

    // 2 draw arrow up and down
    if (MMIIM_TP_CSTAR_KEY_STATE_NONE < choice_bar_ptr->idc_up_state
            && MMIIM_TP_CSTAR_KEY_STATE_MAX > choice_bar_ptr->idc_up_state)
    {

        is_ret = GUIRES_DisplayImg(PNULL, &choice_bar_ptr->idc_up_rect, PNULL, choice_bar_ptr->win_id,
                                   choice_bar_ptr->idc_up_img[choice_bar_ptr->idc_up_state], choice_bar_ptr->lcd_info_ptr);

        if (!is_ret)
        {
            return 1;
        }
    }

    if (MMIIM_TP_CSTAR_KEY_STATE_NONE < choice_bar_ptr->idc_down_state
            && MMIIM_TP_CSTAR_KEY_STATE_MAX > choice_bar_ptr->idc_down_state)
    {
        is_ret = GUIRES_DisplayImg(PNULL, &choice_bar_ptr->idc_down_rect, PNULL, choice_bar_ptr->win_id,
                                   choice_bar_ptr->idc_down_img[choice_bar_ptr->idc_down_state], choice_bar_ptr->lcd_info_ptr);

        if (!is_ret)
        {
            return 1;
        }
    }

    // 3 draw choice content
    if (0 == choice_bar_ptr->total_choice_cnt
            || 0 == choice_bar_ptr->page_cnt
            || 0 == choice_bar_ptr->cur_page_line_cnt)
    {
        return 1;
    }

    //求出当前页的第一项在总的顺序中的位置
    choice_index = choice_bar_ptr->choice_line_cnt * choice_bar_ptr->page_index;
    text_style.font = MMIIM_TP_CSTAR_CHOICE_BAR_FONT_TEXT;
    text_style.font_color = MMIIM_TP_CSTAR_CHOICE_BAR_COLOR_TEXT;
    text_style.align = ALIGN_HVMIDDLE;

    for (i = 0; i < choice_bar_ptr->choice_line_cnt && i < MMIIM_CHOICE_STR_MAX_SHOW_NUM; i++)
    {
        // text
        j = 0;

        while ('\0' != choice_bar_ptr->pChoiceBuffer[choice_index+i][j])
        {
            buffer[j] = choice_bar_ptr->pChoiceBuffer[choice_index+i][j];
            j++;
        }

        text_info.wstr_ptr = buffer;
        text_info.wstr_len = j;

        //draw hot bg
        if (choice_bar_ptr->has_hot && choice_bar_ptr->hot_index == i)
        {
            GUI_FillRect(choice_bar_ptr->lcd_info_ptr, choice_bar_ptr->choice_str_rect[i], MMIIM_TP_CSTAR_CHOICE_BAR_COLOR_HOT);
        }

        //draw text
        GUISTR_DrawTextToLCDInRect(choice_bar_ptr->lcd_info_ptr,
                                   &choice_bar_ptr->choice_str_rect[i],
                                   &choice_bar_ptr->choice_str_rect[i],
                                   &text_info,
                                   &text_style,
                                   GUISTR_STATE_ALIGN | GUISTR_STATE_SINGLE_LINE | GUISTR_STATE_ELLIPSIS,
                                   GUISTR_TEXT_DIR_AUTO
                                  );
    }

    return 0;
}

/*****************************************************************************/
//  Description : 是否是普通键盘状态
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note: 键盘状态可以理解成9键，26键，无所谓9键26键三种状态这里就称为普通状态
/*****************************************************************************/
PUBLIC BOOLEAN MMIIMUI_IsCommonKeyBoardState(
    MMIIM_TP_CSTAR_HANDLE_T* handle_ptr
)
{
    /*这里多说两句，我们在做TP时，会发现，有些是9键标准，有些是26键，
    像这些键盘通常就会有9，26切换图标，还有一些键盘根本就无所谓9键，还是26键的
    因此就把这些键盘状态列出如下*/

    MMIIM_TP_CSTAR_STATE_ID_T ab_stateId = MMIIM_TP_CSTAR_KB_START_ID;

    if (PNULL == handle_ptr)
    {
        //SCI_TRACE_LOW:"[MMIIM] MMIIMUI_IsCommonKeyBoardState: handle_ptr is null."
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIIM_TP_UI_3737_112_2_18_2_29_24_280,(uint8*)"");
        return FALSE;
    }
    
    ab_stateId = handle_ptr->stateId + MMIIM_TP_CSTAR_KB_START_ID;

    if (MMIIM_TP_CSTAR_STATE_DIG == ab_stateId
            || MMIIM_TP_CSTAR_STATE_DIGSYM == ab_stateId
#if defined (IM_SIMP_CHINESE_SUPPORT)
            || MMIIM_TP_CSTAR_STATE_STROKE == ab_stateId
#endif
#if defined (IM_TRAD_CHINESE_SUPPORT)
            || MMIIM_TP_CSTAR_STATE_TRAD_STROKE == ab_stateId
#endif
       )
    {
        return TRUE;
    }

    return FALSE;
}



/******************************************************************************/
// Description:
// Global resource dependence: NONE
// Author: haiwu.chen
// Note:由func中配置的state决定是否显示tips
/******************************************************************************/
LOCAL BOOLEAN IsDisplayTips(
    MMIIM_TP_CSTAR_HANDLE_T* handle_ptr
)
{
    int func_id = 0;

    if (PNULL == handle_ptr)
    {
        //SCI_TRACE_LOW:"[MMIIM] IsDisplayTips: handle_ptr is null."
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIIM_TP_UI_3773_112_2_18_2_29_24_281,(uint8*)"");
        return FALSE;
    }

    func_id = handle_ptr->tp_last_msg_param.idx;
    if (-1 >= func_id)
    {
        return FALSE;
    }

    if (func_id >= MMIIM_TP_CSTAR_SPECIAL_START_ID)
    {
        return FALSE;
    }
    
    if (MMIIM_TP_CSTAR_FUNC_TIPS == g_keyboard_state[handle_ptr->stateId].functab[func_id].state)
    {
        return TRUE;
    }

    return FALSE;
}

/*****************************************************************************/
//  Description : 通过水平垂直偏移，取得对应可替换键的图片ID
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note: 检查按键是否按住可替换键
/*****************************************************************************/
LOCAL BOOLEAN GetReplaceKeyImgID(
    MMIIM_TP_CSTAR_HANDLE_T* handle_ptr,
    uint16 x_idx,
    uint16 y_idx,
    const MMIIM_TP_CSTAR_REPLACE_KEY_T **replace_key_pptr,
    MMIIM_TP_CSTAR_KEY_STATE_T img_state
)
{
    uint16 i = 0;
    MMIIM_TP_CSTAR_STATE_T state = {0};
    const MMIIM_TP_CSTAR_REPLACE_KEY_T *replace_key_ptr = PNULL;

    //SCI_TRACE_LOW:"[MMIIM] GetReplaceKeyImgID"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIIM_TP_UI_3812_112_2_18_2_29_24_282,(uint8*)"");

    if (PNULL == handle_ptr)
        return FALSE;

    //SCI_ASSERT(MMIIM_TP_CSTAR_KEY_STATE_NONE <= img_state && /*assert verified*/
               //MMIIM_TP_CSTAR_KEY_STATE_PRESS >= img_state);

    state = g_keyboard_state[handle_ptr->stateId];

    /*画正常的替换键*/
    if (PNULL != g_keyboard_state[handle_ptr->stateId].replace_key_tab ||
            0 < g_keyboard_state[handle_ptr->stateId].replace_key_cnt)
    {
        for (i = 0; i < g_keyboard_state[handle_ptr->stateId].replace_key_cnt; i++)
        {
            replace_key_ptr = &(g_keyboard_state[handle_ptr->stateId].replace_key_tab[i]);

            if (x_idx == replace_key_ptr->hor_index &&
                    y_idx == replace_key_ptr->ver_index)
            {
                *replace_key_pptr = replace_key_ptr;
                return TRUE;
            }
        }
    }

    return FALSE;
}

/******************************************************************************/
// Description: 显示按键的tips
// Global resource dependence: NONE
// Author: haiwu.chen
// Note:
/******************************************************************************/
LOCAL void DrawKeyTipsEx(
    MMIIM_TP_CSTAR_HANDLE_T* handle_ptr,
    MMI_STRING_T string,
    GUI_POINT_T pt_src
)
{
    GUI_LCD_DEV_INFO tips_lcd_info = {0};
    UILAYER_APPEND_BLT_T append_layer = {0};

    GUI_RECT_T disp_rect = {0};
    GUISTR_STYLE_T style = {0};
    GUI_POINT_T pt_offset = {0};

    MMIIM_TP_CSTSR_TIPS_DATA_T tips_data = {0};

    //SCI_ASSERT(PNULL != handle_ptr); /*assert verified*/

    if (0 == string.wstr_len||PNULL == handle_ptr)
        return;
    
    tips_lcd_info = handle_ptr->tips_lcd_info;
    if (UILAYER_IsMultiLayerEnable()
            || (UILAYER_IsLayerActive(&tips_lcd_info) && 0 != tips_lcd_info.block_id))
    {
        if (!GetTipsRect(handle_ptr, string, pt_src, &tips_data))
            return;

        //记住tips区域，待回头hide
        handle_ptr->tips_rect.left = tips_data.disp_rect.left;
        handle_ptr->tips_rect.right = tips_data.disp_rect.right;
        handle_ptr->tips_rect.top = tips_data.disp_rect.top;
        handle_ptr->tips_rect.bottom = tips_data.disp_rect.bottom;

        pt_offset.x = tips_data.disp_rect.left;
        pt_offset.y = tips_data.disp_rect.top;

        UILAYER_SetLayerPosition(&tips_lcd_info, pt_offset.x, pt_offset.y);
        UILAYER_SetLayerColorKey(&tips_lcd_info, TRUE, UILAYER_TRANSPARENT_COLOR);
        UILAYER_Clear(&tips_lcd_info);

        append_layer.lcd_dev_info = tips_lcd_info;
        append_layer.layer_level = UILAYER_LEVEL_NORMAL;
        UILAYER_AppendBltLayer(&append_layer);

        //画全框，中间会拉伸
        disp_rect = tips_data.disp_rect;

        GUIRES_DisplayImg(PNULL,
                          &disp_rect,
                          PNULL,
                          handle_ptr->init_param.win_id,
                          IMG_IMSP_TIPS,
                          &tips_lcd_info);

        //画文字
        style.font = TIPS_FONT_T;
        style.font_color = MMIIM_TP_CSTAR_TEXT_TIPS_COLOR_HOT;
        style.align = ALIGN_HVMIDDLE;
        GUISTR_DrawTextToLCDInRect(&tips_lcd_info,
                                   &disp_rect,
                                   &disp_rect,
                                   &string,
                                   &style,
                                   GUISTR_STATE_ALIGN | GUISTR_STATE_SINGLE_LINE | GUISTR_STATE_ELLIPSIS, //| GUISTR_STATE_BOLD,
                                   GUISTR_TEXT_DIR_AUTO
                                  );
    }

    return;
}

/******************************************************************************/
// Description: 显示按键的tips
// Global resource dependence: NONE
// Author: haiwu.chen
// Note:
/******************************************************************************/
LOCAL void DrawKeyTips(
    MMIIM_TP_CSTAR_HANDLE_T* handle_ptr,
    MMI_STRING_T string,
    GUI_POINT_T pt_src
)
{
    //SCI_ASSERT(PNULL != handle_ptr); /*assert verified*/
    
    if (PNULL != handle_ptr && 0 != handle_ptr->tips_timer_id)
    {
        MMK_StopTimer(handle_ptr->tips_timer_id);
        handle_ptr->tips_timer_id = 0;
        MMIIMUI_HideKeyTips(handle_ptr);
    }
    
    DrawKeyTipsEx(handle_ptr, string, pt_src);
}

/******************************************************************************/
// Description: 隐藏按键的tips
// Global resource dependence: NONE
// Author: haiwu.chen
// Note:
/******************************************************************************/
PUBLIC void MMIIMUI_HideKeyTips(
    MMIIM_TP_CSTAR_HANDLE_T* handle_ptr
)
{
    GUI_RECT_T tips_rect = {0};
    GUI_LCD_DEV_INFO *tips_lcd_info_ptr = PNULL;

    //SCI_ASSERT(PNULL != handle_ptr); /*assert verified*/
    if(PNULL == handle_ptr)
        return;
    tips_lcd_info_ptr = & (handle_ptr->tips_lcd_info);

    if (UILAYER_IsMultiLayerEnable()
            || UILAYER_IsLayerActive(tips_lcd_info_ptr))
    {
        UILAYER_RemoveBltLayer(tips_lcd_info_ptr);
        
        tips_rect.right = handle_ptr->tips_rect.right - handle_ptr->tips_rect.left;
        tips_rect.bottom = handle_ptr->tips_rect.bottom - handle_ptr->tips_rect.top;
        tips_rect.left = 0;
        tips_rect.top = 0;

        MMITHEME_StoreUpdateRect(tips_lcd_info_ptr, tips_rect);
    }

    return;
}

/******************************************************************************/
// Description: 定时等待并隐藏按键的tips
// Global resource dependence: NONE
// Author: haiwu.chen
// Note:
/******************************************************************************/
PUBLIC void MMIIMUI_HideKeyTipsEx(
    MMIIM_TP_CSTAR_HANDLE_T* handle_ptr
)
{
    handle_ptr->tips_timer_id = 
        MMK_CreateTimerCallback(MMIIM_UI_TIPS_TIMER_OUT, HideTipsTimerCB, (uint32)handle_ptr, FALSE);

    return;
}

/******************************************************************************/
// Description: 定时器隐藏回调函数
// Global resource dependence: NONE
// Author: haiwu.chen
// Note:
/******************************************************************************/
LOCAL void HideTipsTimerCB(uint8 timer_id, uint32 param)
{    
    MMIIM_TP_CSTAR_HANDLE_T* handle_ptr = (MMIIM_TP_CSTAR_HANDLE_T*)param;

    if (PNULL == handle_ptr)
        return;

    if (0 == timer_id || timer_id != handle_ptr->tips_timer_id)
        return;

    MMIIMUI_HideKeyTips(handle_ptr);

    return;        
}    

/*****************************************************************************/
//  Description : 得到输入法UI的大小
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note:
/*****************************************************************************/
PUBLIC void MMIIMUI_GetRect(
    MMIIM_TP_CSTAR_HANDLE_T* handle_ptr,
    GUI_RECT_T* rect
)
{
    uint16 bar_img_width = 0;
    uint16 bar_img_height = 0;

    //得到候选区的区域
    MMIIMUI_GetImageWidthHeight(handle_ptr->init_param.win_id, s_text_bar_theme.img_bg, &bar_img_width, &bar_img_height);

    switch (handle_ptr->ui_state)
    {
    case MMIIM_TP_CSTAR_STATE_NOINPUT:
        *rect = g_keyboard_state[handle_ptr->stateId].rect;
        break;

#ifndef INPUT_METHOD_CSTAR_COMMON_MINI//单字版本，不画pre_edit窗口
    case MMIIM_TP_CSTAR_STATE_INPUTING:
#endif
    case MMIIM_TP_CSTAR_STATE_USER:
        *rect = g_keyboard_state[handle_ptr->stateId].rect;

        if (g_keyboard_state[handle_ptr->stateId].priv_data&MMIIM_TP_CSTAR_CAND)
        {
            rect->top -= (bar_img_height);
        }
        if (g_keyboard_state[handle_ptr->stateId].priv_data&MMIIM_TP_CSTAR_ED)
        {
            rect->top -= (bar_img_height);
        }

        break;
#ifdef INPUT_METHOD_CSTAR_COMMON_MINI//单字版本，不画pre_edit窗口,区域要和MMIIM_TP_CSTAR_STATE_ASSOCIATE一样 
    case MMIIM_TP_CSTAR_STATE_INPUTING:
#endif
    case MMIIM_TP_CSTAR_STATE_ASSOCIATE:
        *rect = g_keyboard_state[handle_ptr->stateId].rect;

        if (g_keyboard_state[handle_ptr->stateId].priv_data&MMIIM_TP_CSTAR_CAND)
        {
            rect->top -= (bar_img_height);
        }

        break;

    default:
        break;
    }
}

/******************************************************************************/
// Description: 显示按键的tips
// Global resource dependence: NONE
// Author: haiwu.chen
// Note:
/******************************************************************************/
LOCAL BOOLEAN GetTipsRect(
    MMIIM_TP_CSTAR_HANDLE_T* handle_ptr,
    MMI_STRING_T string,
    GUI_POINT_T pt_src,
    MMIIM_TP_CSTSR_TIPS_DATA_T* tips_data_ptr
)
{
    GUI_RECT_T client_rect = {0};
    int top = 0;
    int bottom = 0;
    int left = 0;
    int right = 0;
    int tips_width = 0;
    uint16 img_width = 0;
    uint16 img_height = 0;
    uint16 textwidth = 0;
    GUISTR_STYLE_T style = {0};

    if (PNULL == handle_ptr)
    {
        //SCI_TRACE_LOW:"[MMIIM] GetTipsRect: handle_ptr is null."
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIIM_TP_UI_4083_112_2_18_2_29_24_283,(uint8*)"");
        return FALSE;
    }

    if (0 == string.wstr_len)
        return FALSE;

    //先来求一些图片的宽高度
    MMIIMUI_GetImageWidthHeight(handle_ptr->init_param.win_id, IMG_IMSP_TIPS, &img_width, &img_height);

    //小于字体高度，直接不要显得tips得了
    if (pt_src.y < TIPS_FONT_T)
    {
        return FALSE;
    }

    //不够TIPS区域高，则tips与按键之间就不要space了
    else if (pt_src.y < img_height)
    {
        top = 0;
        bottom = pt_src.y - 1;
    }

    //如果大于TIPS区域高，小于区域高加上间隔，则保持高度为区域高，space为剩下的
    else if (pt_src.y < img_height + TIPS_SPACE_HEIGHT)
    {
        top = 0;
        bottom = img_height;
    }

    //>区域高加上间隔的话，就应该正常显示了
    else
    {
        bottom = pt_src.y - TIPS_SPACE_HEIGHT;
        top = bottom - img_height;
    }

    style.font = TIPS_FONT_T;
    style.font_color = MMIIM_TP_CSTAR_TEXT_TIPS_COLOR_HOT;
    style.align = ALIGN_HVMIDDLE;
    textwidth = GUISTR_GetStringWidth(&style, &string, GUISTR_STATE_ALIGN | GUISTR_STATE_SINGLE_LINE | GUISTR_STATE_ELLIPSIS);

	client_rect = MMITHEME_GetClientRectEx(handle_ptr->init_param.win_handle);

    if (textwidth <= img_width)
    {
        //最小
        tips_width = img_width;
    }
    else if (textwidth <= client_rect.right - client_rect.left - TIPS_LEFT_MIN - TIPS_LEFT_MIN)
    {
        //字符串长
        tips_width = textwidth;
    }
    else
    {
        //最大
        tips_width = client_rect.right - client_rect.left - TIPS_LEFT_MIN - TIPS_LEFT_MIN;
    }

    if (pt_src.x <= TIPS_LEFT_MIN)
    {
        left = TIPS_LEFT_MIN;
        right = left + tips_width;
    }
    else if (pt_src.x + tips_width >= client_rect.right - client_rect.left - TIPS_LEFT_MIN)
    {
        right = client_rect.right - client_rect.left - TIPS_LEFT_MIN;
        left = right - tips_width;
    }
    else
    {
        left = pt_src.x;
        right = left + tips_width;
    }

    /*
    //给tips结构赋值
    tips_data_ptr->frame_img_width = img_width;
    tips_data_ptr->frame_img_height = img_height;

    //先来求一些图片的宽高度
    MMIIMUI_GetImageWidthHeight(handle_ptr->init_param.win_id, IMG_IMSP_TIPS_CENTER, &img_width, &img_height);

    tips_data_ptr->center_img_width = img_width;
    tips_data_ptr->center_img_height = img_height;
    */

    tips_data_ptr->disp_rect.left = left;
    tips_data_ptr->disp_rect.right = right;
    tips_data_ptr->disp_rect.top = top;
    tips_data_ptr->disp_rect.bottom = bottom;

    return TRUE;
}

/*****************************************************************************/
//  Description : 取得输入法的最小按键的宽度
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note:
/*****************************************************************************/
PUBLIC uint16 MMIIMUI_GetKeyButtonWidth(
    MMIIM_TP_CSTAR_STATE_T state
)
{
    uint16 width = 0;
    uint16 total = 0;
    uint16 TOP_SPACE_WIDTH = 0;
    uint16 BOTTOM_SPACE_WIDTH = 0;
    uint16 KEY_HOR_COL = 0;

    if (MMITHEME_IsMainScreenLandscape())
    {
        TOP_SPACE_WIDTH = TOP_SPACE_WIDTH_H;
        BOTTOM_SPACE_WIDTH = BOTTOM_SPACE_WIDTH_H;
        KEY_HOR_COL = KEY_HOR_COL_H;
    }
    else
    {
        TOP_SPACE_WIDTH = TOP_SPACE_WIDTH_V;
        BOTTOM_SPACE_WIDTH = BOTTOM_SPACE_WIDTH_V;
        KEY_HOR_COL = KEY_HOR_COL_V;
    }

    total = state.img_rect.right -  state.img_rect.left;

    //减去左右两边的宽
    total -=  TOP_SPACE_WIDTH;
    total -= BOTTOM_SPACE_WIDTH;

    //减去每两个键之间的间隔总和
    total = total - (state.hnum - 1) * KEY_HOR_COL;

    width = (int16)(total / state.hnum);

    return width;
}

/*****************************************************************************/
//  Description : 取得输入法的最小按键的高度
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note:
/*****************************************************************************/
PUBLIC uint16 MMIIMUI_GetKeyButtonHeight(
    MMIIM_TP_CSTAR_STATE_T state
)
{
    uint16 height = 0;
    uint16 total = 0;
    uint16 TOP_SPACE_HEIGHT = 0;
    uint16 BOTTOM_SPACE_HEIGHT = 0;
    uint16 KEY_VER_COL = 0;

    if (MMITHEME_IsMainScreenLandscape())
    {
        TOP_SPACE_HEIGHT = TOP_SPACE_HEIGHT_H;
        BOTTOM_SPACE_HEIGHT = BOTTOM_SPACE_HEIGHT_H;
        KEY_VER_COL = KEY_VER_COL_H;
    }
    else
    {
        TOP_SPACE_HEIGHT = TOP_SPACE_HEIGHT_V;
        BOTTOM_SPACE_HEIGHT = BOTTOM_SPACE_HEIGHT_V;
        KEY_VER_COL = KEY_VER_COL_V;
    }

    total = state.img_rect.bottom - state.img_rect.top;

    //减去左右两边的宽
    total -=  TOP_SPACE_HEIGHT;
    total -= BOTTOM_SPACE_HEIGHT;

    //减去每两个键之间的间隔总和
    total = total - (state.vnum - 1) * KEY_VER_COL;

    height = (int16)(total / state.vnum);

    return height;
}

/*****************************************************************************/
//  Description : 得到焦点区的区域，相对图片的左上角
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note:
/*****************************************************************************/
PUBLIC GUI_RECT_T MMIIMUI_GetFocusRect(
    uint16 rect_num,
    uint16 button_width,
    uint16 button_height,
    uint16 hor_index,
    uint16 ver_index
)
{
    GUI_RECT_T focus_rect = {0};
    int16 num = MAX(1, rect_num);
    uint16 TOP_SPACE_WIDTH = 0;
    uint16 TOP_SPACE_HEIGHT = 0;
    uint16 KEY_HOR_COL = 0;
    uint16 KEY_VER_COL = 0;

    if (MMITHEME_IsMainScreenLandscape())
    {
        TOP_SPACE_WIDTH = TOP_SPACE_WIDTH_H;
        TOP_SPACE_HEIGHT = TOP_SPACE_HEIGHT_H;
        KEY_HOR_COL = KEY_HOR_COL_H;
        KEY_VER_COL = KEY_VER_COL_H;
    }
    else
    {
        TOP_SPACE_WIDTH = TOP_SPACE_WIDTH_V;
        TOP_SPACE_HEIGHT = TOP_SPACE_HEIGHT_V;
        KEY_HOR_COL = KEY_HOR_COL_V;
        KEY_VER_COL = KEY_VER_COL_V;
    }

    focus_rect.left = TOP_SPACE_WIDTH + hor_index * button_width + KEY_HOR_COL * hor_index;
    focus_rect.right = focus_rect.left + (num - 1) * KEY_HOR_COL + num * button_width;
    focus_rect.top = TOP_SPACE_HEIGHT + ver_index * button_height + KEY_VER_COL * ver_index;
    focus_rect.bottom = focus_rect.top + button_height;

    return focus_rect;
}

/*****************************************************************************/
//  Description : 把引擎给的内容一次复制到应用上来
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note:
/*****************************************************************************/
PUBLIC void MMIIMUI_GetChoiceBufferByKernel(
    MMIIM_TP_CSTAR_CHOICE_BAR_T* choice_bar_ptr,
    wchar* buf,
    uint16 num
)
{
    uint16 i = 0;
    uint16 j = 0;

    //SCI_ASSERT(PNULL != choice_bar_ptr); /*assert verified*/
    //SCI_ASSERT(PNULL != choice_bar_ptr->lcd_info_ptr); /*assert verified*/
    if(PNULL == choice_bar_ptr ||PNULL == choice_bar_ptr->lcd_info_ptr)
        return;

//mini版本存在bug，暂且仅仅应用在该版本上，防止存在以外风险
//具体见NEWMS104272:9键，拼音输入点击虚拟键盘候选字翻页后，从新点击choice字符后，
//候选字字符显示错乱
#ifdef INPUT_METHOD_CSTAR_COMMON_MINI   
{
    BOOLEAN buf_changed = FALSE;
    wchar *ptmp_buf = NULL;

    ptmp_buf = buf;
    for(i = 0; i < (num < MMIIM_CHOICE_MAX_NUM ? num : MMIIM_CHOICE_MAX_NUM); i ++)
    {
        if(ptmp_buf == NULL)
            break;
        
        if(MMIAPICOM_Wstrcmp((wchar  *)&choice_bar_ptr->pChoiceBuffer[i][0] , ptmp_buf))
        {
            buf_changed = TRUE;
            break;
        }

        ptmp_buf += (MMIAPICOM_Wstrlen((wchar  *)&choice_bar_ptr->pChoiceBuffer[i][0]) + 1);		// +1是因buf数据结构为每个字符串以0x0000结尾
    }

    //删除掉所有字符后，也表示有数据更新
    if(num == 0)
    {
        buf_changed = TRUE;
    }

    if(buf_changed)		//字符串发生改变
    {
        SCI_MEMSET(choice_bar_ptr->pChoiceBuffer, 0, sizeof(wchar) *MMIIM_CHOICE_MAX_NUM*MMIIM_MAX_PYCHOICE_CHAR_NUM);

        choice_bar_ptr->hot_index = -1;
        choice_bar_ptr->cur_page_line_cnt = 0;
        choice_bar_ptr->total_choice_cnt = 0;
        choice_bar_ptr->is_choice_state = 0;
        choice_bar_ptr->choice_last_index = 0;
        choice_bar_ptr->choice_index = 0;
        choice_bar_ptr->page_cnt = 0;
        choice_bar_ptr->page_index = 0;
    }
}
#else
    SCI_MEMSET(choice_bar_ptr->pChoiceBuffer, 0, sizeof(wchar) *MMIIM_CHOICE_MAX_NUM*MMIIM_MAX_PYCHOICE_CHAR_NUM);

    choice_bar_ptr->hot_index = -1;
    choice_bar_ptr->cur_page_line_cnt = 0;
    choice_bar_ptr->total_choice_cnt = 0;
    choice_bar_ptr->is_choice_state = 0;
    choice_bar_ptr->choice_last_index = 0;
    choice_bar_ptr->choice_index = 0;
    choice_bar_ptr->page_cnt = 0;
    choice_bar_ptr->page_index = 0;
#endif

    if (PNULL == buf || 0 == num)
    {
        return;
    }

    while (choice_bar_ptr->total_choice_cnt < num)
    {
        choice_bar_ptr->pChoiceBuffer[choice_bar_ptr->total_choice_cnt][j] = buf[i];
        i++;
        j++;

        if (0 == buf[i])
        {
            choice_bar_ptr->total_choice_cnt++;
            i++;
            j = 0;

            if (MMIIM_CHOICE_MAX_NUM <= choice_bar_ptr->total_choice_cnt)
            {
                break;
            }
        }
    }

    if (0 == choice_bar_ptr->total_choice_cnt % choice_bar_ptr->choice_line_cnt)
    {
        choice_bar_ptr->page_cnt = choice_bar_ptr->total_choice_cnt / choice_bar_ptr->choice_line_cnt;
    }
    else
    {
        choice_bar_ptr->page_cnt = choice_bar_ptr->total_choice_cnt / choice_bar_ptr->choice_line_cnt + 1;
    }

    //给当前页实际的行数赋值
    if (choice_bar_ptr->total_choice_cnt > choice_bar_ptr->choice_line_cnt)
    {
        choice_bar_ptr->cur_page_line_cnt = choice_bar_ptr->choice_line_cnt;
    }
    else
    {
        choice_bar_ptr->cur_page_line_cnt = choice_bar_ptr->total_choice_cnt;
    }

    choice_bar_ptr->idc_up_state = MMIIM_TP_CSTAR_KEY_STATE_INACTIVE;
    choice_bar_ptr->idc_down_state = MMIIM_TP_CSTAR_KEY_STATE_INACTIVE;

    if (choice_bar_ptr->page_cnt > 1)
    {
        choice_bar_ptr->idc_down_state = MMIIM_TP_CSTAR_KEY_STATE_ACTIVE;
    }
}

/*****************************************************************************/
//  Description : 检查按键点是否在图标之上
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note:如果点刚好在间隔区内则返回false, 在上面返回偏移;
/*****************************************************************************/
PUBLIC BOOLEAN MMIIMUI_CheckPointAvailability(
    MMIIM_TP_CSTAR_STATE_T state,
    GUI_POINT_T point,
    uint16 button_width,
    uint16 button_height,
    uint16* hor_index_ptr,
    uint16* ver_index_ptr
)
{
    //以下算法留了个bug，在一个按键如果占有多个小键的话，点中间，应该响应不了
    //同志们先用，回头我再补充完善，碰到两格的，先别点中间那两个像素的间隔
    uint16 hor_index = 0;
    uint16 ver_index = 0;
    BOOLEAN is_hor_valid = FALSE;
    BOOLEAN is_ver_valid = FALSE;
    uint16 button_left = 0;
    uint16 button_right = 0;
    uint16 button_top = 0;
    uint16 button_bottom = 0;
    uint16 TOP_SPACE_WIDTH = 0;
    uint16 TOP_SPACE_HEIGHT = 0;
    uint16 KEY_HOR_COL = 0;
    uint16 KEY_VER_COL = 0;

    if (!GUI_PointIsInRect(point, state.rect))
        return FALSE;

    if (MMITHEME_IsMainScreenLandscape())
    {
        TOP_SPACE_WIDTH = TOP_SPACE_WIDTH_H;
        TOP_SPACE_HEIGHT = TOP_SPACE_HEIGHT_H;
        KEY_HOR_COL = KEY_HOR_COL_H;
        KEY_VER_COL = KEY_VER_COL_H;
    }
    else
    {
        TOP_SPACE_WIDTH = TOP_SPACE_WIDTH_V;
        TOP_SPACE_HEIGHT = TOP_SPACE_HEIGHT_V;
        KEY_HOR_COL = KEY_HOR_COL_V;
        KEY_VER_COL = KEY_VER_COL_V;
    }

    for (hor_index = 0; hor_index < state.hnum; hor_index++)
    {
        button_left = state.rect.left + TOP_SPACE_WIDTH + hor_index * button_width + KEY_HOR_COL * hor_index;
        button_right = button_left + button_width;

        if (point.x >= button_left &&
                point.x <= button_right)
        {
            is_hor_valid = TRUE;
            *hor_index_ptr = hor_index;
            break;
        }
    }

    if (!is_hor_valid)
    {
        return FALSE;
    }

    for (ver_index = 0; ver_index < state.vnum; ver_index++)
    {
        button_top = state.rect.top + TOP_SPACE_HEIGHT + ver_index * button_height + KEY_VER_COL * ver_index;
        button_bottom = button_top + button_height;

        if (point.y >= button_top &&
                point.y <= button_bottom)
        {
            is_ver_valid = TRUE;
            *ver_index_ptr = ver_index;
            break;
        }
    }

    return (is_ver_valid && is_hor_valid);
}

/*****************************************************************************/
//  Description : create tips latyer
//  Global resource dependence : none
//  Author:
//  Note:
/*****************************************************************************/
PUBLIC void MMIIMUI_CreateTipsLayer(MMIIM_TP_CSTAR_HANDLE_T* handle_ptr, GUIIM_INIT_KERNEL_T* param_ptr)
{
    uint16 logic_lcd_width = 0;
    uint16 logic_lcd_height = 0;
    uint16 img_width = 0;
    uint16 img_height = 0;

    //创建tips层
    if (UILAYER_IsMultiLayerEnable())
    {
        UILAYER_CREATE_T    create_info = {0};

        GUILCD_GetLogicWidthHeight(MAIN_LCD_ID, &logic_lcd_width, &logic_lcd_height);
        MMIIMUI_GetImageWidthHeight(handle_ptr->init_param.win_id, IMG_IMSP_TIPS, &img_width, &img_height);

        create_info.lcd_id = MAIN_LCD_ID;
        create_info.owner_handle = param_ptr->win_id;
        create_info.offset_x = 0;
        create_info.offset_y = 0;
        create_info.width = logic_lcd_width - TIPS_LEFT_MIN*2;
        create_info.height = img_height;
        create_info.is_bg_layer = FALSE;
        create_info.is_static_layer = TRUE;        
        UILAYER_CreateLayer(&create_info,
                                  & (handle_ptr->tips_lcd_info));

        UILAYER_SetLayerColorKey(& (handle_ptr->tips_lcd_info), TRUE, UILAYER_TRANSPARENT_COLOR);
    }
}

/*****************************************************************************/
//  Description : 重置混淆区相关变量
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note:
/*****************************************************************************/
PUBLIC void MMIIMUI_ClearChoiceBarData(MMIIM_TP_CSTAR_CHOICE_BAR_T *choice_bar_ptr)
{
    //SCI_ASSERT(PNULL != choice_bar_ptr); /*assert verified*/
    if(PNULL != choice_bar_ptr)
    {
        SCI_MEMSET(choice_bar_ptr->pChoiceBuffer, 0, sizeof(wchar) *MMIIM_CHOICE_MAX_NUM*MMIIM_MAX_PYCHOICE_CHAR_NUM);

        choice_bar_ptr->cur_page_line_cnt = 0;
        choice_bar_ptr->total_choice_cnt = 0;
        choice_bar_ptr->choice_last_index = 0;
        choice_bar_ptr->choice_index = 0;
        choice_bar_ptr->has_hot = 1;
        choice_bar_ptr->hot_index = -1;

        choice_bar_ptr->page_cnt = 0;
        choice_bar_ptr->page_index = 0;
        choice_bar_ptr->pageflag = MMIIM_TP_CSTAR_PAGEFLAG_NONE;
        choice_bar_ptr->idc_up_state = MMIIM_TP_CSTAR_KEY_STATE_INACTIVE;
        choice_bar_ptr->idc_down_state = MMIIM_TP_CSTAR_KEY_STATE_INACTIVE;
    }
}

/******************************************************************************/
// Description: 由当前的输入法及是否全键盘得到键盘的状态
// Global resource dependence: NONE
// Author: haiwu.chen
// Note:
/******************************************************************************/
PUBLIC MMIIM_TP_CSTAR_STATE_ID_T MMIIMUI_GetVKboardState(
    GUIIM_METHOD_T method,
    BOOLEAN is_full_keypad
)
{
    uint16 i = 0;
    uint16 im_cnt = ARR_SIZE(g_method_keyboard_relation_list);
    MMIIM_TP_CSTAR_STATE_ID_T kb_state = MMIIM_TP_CSTAR_STATE_ABC_26KEY_LEAD;

    //SCI_TRACE_LOW:"[MMIIM] GetVKboardState"
    SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIIM_TP_UI_4584_112_2_18_2_29_25_284,(uint8*)"");

    if(GUIIM_M_NONE == method)
    {
        return kb_state - MMIIM_TP_CSTAR_KB_START_ID;
    }

    for(i = 0; i < im_cnt; i++)
    {
        if(g_method_keyboard_relation_list[i].gui_method== method)
        {
            kb_state = g_method_keyboard_relation_list[i].kb_state;
            break;
        }
    }

    return kb_state - MMIIM_TP_CSTAR_KB_START_ID;
}

/*****************************************************************************/
//  Description : 根据当前的输入法获取下一个同类语言的大小写输入法
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note: 如果语言区分大小写，则在三种之间来回切换
/*****************************************************************************/
PUBLIC GUIIM_METHOD_T MMIIMUI_GetNextCapsByMethod(
    GUIIM_METHOD_T cur_method,
    GUIIM_CAPITAL_MODE_T cur_caps   
)
{
    GUIIM_CAPITAL_MODE_T next_cap = GUIIM_MODE_MAX;
    
    if (GUIIM_MODE_MAX == cur_caps)
    {
        return cur_method;
    }

    if (GUIIM_MODE_LEAD_UPPER == cur_caps)
    {
        next_cap = GUIIM_MODE_LOWER;
    }
    else if (GUIIM_MODE_LOWER == cur_caps)
    {
        next_cap = GUIIM_MODE_UPPER;
    }
    else if (GUIIM_MODE_UPPER == cur_caps)
    {
        next_cap = GUIIM_MODE_LEAD_UPPER;
    }
    else
    {
        return cur_method;
    }
    
    return MMITHEME_IMGetMethodByCapital(cur_method, next_cap);
}

/*****************************************************************************/
//  Description : 外部消息转化为内部消息类型
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note:
/*****************************************************************************/
PUBLIC void MMIIMUI_TransMsg(
    MMIIM_TP_CSTAR_HANDLE_T *data_ptr,
    GUIIM_EVENT_DATA_U const *event_data_ptr,
    MMIIM_TP_CSTAR_MSG_T *msg_ptr
)
{
    MMIIM_TP_CSTAR_STATE_T state = {0};
    BOOLEAN is_tp_in_rect = FALSE;
    BOOLEAN is_ret = TRUE;
    uint16 x_idx = 0;//水平偏移量
    uint16 y_idx = 0;
    uint16 button_w = 0;//按钮宽
    uint16 button_h = 0;
    int16 rect_num = 0;
    int16 count = 0;
    uint16 i = 0;

    //SCI_ASSERT(PNULL != data_ptr); /*assert verified*/
    //SCI_ASSERT(PNULL != event_data_ptr); /*assert verified*/
    //SCI_ASSERT(PNULL != msg_ptr); /*assert verified*/
    if(PNULL == data_ptr || PNULL == event_data_ptr ||PNULL == msg_ptr)
        return;
    //消息类型
    msg_ptr->id = MMIIM_TP_CSTAR_MSG_NONE;

    switch (event_data_ptr->sys_msg.msg_id)
    {
        //触笔消息转换
#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_TP_PRESS_DOWN:
        msg_ptr->id = MMIIM_TP_CSTAR_MSG_TPDOWN;
        break;
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527

#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_TP_PRESS_MOVE:
        msg_ptr->id = MMIIM_TP_CSTAR_MSG_TPMOVE;
        break;
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527

#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_TP_PRESS_UP:
        msg_ptr->id = MMIIM_TP_CSTAR_MSG_TPUP;
        break;
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527

#ifdef TOUCH_PANEL_SUPPORT //IGNORE9527
    case MSG_TP_PRESS_LONG:
        msg_ptr->id = MMIIM_TP_CSTAR_MSG_TPLONG;
        break;
#endif //TOUCH_PANEL_SUPPORT //IGNORE9527

    default:
        {
            switch (event_data_ptr->sys_msg.msg_id & MMIIM_TP_CSTAR_KEY_TYPE_MASK)
            {
            case KEY_PRESSED:
                msg_ptr->id = MMIIM_TP_CSTAR_MSG_KEY_PRESS;
                break;

            case KEY_RELEASED:
                msg_ptr->id = MMIIM_TP_CSTAR_MSG_KEY_RELEASE;
                break;

            case KEY_LONG_PRESSED:
                msg_ptr->id = MMIIM_TP_CSTAR_MSG_KEY_LONG_PRESS;
                break;

            case KEY_LONG_RELEASED:
                msg_ptr->id = MMIIM_TP_CSTAR_MSG_KEY_LONG_RELEASE;
                break;

            default:
                break;
            }
        }
        break;
    }

    //非处理数据，返回，无此消息类型，直接return
    if (MMIIM_TP_CSTAR_MSG_NONE == msg_ptr->id)
    {
        return;
    }

    //下面取出哪个键被按下，获取消息参数
    if (MMIIM_TP_CSTAR_MSG_TPDOWN == msg_ptr->id ||
            MMIIM_TP_CSTAR_MSG_TPMOVE == msg_ptr->id ||
            MMIIM_TP_CSTAR_MSG_TPUP == msg_ptr->id ||
            MMIIM_TP_CSTAR_MSG_TPLONG == msg_ptr->id)
    {
        //触笔消息
        msg_ptr->para.tp.point.x = MMK_GET_TP_X(event_data_ptr->sys_msg.param);
        msg_ptr->para.tp.point.y = MMK_GET_TP_Y(event_data_ptr->sys_msg.param);
        msg_ptr->para.tp.area = MMIIM_TP_CSTAR_MSG_TP_NONE;//触笔点在哪个区 

        //SCI_ASSERT(data_ptr->stateId < MMIIM_TP_CSTAR_STATE_MAX); /*assert verified*/
        if(data_ptr->stateId < MMIIM_TP_CSTAR_STATE_MAX)
        {
            state = g_keyboard_state[data_ptr->stateId];
        }

        //SCI_ASSERT(state.hnum); /*assert verified*/
        //SCI_ASSERT(state.vnum); /*assert verified*/

        do
        {
            //取触笔按中对应键盘区
            is_tp_in_rect = GUI_PointIsInRect(msg_ptr->para.tp.point, state.rect);

            if (is_tp_in_rect)
            {
                msg_ptr->para.tp.area = MMIIM_TP_CSTAR_MSG_TP_KB;
                msg_ptr->para.tp.idx = -1;

                //在主键区中，还有一个特殊的应用控制混淆音区，纯9键盘才有这种需要
                if (!data_ptr->is_full_keypad && !MMIIMUI_IsCommonKeyBoardState(data_ptr))
                {
                    if (GUI_PointIsInRect(msg_ptr->para.tp.point, data_ptr->choice_bar.rect))
                    {
                        msg_ptr->para.tp.area = MMIIM_TP_CSTAR_MSG_TP_CHOICE;

                        //再来检查，按住的是哪个具体位置
                        if (GUI_PointIsInRect(msg_ptr->para.tp.point, data_ptr->choice_bar.idc_up_rect))
                        {
                            msg_ptr->para.tp.idx = CAND_LEFT_ARROW_IDX;
                        }
                        else if (GUI_PointIsInRect(msg_ptr->para.tp.point, data_ptr->choice_bar.idc_down_rect))
                        {
                            msg_ptr->para.tp.idx = CAND_RIGHT_ARROW_IDX;
                        }
                        else
                        {
                            for (i = 0; i < data_ptr->choice_bar.choice_line_cnt && i < data_ptr->choice_bar.cur_page_line_cnt; i++)
                            {
                                if (GUI_PointIsInRect(msg_ptr->para.tp.point, data_ptr->choice_bar.choice_str_rect[i]))
                                {
                                    msg_ptr->para.tp.idx = i;
                                    break;
                                }
                            }
                        }

                        break;
                    }
                }

                button_w = MMIIMUI_GetKeyButtonWidth(state);
                button_h = MMIIMUI_GetKeyButtonHeight(state);

                //SCI_ASSERT(0 != button_w); /*assert verified*/
                //SCI_ASSERT(0 != button_h); /*assert verified*/

                is_ret = MMIIMUI_CheckPointAvailability(state, msg_ptr->para.tp.point, button_w, button_h, &x_idx, &y_idx);      

                //SCI_TRACE_LOW:"[MMIIM] MMIIMUI_TransMsg: p.x=%d, p.y=%d, x=%d, y=%d"
                SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIIM_TP_UI_4791_112_2_18_2_29_26_285,(uint8*)"dddd", msg_ptr->para.tp.point.x, msg_ptr->para.tp.point.y, x_idx, y_idx);

                if (!is_ret)
                {
                    //这里用户点到了键盘内的一个无效区，则应该做一下修复。修复算法，是左靠还是右靠，待定
                    return;
                }

                count = (int16)(y_idx * state.hnum + x_idx);
                rect_num = state.functab[count].rect_num;

                if (0 == rect_num) //可以是占一个小框，也可以是多个
                {
                    while (!state.functab[count].rect_num) //多个的话，紧接着下一个键，直到数到rectnum==0为止
                    {
                        count--;
                        x_idx--;

                        if (count < 0) /*lint !e685*/  //|| x_idx < 0)
                        {
                            return;
                        }
                    }
                }

                rect_num = state.functab[count].rect_num;

                msg_ptr->para.tp.h_idx = x_idx;
                msg_ptr->para.tp.v_idx = y_idx;
                msg_ptr->para.tp.idx = (int16)(y_idx * state.hnum + x_idx);
                msg_ptr->para.tp.rect = MMIIMUI_GetFocusRect(rect_num, button_w, button_h, x_idx, y_idx);
                break;
            }

            //按在候选区
            is_tp_in_rect = GUI_PointIsInRect(msg_ptr->para.tp.point, data_ptr->cand_rect);

            if (is_tp_in_rect && (state.priv_data&MMIIM_TP_CSTAR_CAND))
            {
                msg_ptr->para.tp.area = MMIIM_TP_CSTAR_MSG_TP_CAND;
                msg_ptr->para.tp.idx = -1;

                MMIIMUI_SetTpOnCandBarIdx(data_ptr, msg_ptr->para.tp.point, data_ptr->event_data_ptr, & (msg_ptr->para.tp));

                break;
            }

        }
        while (0);
    }
    else if (MMIIM_TP_CSTAR_MSG_KEY_PRESS == msg_ptr->id ||
             MMIIM_TP_CSTAR_MSG_KEY_RELEASE == msg_ptr->id ||
             MMIIM_TP_CSTAR_MSG_KEY_LONG_PRESS == msg_ptr->id ||
             MMIIM_TP_CSTAR_MSG_KEY_LONG_RELEASE == msg_ptr->id)
    {
        msg_ptr->para.key = event_data_ptr->sys_msg.msg_id & MMIIM_TP_CSTAR_KEY_MASK;
    }


    return;
}

/*****************************************************************************/
//  Description : TpDownProcess系统消息处理
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note:
/*****************************************************************************/
PUBLIC void MMIIMUI_SaveLastTpMsgParam(
    MMIIM_TP_CSTAR_HANDLE_T *data_ptr,
    MMIIM_TP_CSTAR_MSG_PARA_TP_T const *para_ptr
)
{
    //SCI_ASSERT(PNULL != data_ptr); /*assert verified*/
    //SCI_ASSERT(PNULL != para_ptr); /*assert verified*/
    if(PNULL != data_ptr && PNULL != para_ptr)
    {
        data_ptr->tp_last_msg_param.area = para_ptr->area;
        data_ptr->tp_last_msg_param.h_idx = para_ptr->h_idx;
        data_ptr->tp_last_msg_param.v_idx = para_ptr->v_idx;
        data_ptr->tp_last_msg_param.idx = para_ptr->idx;
        data_ptr->tp_last_msg_param.point.x = para_ptr->point.x;
        data_ptr->tp_last_msg_param.point.y = para_ptr->point.y;
        data_ptr->tp_last_msg_param.rect.left = para_ptr->rect.left;
        data_ptr->tp_last_msg_param.rect.top = para_ptr->rect.top;
        data_ptr->tp_last_msg_param.rect.right = para_ptr->rect.right;
        data_ptr->tp_last_msg_param.rect.bottom = para_ptr->rect.bottom;
    }
}

/*****************************************************************************/
//  Description : 清除按键痕迹
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note:
/*****************************************************************************/
PUBLIC void MMIIMUI_ClearPressKBMark(
    MMIIM_TP_CSTAR_HANDLE_T* handle_ptr
)
{
    //画方框
    //SCI_ASSERT(PNULL != handle_ptr); /*assert verified*/
    if(PNULL == handle_ptr )
        return;
    
    //隐藏tips
    MMIIMUI_HideKeyTipsEx(handle_ptr);

    //记住锁区域
    if ((g_keyboard_state[handle_ptr->stateId].priv_data&MMIIM_TP_CSTAR_LOCK) &&
            (handle_ptr->tp_last_msg_param.idx == 11))
    {
        handle_ptr->lock_rect.left = handle_ptr->press_rect.left;
        handle_ptr->lock_rect.right = handle_ptr->press_rect.right;
        handle_ptr->lock_rect.top = handle_ptr->press_rect.top;
        handle_ptr->lock_rect.bottom = handle_ptr->press_rect.bottom;
        handle_ptr->lock_img_rect.left = handle_ptr->press_img_rect.left;
        handle_ptr->lock_img_rect.right = handle_ptr->press_img_rect.right;
        handle_ptr->lock_img_rect.top = handle_ptr->press_img_rect.top;
        handle_ptr->lock_img_rect.bottom = handle_ptr->press_img_rect.bottom;
    }

    handle_ptr->press_rect.bottom = 0;
    handle_ptr->press_rect.left = 0;
    handle_ptr->press_rect.right = 0;
    handle_ptr->press_rect.top = 0;
    handle_ptr->press_img_rect.bottom = 0;
    handle_ptr->press_img_rect.left = 0;
    handle_ptr->press_img_rect.right = 0;
    handle_ptr->press_img_rect.top = 0;
    
    return;
}

/*****************************************************************************/
//  Description : 清除候选栏按键痕迹
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note:
/*****************************************************************************/
PUBLIC void MMIIMUI_ClearPressCandMark(
    MMIIM_TP_CSTAR_HANDLE_T* handle_ptr
)
{
    return;
}

/*****************************************************************************/
//  Description : 查找字符
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note:
/*****************************************************************************/
PUBLIC BOOLEAN MMIIMUI_SearchFromStrtab(
    const wchar *char_ptr,
    const wchar *strtab_ptr
)
{
    const wchar *temp_ptr = PNULL;

    if (PNULL == char_ptr
        || PNULL == strtab_ptr)
    {
        //SCI_TRACE_LOW:"[MMIIM] MMIIMUI_SearchFromStrtab: param is null."
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIIM_TP_UI_4946_112_2_18_2_29_26_286,(uint8*)"");
        return FALSE;
    }
    
    temp_ptr = &strtab_ptr[1];

    while (temp_ptr < &strtab_ptr[1] + strtab_ptr[0])
    {
        if (*temp_ptr == *char_ptr)
        {
            return TRUE;
        }

        temp_ptr++;
    }

    return FALSE;
}

/*****************************************************************************/
//  Description : MMIIMUI_ClearKbUpOnInValidRect
//  Global resource dependence : none
//  Author: haiwu.chen
//  Note:
/*****************************************************************************/
PUBLIC BOOLEAN MMIIMUI_ClearKbUpOnInValidRect(
    MMIIM_TP_CSTAR_HANDLE_T *data_ptr
)
{
    if (PNULL == data_ptr)
    {
        //SCI_TRACE_LOW:"[MMIIM] MMIIMUI_ClearKbUpOnInValidRect: data_ptr is null."
        SCI_TRACE_ID(TRACE_TOOL_CONVERT,MMIIM_TP_UI_4975_112_2_18_2_29_26_287,(uint8*)"");
        return FALSE;
    }

    if (MMIIM_TP_CSTAR_MSG_TP_CHOICE == data_ptr->tp_last_msg_param.area)
    {
        data_ptr->choice_bar.hot_index = -1;
        data_ptr->is_bar_edit_dirty = TRUE;
        data_ptr->is_bar_choice_dirty = TRUE;
        data_ptr->is_kb_dirty = TRUE;
    }
    else if (MMIIM_TP_CSTAR_MSG_TP_CAND == data_ptr->tp_last_msg_param.area)
    {
        data_ptr->is_bar_cand_dirty = TRUE;
    }
    else if (MMIIM_TP_CSTAR_MSG_TP_KB == data_ptr->tp_last_msg_param.area)
    {
        data_ptr->is_kb_dirty = TRUE;
        data_ptr->is_bar_choice_dirty = TRUE;
    }
    else
    {
    }
    
    data_ptr->tp_last_msg_param.idx = -1;
    MMIIMUI_ClearPressKBMark(data_ptr);
    MMIIMUI_ReDrawAllBoard(data_ptr);

    return TRUE;
}
/*****************************************************************************/
//  Description : 根据语言获得对齐方式(从左往右还是从右往左)
//  Global resource dependence : none
//  Author: juan.wu
//  Note:
/*****************************************************************************/
PUBLIC uint8 MMIIM_TPGetAligntype(GUIIM_METHOD_T method)
{
    uint8   direction = 0;
    switch(method)
    {
        case GUIIM_M_TP_URDU:
        case GUIIM_M_TP_ARABIC:
        case GUIIM_M_TP_PERSIAN:
        case GUIIM_M_TP_HEBREW:
        case GUIIM_M_TP_URDU_ABC:
        case GUIIM_M_TP_ARABIC_ABC:
        case GUIIM_M_TP_PERSIAN_ABC:
        case GUIIM_M_TP_HEBREW_ABC:
        case GUIIM_M_TPQ_ARABIC:
        case GUIIM_M_TPQ_PERSIAN:
        case GUIIM_M_TPQ_URDU:
        case GUIIM_M_TPQ_HEBREW:
        case GUIIM_M_TPQ_ARABIC_ABC:
        case GUIIM_M_TPQ_PERSIAN_ABC:
        case GUIIM_M_TPQ_URDU_ABC:
        case GUIIM_M_TPQ_HEBREW_ABC:
        case GUIIM_M_TP_UYGHUR:
        case GUIIM_M_TP_UYGHUR_ABC:
        case GUIIM_M_TPQ_UYGHUR:
        case GUIIM_M_TPQ_UYGHUR_ABC:
            direction = MMIIM_DRAW_RIGHT2LEFT;
            break;

        default:
            direction = MMIIM_DRAW_LEFT2RIGHT;
            break;
    }
    return direction;
}

#endif      //MMI_IM_PDA_SUPPORT

/*Edit by script, ignore 4 case. Thu Apr 26 19:00:57 2012*/ //IGNORE9527
