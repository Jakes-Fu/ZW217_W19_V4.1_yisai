#! /usr/bin/python
# coding=utf8

"""
trace scan app written in python

Usage: python trace_scan.py <clean> to delete macro 
	python trace_scan.py <out_dir> to do trace scan and save StringRecord.bin to build/out_dir/img/

Examples:
  trace_scan.py clean 
  trace_scan.py MPWPS_builddir 
"""

import sys, os, struct, csv, re, shutil

file_code_record = 'file_code_record.csv'
string_record = 'StringRecord'
string_record_magic_number = 0x34800
strong_scan = False
readonly_mode = False

macroPattern = r'''
	^						#  match beginning of string
	(						# prefix start
	(\s*)     				# any whitespace character
	|(\s*/\*.*\*/\s*) 		# optional separator is any number of non-digits
	)						# prefix end
	\#\s*define  			# # define
	\s+         			# space after define
	TRACE_INFO_FILE     	# macro
	\s+         			# space 
	(?P<file_code>\d+)  	# filecode
	'''

funcPattern = r'''
	^						#  match beginning of string
	(						# prefix start
	(\s*)     				# any whitespace character
	|(\s*/\*.*\*/\s*) 		# optional separator is any number of non-digits
	)						# prefix end
	(printf
	|
	(TRACE_FUNCTION	# base function name
	(						# suffix start
	(_P[1-4])?				# only P?
	|((_L[1-5])(_P[1-4])?) 	# L? and P?
	)?))						# suffix end
	(\s*)      				# space
	\(						# (
	(\s*)      				# space
	"        				# left quot
	(?P<fmt_str>.*)			# fmt string
	(?!\\)"        			# right quot
	'''

root = ''

c_file_header = r'''/*Generated by trace_scan.py.*/

unsigned char g_StringRecords[] = {
'''

c_file_foot = r'''
	0x00
};
'''

class HashMapper:
	"""Generate hash value from strings. """
	def __init__(self, max_num = 65536):
		self.map_size = max_num
		self.__int_dict = {}
		
	def get_hash(self, name):
		index = name.__hash__() % self.map_size
		while True:
			if not self.__int_dict.has_key(index):
				self.__int_dict[index] = name
				break
			else:
				if self.__int_dict[index] == name:
					break
				else:
					index += 1
					if index >= self.map_size:
						index = 0				
		return index
		
def get_rel_path(path):
	global root
	if root[len(root) -1] == os.sep:
		rel = path[len(root):]
	else:
		rel = path[len(root)+1:]
	rel = rel.replace(os.sep, '\\')
	return rel
		
def write_records(bin_file, c_file, records):
	for record in records:
	  if (record[1]<65535):
			buf = struct.pack('>HH', record[0], record[1])
			line = '\t'
			for byte in buf:
				line += '0x%02x, ' % struct.unpack('B', byte)
			#c_file.write(line)
			bin_file.write(buf)
			buf = struct.pack(str(len(record[2])) + 'sB', record[2], 0)
			line = ''
			for byte in buf:
				line += '0x%02x, ' % struct.unpack('B', byte)
			#c_file.write(line + '\n')
			bin_file.write(buf)
		
def scan_file(file, code, regMacro, regFunc, chg_fd):
	global readonly_mode
	found = False
	changed = False
	if readonly_mode:
		fd = open(file, 'rb')
	else:
		fd = open(file, 'r+b')
		
	outlines = []
	records = []
	lines = fd.readlines()
	for line in lines:
		global strong_scan
		if strong_scan:
				line = line.replace('\r', '')
		mm = regMacro.match(line)
		if not mm is None:
			if not found:
				found = True
				if not mm.group('file_code') == str(code):
					outline = line[:mm.start('file_code')] + str(code) + '\n'
					changed = True
					outlines.append(outline)
				else:
					outlines.append(line)
			else:
				changed = True
				pass #outline = line[mm.end('file_code'):]
		else:
			outlines.append(line)
			mf = regFunc.match(line)
			if not mf is None:
				records.append([code, len(outlines), mf.group('fmt_str')])

	if not found:
		changed = True
	#write back to file
	global root
	if changed or strong_scan:
		if readonly_mode:
			relPath = get_rel_path(file)
			chg_fd.write(relPath + ' \t\t\t' +r'#define TRACE_INFO_FILE ' + str(code) + '\n');
		else:
			fd.seek(0)
			fd.truncate()
			if not found:
				fd.write(r'#define TRACE_INFO_FILE ' + str(code) + '\n')
				#line ++
				for record in records:
					record[1] += 1
		
			fd.writelines(outlines)
			
	fd.close()
	return records
	
def del_macro_in_file(file, regMacro):
	try:
		fd = open(file, 'r+b')
		outlines = []
		lines = fd.readlines()
		for line in lines:
			mm = regMacro.match(line)
			if mm is None:
				outlines.append(line)
				
		fd.seek(0)
		fd.truncate()	
		fd.writelines(outlines)		
		fd.close()
	except IOError:
		pass
	
	
def scan_trace(filemap, out_bin, out_c):
	print 'add macro and scan trace started'
	hm = HashMapper()
	bin_file = open(out_bin, 'wb')
	fd_chg = open(out_c, 'w+')
	#c_file.write(c_file_header)
	#write magic number
	buf = struct.pack('>L', string_record_magic_number)
	bin_file.write(buf)
	line = '\t'
	for byte in buf:
		line += '0x%02x, ' % struct.unpack('B', byte)
	#c_file.write(line + '\n')
	
	global macroPattern
	global funcPattern
	global root
	regMacro = re.compile(macroPattern, re.VERBOSE)
	regFunc = re.compile(funcPattern, re.VERBOSE)
	for file in filemap:
		relPath = get_rel_path(file)
		print 'scan', relPath, '...'
		records = scan_file(file, hm.get_hash(relPath), regMacro, regFunc, fd_chg)
		write_records(bin_file, fd_chg, records)
		
	bin_file.close()
	#c_file.write(c_file_foot)
	fd_chg.close()
	#copy to TraceInfo_Tool folder and Logel_for_TD folder
	logel_path = os.path.join(root, r'tools\DEBUG_TOOL\Logel_for_TD\Bin\Parser')
	if not os.path.exists(logel_path):
		logel_path = os.path.join(root, r'tools\DEBUG_TOOL\Logel_for_TD\Bin')
	bin_copy = os.path.join(logel_path, string_record)
	bin_copy += '.bin'
	shutil.copy(out_bin, bin_copy)
	bin_copy = os.path.join(root, r'PS\sdi\tools\TraceInfo_Tool', string_record)
	bin_copy += '.bin'
	shutil.copy(out_bin, bin_copy)
	print 'trace scan finished'

def del_macros(filemap):
	global macroPattern
	regMacro = re.compile(macroPattern, re.VERBOSE)
	print 'delete macro started'
	for file in filemap:
		print 'delete macro in', file, '...'
		del_macro_in_file(file, regMacro)
		
def usage():
	print __doc__

def main(argv):
	if not len(argv) in [1, 2]:
		usage()
		exit()

	#get root dir
	global root
	global strong_scan
	global readonly_mode
	print sys.argv[0]

	py_dir = os.path.abspath(os.path.dirname(sys.argv[0]))
	root = os.sep.join(py_dir.split(os.sep)[0:-2])
	root += os.sep
	root = os.path.abspath(root)
	print root
	
	del_macro = True
	outbinfile = ''
	outcfile = ''
	if 'help' in argv[0]:
		usage()
		exit()
	elif cmp(argv[0].lower(), 'clean'):
		del_macro = False
		out_dir = argv[0]
		out_dir = os.path.join(root, 'build', out_dir, 'img')
		if not os.path.exists(out_dir):
			os.makedirs(out_dir)
		outbinfile = os.path.join(out_dir, string_record)
		outbinfile += '.bin'
		print "output scan file path is", outbinfile
		outcfile = os.path.join(out_dir, 'need_change_files')
		outcfile += '.txt'
		print "output scan file path is", outcfile
		
	if len(argv) >= 2:
		if argv[1] == 'strong':
			strong_scan = True
		elif argv[1] == 'readonly':
			readonly_mode = True
			
	#get .c file map
	print "collecting .c files ..."
	#get scan folders
	cfg_file = os.path.join(root, 'trace_scan_dirs.txt')
	fd_cfg = open(cfg_file)
	cfg_items = fd_cfg.readlines()
	fd_cfg.close()
	scan_dirs = []
	for cfg_item in cfg_items :
		cfg_item = cfg_item.strip()
		if len(cfg_item) > 0 :
			scan_dirs.append(os.path.join(root, cfg_item))
			
	
	#walk scan folders
	filemap = []
	for scan_dir in scan_dirs :
		print 'scan dir:', scan_dir
		for dir, folders, files in os.walk(scan_dir):
			if not '.svn' in dir:
				for name in files:
					if name[-2:] == '.c':
						filemap.append(os.path.join(dir, name))
		
	if del_macro:
		del_macros(filemap)
	else:
		scan_trace(filemap, outbinfile, outcfile)
					

if __name__ == "__main__":
    main(sys.argv[1:])

    

        
    
