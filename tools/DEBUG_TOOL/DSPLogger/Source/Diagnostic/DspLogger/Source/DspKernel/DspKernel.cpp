/*============================================================================*
 *
 *                          Copyright (c) 2001 Spreadtrum
 *                              All Rights Reserved
 *
 *-----------------------------------------------------------------------------
 *
 * File name:
 *      DspKernel.cpp
 *
 * Description:
 *      DspKernel.dll provides the kernel debugging functions to communicate 
 *      with the DSP module. All of these operations are encapsulated into the
 *      class CDspKernel.
 *
 *      This .cpp file provides the implementation of all the exported functions
 *      of CDspKernel
 *
 * Note:
 *      1. This DLL project is compiled in 4 bytes' alignment.
 *      2. It depends on the SciUart.dll.
 *
 *============================================================================*/


/*============================================================================*
 *                          Edit History
 *-----------------------------------------------------------------------------
 * 2002-08-01   Jun Liu     Created
 *-----------------------------------------------------------------------------
 * 2002-11-13   Kai Liu     Add more functions
 *-----------------------------------------------------------------------------
 * 2006-10-1    andybian    Modify and Add more functions
 *============================================================================*/

/*============================================================================*
 *                          Header files
 *============================================================================*/

#include "stdafx.h"
#include "DspKernel.h"
#include <process.h>
#include <crtdbg.h>
#include <math.h>
#include <WINSOCK2.H>




//teana hu 2009.03.16
#define CONVERT_UINT32(result, source) \
result = (source >> 24) & 0xFF; \
result += ((source >> 16) & 0xFF) << 8; \
result += ((source >> 8) & 0xFF) << 16; \
result += (source & 0xFF) << 24; 

#define CONVERT_UINT16(result, source) \
result = (source >> 8) & 0xFF; \
result += (source & 0xFF) << 8; 

#define CONVERT_DWORD( pSrc ) BYTE tmp=*(pSrc);*(pSrc)=*(pSrc+3);*(pSrc+3)=tmp;tmp=*(pSrc+1);*(pSrc+1)=*(pSrc+2);*(pSrc+2)=tmp;


/*============================================================================*
 *                          global variables
 *============================================================================*/
HANDLE ghInstance				= 0;
DWORD  gdwAllocationGranularity = 0;

/*============================================================================*
 *                          global funtions
 *============================================================================*/
// -----------------------------------------------------------------------------
// Function:
//      DspKernelProc
//
// Discription:
//      entry function of the DspKernel Thread
// 
// -----------------------------------------------------------------------------
UINT WINAPI DspKernelProc(
        LPVOID lpParameter   // thread data
)
{
    CDspKernel* pKernel = (CDspKernel*)lpParameter;
	MSG msg;
	PeekMessage(&msg,NULL,0,0,PM_REMOVE);
	SetEvent(pKernel->m_hThreadEvent);
	while(::GetMessage(&msg,NULL,0,0))
    {
		pKernel->Receive((void*)msg.wParam, msg.lParam);
		Sleep(1);
    }	
    return 0;

}


/*============================================================================*
 *                          DLL main entry
 *============================================================================*/

// -----------------------------------------------------------------------------
// Function:
//      DllMain
//
// Discription:
//      DLL main entry function
// 
// Note:
//      This function is automatically generated by the Application Wizard
// -----------------------------------------------------------------------------
BOOL APIENTRY DllMain(
    HANDLE  hModule, 
    DWORD   ul_reason_for_call, 
    LPVOID  
)
{
    switch ( ul_reason_for_call )
    {
        case DLL_PROCESS_ATTACH:
			ghInstance = hModule;
            SYSTEM_INFO sysInfo;
            ::GetSystemInfo(&sysInfo);
            gdwAllocationGranularity  = sysInfo.dwAllocationGranularity / TP_SIZE;
            
			break;
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        case DLL_PROCESS_DETACH:
            break;
    }

    return TRUE;
}


/*============================================================================*
 *                          Constructor / destructor
 *============================================================================*/

CDspKernel::CDspKernel()
{
	m_bDynDisplay	= FALSE;
    m_pPort			= NULL;
    m_hThread		= NULL;
    m_dwGuiMsgId	= 0;
    m_dwMsgId		= 0;
    m_bPause		= TRUE;
	m_bLogSN		= FALSE;
    m_hGuiWnd		= NULL;
    m_dwThreadId	= NULL;
	m_uChanType		= TOOL_CHANNEL_UART;
	m_dwFrameHead	= 0xFBA5;
	m_preBuf		= -1;
	m_nAddLen		= 0;

	//teana hu 2009.04.02
	memset(&m_FrameHeadBuf, 0, FRAME_HEAD_SIZE);
	m_dwFrameHeadCount = 0;


	//teana hu 2009.05.15
	m_dwGenerateTPTime = TOOL_TIME;
	m_bGenerateOrgFile = TRUE;
	m_fpMemory			= NULL;
	m_fpDump			= NULL;
	m_fpAudio			= NULL;
	m_fpLogSN			= NULL;
	memset(m_szPrefix,	0, MAX_PATH);
	memset(m_szFilePath,0, MAX_PATH);
	memset(m_szDumpFile,0, MAX_PATH);
	memset(m_szMemoryFile,  0, MAX_PATH);
	memset(m_szAudioFile,0, MAX_PATH);
	memset(m_szTPDirectory, 0, MAX_PATH);
	//teana hu 2010.11.25
	memset(&m_byCacheTP, 0, 4);
	m_dwCacheTPNum		= 0;
	memset(&m_byCacheMem, 0, 4);
	m_dwCacheMemNum		= 0;
	memset(&m_byCacheDmp, 0, 4);
	m_dwCacheDmpNum		= 0;
	memset(&m_byCacheAudio, 0, 4);
	m_dwCacheAudioNum	= 0;
	
	//teana hu 2011.03.18 for beijing test
	m_nMemDumpSize	= 0;
	m_dwMemSize		= 0;
	m_dwDumpSize	= 0;
	m_dwAudioSize	= 0;
	
	//teana hu 2011.04.28
	m_pChannel		= NULL;
	memset(&m_ca, 0, sizeof(CHANNEL_ATTRIBUTE));

	//teana hu 2012.04.06
	m_dwD0A0Time	= 0;
	m_bD0A0			= FALSE;
	m_bNotFilterAddr= FALSE;
	memset(&m_wD0A0, 0, sizeof(WORD)*2);
	memset(&m_dwTPCache, 0, sizeof(DWORD)*TP_CACHE_NUM);
	m_nTPCacheIndex = 0;
	m_dwStartTime	= 0;
	m_dwGap			= 0;
	InitializeCriticalSection(&m_CSFile);
	m_hThreadEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
	m_nDsplogType  = E_COMMON_DSP;
	memset(m_szLogSign,0,sizeof(m_szLogSign));
	m_pDesCallBack	= NULL;
}

CDspKernel::~CDspKernel()
{
    m_TPSet.Close();
	CloseDumpFile();
	DeleteCriticalSection(&m_CSFile);
	if (m_hThreadEvent)
	{
		CloseHandle(m_hThreadEvent);
		m_hThreadEvent = NULL;
	}
}


/*============================================================================*
 *                          Implementation of CDspKernel
 *============================================================================*/

// -----------------------------------------------------------------------------
//      Open the UART,connect to the dsp
// -----------------------------------------------------------------------------
BOOL CDspKernel::Connect(
						 HWND   hWnd,               //handle of the window to receive message
						 UINT uChanType,            // Communication type,maybe uart,socket,etc
						 LPVOID lpOpenArgs,         // argument for open communicatin channel
						 DWORD  dwMsgID				/* = 0 */
                        )
{
	BOOL bStatus = FALSE;
    // Clear tpset
    m_TPSet.Close();
	m_TPSet.ClearPos();
	m_uChanType = uChanType;

	//if serial port has open ,close it 
	
	m_dwGuiMsgId = dwMsgID;
	m_hGuiWnd	 = hWnd;
	m_TPSet.SetGuiHwnd(hWnd);
	
    if( uChanType == TOOL_CHANNEL_UART )
    {
		if (m_pPort)
		{
			DisConnect();
		}    
		ResetEvent(m_hThreadEvent);
		if(!CreateScene(hWnd))
		{
			return FALSE;
		}
		WaitForSingleObject(m_hThreadEvent,INFINITE);
		bStatus = ConnectToChannel(m_dwThreadId, (LPBYTE)lpOpenArgs);
    }
    else if( uChanType == TOOL_CHANNEL_SOCKET_CLIENT )
    {
		bStatus = ConnectToCS((LPBYTE)lpOpenArgs);
    }
    return bStatus;
}
BOOL CDspKernel::ConnectToChannel(DWORD dwThreadID, LPBYTE lpOpenPara)
{
	BOOL bOK = FALSE;
	do 
	{
		if( !CreateChannel(&m_pPort,CHANNEL_TYPE_COM))	break;
		m_pPort->SetReceiver(m_dwMsgId,TRUE,(LPCVOID)m_dwThreadId);

		//set org file function
		char szFileName[MAX_PATH]	= {0};
		WCHAR szWFileNamr[MAX_PATH] = {0};
		sprintf(szFileName, "%s\\%s%s.org",m_szFilePath,m_szPrefix,GetLocalTime().c_str());
		MultiByteToWideChar(CP_ACP, 0, szFileName, -1, szWFileNamr, MAX_PATH);
		
		if(m_bGenerateOrgFile)
		{
			m_pPort->InitLog(szWFileNamr,ISpLog::typeBinary|0x0100,SPLOGLV_NONE,NULL,NULL);
		}
		else
		{
			m_pPort->InitLog(szWFileNamr,ISpLog::defaultTextFlag,SPLOGLV_NONE,NULL,NULL);
		}

		//Open the UART    
		CHANNEL_ATTRIBUTE ca;
		LPDWORD lpPort		= (LPDWORD)lpOpenPara;
		ca.ChannelType		= CHANNEL_TYPE_COM;
		ca.Com.dwPortNum	= lpPort[0];
		ca.Com.dwBaudRate	= lpPort[1];
		bOK = m_pPort->Open(&ca);
		
		if( !bOK )
		{
			ReleaseChannel(m_pPort);
			m_pPort = NULL;
			DestroyScene();
		}
	} while(0);

	return 	bOK;
}
// -----------------------------------------------------------------------------
//      Close the UART,disconnect to the dsp and release resourses
// -----------------------------------------------------------------------------
BOOL CDspKernel::DisConnect()
{ 
	if(m_pChannel)
	{
		ExeDiagCmd( MSG_UNREG,ITC_REQ_TYPE,NULL,0,1000,NULL );
		m_pChannel->Close();
		ReleaseDiagChannel(m_pChannel);
		m_pChannel = NULL;
	}
	if(m_pPort)
	{
		DestroyScene();
		m_pPort->Close();
		ReleaseChannel(m_pPort);
		m_pPort = NULL;
	}
	//stop catch tp	
	m_bPause = TRUE; 

	//stop timer
    m_Timer.EndTimer();
    return TRUE;
}

// -----------------------------------------------------------------------------
// Load previous dsplogger file
// -----------------------------------------------------------------------------
BOOL CDspKernel::Load
					(								 // test points count read from file
						LPCTSTR lpFileName           //the destinate file name
					)
{
    return m_TPSet.Load(lpFileName);
}

// -----------------------------------------------------------------------------
// Start parsing and logging test points
// -----------------------------------------------------------------------------
BOOL CDspKernel::Start()
{  
    // Close previous tp set first
    m_TPSet.Close();

	memset(m_szDumpFile,   0, MAX_PATH);
	memset(m_szMemoryFile, 0, MAX_PATH);
	memset(m_szAudioFile,0, MAX_PATH);

	//teana.hu 2009.10.26
	GenerateTPDirectory();
	//GeneratePreFix();
    
    //Start Timer
    m_Timer.BeginTimer();

	if(m_uChanType == TOOL_CHANNEL_SOCKET_CLIENT)
	{
		ExeDiagCmd( MSG_REG,DIAG_MOBILETV_DSP_LOG_F,NULL,0,1000,NULL );
	}
    
    m_bPause = FALSE;
	
	//teana hu 2009.11.11
	AddFlagTime(TRUE);

    return TRUE;
}

// -----------------------------------------------------------------------------
// Stop parsing and logging test points
// -----------------------------------------------------------------------------
BOOL CDspKernel::Stop()
{
    m_bPause = TRUE; 
    
    if (m_TPSet.m_bOnlySaveRct)
    {
        m_TPSet.CombineFile();
    }

	if(m_uChanType == TOOL_CHANNEL_SOCKET_CLIENT)
	{
		ExeDiagCmd( MSG_UNREG,DIAG_MOBILETV_DSP_LOG_F,NULL,0,1000,NULL );
	}
	AddFlagTime(FALSE);
	CloseDumpFile();
	//m_TPSet.Close();
	m_dwMemSize		= 0;
	m_dwDumpSize	= 0;
	m_dwAudioSize	= 0;
    return TRUE;
}
void CDspKernel::CloseDumpFile()
{
	CAutoCS cs( m_CSFile );
	FlushCacheData(IQ_MEMORY_DATA);
	FlushCacheData(DUMP_DATA);
	FlushCacheData(AUDIO_MEM_DATA);
	SAFE_CLOSE_FILE(m_fpDump);
	SAFE_CLOSE_FILE(m_fpMemory);
	SAFE_CLOSE_FILE(m_fpAudio);
	SAFE_CLOSE_FILE(m_fpLogSN);
}

void CDspKernel::FlushCacheData(int nFileType)
{
	FILE* pFile		= NULL;
	int  nCacheSize = 0 ; 
	LPBYTE lpByData = NULL;
	switch(nFileType)
	{
	case IQ_MEMORY_DATA:
		pFile		= m_fpMemory;
		nCacheSize	= m_dwCacheMemNum;
		lpByData	= &(m_byCacheMem[0]);
		m_dwCacheMemNum  = 0;
		break;
	case DUMP_DATA:
		pFile		= m_fpDump;
		nCacheSize	= m_dwCacheDmpNum;
		lpByData	= &(m_byCacheDmp[0]);
		m_dwCacheDmpNum	= 0;
		break;
	case AUDIO_MEM_DATA:
		pFile		= m_fpAudio;
		nCacheSize	= m_dwCacheAudioNum;
		lpByData	= &(m_byCacheAudio[0]);
		m_dwCacheAudioNum = 0;
		break;
	default:
		break;

	}

	if(pFile && nCacheSize>0 && lpByData)
	{
		if(1 == nCacheSize)
		{
		
			fwrite(lpByData, 1, 1, pFile);
			fflush(m_fpMemory);
		}
		else if(2 == nCacheSize)
		{
			fwrite(lpByData+1, 1, 1, pFile);
			fwrite(lpByData,   1, 1, pFile);
		}
		else if(3 == nCacheSize)
		{
			fwrite(lpByData+2, 1, 1, pFile);
			fwrite(lpByData+1, 1, 1, pFile);
			fwrite(lpByData,   1, 1, pFile);

        }
		fflush(pFile);
	}

}
// -----------------------------------------------------------------------------
// Pause parsing and logging test points
// -----------------------------------------------------------------------------
BOOL CDspKernel::Pause()
{
    m_bPause = TRUE;
    return TRUE;
}

// -----------------------------------------------------------------------------
// resume parsing and logging test points
// -----------------------------------------------------------------------------
BOOL CDspKernel::Resume()
{
	AddFlagTime(TRUE);
    m_bPause = FALSE;
    return TRUE;
}


// -----------------------------------------------------------------------------
// return test point set pointer
// -----------------------------------------------------------------------------
ITPSet* CDspKernel::GetTpSet()
{
    return &m_TPSet;
}

// -----------------------------------------------------------------------------
//  set dynamic display
// -----------------------------------------------------------------------------

void CDspKernel::SetDynDisplay(BOOL bDisplay)
{
	m_bDynDisplay= bDisplay;
}
// -----------------------------------------------------------------------------
// Release IDspkernel object
// -----------------------------------------------------------------------------
void CDspKernel::Release()
{
    delete this;
}


void CDspKernel::SetPlaybackData(void* pData, DWORD dwSize, DWORD dwReserve )
{
	if(dwReserve == 1) //0: none; 1: begin; 2: end
	{
		m_Timer.BeginTimer();
	}

	
	ProcessDataStream((unsigned char *)pData, dwSize);
	

	if(dwReserve == 2)
	{
		m_Timer.EndTimer();
	}
}

void CDspKernel::SetFrameHead(DWORD dwFrameHead)
{
	m_dwFrameHead = dwFrameHead;
}

void CDspKernel::SetGenerateFlag(DWORD dwGenerateTPTime, BOOL bGenerateOrgFile)
{
	m_dwGenerateTPTime = dwGenerateTPTime;
	m_bGenerateOrgFile = bGenerateOrgFile;
}

void CDspKernel::SetFilePreFix(LPSTR lpPreFix)
{
	if(lpPreFix != NULL)
	{
		sprintf(m_szPrefix,"%s_",lpPreFix);
		m_TPSet.SetFilePreFix(m_szPrefix);
	}
}

void CDspKernel::SetLogFilePath( char* lpszPath )
{
	strcpy(m_szFilePath, lpszPath);
}

// -----------------------------------------------------------------------------
// Clear all test points
// -----------------------------------------------------------------------------
BOOL CDspKernel::Clear()
{
	if (m_bPause == TRUE)
	{
		m_TPSet.Close();// close tp mapping file
	}
	else
	{
		m_TPSet.Clear();//close tp mapping file and delete it
	}

	if(!m_bPause)
	{
		AddFlagTime(TRUE);
	}
		
    return TRUE;
}

// -----------------------------------------------------------------------------
// Name:
//      Receive
//
// Function:
//      Receive a Dsp frame from the uart
// 
// Discription:
//      not return until finishing all the data or timeout
//      
// -----------------------------------------------------------------------------
UINT CDspKernel::Receive(
		void* pData,  //the data pointer
		DWORD dwSize  //the data block size
		)
{
    if( NULL == pData )
    {
        return 0;
    }

	BYTE* pSrc = (BYTE*)pData;
	if (NULL == pSrc)
	{
		return 0;
	}

	static CProcessByte pb(m_bNotFilterAddr);

	if(m_bPause)
	{	
		if( m_pPort )
		{
			m_pPort->FreeMem( pData);   
		}

		return 0;
	}

	//teana hu 2009.05.18
	ProcessDataStream(pSrc, dwSize, m_bPause);

    if( m_pPort )
    {
        m_pPort->FreeMem(pData); 
    }

    return 0;
}

int CDspKernel::OnChannelEvent( unsigned int event,void* lpEventData )
{
	if( PP_EVENT_BIG_ENDIAN == event )
	{
		m_nEndian = PP_BIG_ENDIAN;
	}
	else if( PP_EVENT_LITTLE_ENDIAN == event )
	{
		m_nEndian = PP_LITTLE_ENDIAN;
	}
	
	if( NULL != lpEventData )
	{
		PRT_BUFF* lpBuff = (PRT_BUFF*)lpEventData;
		lpBuff->free_prt( lpBuff );
	}
	return 0;
}

void CDspKernel::GenerateSaveFile(int nFileType)
{
	//path\\forlder\\Prefix Time LogSign).type
	if (nFileType == IQ_MEMORY_DATA)
	{
		sprintf(m_szMemoryFile, "%s\\%s\\%s%s%s_iq.mem", m_szFilePath, m_szTPDirectory,m_szPrefix,GetLocalTime().c_str(),m_szLogSign);
	}
	else if (nFileType == DUMP_DATA)
	{
		sprintf(m_szDumpFile, "%s\\%s\\%s%s%s.dump", m_szFilePath,m_szTPDirectory, m_szPrefix,GetLocalTime().c_str(),m_szLogSign);
	}
	else if (nFileType == AUDIO_MEM_DATA)
	{
		sprintf(m_szAudioFile, "%s\\%s\\%s%s%s_audio.mem", m_szFilePath,m_szTPDirectory, m_szPrefix,GetLocalTime().c_str(),m_szLogSign);
	}
	else if (LOG_SN_INFO == nFileType)
	{
		sprintf(m_szLogSNFile, "%s\\%s\\%s%s_SN.csv", m_szFilePath,m_szTPDirectory, m_szPrefix,GetLocalTime().c_str());
	}
}

void CDspKernel::SetDspLogType( int nType)
{
	m_nDsplogType = nType;
	switch(nType)
	{
	case E_LTE_DSP:
		strcpy(m_szLogSign, "_lte");
		break;
	case E_TG_DSP:
		strcpy(m_szLogSign, "_tg");
		break;
	case E_W_DSP:
		strcpy(m_szLogSign, "_w");
		break;
	case E_AG_DSP:
		strcpy(m_szLogSign, "_ag");
		break;
	default:
		m_nDsplogType = E_COMMON_DSP;
		strcpy(m_szLogSign, "");
		break;
	}
	m_TPSet.SetLogSign(m_szLogSign);
	CloseDumpFile();
}
BOOL	CDspKernel::LogSNFile(char* szLog)
{
	BOOL bOK = FALSE;
	do 
	{
		if(!m_bLogSN)
		{
			break;
		}
		if ( NULL == szLog || 0 == strlen(szLog))
		{
			break;
		}
		if(m_fpLogSN == NULL)
		{
			GenerateSaveFile(LOG_SN_INFO);
			m_fpLogSN = fopen(m_szLogSNFile, "ab");
			if(m_fpLogSN == NULL)
			{
				break;
			}
			else
			{
				char szTitle[MAX_PATH] = {0};
				sprintf(szTitle,"SN,LEN,Subtype,SN(hex),Len(hex)\n");
				fwrite(szTitle,strlen(szTitle),1,m_fpLogSN);			
				fflush(m_fpLogSN);
			}
		}

		fwrite(szLog,strlen(szLog),1,m_fpLogSN);			
		fflush(m_fpLogSN);

	} while(0);
	return bOK;
}
BOOL CDspKernel::SaveMemFile(const BYTE* pData, DWORD dwDataLen)
{
	BOOL bOK = FALSE;
	BYTE* pSrc		= (BYTE* )pData;
	DWORD dwSize	= dwDataLen;
	CAutoCS cs( m_CSFile );
	do 
	{
		if ( NULL == pSrc || 0 == dwSize || m_bPause)
		{
			break;
		}

		::PostMessage(m_hGuiWnd, WM_REFLASH_STATUSBAR, NULL, 0);
		if(m_fpMemory == NULL)
		{
			GenerateSaveFile(IQ_MEMORY_DATA);
			m_fpMemory = fopen(m_szMemoryFile, "ab");
			if(m_fpMemory == NULL)
			{
				break;
			}
		}
		
		if( m_nEndian == PP_BIG_ENDIAN )
		{
			// User choose big endian
			fwrite(pSrc, 1, dwSize, m_fpMemory);
			fflush(m_fpMemory);
		}
		else
		{
			if( m_dwCacheMemNum )
			{
				if( m_dwCacheMemNum + dwSize < 4 )
				{
					memcpy( m_byCacheMem+m_dwCacheMemNum,pSrc,dwSize );
					m_dwCacheMemNum += dwSize;
					bOK = TRUE;
					break;
				}
				else
				{
					DWORD dwMove = 4 - m_dwCacheMemNum;
					memcpy( m_byCacheMem+m_dwCacheMemNum,pSrc,dwMove );
					CONVERT_DWORD( m_byCacheMem );
					fwrite( m_byCacheMem,1,4,m_fpMemory );
					m_dwCacheMemNum = 0;
					pSrc += dwMove;
					dwSize -= dwMove;
				}
			}
			
			m_dwCacheMemNum = dwSize % 4;
			dwSize -= m_dwCacheMemNum;
			for( int i=0;i<(int)dwSize;i+=4 )
			{
				CONVERT_DWORD( pSrc+i );
			}
			
			fwrite(pSrc, 1, dwSize, m_fpMemory);
			fflush(m_fpMemory);
			
			if( m_dwCacheMemNum )
			{
				memcpy( m_byCacheMem,pSrc+dwSize,m_dwCacheMemNum );
			}
			
		}
		bOK = TRUE;
		
		if(m_nMemDumpSize > 0)
		{
			m_dwMemSize += dwSize;
			if((int)m_dwMemSize >= m_nMemDumpSize)
			{
				SAFE_CLOSE_FILE(m_fpMemory);
				memset(m_szMemoryFile, 0, MAX_PATH);

				GenerateSaveFile(IQ_MEMORY_DATA);
				m_fpMemory = fopen(m_szMemoryFile, "ab");
				if(m_fpMemory == NULL)
				{
					bOK = FALSE;
					break;
				}
				m_dwMemSize = 0;
			}
		}
	} while(0);
	return bOK;

}

BOOL CDspKernel::SaveDumpFile(const BYTE* pData, DWORD dwDataLen)
{
	BOOL bOK = FALSE;
	BYTE* pSrc		= (BYTE* )pData;
	DWORD dwSize	= dwDataLen;
	CAutoCS cs( m_CSFile );
	do 
	{
		if ( NULL == pSrc || 0 == dwSize || m_bPause)
		{
			break;
		}
		if(m_fpDump == NULL)
		{
			GenerateSaveFile(DUMP_DATA);
			m_fpDump = fopen(m_szDumpFile, "ab");
			if(m_fpDump == NULL)
			{
				break;
			}
		}
		
		if( m_nEndian == PP_BIG_ENDIAN)
		{
			// User choose big endian
			fwrite(pSrc, 1, dwSize, m_fpDump);
			fflush(m_fpDump);
		}
		else
		{
			if( m_dwCacheDmpNum )
			{
				if( m_dwCacheDmpNum + dwSize < 4 )
				{
					memcpy( m_byCacheDmp+m_dwCacheDmpNum,pSrc,dwSize );
					m_dwCacheDmpNum += dwSize;
					break;
				}
				else
				{
					DWORD dwMove = 4 - m_dwCacheDmpNum;
					memcpy( m_byCacheDmp+m_dwCacheDmpNum,pSrc,dwMove );
					CONVERT_DWORD( m_byCacheDmp );
					fwrite( m_byCacheDmp,1,4,m_fpDump );
					m_dwCacheDmpNum = 0;
					pSrc += dwMove;
					dwSize -= dwMove;
				}
			}
			
			m_dwCacheDmpNum = dwSize % 4;
			dwSize -= m_dwCacheDmpNum;
			for( int i=0;i<(int)dwSize;i+=4 )
			{
				CONVERT_DWORD( pSrc+i );
			}
			
			fwrite(pSrc, 1, dwSize, m_fpDump);
			fflush(m_fpDump);
			
			if( m_dwCacheDmpNum )
			{
				memcpy( m_byCacheDmp,pSrc+dwSize,m_dwCacheDmpNum );
			}
		}
		bOK = TRUE;
		if(m_nMemDumpSize > 0)
		{
			m_dwDumpSize += dwSize;
			if((int)m_dwDumpSize >= m_nMemDumpSize)
			{
				SAFE_CLOSE_FILE(m_fpDump);
				memset(m_szDumpFile, 0, MAX_PATH);
				GenerateSaveFile(DUMP_DATA);
				m_fpDump = fopen(m_szDumpFile, "ab");
				if(m_fpDump == NULL)
				{
					bOK = FALSE;
					break;;
				}
				m_dwDumpSize = 0;
			}
		}
	}while(0);

	return bOK;
}


BOOL CDspKernel::SaveAudioFile(const BYTE* pData, DWORD dwDataLen)
{
	BOOL bOK		= FALSE;
	BYTE* pSrc		= (BYTE* )pData;
	DWORD dwSize	= dwDataLen;
	CAutoCS cs( m_CSFile );
	do 
	{
		if ( NULL == pSrc || 0 == dwSize || m_bPause)
		{
			break;
		}
		if(m_fpAudio == NULL)
		{
			GenerateSaveFile(AUDIO_MEM_DATA);
			m_fpAudio = fopen(m_szAudioFile, "ab");
			if(m_fpAudio == NULL)
			{
				break;
			}
		}
		
		if( m_nEndian == PP_BIG_ENDIAN)
		{
			// User choose big endian
			fwrite(pSrc, 1, dwSize, m_fpAudio);
			fflush(m_fpAudio);
		}
		else
		{
			if( m_dwCacheAudioNum )
			{
				if( m_dwCacheAudioNum + dwSize < 4 )
				{
					memcpy( m_byCacheAudio+m_dwCacheAudioNum,pSrc,dwSize );
					m_dwCacheAudioNum += dwSize;
					break;
				}
				else
				{
					DWORD dwMove = 4 - m_dwCacheAudioNum;
					memcpy( m_byCacheAudio+m_dwCacheAudioNum,pSrc,dwMove );
					CONVERT_DWORD( m_byCacheAudio );
					fwrite( m_byCacheAudio,1,4,m_fpAudio );
					m_dwCacheAudioNum = 0;
					pSrc += dwMove;
					dwSize -= dwMove;
				}
			}
			
			m_dwCacheAudioNum = dwSize % 4;
			dwSize -= m_dwCacheAudioNum;
			for( int i=0;i<(int)dwSize;i+=4 )
			{
				CONVERT_DWORD( pSrc+i );
			}
			
			fwrite(pSrc, 1, dwSize, m_fpAudio);
			fflush(m_fpAudio);
			
			if( m_dwCacheAudioNum )
			{
				memcpy( m_byCacheAudio,pSrc+dwSize,m_dwCacheAudioNum );
			}
		}
		bOK = TRUE;
		if(m_nMemDumpSize > 0)
		{
			m_dwAudioSize += dwSize;
			if((int)m_dwAudioSize >= m_nMemDumpSize)
			{
				SAFE_CLOSE_FILE(m_fpAudio);
				memset(m_szAudioFile, 0, MAX_PATH);
				GenerateSaveFile(AUDIO_MEM_DATA);
				m_fpAudio = fopen(m_szAudioFile, "ab");
				if(m_fpAudio == NULL)
				{
					bOK = FALSE;
					break;;
				}
				m_dwAudioSize = 0;
			}
		}
	}while(0);
	
	return bOK;
}
void CDspKernel::ProcessTpPakge(const BYTE* pData, DWORD dwDataLen)
{

	BYTE* pSrc		= (BYTE* )pData;
	DWORD dwSize	= dwDataLen;
	if (NULL == pSrc || 0 == dwSize)
	{
		return;
	}
	if (PP_LITTLE_ENDIAN != m_nEndian)
	{
		ProcessDataStream(pSrc, dwSize, m_bPause);
	}
	else // PP_LITTLE_ENDIAN == m_nEndian
	{
		// User choose little endian
		
		if( dwSize + m_dwCacheTPNum < 4 )
		{
			memcpy( m_byCacheTP+m_dwCacheTPNum,pSrc,dwSize );
			m_dwCacheTPNum += dwSize;
			return;
		}

		int nStart = 0;
		int nRet = (dwSize + m_dwCacheTPNum) % 4;	
		int nBufLen = dwSize - nRet + m_dwCacheTPNum;
		LPBYTE lpBuf = new BYTE[nBufLen];
		if (lpBuf)
		{
			int nNum = (dwSize + m_dwCacheTPNum) / 4;			
			switch(m_dwCacheTPNum) 
			{
			case 1:
				lpBuf[3] = m_byCacheTP[0];
				lpBuf[2] = *pSrc;
				lpBuf[1] = *(pSrc + 1);
				lpBuf[0] = *(pSrc + 2);
				pSrc += 3;
				dwSize -= 3;				
				nStart = 1;
				break;
			case 2:
				lpBuf[3] = m_byCacheTP[0];
				lpBuf[2] = m_byCacheTP[1];
				lpBuf[1] = *pSrc;
				lpBuf[0] = *(pSrc + 1);
				pSrc += 2;
				dwSize -= 2;
				nStart = 1;
				break;
			case 3:
				lpBuf[3] = m_byCacheTP[0];
				lpBuf[2] = m_byCacheTP[1];
				lpBuf[1] = m_byCacheTP[2];
				lpBuf[0] = *pSrc;
				pSrc += 1;
				dwSize -= 1;
				nStart = 1;
				break;
			default:
				break;
			}
			
			for(int i = nStart; i < nNum; i++)
			{
				lpBuf[i * 4	   ] = *(pSrc + (i-nStart) * 4 + 3);
				lpBuf[i * 4 + 1] = *(pSrc + (i-nStart) * 4 + 2);
				lpBuf[i * 4 + 2] = *(pSrc + (i-nStart) * 4 + 1);
				lpBuf[i * 4 + 3] = *(pSrc + (i-nStart) * 4);
			}
			if (0 != nNum)
			{
				int nOffset = (nNum-1)*4;
				pSrc += nOffset;
			}
					
			ProcessDataStream(lpBuf, nBufLen, m_bPause);
			
			if(nRet != 0)
			{
				memcpy(&m_byCacheTP, pSrc, nRet);
			}
			m_dwCacheTPNum = nRet;
			delete [] lpBuf;
		}	
	}

}
int CDspKernel::OnChannelData(LPVOID lpData, ULONG /*reserved*/ )
{
	PRT_BUFF* lpBuff = (PRT_BUFF*)lpData;
	if (NULL == lpBuff)	
	{
		return 0;
	}
	
	do 
	{
		DIAG_HEADER* lpHead = (DIAG_HEADER*)lpBuff->lpData;
		if( NULL ==lpHead  || lpBuff->size < sizeof( DIAG_HEADER ) )
		{
			break;
		}

		
		if( DIAG_MOBILETV_DSP_LOG_F == lpHead->type	)
		{
			char szLogType[MAX_PATH*2] = {0};
			DWORD dwSize = lpBuff->size - sizeof(DIAG_HEADER);
			BYTE* pSrc = lpBuff->lpData + sizeof(DIAG_HEADER);
			if ( ((lpHead->subtype & 0xF0) >>4) == m_nDsplogType	)
			{
				
				if( (lpHead->subtype & 0x0F) == IQ_MEMORY_DATA)		//IQ memory data
				{
					SaveMemFile(pSrc,dwSize);
				}
				else if ((lpHead->subtype & 0x0F) == DUMP_DATA)		//dump data
				{
					SaveDumpFile(pSrc,dwSize);
				}
				else if ((lpHead->subtype & 0x0F) == AUDIO_MEM_DATA)	//audio memroy data
				{
					SaveAudioFile(pSrc,dwSize);
				}
				else if ( (lpHead->subtype & 0x0F) == TP_DATA) //tp data
				{
					ProcessTpPakge(pSrc,dwSize);
				}	
			}
			sprintf(szLogType,"%d,%d,0x%X,0x%08X,0x%04X\n",lpHead->sn,dwSize,lpHead->subtype,lpHead->sn,dwSize);
			LogSNFile(szLogType);
		}
	
		else if(lpHead->type == ITC_REQ_TYPE && lpHead->subtype == ITC_REP_SUBTYPE)
		{
			if( lpBuff->size == sizeof( DIAG_HEADER ) + sizeof( ITC_Rep_T ) )
			{
				ITC_Rep_T* lpRep = (ITC_Rep_T*)(lpBuff->lpData + sizeof( DIAG_HEADER ) );
				if( Query_Endian == lpRep->dwReqType )
				{
					m_nEndian = ( lpRep->dwRetCode & 0xFF );
					::PostMessage(m_hGuiWnd, WM_NOTICE_ENDIAN, NULL, m_nEndian);
				}
			}
			else
			{
				::PostMessage(m_hGuiWnd, WM_NOTICE_ENDIAN, NULL, PP_UNKOWN_ENDIAN);
			}
		}


	} while(0);

	lpBuff->free_prt( lpBuff );	
	return 0;
}
/*============================================================================*
 *                          Private Functions
 *============================================================================*/
// -----------------------------------------------------------------------------
// Name:
//      CreateMsgThread
//
// Function:
//      Create a thread to receive the messages from uart 
//      
// -----------------------------------------------------------------------------
BOOL CDspKernel::QueryEndian()
{
	BOOL bRet = FALSE;
	
	if( m_uChanType == TOOL_CHANNEL_SOCKET_CLIENT )
	{
		LPBYTE lpBuf = new BYTE[PROTOCOL_HEADER_SIZE + sizeof(ITC_Req_T)];
		if (lpBuf)
		{
			Protocol_Header ph;
			ph.type = ITC_REQ_TYPE;
			ph.subtype = ITC_REQ_SUBTYPE;
			ph.length = PROTOCOL_HEADER_SIZE + sizeof(ITC_Req_T);
			ph.sequenceNum = SPECIAL_SN;
			
			ITC_Req_T ItcReq;
			memset(&ItcReq, 0, sizeof(ITC_Req_T));
			ItcReq.dwReqType = Query_Endian;
			_tcscpy(ItcReq.szToolName, "DSP Logger - [Test Points]");
			
			memcpy(lpBuf, &ph, PROTOCOL_HEADER_SIZE);		
			memcpy(lpBuf + PROTOCOL_HEADER_SIZE, &ItcReq, sizeof(ITC_Req_T));
			
			ExeDiagCmd(ITC_REQ_TYPE,ITC_REQ_SUBTYPE,lpBuf,PROTOCOL_HEADER_SIZE + sizeof(ITC_Req_T),3000,NULL);
			
			delete [] lpBuf;
		}
		
	}
	
	return bRet;
}

// -----------------------------------------------------------------------------
// Name:
//      CreateScene
//
// Function:
//      Create the scene to be ready to receive the message
//      
// Note:
//      This function do not open uart
// -----------------------------------------------------------------------------
BOOL CDspKernel::CreateScene(	
							 HWND hWnd      //handle of the gui window to receive the message
							 )
{
    //create the thread
	m_hThread = (HANDLE)_beginthreadex(NULL,0,DspKernelProc,(void*)this,0,&m_dwThreadId);
	if(NULL == m_hThread)	
	{
		return FALSE;
	}

	//get the unique message id
	m_dwMsgId = RegisterWindowMessage("UART Data Message");

    return TRUE;
}

// -----------------------------------------------------------------------------
// Name:
//      DestroyScene
//
// Function:
//      Destroy the scene created by CreateScene
//      
// -----------------------------------------------------------------------------
BOOL CDspKernel::DestroyScene()
{
    //detroy the message window
	if (m_hThread)
	{  
		PostThreadMessage(m_dwThreadId,WM_QUIT,0,0);
		WaitForSingleObject(m_hThread,3000);
		CloseHandle(m_hThread);
		m_hThread = NULL; 
	}
   
    return TRUE;
}

IDspKernel* CreateDspKernel()
{
    return new CDspKernel;
}

void WINAPI CDspKernel::SetCBDescripTionFunc(PFCBLookUpDescription pFunc)
{
	if(pFunc == NULL)
	{
		return;
	}
	m_pDesCallBack = pFunc;
}

// -----------------------------------------------------------------------------
// Export to text file
// -----------------------------------------------------------------------------
BOOL CDspKernel::Export(
                    LPCTSTR lpszSrcFile,        // Source file full path name,if NULL,export current file
                    LPCTSTR lpszDesFile,        // Destinate file full path name,can not be null
                    LONGLONG llStart,           // From which to export
                    LONGLONG llCount,            // How many test points to be exported
					DWORD	dwType				//file type, *.log, *.org....
                    )
{
    if( NULL == lpszDesFile )
    {
        // Destinate file can not be null
        return FALSE;
    }

    CMassTPSet tpSet;
    ITPSet* pTpSet = NULL;

    if( NULL == lpszSrcFile || 0 == strlen( lpszSrcFile ) )
    {
        // Try to use current opened tp file
        if( 0 == m_TPSet.GetTpCount() )
        {
            // No test points
            return FALSE;
        }
        else
        {
            pTpSet = &m_TPSet;
        }
    }
    else
    {
        if( !tpSet.Load( lpszSrcFile ) )
        {
            // Can not load test point file
            return FALSE;
        }
        else
        {
            pTpSet = &tpSet;
        }
    }

    LONGLONG count = pTpSet->GetTpCount();

    if ( llStart >= count )
    {
        // No test point export
        return FALSE;
    }

    if( llStart < 0 )
    {
        llStart = 0;
    } 

    if( -1 == llCount )
    {
        llCount = count;
    }
    else if( llStart + llCount > count )
    {
        // Exactly count to be exported
        llCount = count - llStart;
    }


	switch(dwType) {
	case FILE_LOG_UNDES:
		{
			FILE* pf = fopen( lpszDesFile,"w" );
			if( NULL == pf )
			{
				// Could not open file
				return FALSE;
			}
			for(LONGLONG i = llStart;i < llCount+llStart;i++)
			{
				fprintf(pf,"%04X    %04X    %8d\n",pTpSet->GetTPAddr((ULONG)i),pTpSet->GetTPData((ULONG)i),(ULONG)pTpSet->GetTPTime((ULONG)i));
			}
			SAFE_CLOSE_FILE(pf);
		}
		break;
	case FILE_LOG_ADDDES:
		{
			FILE* pf = fopen( lpszDesFile,"w" );
			if( NULL == pf )
			{
				// Could not open file
				return FALSE;
			}
			for(LONGLONG i = llStart;i < llCount+llStart;i++)
			{
				char szDesc[MAX_LUA_DESCTRIPTION_LEN] = {0};
				if (m_pDesCallBack)
				{
					m_pDesCallBack((int)pTpSet->GetTPAddr((ULONG)i), (int)pTpSet->GetTPData((ULONG)i),szDesc,MAX_LUA_DESCTRIPTION_LEN);
				}
				fprintf(pf,"%04X    %04X    %8d    %s\n",
					pTpSet->GetTPAddr((ULONG)i),
					pTpSet->GetTPData((ULONG)i),
					(ULONG)pTpSet->GetTPTime((ULONG)i),
					szDesc);
			}
			SAFE_CLOSE_FILE(pf);
		}
		break;
	case FILE_ORG:
		{	
			FILE* pf = fopen( lpszDesFile,"wb" );
			if( NULL == pf )
			{
				// Could not open file
				return FALSE;
			}
			for(LONGLONG i = llStart;i < llCount+llStart;i++)
			{
				WORD wAddr = pTpSet->GetTPAddr((ULONG)i);
				WORD wData = pTpSet->GetTPData((ULONG)i);
				if(wAddr != 0xFFFF)
				{
					WORD wTmp = 0;
					CONVERT_UINT16(wTmp, wAddr);
					wAddr = wTmp;
					CONVERT_UINT16(wTmp, wData);
					wData = wTmp;
					fwrite(&wAddr, 1, sizeof(WORD), pf);
					fwrite(&wData, 1, sizeof(WORD), pf);
				}
				else
				{
					BYTE bt = (BYTE)(wData & 0x00FF);
					fwrite(&bt, 1, 1, pf);
				}
				fflush(pf);
			}
			SAFE_CLOSE_FILE(pf);
			
		}
		break;
	default:
		break;
	}

    return TRUE;
}

BOOL CDspKernel::SaveTP(
					LPCTSTR lpszDesFile        // Destinate file full path name,can not be null
					)

{
	ITPSet* pTpSet = NULL;

    if( NULL == lpszDesFile )
    {
        // Destinate file can not be null
        return FALSE;
    }
    
    if( NULL == lpszDesFile || 0 == strlen( lpszDesFile  ) ) return FALSE;

	// Try to use current opened tp file
	if( 0 == m_TPSet.GetTpCount() )
	{
		// No test points
		return FALSE;
	}
	else
	{
		pTpSet = &m_TPSet;
	}
    
    LONGLONG count = pTpSet->GetTpCount();

    FILE* pf = fopen( lpszDesFile,"wb+" );
    if( NULL == pf )
    {
        // Could not open file
        return FALSE;
    }

    for(LONGLONG i = 0;i < count;i++)
    {
		DWORD Data[2];
		Data[0]= pTpSet->GetTPAddr((ULONG)i)<<16 | pTpSet->GetTPData((ULONG)i); 
		Data[0] = (DWORD)(ConvertEndian( Data[0] ) );			
		
		Data[1] =pTpSet->GetTPTime((ULONG)i);
		fwrite(Data,TP_ITEM_SIZE,2,pf);			
	}

    SAFE_CLOSE_FILE(pf);

	//teana hu 2009.06.17
	if(m_szMemoryFile[0] != '\0')
	{
		char szMemoryFile[MAX_PATH] = {0};
		
		strncpy(szMemoryFile, lpszDesFile, strlen(lpszDesFile) - 3);
		strcat(szMemoryFile, ".mem");		
		CopyFile(m_szMemoryFile, szMemoryFile, FALSE);
	}

	if(m_szDumpFile[0] != '\0')
	{
		char szDumpFile[MAX_PATH] = {0};
		
		strncpy(szDumpFile, lpszDesFile, strlen(lpszDesFile) - 3);
		strcat(szDumpFile, ".dump");
		CopyFile(m_szDumpFile, szDumpFile, FALSE);
	}

	if(m_szAudioFile[0] != '\0')
	{
		char szAudioFile[MAX_PATH] = {0};
		
		strncpy(szAudioFile, lpszDesFile, strlen(lpszDesFile) - 3);
		strcat(szAudioFile, "_audio.mem");
		CopyFile(m_szAudioFile, szAudioFile, FALSE);
	}
	

    return TRUE;
}


BOOL CDspKernel::ConnectToCS(LPBYTE lpOpenPara)
{
	DWORD  dwPort;
    DWORD  dwIPAddress;
	char  szIpaddr[16];
    
    dwPort		= *(DWORD *)&lpOpenPara[ 0 ];
    dwIPAddress =  *(DWORD *)&lpOpenPara[ 4 ];

	sprintf(szIpaddr, "%d.%d.%d.%d",
		FOURTH_IPADDRESS(dwIPAddress),
		THIRD_IPADDRESS(dwIPAddress),
		SECOND_IPADDRESS(dwIPAddress),
		FIRST_IPADDRESS(dwIPAddress)           
		);

	m_ca.ChannelType	= CHANNEL_TYPE_SOCKET;
	m_ca.Socket.dwFlag	= SC_TYPE_CLIENT;
	m_ca.Socket.dwIP	= ntohl(inet_addr(szIpaddr));
	m_ca.Socket.dwPort	= dwPort;

	if( NULL == m_pChannel )
	{
		if( !CreateDiagChannel( &m_pChannel ) )
		{
			return FALSE;
		}
	}
    
    if( CHANNEL_TYPE_SOCKET == m_ca.ChannelType )
	{
		// Set diag type
		m_pChannel->SetProperty( 0,PPI_DIAG_Type,(void*)DIAG_TYPE_NO_HEADER );
		
		// Set endian
		m_pChannel->SetProperty( 0,PPI_Endian,(void*)(PP_LITTLE_ENDIAN << 8 | PP_LITTLE_ENDIAN));
	}
	
	m_pChannel->AddObserver( this );
    BOOL bConnected = m_pChannel->Open( &m_ca );
	
    if ( !bConnected )
    {
        DisConnect();
        return FALSE;
    }

	ExeDiagCmd( MSG_REG,ITC_REQ_TYPE,NULL,0,1000,NULL );
    return TRUE;
}

BOOL CDspKernel::ExeDiagCmd( BYTE type,BYTE subtype,LPBYTE lpData,DWORD dwLen,DWORD dwTimeout,PRT_BUFF** lppBuff )
{
	DIAG_PACKAGE dp;
	if(lpData == NULL)
	{
		dp.header.type = type;
		dp.header.subtype = subtype;
		dp.header.sn = SPECIAL_SN;
		dp.header.len = dwLen;
		dp.data = lpData;
	}
	else
	{
		memcpy( (LPBYTE)(&(dp.header)), lpData, sizeof( DIAG_HEADER ) );
		dp.header.len = dwLen - sizeof( DIAG_HEADER );
		dp.data = lpData + sizeof( DIAG_HEADER );
	}

	PRT_WRITE_T pwt;
	pwt.nCond = -1;
	pwt.action = PRT_WRITE_no_respond;
	pwt.lpProtocolData = &dp;
	
	m_pChannel->Write( &pwt,1 );
	
	return TRUE;
}

void CDspKernel::GeneratePreFix()
{
	if (0 == strlen(m_szPrefix))
	{
		sprintf(m_szPrefix, "%s", GetLocalTime().c_str());	
	}
}

void CDspKernel::GenerateTPDirectory()
{
	ZeroMemory(m_szTPDirectory, MAX_PATH);
	sprintf(m_szTPDirectory, "%s",GetLocalTime().c_str());
	m_TPSet.SetTPDirectory(m_szTPDirectory);
}
void CDspKernel::ProcessToolTime(LPBYTE pSrcBuf, DWORD dwSize,CProcessByte& pb)
{
	if (NULL == pSrcBuf)
	{
		return;
	}
	LPBYTE pSrc = pSrcBuf;
/*	for(UINT i=0; i<dwSize;)
	{
		BOOL bRet = pb.ProcessByte(*pSrc);
		if(bRet)
		{
			BYTE* pBuf   = pb.GetData();
			DWORD dwTime = m_Timer.GetTickCount();	
			m_TPSet.AddTp(pBuf, dwTime);
		}
		
		++i;
		++pSrc;
	}*/

	//////////////////////////////////////////////////////////////////////////
	for(UINT i=0; i<dwSize;)
	{
		if(!pb.IsFullData())
		{
			BOOL bRet = pb.ProcessByte(*pSrc);
			if(bRet)
			{
				BYTE* pBuf   = pb.GetData();
				DWORD dwTime = m_Timer.GetTickCount();	
				m_TPSet.AddTp(pBuf, dwTime);
			}
			
			++i;
			++pSrc;
		}
		else if(*pSrc == ((m_dwFrameHead & 0xFF00) >> 8) || m_dwFrameHead > 0)//for 0xFBA5 ......
		{
			int nSize = dwSize - i;
			DWORD dwCount = AddFrameHead(pSrc, nSize);
			i += dwCount;
			pSrc += dwCount;
			nSize -= dwCount;
			
			if(m_dwFrameHeadCount == FRAME_HEAD_SIZE)
			{
				int nRet = ProcessFrameData(pSrc, nSize);
				if(nRet != -1)
				{
					pSrc += m_nAddLen;
					i += m_nAddLen;
					m_nAddLen = 0;
					if(nRet == 0)
					{
						m_dwFrameHeadCount = 0; 
						ZeroMemory(m_FrameHeadBuf, FRAME_HEAD_SIZE);
						m_preBuf = -1;
					}
				}
				else
				{
					for(int j = 0; j < FRAME_HEAD_SIZE; j++)
					{
						BOOL bRet = pb.ProcessByte(m_FrameHeadBuf[j]);
						if(bRet)
						{
							BYTE* pBuf   = pb.GetData();
							DWORD dwTime = m_Timer.GetTickCount();			
							m_TPSet.AddTp(pBuf, dwTime);
						}
					}
					m_dwFrameHeadCount = 0;
					ZeroMemory(m_FrameHeadBuf, FRAME_HEAD_SIZE);
					m_preBuf = -1;
				}
			}
			else if(m_dwFrameHeadCount == 0) // is not frame head or empty
			{
				for(int j = 0; j < FRAME_HEAD_SIZE; j++)
				{
					BOOL bRet = pb.ProcessByte(m_FrameHeadBuf[j]);
					if(bRet)
					{
						BYTE* pBuf   = pb.GetData();
						DWORD dwTime = m_Timer.GetTickCount();			
						m_TPSet.AddTp(pBuf, dwTime);
					}
				}
				ZeroMemory(m_FrameHeadBuf, FRAME_HEAD_SIZE);
			}
		}
		else
		{
			BOOL bRet = pb.ProcessByte(*pSrc);
			if(bRet)
			{
				BYTE* pBuf   = pb.GetData();
				DWORD dwTime = m_Timer.GetTickCount();			
				m_TPSet.AddTp(pBuf, dwTime);
			}
			
			++i;
			++pSrc;
		}					
	}
}

void CDspKernel::ProcessPhoneTime(LPBYTE pSrcBuf, DWORD dwSize,CProcessByte& pb)
{
	if (NULL == pSrcBuf)
	{
		return;
	}
	LPBYTE pSrc = pSrcBuf;
	for(UINT i=0; i<dwSize; ++i, ++pSrc)
	{
		if(!pb.IsFullTime())
		{
			BOOL bRet = pb.ProcessTime(*pSrc);
			if(bRet)
			{
				BYTE* pBuf = pb.GetData();
				DWORD dwTemp = pb.GetTime();
				DWORD dwTime = 0;
				CONVERT_UINT32(dwTime, dwTemp);
				m_TPSet.AddTp(pBuf, dwTime);
			}
		}
		else
		{
			BOOL bRet = pb.ProcessByte(*pSrc);
			if(bRet)
			{
				// Receive an test point
				BYTE* pBuf   = pb.GetData();
				if(pb.IsLoseData())
				{
					DWORD dwTime = m_Timer.GetTickCount();
					m_TPSet.AddTp(pBuf, dwTime);
					continue;
				}
				
				++i;
				++pSrc;
				for(int j = i; j < (int)dwSize; ++j,++i,++pSrc)
				{
					BOOL bResult = pb.ProcessTime(*pSrc);
					if(bResult)
					{
						DWORD dwTemp = pb.GetTime();
						DWORD dwTime = 0;
						CONVERT_UINT32(dwTime, dwTemp);
						m_TPSet.AddTp(pBuf, dwTime);
						break;
					}
				}
			}
		}
	}
}

void CDspKernel::ProcessD0A0Time(LPBYTE pSrcBuf, DWORD dwSize,CProcessByte& pb)
{
	if (NULL == pSrcBuf)
	{
		return;
	}
	LPBYTE pSrc = pSrcBuf;
	for(UINT i=0; i<dwSize; ++i, ++pSrc)
	{
		BOOL bRet = pb.ProcessByte(*pSrc);
		if(bRet)
		{
			BYTE* pBuf   = pb.GetData();
			if(pBuf[0] == 0xD0 && pBuf[1] == 0xA0)
			{
				if(m_bD0A0)
				{
					CONVERT_UINT16(m_wD0A0[1], *((WORD *)&pBuf[2]));
					m_dwD0A0Time = 0;
					m_dwD0A0Time |= m_wD0A0[0];
					m_dwD0A0Time = m_dwD0A0Time << 16;
					m_dwD0A0Time |= m_wD0A0[1];
					m_bD0A0 = FALSE;
				}
				else
				{
					CONVERT_UINT16(m_wD0A0[0], *((WORD *)&pBuf[2]));
					m_bD0A0 = TRUE;
				}
			}
			else if(m_bD0A0)
			{
				m_bD0A0 = FALSE;
				memset(&m_wD0A0, 0, sizeof(WORD) * 2);
			}
			
			if(m_dwD0A0Time == 0 && m_nTPCacheIndex < TP_CACHE_NUM)
			{
				m_dwTPCache[m_nTPCacheIndex] = *((DWORD *)pBuf);
				++m_nTPCacheIndex;
			}
			else
			{
				if(m_nTPCacheIndex != 0)
				{
					DWORD dwTime = m_Timer.GetTickCount();
					dwTime = m_dwD0A0Time - dwTime;
					for(int j = 0; j < m_nTPCacheIndex; ++j)
					{
						m_TPSet.AddTp((BYTE*)&m_dwTPCache[j], dwTime);
					}
					m_nTPCacheIndex = 0;
					memset(&m_dwTPCache, 0, sizeof(DWORD)*TP_CACHE_NUM);
				}
				m_TPSet.AddTp(pBuf, m_dwD0A0Time);
			}
		}
	}
}
void CDspKernel::ProcessDataStream(LPBYTE pSrc, DWORD dwSize, BOOL bPause)
{
	static CProcessByte pb(m_bNotFilterAddr);

	if(bPause || NULL == pSrc  || 0 == dwSize )
	{
		pb.Reset();

		return;
	}

	//teana hu 2009.05.18
	if(m_dwGenerateTPTime == TOOL_TIME)
	{
		ProcessToolTime(pSrc,dwSize,pb);
		/* //0xFBA5 tp package
		for(UINT i=0; i<dwSize;)
		{
			if(!pb.IsFullData())
			{
				BOOL bRet = pb.ProcessByte(*pSrc);
				if(bRet)
				{
					BYTE* pBuf   = pb.GetData();
					DWORD dwTime = m_Timer.GetTickCount();	
					m_TPSet.AddTp(pBuf, dwTime);
				}
				
				i ++;
				pSrc ++;
			}
			else if(*pSrc == ((m_dwFrameHead & 0xFF00) >> 8) || m_dwFrameHead > 0)//for 0xFBA5 ......
			{
				int nSize = dwSize - i;
				DWORD dwCount = AddFrameHead(pSrc, nSize);
				i += dwCount;
				pSrc += dwCount;
				nSize -= dwCount;
				
				if(m_dwFrameHeadCount == FRAME_HEAD_SIZE)
				{
					int nRet = ProcessFrameData(pSrc, nSize);
					if(nRet != -1)
					{
						pSrc += m_nAddLen;
						i += m_nAddLen;
						m_nAddLen = 0;
						if(nRet == 0)
						{
							m_dwFrameHeadCount = 0; 
							ZeroMemory(m_FrameHeadBuf, FRAME_HEAD_SIZE);
							m_preBuf = -1;
						}
					}
					else
					{
						for(int j = 0; j < FRAME_HEAD_SIZE; j++)
						{
							BOOL bRet = pb.ProcessByte(m_FrameHeadBuf[j]);
							if(bRet)
							{
								BYTE* pBuf   = pb.GetData();
								DWORD dwTime = m_Timer.GetTickCount();			
								m_TPSet.AddTp(pBuf, dwTime);
							}
						}
						m_dwFrameHeadCount = 0;
						ZeroMemory(m_FrameHeadBuf, FRAME_HEAD_SIZE);
						m_preBuf = -1;
					}
				}
				else if(m_dwFrameHeadCount == 0) // is not frame head or empty
				{
					for(int j = 0; j < FRAME_HEAD_SIZE; j++)
					{
						BOOL bRet = pb.ProcessByte(m_FrameHeadBuf[j]);
						if(bRet)
						{
							BYTE* pBuf   = pb.GetData();
							DWORD dwTime = m_Timer.GetTickCount();			
							m_TPSet.AddTp(pBuf, dwTime);
						}
					}
					ZeroMemory(m_FrameHeadBuf, FRAME_HEAD_SIZE);
				}
			}
			else
			{
				BOOL bRet = pb.ProcessByte(*pSrc);
				if(bRet)
				{
					BYTE* pBuf   = pb.GetData();
					DWORD dwTime = m_Timer.GetTickCount();			
					m_TPSet.AddTp(pBuf, dwTime);
				}
				
				i ++;
				pSrc ++;
			}					
		}*/
	}
	else if(m_dwGenerateTPTime == PHONE_TIME)
	{
		ProcessPhoneTime(pSrc,dwSize,pb);
	}
	else if(m_dwGenerateTPTime == D0A0_TIME)
	{
		ProcessD0A0Time(pSrc,dwSize,pb);
	}
}

void CDspKernel::AddFlagTime(BOOL bStart,DWORD dwPCTime/* =0*/)
{
	BYTE buf[4] = {0};
	DWORD dwTime = 0;
	if(!bStart)
	{
		buf[3] = 1;
	}
	
	if (dwPCTime)
	{
		dwTime = dwPCTime;
	}
	else
	{
		SYSTEMTIME systime;
		::GetLocalTime(&systime);
		dwTime = systime.wHour * 1000 * 60 *60 + systime.wMinute * 1000 * 60 + systime.wSecond * 1000 + systime.wMilliseconds;
		
	}
	m_TPSet.AddTp(buf, dwTime);
	if(bStart)
	{
		m_TPSet.SetStartTime(dwTime);
		m_dwStartTime = dwTime;
	}
}

DWORD CDspKernel::AddFrameHead(LPBYTE lpSrc, DWORD dwSize)
{
	if(m_dwFrameHeadCount == FRAME_HEAD_SIZE)
	{
		return 0;
	}
	
	DWORD dwLen = FRAME_HEAD_SIZE - m_dwFrameHeadCount;
	dwLen = (dwSize >= dwLen) ? dwLen : dwSize;

	for(int i = 0; i < (int)dwLen; i++)
	{
		m_FrameHeadBuf[m_dwFrameHeadCount ++] = *lpSrc;
		lpSrc ++;
	}

	if(m_dwFrameHeadCount == FRAME_HEAD_SIZE)
	{
		int nRet1 = (m_dwFrameHead & 0xFF00) >> 8;
		int nRet2 = m_dwFrameHead & 0x00FF;
		BOOL bRet = IsDataFlag(m_FrameHeadBuf[2]);
		if(m_FrameHeadBuf[0] != nRet1 ||
			m_FrameHeadBuf[1] != nRet2 ||
			!bRet)
		{
			m_dwFrameHeadCount = 0;
		}
	}
	
	return dwLen;

}

BOOL CDspKernel::IsDataFlag(BYTE bData)
{
	int nSize = sizeof(DataFlag) / sizeof(DataFlag[0]);
	for(int i = 0; i < nSize; i++)
	{
		if((bData & 0xF0)>>4 == DataFlag[i])
		{
			return TRUE;
		}
	}
	return FALSE;
}

int CDspKernel::ProcessFrameData(LPBYTE lpSrc, DWORD dwSize)
{
	//get data len
	static DWORD dwLength	= 0;
	static DWORD dwDataType = FRAME_DATA_EQUAL;
	static WORD wAddr		= 0;
	DWORD dwTmp				= m_FrameHeadBuf[2];

	if(dwLength == 0)
	{
		if((m_FrameHeadBuf[2] & 0xF0) >> 4 == 0x0)
		{
			dwDataType	= FRAME_DATA_EQUAL;
			dwLength	= ((dwTmp & 0x000f) << 8) + m_FrameHeadBuf[3];
			dwLength	= dwLength * 2;
		}
		else if((m_FrameHeadBuf[2] & 0xF0) >> 4 == 0x1)
		{
			dwDataType	= FRAME_DATA_ASCEND;
			dwLength	= ((dwTmp & 0x000f) << 8) + m_FrameHeadBuf[3];
			dwLength	= dwLength * 2;
		}
		else if((m_FrameHeadBuf[2] & 0xF0) >> 4 == 0x2)
		{
			dwDataType	= FRAME_DATA_DESCEND;
			dwLength	= ((dwTmp & 0x000f) << 8) + m_FrameHeadBuf[3];
			dwLength	= dwLength * 2;
		}
		else if((m_FrameHeadBuf[2] & 0xF0) >> 4 == 0xa)
		{
			dwDataType	= FRAME_DATA_A;
			dwLength	= (m_FrameHeadBuf[3] & 0x000f) + 1;
			dwLength	= dwLength * 2;
		}
		else if((m_FrameHeadBuf[2] & 0xF0) >> 4 == 0xb)
		{
			dwDataType	= FRAME_DATA_B;
			dwLength	= (m_FrameHeadBuf[3] & 0x00ff) + 1;
			dwLength	= dwLength * 2;
		}
		
		if( 
			dwDataType == FRAME_DATA_ASCEND		||
			dwDataType == FRAME_DATA_DESCEND	||
			dwDataType == FRAME_DATA_EQUAL
		  )
		{
			//teana hu 2009.12.22
			if(dwSize <= 0)
			{
				wAddr = 0;
				return dwLength;
			}

			if(dwSize >= 2)
			{
				wAddr		= *((WORD *)lpSrc);
				WORD wTmp	= 0;
				CONVERT_UINT16(wTmp, wAddr);
				wAddr		= wTmp;
				if((wAddr & 0xF000) != 0xe000)
				{
					return -1;
				}
				lpSrc	+= 2;
				dwSize	-= 2;
				m_nAddLen += 2;
			}
			else if(dwSize == 1)
			{
				if((*lpSrc & 0xF0) != 0xe0)
				{
					return -1;
				}
				wAddr = 0;
				m_preBuf = *lpSrc;
				lpSrc++;
				dwSize--;
				m_nAddLen++;
			}
		
			if(dwSize <= 0)
			{
				return dwLength;
			}
		}
		else if(dwDataType == FRAME_DATA_A)
		{
			wAddr = (WORD)( (((dwTmp & 0x000F) + 0x00d0) << 8) + (m_FrameHeadBuf[3] & 0x00F0) );

		}
		else if(dwDataType == FRAME_DATA_B)
		{
			wAddr = (WORD)(((dwTmp & 0x000F) + 0x00d0) << 8);
		}
	}
	
	if(dwLength > 0)
	{
		if(wAddr == 0)
		{
			if(m_preBuf != -1)
			{
				wAddr = (WORD)((m_preBuf << 8) + *lpSrc);
				lpSrc ++;
				dwSize --;
				m_nAddLen++;
				m_preBuf = -1;
			}
			else if(dwSize >= 2)
			{
				wAddr = *((WORD *)lpSrc);
				WORD wTmp = 0;
				CONVERT_UINT16(wTmp, wAddr);
				wAddr = wTmp;
				if((wAddr & 0xF000) != 0xe000)
				{
					return -1;
				}
				lpSrc += 2;
				dwSize -= 2;
				m_nAddLen += 2;
			}
			else
			{
				return dwLength;
			}		
		}
		
		if(dwSize == 1)
		{
			m_preBuf = *lpSrc;
			lpSrc++;
			dwSize--;
			m_nAddLen++;
			return dwLength;
		}

		int nLen = (dwSize >= dwLength) ? dwLength: dwSize;
		WORD wData = 0;

		for(int i = 0; i < nLen; i += 2)
		{
			if(m_preBuf != -1)
			{
				wData = (m_preBuf << 8) + *lpSrc;
				lpSrc ++;
				i--;
				m_preBuf = -1;
			}
			else
			{
				if(nLen - i == 1)
				{
					break;
				}
				wData = *((WORD *)lpSrc);
				WORD wTmp = 0;
				CONVERT_UINT16(wTmp, wData);
				wData = wTmp;
				lpSrc += 2;
			}
			DWORD dwTime = m_Timer.GetTickCount();
			BYTE bBody[4] = {0};
			bBody[0] = (BYTE)((wAddr & 0xFF00) >> 8);
			bBody[1] = (BYTE)(wAddr & 0x00FF);
			bBody[2] = (BYTE)((wData & 0xFF00) >> 8);
			bBody[3] = (BYTE)(wData & 0x00FF);
			m_TPSet.AddTp(bBody, dwTime);

			if(dwDataType == FRAME_DATA_ASCEND ||
				dwDataType == FRAME_DATA_A ||
				dwDataType == FRAME_DATA_B)
			{
				wAddr++;
			}
			else if(dwDataType == FRAME_DATA_DESCEND)
			{
				wAddr--;
			}
		}

		int nRet = (int)fabs(i - nLen);
		if(nRet == 1)
		{
			m_preBuf = *lpSrc;
			lpSrc++;
			dwSize--;
		}
		
		m_nAddLen += nLen;
		dwLength -= nLen;
	}

	return dwLength;
	
}


void CDspKernel::SetPlaybackDataEx(void* pData, DWORD dwSize,
								   DWORD dwReserve/*=0*/,DWORD dwPCTime/*=0*/ )
{
	if(dwReserve == 1) //0: none; 1: begin; 2: end
	{
		m_Timer.BeginTimer();
		AddFlagTime(TRUE,dwPCTime);
		m_dwGap = 0;
	}
	

	ProcessOrgStream((unsigned char *)pData, dwSize,dwPCTime);
	
	
	if(dwReserve == 2)
	{
		m_Timer.EndTimer();
		AddFlagTime(FALSE,dwPCTime);
		m_dwGap=0;
	}
}
BOOL CDspKernel::Is24HourGap()
{
	return (12*60*60*1000==m_dwGap) ? FALSE : TRUE;
}
DWORD CDspKernel::GetTimeGap(DWORD dwStartTime,DWORD dwCurrentTime)
{
	DWORD dwTime = 0;
	if (dwCurrentTime>=dwStartTime)
	{
		dwTime = dwCurrentTime-dwStartTime + m_dwGap;
	}
	else
	{
		DWORD dwCurrentHour =  dwCurrentTime/(1000*60*60);

		if (dwCurrentHour == 0) //24 小时进制
		{
			m_dwGap = 24*60*60*1000;
			
		}
		else if (dwCurrentHour == 1) //12 小时进制
		{
			m_dwGap = 12*60*60*1000;
		}
		dwTime = dwCurrentTime-dwStartTime + m_dwGap;
		m_dwStartTime = dwCurrentTime;
		
	}
	return dwTime;
}
void CDspKernel::ProcessOrgStream(LPBYTE pSrcBuf, DWORD dwSize, DWORD dwPCTime,BOOL bPause)
{
	static CProcessByte pb(m_bNotFilterAddr);
	
	if(bPause || NULL == pSrcBuf || 0 == dwSize)
	{
		pb.Reset();
		
		return;
	}

/*	for(UINT i=0; i<dwSize;)
	{
		BOOL bRet = pb.ProcessByte(*pSrc);
		if(bRet)
		{
			BYTE* pBuf   = pb.GetData();
			m_TPSet.AddTp(pBuf, GetTimeGap(m_dwStartTime,dwPCTime));
		}
		
		++i;
		++pSrc;
	}*/

	 //FBA5 tp package
	LPBYTE pSrc = pSrcBuf;
	for(UINT i=0; i<dwSize;)
	{
		
		if(!pb.IsFullData())
		{
			BOOL bRet = pb.ProcessByte(*pSrc);
			if(bRet)
			{
				BYTE* pBuf   = pb.GetData();
				//DWORD dwTime = m_Timer.GetTickCount();
				m_TPSet.AddTp(pBuf, GetTimeGap(m_dwStartTime,dwPCTime));
			}
			
			++i;
			++pSrc;
		}
		else if(*pSrc == ((m_dwFrameHead & 0xFF00) >> 8) || m_dwFrameHead > 0)//for 0xFBA5 ......
		{
			int nSize = dwSize - i;
			DWORD dwCount = AddFrameHead(pSrc, nSize);
			i += dwCount;
			pSrc += dwCount;
			nSize -= dwCount;
			
			if(m_dwFrameHeadCount == FRAME_HEAD_SIZE)
			{
				int nRet = ProcessFrameData(pSrc, nSize);
				if(nRet != -1)
				{
					pSrc += m_nAddLen;
					i += m_nAddLen;
					m_nAddLen = 0;
					if(nRet == 0)
					{
						m_dwFrameHeadCount = 0; 
						ZeroMemory(m_FrameHeadBuf, FRAME_HEAD_SIZE);
						m_preBuf = -1;
					}
				}
				else
				{
					for(int j = 0; j < FRAME_HEAD_SIZE; j++)
					{
						BOOL bRet = pb.ProcessByte(m_FrameHeadBuf[j]);
						if(bRet)
						{
							BYTE* pBuf   = pb.GetData();
							//DWORD dwTime = m_Timer.GetTickCount();	
							m_TPSet.AddTp(pBuf, GetTimeGap(m_dwStartTime,dwPCTime));
						}
					}
					m_dwFrameHeadCount = 0;
					ZeroMemory(m_FrameHeadBuf, FRAME_HEAD_SIZE);
					m_preBuf = -1;
				}
			}
			else if(m_dwFrameHeadCount == 0) // is not frame head or empty
			{
				for(int j = 0; j < FRAME_HEAD_SIZE; j++)
				{
					BOOL bRet = pb.ProcessByte(m_FrameHeadBuf[j]);
					if(bRet)
					{
						BYTE* pBuf   = pb.GetData();
						//DWORD dwTime = m_Timer.GetTickCount();	
						m_TPSet.AddTp(pBuf, GetTimeGap(m_dwStartTime,dwPCTime));
					}
				}
				ZeroMemory(m_FrameHeadBuf, FRAME_HEAD_SIZE);
			}
		}
		else
		{
			BOOL bRet = pb.ProcessByte(*pSrc);
			if(bRet)
			{
				BYTE* pBuf   = pb.GetData();
				//DWORD dwTime = m_Timer.GetTickCount();	
				m_TPSet.AddTp(pBuf, GetTimeGap(m_dwStartTime,dwPCTime));
			}
			
			++i;
			++pSrc;
		}
		
	}

}