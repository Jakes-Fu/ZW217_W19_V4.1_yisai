#ifndef TRANSFER_ENGINE_API_C_H
#define TRANSFER_ENGINE_API_C_H
/*============================================================================
// File Name:      Transfer_Engine_api_c.h
// Author:         caesar.shen
// DATE:           2001-11-9
// Copyright:      2001 Spreatrum, Incoporated. All Rights Reserved.         
// Description:    Head file of c interface of the transfer_engine 
//
//	
// ============================================================================
*/
#ifndef C_LIBRARY
#define C_LIBRARY
#endif
#include "Datatype_layer_Abstract.h"
#include "cdfmsg.h"
/* ============================================================================
//                        Edit History                                       
// ----------------------------------------------------------------------------
// DATE           NAME             DESCRIPTION                               
// 2001-11-9     caesar		   Create. 
// ============================================================================
*/
/*!
	\file Transfer_Engine_api_c.h
	\brief Contains the high level c api for the transfer engine.

  Transfer engine library supports both c and c++ programs, this file privades the c api 
  interface. In order to use the c api interface, you have to include this file, and your
  program must link to TrnsEngineC.lib(or TRnsEngineCD.lib if is Debug ). At this time,
  the c api interface only supports Bulk output driver(which outputs  structu buffer) and 
  trace output driver. The dynamic output driver(which outputs tree) is not supported 
  currently, because the driver and its support files are written in c++, and it seems that
  no one will use it in c program.

  The C api interface is simple, clear and small in size. It is suitable for both embed system
  and windows system. It provides three functions, one for encode, one for encode and the other
  for trace. The Trace ability is not nessary when the program is released, so you can disable the
  trace output driver in output_driver_configeration.h when released. This may save some kbs 
  of memory.

  \note
  You can not use c interface api and c++ interface api in a same program. In this situation, I
  suggest you to use the c++ interface api only, because the c++ interface can provide all the
  functionality that c api can provide.

*/
/*!
	\fn int Decode_Message(H_CDF_MSG msg, BYTE* bits, DWORD bit_len)
	\brief Decode a message
	\param msg A valid structure buffer handle
	\param bits A buffer contains the bit encoded message
	\param bit_len The length of the buffer in bit.
	\return 0 on success or an error code.

  This function is used to decode a message(transfer from a bit encoded message to a structure buffer).
  The bits parameter points to a buffer where the bit encoded message is placed and its length is indicated
  by bit_len parameter. You have to create structure buffer before call this function, and use its handle as
  the msg parameter. 

  After this function is successfully returned, the decoded message is stored in the structure buffer indicated
  by the msg parameter, all the memory blocks, both main structure buffer and array buffer, are allocated by the
  engine.

  This function has a return value of int, below is its possible values:
  <ul>
  <li> -2				The output driver is not installed.
  <li> -1				The code of the message is invalid.	
  <li> 0				Success.
  <li> Other			Please see the H_BU_RESULT
  </ul>

  The transfer engine framework supports multi output drivers, they can be linked
  on demand. If an output driver is not linked and you try to use it,-2 will be 
  returned. For sample: You use Trace_Message() function when trace output driver
  is not installed.

  The transfer engine uses c functions to decode and encode the message. These c functions
  are created automatically through the structure define script(*.desc). If you try to decode
  a message whose code can not found in the engine, -1 will be returned. The solution is 
  recompile the script(*.desc) which contains the new message define and copy the generated 
  file(caimessage.h autogeneratedcode.c) to the engine_framework project and  rebuild it.

  To understand how message code is mapped to the channel and type in structure define script,
  please see the document of cdfmsg.h.

  If the return value is a positive value, it means the error is a rutime error. All the
  possible errors are listed in H_BU_RESULT.

  \note
  Don't call cdf_alloc_buffer() on the msg before call Decode_Message(). cdf_alloc_buffer()
  will called automatically by this function. If cdf_alloc_buffer() is called more than once
  on a same structure buffer, ASSERT() will fail.
  <br><br>	
  With the same reason, don't call this function twice on a same message, or ASSERT() will 
  fail.
  <br><br>
  This function needs Bulk output driver being installed. To install the output driver, please
  modify the output_driver_configeration.h.

  \sa H_BU_RESULT
*/
int Decode_Message(H_CDF_MSG msg, BYTE* bits, DWORD bit_len);
/*!
	\fn int Encode_Message(H_CDF_MSG msg, BYTE** bits, DWORD* bit_len)
	\brief Encode a message.
	\param msg A valid structure buffer handle.
	\param bits Address of the bit buffer pointer.
	\param bit_len The length of the bit buffer in bit.
	\return 0 on success or an error code.

  This function encode a structure buffer to a bit encoded message. The buffer of the
  bit message is allocated by this function and should be freed by the caller.

  After this function is successfully returned, the * bits points to a buffer which contains
  the bit message and * bit_len conatins the buffer length in bit.

   This function has a return value of int, below is its possible values:
  <ul>
  <li> -2				The output driver is not installed.
  <li> -1				The code of the message is invalid.	
  <li> 0				Success.
  <li> Other			Please see the H_BU_RESULT
  </ul>
	
   All the possible error code is the same as Decode_Message() function.

  \note
  Before call this function, the msg must be filled with value. All the buffer should be allocated
  by the user(using cdf_alloc_buffer() and cdf_alloc_array()). Of course, you can use this function 
  on a same message more than twice.
  <br><br>	
  This function needs Bulk output driver being installed. To install the output driver, please
  modify the output_driver_configeration.h.
  <br><br>
  Don't forget to free the buffer when finished using it.
	\sa H_BU_RESULT
*/
int Encode_Message(H_CDF_MSG msg, BYTE** bits, DWORD* bit_len); 
/*!
	\fn int Trace_Message(DWORD code)
	\brief Trance the message.
	\param code A Valid message code.
	\return 0 on success or an error code.

  This function is used to debug the transfer engine and the output driver. Output the function calls
  from the engine to the outputdriver are printed to the stdout.
  
  \note
  This function needs Trace output driver being installed. To install the output driver, please
  modify the output_driver_configeration.h.
	
*/
int Trace_Message(DWORD code);



#endif /*TRANSFER_ENGINE_API_C_H*/