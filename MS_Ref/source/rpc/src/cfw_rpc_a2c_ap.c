/* Copyright (C) 2018 RDA Technologies Limited and/or its affiliates("RDA").
 * All rights reserved.
 *
 * This software is supplied "AS IS" without any warranties.
 * RDA assumes no responsibility or liability for the use of the software,
 * conveys no license or title under any patent, copyright, or mask work
 * right to the product. RDA reserves the right to make changes in the
 * software without notification.  RDA also make no representation or
 * warranty that such application will be suitable for the specified use
 * without further testing or modification.
 */
#ifndef ERR_NOT_SUPPORT
#define ERR_NOT_SUPPORT 0x17
#endif
// AUTO GENERATED

#ifndef DISABLE_RPC_CFW_IsFreeUTI
uint32_t CFW_IsFreeUTI(uint16_t nUTI, uint32_t nServiceId)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_IsFreeUTI *ipar;
    struct OPAR_CFW_IsFreeUTI *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_IsFreeUTI) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_IsFreeUTI) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_IsFreeUTI *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_IsFreeUTI *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_IsFreeUTI;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nServiceId = nServiceId;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetFreeUTI
uint32_t CFW_GetFreeUTI(uint32_t nServiceId, uint8_t *nUTI)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetFreeUTI *ipar;
    struct OPAR_CFW_GetFreeUTI *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetFreeUTI) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetFreeUTI) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetFreeUTI *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetFreeUTI *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetFreeUTI;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nServiceId = nServiceId;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *nUTI = opar->nUTI;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_ShellControl
uint32_t CFW_ShellControl(uint8_t nCommand)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_ShellControl *ipar;
    struct OPAR_CFW_ShellControl *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_ShellControl) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_ShellControl) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_ShellControl *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_ShellControl *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ShellControl;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCommand = nCommand;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_ShellControl_V2
uint32_t CFW_ShellControl_V2(uint16_t nUTI, uint8_t nCommand)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_ShellControl_V2 *ipar;
    struct OPAR_CFW_ShellControl_V2 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_ShellControl_V2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_ShellControl_V2) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_ShellControl_V2 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_ShellControl_V2 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ShellControl_V2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nCommand = nCommand;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetPhoneFunctionality
uint32_t CFW_CfgSetPhoneFunctionality(uint8_t nLevel, uint8_t nRst)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetPhoneFunctionality *ipar;
    struct OPAR_CFW_CfgSetPhoneFunctionality *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetPhoneFunctionality) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetPhoneFunctionality) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetPhoneFunctionality *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetPhoneFunctionality *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetPhoneFunctionality;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nLevel = nLevel;
    ipar->nRst = nRst;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetPhoneFunctionality
uint32_t CFW_CfgGetPhoneFunctionality(uint8_t *nLevel)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_CfgGetPhoneFunctionality *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetPhoneFunctionality) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_CfgGetPhoneFunctionality *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetPhoneFunctionality;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *nLevel = opar->nLevel;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgStoreUserProfile
uint32_t CFW_CfgStoreUserProfile(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_CfgStoreUserProfile *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgStoreUserProfile) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_CfgStoreUserProfile *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgStoreUserProfile;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetUserProfile
uint32_t CFW_CfgGetUserProfile(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_CfgGetUserProfile *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetUserProfile) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_CfgGetUserProfile *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetUserProfile;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgRestoreFactoryProfile
uint32_t CFW_CfgRestoreFactoryProfile(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_CfgRestoreFactoryProfile *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgRestoreFactoryProfile) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_CfgRestoreFactoryProfile *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgRestoreFactoryProfile;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetCharacterSet
uint32_t CFW_CfgGetCharacterSet(uint8_t *chset)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_CfgGetCharacterSet *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetCharacterSet) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_CfgGetCharacterSet *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetCharacterSet;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *chset = opar->chset;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetCharacterSet
uint32_t CFW_CfgSetCharacterSet(uint8_t chset)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetCharacterSet *ipar;
    struct OPAR_CFW_CfgSetCharacterSet *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetCharacterSet) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetCharacterSet) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetCharacterSet *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetCharacterSet *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetCharacterSet;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->chset = chset;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetIndicatorEvent
uint32_t CFW_CfgSetIndicatorEvent(uint16_t ind, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetIndicatorEvent *ipar;
    struct OPAR_CFW_CfgSetIndicatorEvent *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetIndicatorEvent) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetIndicatorEvent) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetIndicatorEvent *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetIndicatorEvent *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetIndicatorEvent;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->ind = ind;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetIndicatorEvent
uint32_t CFW_CfgGetIndicatorEvent(uint16_t *ind, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgGetIndicatorEvent *ipar;
    struct OPAR_CFW_CfgGetIndicatorEvent *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgGetIndicatorEvent) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetIndicatorEvent) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgGetIndicatorEvent *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgGetIndicatorEvent *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetIndicatorEvent;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *ind = opar->ind;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetQualReport
uint32_t CFW_SetQualReport(bool bStart, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetQualReport *ipar;
    struct OPAR_CFW_SetQualReport *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetQualReport) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetQualReport) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetQualReport *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetQualReport *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetQualReport;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->bStart = bStart;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetFirstPowerOnFlag
uint32_t CFW_CfgSetFirstPowerOnFlag(bool bFPO)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetFirstPowerOnFlag *ipar;
    struct OPAR_CFW_CfgSetFirstPowerOnFlag *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetFirstPowerOnFlag) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetFirstPowerOnFlag) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetFirstPowerOnFlag *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetFirstPowerOnFlag *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetFirstPowerOnFlag;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->bFPO = bFPO;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgCheckFirstPowerOnFlag
uint32_t CFW_CfgCheckFirstPowerOnFlag(bool *bFPO)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_CfgCheckFirstPowerOnFlag *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgCheckFirstPowerOnFlag) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_CfgCheckFirstPowerOnFlag *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgCheckFirstPowerOnFlag;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *bFPO = opar->bFPO;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetEventReport
uint32_t CFW_CfgGetEventReport(uint16_t *pMer)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_CfgGetEventReport *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetEventReport) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_CfgGetEventReport *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetEventReport;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pMer = opar->pMer;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetEventReport
uint32_t CFW_CfgSetEventReport(uint16_t pMer)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetEventReport *ipar;
    struct OPAR_CFW_CfgSetEventReport *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetEventReport) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetEventReport) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetEventReport *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetEventReport *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetEventReport;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pMer = pMer;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetResultCodePresentMode
uint32_t CFW_CfgSetResultCodePresentMode(uint8_t nMode)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetResultCodePresentMode *ipar;
    struct OPAR_CFW_CfgSetResultCodePresentMode *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetResultCodePresentMode) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetResultCodePresentMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetResultCodePresentMode *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetResultCodePresentMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetResultCodePresentMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nMode = nMode;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetResultCodePresentMode
uint32_t CFW_CfgGetResultCodePresentMode(uint8_t *nMode)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_CfgGetResultCodePresentMode *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetResultCodePresentMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_CfgGetResultCodePresentMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetResultCodePresentMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *nMode = opar->nMode;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetResultCodeFormatMode
uint32_t CFW_CfgSetResultCodeFormatMode(uint8_t pMode)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetResultCodeFormatMode *ipar;
    struct OPAR_CFW_CfgSetResultCodeFormatMode *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetResultCodeFormatMode) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetResultCodeFormatMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetResultCodeFormatMode *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetResultCodeFormatMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetResultCodeFormatMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pMode = pMode;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetResultCodeFormatMode
uint32_t CFW_CfgGetResultCodeFormatMode(uint8_t *pMode)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_CfgGetResultCodeFormatMode *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetResultCodeFormatMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_CfgGetResultCodeFormatMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetResultCodeFormatMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pMode = opar->pMode;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetEchoMode
uint32_t CFW_CfgSetEchoMode(uint8_t nMode)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetEchoMode *ipar;
    struct OPAR_CFW_CfgSetEchoMode *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetEchoMode) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetEchoMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetEchoMode *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetEchoMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetEchoMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nMode = nMode;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetEchoMode
uint32_t CFW_CfgGetEchoMode(uint8_t *nMode)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_CfgGetEchoMode *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetEchoMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_CfgGetEchoMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetEchoMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *nMode = opar->nMode;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetExtendedErrorV1
uint32_t CFW_CfgGetExtendedErrorV1(CFW_EXTENDED_ERROR *pExtendedError)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_CfgGetExtendedErrorV1 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetExtendedErrorV1) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_CfgGetExtendedErrorV1 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetExtendedErrorV1;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pExtendedError = opar->pExtendedError;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetErrorReport
uint32_t CFW_CfgGetErrorReport(uint8_t *pLevel)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_CfgGetErrorReport *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetErrorReport) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_CfgGetErrorReport *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetErrorReport;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pLevel = opar->pLevel;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetErrorReport
uint32_t CFW_CfgSetErrorReport(uint8_t pLevel)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetErrorReport *ipar;
    struct OPAR_CFW_CfgSetErrorReport *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetErrorReport) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetErrorReport) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetErrorReport *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetErrorReport *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetErrorReport;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pLevel = pLevel;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgDeviceSwithOff
uint32_t CFW_CfgDeviceSwithOff(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_CfgDeviceSwithOff *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgDeviceSwithOff) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_CfgDeviceSwithOff *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgDeviceSwithOff;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetConnectResultFormatCode
uint32_t CFW_CfgSetConnectResultFormatCode(uint8_t nValue)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetConnectResultFormatCode *ipar;
    struct OPAR_CFW_CfgSetConnectResultFormatCode *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetConnectResultFormatCode) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetConnectResultFormatCode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetConnectResultFormatCode *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetConnectResultFormatCode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetConnectResultFormatCode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nValue = nValue;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetConnectResultFormatCode
uint32_t CFW_CfgGetConnectResultFormatCode(uint8_t *nValue)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_CfgGetConnectResultFormatCode *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetConnectResultFormatCode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_CfgGetConnectResultFormatCode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetConnectResultFormatCode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *nValue = opar->nValue;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetSoftReset
uint32_t CFW_CfgSetSoftReset(uint8_t cause)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetSoftReset *ipar;
    struct OPAR_CFW_CfgSetSoftReset *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetSoftReset) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetSoftReset) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetSoftReset *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetSoftReset *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetSoftReset;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->cause = cause;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetSoftReset
uint32_t CFW_CfgGetSoftReset(uint8_t *cause)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_CfgGetSoftReset *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetSoftReset) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_CfgGetSoftReset *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetSoftReset;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *cause = opar->cause;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetSmsStorage
uint32_t CFW_CfgSetSmsStorage(uint8_t nStorage, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetSmsStorage *ipar;
    struct OPAR_CFW_CfgSetSmsStorage *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetSmsStorage) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetSmsStorage) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetSmsStorage *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetSmsStorage *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetSmsStorage;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nStorage = nStorage;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetSmsStorage
uint32_t CFW_CfgGetSmsStorage(uint8_t *nStorage, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgGetSmsStorage *ipar;
    struct OPAR_CFW_CfgGetSmsStorage *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgGetSmsStorage) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetSmsStorage) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgGetSmsStorage *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgGetSmsStorage *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetSmsStorage;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *nStorage = opar->nStorage;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetNewSmsOption
uint32_t CFW_CfgSetNewSmsOption(uint8_t nOption, uint8_t nNewSmsStorage, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetNewSmsOption *ipar;
    struct OPAR_CFW_CfgSetNewSmsOption *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetNewSmsOption) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetNewSmsOption) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetNewSmsOption *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetNewSmsOption *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetNewSmsOption;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nOption = nOption;
    ipar->nNewSmsStorage = nNewSmsStorage;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetNewSmsOption
uint32_t CFW_CfgGetNewSmsOption(uint8_t *nOption, uint8_t *nNewSmsStorage, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgGetNewSmsOption *ipar;
    struct OPAR_CFW_CfgGetNewSmsOption *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgGetNewSmsOption) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetNewSmsOption) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgGetNewSmsOption *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgGetNewSmsOption *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetNewSmsOption;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *nOption = opar->nOption;
    *nNewSmsStorage = opar->nNewSmsStorage;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetSmsOverflowInd
uint32_t CFW_CfgSetSmsOverflowInd(uint8_t nMode, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetSmsOverflowInd *ipar;
    struct OPAR_CFW_CfgSetSmsOverflowInd *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetSmsOverflowInd) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetSmsOverflowInd) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetSmsOverflowInd *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetSmsOverflowInd *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetSmsOverflowInd;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nMode = nMode;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetSmsOverflowInd
uint32_t CFW_CfgGetSmsOverflowInd(uint8_t *nMode, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgGetSmsOverflowInd *ipar;
    struct OPAR_CFW_CfgGetSmsOverflowInd *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgGetSmsOverflowInd) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetSmsOverflowInd) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgGetSmsOverflowInd *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgGetSmsOverflowInd *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetSmsOverflowInd;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *nMode = opar->nMode;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetSmsFormat
uint32_t CFW_CfgSetSmsFormat(uint8_t nFormat, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetSmsFormat *ipar;
    struct OPAR_CFW_CfgSetSmsFormat *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetSmsFormat) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetSmsFormat) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetSmsFormat *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetSmsFormat *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetSmsFormat;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nFormat = nFormat;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetSmsFormat
uint32_t CFW_CfgGetSmsFormat(uint8_t *nFormat, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgGetSmsFormat *ipar;
    struct OPAR_CFW_CfgGetSmsFormat *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgGetSmsFormat) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetSmsFormat) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgGetSmsFormat *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgGetSmsFormat *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetSmsFormat;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *nFormat = opar->nFormat;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetSmsShowTextModeParam
uint32_t CFW_CfgSetSmsShowTextModeParam(uint8_t nShow, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetSmsShowTextModeParam *ipar;
    struct OPAR_CFW_CfgSetSmsShowTextModeParam *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetSmsShowTextModeParam) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetSmsShowTextModeParam) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetSmsShowTextModeParam *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetSmsShowTextModeParam *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetSmsShowTextModeParam;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nShow = nShow;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetSmsShowTextModeParam
uint32_t CFW_CfgGetSmsShowTextModeParam(uint8_t *nShow, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgGetSmsShowTextModeParam *ipar;
    struct OPAR_CFW_CfgGetSmsShowTextModeParam *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgGetSmsShowTextModeParam) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetSmsShowTextModeParam) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgGetSmsShowTextModeParam *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgGetSmsShowTextModeParam *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetSmsShowTextModeParam;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *nShow = opar->nShow;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetSmsParam
uint32_t CFW_CfgSetSmsParam(CFW_SMS_PARAMETER *pInfo, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetSmsParam *ipar;
    struct OPAR_CFW_CfgSetSmsParam *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetSmsParam) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetSmsParam) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetSmsParam *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetSmsParam *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetSmsParam;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pInfo = *pInfo;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetSmsParam
uint32_t CFW_CfgGetSmsParam(CFW_SMS_PARAMETER *pInfo, uint8_t nIndex, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgGetSmsParam *ipar;
    struct OPAR_CFW_CfgGetSmsParam *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgGetSmsParam) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetSmsParam) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgGetSmsParam *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgGetSmsParam *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetSmsParam;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nIndex = nIndex;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pInfo = opar->pInfo;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetDefaultSmsParam
uint32_t CFW_CfgSetDefaultSmsParam(CFW_SMS_PARAMETER *pInfo, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetDefaultSmsParam *ipar;
    struct OPAR_CFW_CfgSetDefaultSmsParam *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetDefaultSmsParam) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetDefaultSmsParam) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetDefaultSmsParam *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetDefaultSmsParam *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetDefaultSmsParam;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pInfo = *pInfo;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetDefaultSmsParam
uint32_t CFW_CfgGetDefaultSmsParam(CFW_SMS_PARAMETER *pInfo, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgGetDefaultSmsParam *ipar;
    struct OPAR_CFW_CfgGetDefaultSmsParam *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgGetDefaultSmsParam) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetDefaultSmsParam) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgGetDefaultSmsParam *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgGetDefaultSmsParam *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetDefaultSmsParam;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pInfo = opar->pInfo;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetSmsStorageInfo
uint32_t CFW_CfgSetSmsStorageInfo(CFW_SMS_STORAGE_INFO *pStorageInfo, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetSmsStorageInfo *ipar;
    struct OPAR_CFW_CfgSetSmsStorageInfo *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetSmsStorageInfo) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetSmsStorageInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetSmsStorageInfo *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetSmsStorageInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetSmsStorageInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pStorageInfo = *pStorageInfo;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetSmsStorageInfo
uint32_t CFW_CfgGetSmsStorageInfo(CFW_SMS_STORAGE_INFO *pStorageInfo, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgGetSmsStorageInfo *ipar;
    struct OPAR_CFW_CfgGetSmsStorageInfo *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgGetSmsStorageInfo) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetSmsStorageInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgGetSmsStorageInfo *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgGetSmsStorageInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetSmsStorageInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pStorageInfo = opar->pStorageInfo;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimGetSmsTotalNum
uint32_t CFW_SimGetSmsTotalNum(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimGetSmsTotalNum *ipar;
    struct OPAR_CFW_SimGetSmsTotalNum *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimGetSmsTotalNum) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimGetSmsTotalNum) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimGetSmsTotalNum *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimGetSmsTotalNum *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimGetSmsTotalNum;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSelectSmsService
uint32_t CFW_CfgSelectSmsService(uint8_t nService, uint8_t *pSupportedType)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSelectSmsService *ipar;
    struct OPAR_CFW_CfgSelectSmsService *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSelectSmsService) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSelectSmsService) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSelectSmsService *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSelectSmsService *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSelectSmsService;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nService = nService;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pSupportedType = opar->pSupportedType;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgQuerySmsService
uint32_t CFW_CfgQuerySmsService(uint8_t *nService)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_CfgQuerySmsService *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgQuerySmsService) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_CfgQuerySmsService *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgQuerySmsService;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *nService = opar->nService;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetSmsCB
uint32_t CFW_CfgSetSmsCB(uint8_t mode, uint8_t mids[6], uint8_t dcss[6])
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetSmsCB *ipar;
    struct OPAR_CFW_CfgSetSmsCB *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetSmsCB) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetSmsCB) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetSmsCB *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetSmsCB *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetSmsCB;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->mode = mode;
    memcpy(ipar->mids, mids, sizeof(ipar->mids));
    memcpy(ipar->dcss, dcss, sizeof(ipar->dcss));
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetSmsCB
uint32_t CFW_CfgGetSmsCB(uint8_t *pMode, uint8_t mids[6], uint8_t dcss[6])
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_CfgGetSmsCB *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetSmsCB) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_CfgGetSmsCB *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetSmsCB;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pMode = opar->pMode;
    memcpy(mids, opar->mids, sizeof(opar->mids));
    memcpy(dcss, opar->dcss, sizeof(opar->dcss));
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetSimPHYType
uint8_t CFW_GetSimPHYType(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetSimPHYType *ipar;
    struct OPAR_CFW_GetSimPHYType *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetSimPHYType) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetSimPHYType) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetSimPHYType *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetSimPHYType *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetSimPHYType;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetSimStatus
void CFW_SetSimStatus(CFW_SIM_ID nSimID, CFW_SIM_STATUS nSimStatus)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetSimStatus *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetSimStatus) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetSimStatus *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetSimStatus;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    ipar->nSimStatus = nSimStatus;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_GetSimStatus
CFW_SIM_STATUS CFW_GetSimStatus(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetSimStatus *ipar;
    struct OPAR_CFW_GetSimStatus *opar;
    CFW_SIM_STATUS result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetSimStatus) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetSimStatus) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetSimStatus *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetSimStatus *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetSimStatus;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetSimType
bool CFW_GetSimType(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetSimType *ipar;
    struct OPAR_CFW_GetSimType *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetSimType) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetSimType) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetSimType *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetSimType *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetSimType;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_ImsSsUtAddrSet
uint32_t CFW_ImsSsUtAddrSet(uint8_t nCid, uint8_t nSize, uint8_t * paddr, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_ImsSsUtAddrSet *ipar;
    struct OPAR_CFW_ImsSsUtAddrSet *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_ImsSsUtAddrSet) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_ImsSsUtAddrSet) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_ImsSsUtAddrSet *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_ImsSsUtAddrSet *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ImsSsUtAddrSet;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCid = nCid;
    ipar->nSize = nSize;
    ipar->paddr = paddr;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimClose
uint32_t CFW_SimClose(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimClose *ipar;
    struct OPAR_CFW_SimClose *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimClose) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimClose) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimClose *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimClose *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimClose;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetStackSimFileID
uint32_t CFW_GetStackSimFileID(uint16_t n3GppFileID, uint16_t EFPath, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetStackSimFileID *ipar;
    struct OPAR_CFW_GetStackSimFileID *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetStackSimFileID) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetStackSimFileID) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetStackSimFileID *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetStackSimFileID *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetStackSimFileID;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->n3GppFileID = n3GppFileID;
    ipar->EFPath = EFPath;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetStackSimFileIDByPath_V2
uint32_t CFW_GetStackSimFileIDByPath_V2(uint16_t n3GppFileID, uint8_t * EFTotalPath, uint8_t iEfPathLength, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetStackSimFileIDByPath_V2 *ipar;
    struct OPAR_CFW_GetStackSimFileIDByPath_V2 *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(iEfPathLength+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetStackSimFileIDByPath_V2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetStackSimFileIDByPath_V2) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetStackSimFileIDByPath_V2 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetStackSimFileIDByPath_V2 *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetStackSimFileIDByPath_V2);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetStackSimFileIDByPath_V2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->n3GppFileID = n3GppFileID;
    memcpy(ivar_ptr, EFTotalPath, iEfPathLength);
    ivar_ptr[iEfPathLength] = (char)0;
    ivar_ptr += ALIGNUP8(iEfPathLength + 1);
    ipar->iEfPathLength = iEfPathLength;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_UsimDecodeEFFcp
void CFW_UsimDecodeEFFcp(uint8_t RespData[256], CFW_UsimEfStatus *pSimEfStatus)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_UsimDecodeEFFcp *ipar;
    struct OPAR_CFW_UsimDecodeEFFcp *opar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_UsimDecodeEFFcp) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_UsimDecodeEFFcp) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_UsimDecodeEFFcp *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_UsimDecodeEFFcp *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_UsimDecodeEFFcp;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ipar->RespData, RespData, sizeof(ipar->RespData));
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pSimEfStatus = opar->pSimEfStatus;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_UsimDecodeEFFcpV2
uint32_t CFW_UsimDecodeEFFcpV2(uint8_t * RespData, uint16_t iLen, CFW_UsimEfStatus *pSimEfStatus)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_UsimDecodeEFFcpV2 *ipar;
    struct OPAR_CFW_UsimDecodeEFFcpV2 *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(iLen+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_UsimDecodeEFFcpV2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_UsimDecodeEFFcpV2) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_UsimDecodeEFFcpV2 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_UsimDecodeEFFcpV2 *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_UsimDecodeEFFcpV2);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_UsimDecodeEFFcpV2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ivar_ptr, RespData, iLen);
    ivar_ptr[iLen] = (char)0;
    ivar_ptr += ALIGNUP8(iLen + 1);
    ipar->iLen = iLen;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pSimEfStatus = opar->pSimEfStatus;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimReadRecordWithLen
uint32_t CFW_SimReadRecordWithLen(uint8_t nFileID, uint8_t nRecordNum, uint16_t nLen, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimReadRecordWithLen *ipar;
    struct OPAR_CFW_SimReadRecordWithLen *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimReadRecordWithLen) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimReadRecordWithLen) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimReadRecordWithLen *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimReadRecordWithLen *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimReadRecordWithLen;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nFileID = nFileID;
    ipar->nRecordNum = nRecordNum;
    ipar->nLen = nLen;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimReadRecordAllParam
uint32_t CFW_SimReadRecordAllParam(uint8_t nFileID, uint8_t nRecordNum, uint8_t nRecordMode, uint16_t nLen, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimReadRecordAllParam *ipar;
    struct OPAR_CFW_SimReadRecordAllParam *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimReadRecordAllParam) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimReadRecordAllParam) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimReadRecordAllParam *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimReadRecordAllParam *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimReadRecordAllParam;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nFileID = nFileID;
    ipar->nRecordNum = nRecordNum;
    ipar->nRecordMode = nRecordMode;
    ipar->nLen = nLen;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimGetDFStatus
uint32_t CFW_SimGetDFStatus(uint8_t nFile, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimGetDFStatus *ipar;
    struct OPAR_CFW_SimGetDFStatus *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimGetDFStatus) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimGetDFStatus) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimGetDFStatus *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimGetDFStatus *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimGetDFStatus;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nFile = nFile;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimReadBinary
uint32_t CFW_SimReadBinary(uint8_t nFileId, uint8_t nOffset, uint8_t nBytesToRead, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimReadBinary *ipar;
    struct OPAR_CFW_SimReadBinary *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimReadBinary) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimReadBinary) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimReadBinary *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimReadBinary *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimReadBinary;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nFileId = nFileId;
    ipar->nOffset = nOffset;
    ipar->nBytesToRead = nBytesToRead;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimReadElementary
uint32_t CFW_SimReadElementary(uint8_t nFileId, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimReadElementary *ipar;
    struct OPAR_CFW_SimReadElementary *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimReadElementary) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimReadElementary) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimReadElementary *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimReadElementary *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimReadElementary;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nFileId = nFileId;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimGetOperationTimes
uint32_t CFW_SimGetOperationTimes(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_SimGetOperationTimes *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimGetOperationTimes) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_SimGetOperationTimes *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimGetOperationTimes;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimUpdateBinary
uint32_t CFW_SimUpdateBinary(uint8_t nFileId, uint8_t nOffset, uint8_t * pData, uint8_t nBytesToWrite, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimUpdateBinary *ipar;
    struct OPAR_CFW_SimUpdateBinary *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nBytesToWrite+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimUpdateBinary) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimUpdateBinary) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimUpdateBinary *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimUpdateBinary *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimUpdateBinary);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimUpdateBinary;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nFileId = nFileId;
    ipar->nOffset = nOffset;
    memcpy(ivar_ptr, pData, nBytesToWrite);
    ivar_ptr[nBytesToWrite] = (char)0;
    ivar_ptr += ALIGNUP8(nBytesToWrite + 1);
    ipar->nBytesToWrite = nBytesToWrite;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimReadRecord
uint32_t CFW_SimReadRecord(uint8_t nFileID, uint8_t nRecordNum, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimReadRecord *ipar;
    struct OPAR_CFW_SimReadRecord *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimReadRecord) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimReadRecord) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimReadRecord *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimReadRecord *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimReadRecord;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nFileID = nFileID;
    ipar->nRecordNum = nRecordNum;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimUpdateRecord
uint32_t CFW_SimUpdateRecord(uint8_t nFileID, uint8_t nRecordNum, uint8_t nRecordSize, uint8_t * pData, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimUpdateRecord *ipar;
    struct OPAR_CFW_SimUpdateRecord *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nRecordSize+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimUpdateRecord) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimUpdateRecord) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimUpdateRecord *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimUpdateRecord *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimUpdateRecord);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimUpdateRecord;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nFileID = nFileID;
    ipar->nRecordNum = nRecordNum;
    ipar->nRecordSize = nRecordSize;
    memcpy(ivar_ptr, pData, nRecordSize);
    ivar_ptr[nRecordSize] = (char)0;
    ivar_ptr += ALIGNUP8(nRecordSize + 1);
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimUpdateRecordAllParam
uint32_t CFW_SimUpdateRecordAllParam(uint8_t nFileID, uint8_t nRecordNum, uint8_t nRecordSize, uint8_t nRecordMode, uint8_t * pData, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimUpdateRecordAllParam *ipar;
    struct OPAR_CFW_SimUpdateRecordAllParam *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nRecordSize+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimUpdateRecordAllParam) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimUpdateRecordAllParam) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimUpdateRecordAllParam *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimUpdateRecordAllParam *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimUpdateRecordAllParam);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimUpdateRecordAllParam;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nFileID = nFileID;
    ipar->nRecordNum = nRecordNum;
    ipar->nRecordSize = nRecordSize;
    ipar->nRecordMode = nRecordMode;
    memcpy(ivar_ptr, pData, nRecordSize);
    ivar_ptr[nRecordSize] = (char)0;
    ivar_ptr += ALIGNUP8(nRecordSize + 1);
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimGetFileStatus
uint32_t CFW_SimGetFileStatus(uint8_t nFileID, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimGetFileStatus *ipar;
    struct OPAR_CFW_SimGetFileStatus *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimGetFileStatus) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimGetFileStatus) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimGetFileStatus *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimGetFileStatus *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimGetFileStatus;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nFileID = nFileID;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimSetProiorityResetFlag
void CFW_SimSetProiorityResetFlag(uint8_t nResetFlag)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimSetProiorityResetFlag *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimSetProiorityResetFlag) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimSetProiorityResetFlag *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimSetProiorityResetFlag;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nResetFlag = nResetFlag;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_SmsMoInit
uint32_t CFW_SmsMoInit(uint16_t nUti, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SmsMoInit *ipar;
    struct OPAR_CFW_SmsMoInit *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SmsMoInit) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SmsMoInit) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SmsMoInit *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SmsMoInit *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SmsMoInit;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUti = nUti;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimInit
uint32_t CFW_SimInit(bool bRstSim, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimInit *ipar;
    struct OPAR_CFW_SimInit *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimInit) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimInit) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimInit *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimInit *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimInit;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->bRstSim = bRstSim;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetSimSwitch
uint32_t CFW_CfgSetSimSwitch(uint8_t n)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetSimSwitch *ipar;
    struct OPAR_CFW_CfgSetSimSwitch *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetSimSwitch) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetSimSwitch) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetSimSwitch *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetSimSwitch *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetSimSwitch;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->n = n;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetSimSwitch
uint32_t CFW_CfgGetSimSwitch(uint8_t *n)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_CfgGetSimSwitch *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetSimSwitch) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_CfgGetSimSwitch *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetSimSwitch;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *n = opar->n;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SwitchDualSimSlot
uint32_t CFW_SwitchDualSimSlot(uint8_t nSimSlot)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SwitchDualSimSlot *ipar;
    struct OPAR_CFW_SwitchDualSimSlot *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SwitchDualSimSlot) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SwitchDualSimSlot) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SwitchDualSimSlot *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SwitchDualSimSlot *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SwitchDualSimSlot;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimSlot = nSimSlot;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_SimSwitch
void SimSwitch(uint8_t SimNum)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_SimSwitch *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_SimSwitch) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_SimSwitch *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_SimSwitch;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->SimNum = SimNum;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetPbkStrorageInfo
uint32_t CFW_CfgSetPbkStrorageInfo(CFW_PBK_STRORAGE_INFO *pStorageInfo)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetPbkStrorageInfo *ipar;
    struct OPAR_CFW_CfgSetPbkStrorageInfo *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetPbkStrorageInfo) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetPbkStrorageInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetPbkStrorageInfo *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetPbkStrorageInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetPbkStrorageInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pStorageInfo = *pStorageInfo;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetPbkStrorageInfo
uint32_t CFW_CfgGetPbkStrorageInfo(CFW_PBK_STRORAGE_INFO *pStorageInfo)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_CfgGetPbkStrorageInfo *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetPbkStrorageInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_CfgGetPbkStrorageInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetPbkStrorageInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pStorageInfo = opar->pStorageInfo;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetPbkStorage
uint32_t CFW_CfgSetPbkStorage(uint8_t nStorage, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetPbkStorage *ipar;
    struct OPAR_CFW_CfgSetPbkStorage *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetPbkStorage) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetPbkStorage) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetPbkStorage *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetPbkStorage *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetPbkStorage;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nStorage = nStorage;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetPbkStorage
uint32_t CFW_CfgGetPbkStorage(uint8_t *nStorage, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgGetPbkStorage *ipar;
    struct OPAR_CFW_CfgGetPbkStorage *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgGetPbkStorage) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetPbkStorage) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgGetPbkStorage *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgGetPbkStorage *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetPbkStorage;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *nStorage = opar->nStorage;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetStoredPlmnList
uint32_t CFW_CfgSetStoredPlmnList(CFW_StoredPlmnList *pPlmnL, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetStoredPlmnList *ipar;
    struct OPAR_CFW_CfgSetStoredPlmnList *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetStoredPlmnList) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetStoredPlmnList) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetStoredPlmnList *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetStoredPlmnList *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetStoredPlmnList;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pPlmnL = *pPlmnL;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetStoredPlmnList
uint32_t CFW_CfgGetStoredPlmnList(CFW_StoredPlmnList *pPlmnL, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgGetStoredPlmnList *ipar;
    struct OPAR_CFW_CfgGetStoredPlmnList *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgGetStoredPlmnList) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetStoredPlmnList) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgGetStoredPlmnList *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgGetStoredPlmnList *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetStoredPlmnList;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pPlmnL = opar->pPlmnL;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgNwSetLockedFrequencyBand
uint32_t CFW_CfgNwSetLockedFrequencyBand(uint8_t nBand, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgNwSetLockedFrequencyBand *ipar;
    struct OPAR_CFW_CfgNwSetLockedFrequencyBand *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgNwSetLockedFrequencyBand) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgNwSetLockedFrequencyBand) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgNwSetLockedFrequencyBand *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgNwSetLockedFrequencyBand *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgNwSetLockedFrequencyBand;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nBand = nBand;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgNwGetLockedFrequencyBand
uint32_t CFW_CfgNwGetLockedFrequencyBand(uint8_t *pBand, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgNwGetLockedFrequencyBand *ipar;
    struct OPAR_CFW_CfgNwGetLockedFrequencyBand *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgNwGetLockedFrequencyBand) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgNwGetLockedFrequencyBand) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgNwGetLockedFrequencyBand *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgNwGetLockedFrequencyBand *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgNwGetLockedFrequencyBand;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pBand = opar->pBand;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgNwSetFrequencyBand
uint32_t CFW_CfgNwSetFrequencyBand(uint8_t nBand, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgNwSetFrequencyBand *ipar;
    struct OPAR_CFW_CfgNwSetFrequencyBand *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgNwSetFrequencyBand) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgNwSetFrequencyBand) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgNwSetFrequencyBand *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgNwSetFrequencyBand *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgNwSetFrequencyBand;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nBand = nBand;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgNwGetFrequencyBand
uint32_t CFW_CfgNwGetFrequencyBand(uint8_t *nBand, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgNwGetFrequencyBand *ipar;
    struct OPAR_CFW_CfgNwGetFrequencyBand *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgNwGetFrequencyBand) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgNwGetFrequencyBand) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgNwGetFrequencyBand *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgNwGetFrequencyBand *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgNwGetFrequencyBand;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *nBand = opar->nBand;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgNwSetNetWorkMode
uint32_t CFW_CfgNwSetNetWorkMode(uint8_t nMode, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgNwSetNetWorkMode *ipar;
    struct OPAR_CFW_CfgNwSetNetWorkMode *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgNwSetNetWorkMode) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgNwSetNetWorkMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgNwSetNetWorkMode *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgNwSetNetWorkMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgNwSetNetWorkMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nMode = nMode;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgNwGetNetWorkMode
uint32_t CFW_CfgNwGetNetWorkMode(uint8_t *pMode, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgNwGetNetWorkMode *ipar;
    struct OPAR_CFW_CfgNwGetNetWorkMode *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgNwGetNetWorkMode) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgNwGetNetWorkMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgNwGetNetWorkMode *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgNwGetNetWorkMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgNwGetNetWorkMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pMode = opar->pMode;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetNwStatus
uint32_t CFW_CfgSetNwStatus(uint8_t n, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetNwStatus *ipar;
    struct OPAR_CFW_CfgSetNwStatus *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetNwStatus) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetNwStatus) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetNwStatus *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetNwStatus *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetNwStatus;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->n = n;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetNwStatus
uint32_t CFW_CfgGetNwStatus(uint8_t *pCmd, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgGetNwStatus *ipar;
    struct OPAR_CFW_CfgGetNwStatus *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgGetNwStatus) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetNwStatus) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgGetNwStatus *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgGetNwStatus *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetNwStatus;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pCmd = opar->pCmd;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgNwSetCgclassType
uint32_t CFW_CfgNwSetCgclassType(uint8_t nCgclassType, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgNwSetCgclassType *ipar;
    struct OPAR_CFW_CfgNwSetCgclassType *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgNwSetCgclassType) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgNwSetCgclassType) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgNwSetCgclassType *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgNwSetCgclassType *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgNwSetCgclassType;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCgclassType = nCgclassType;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgNwGetCgclassType
uint32_t CFW_CfgNwGetCgclassType(uint8_t *nCgclassType, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgNwGetCgclassType *ipar;
    struct OPAR_CFW_CfgNwGetCgclassType *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgNwGetCgclassType) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgNwGetCgclassType) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgNwGetCgclassType *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgNwGetCgclassType *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgNwGetCgclassType;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *nCgclassType = opar->nCgclassType;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgNwSetFM
uint32_t CFW_CfgNwSetFM(CFW_COMM_MODE bMode, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgNwSetFM *ipar;
    struct OPAR_CFW_CfgNwSetFM *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgNwSetFM) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgNwSetFM) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgNwSetFM *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgNwSetFM *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgNwSetFM;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->bMode = bMode;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgNwGetOperatorInfo
uint32_t CFW_CfgNwGetOperatorInfo(uint8_t * *pOperatorId, uint8_t * *pOperatorName, uint32_t nIndex)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgNwGetOperatorInfo *ipar;
    struct OPAR_CFW_CfgNwGetOperatorInfo *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgNwGetOperatorInfo) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgNwGetOperatorInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgNwGetOperatorInfo *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgNwGetOperatorInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgNwGetOperatorInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nIndex = nIndex;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pOperatorId = opar->pOperatorId;
    *pOperatorName = opar->pOperatorName;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgNwGetOperatorId
uint32_t CFW_CfgNwGetOperatorId(uint8_t * *pOperatorId, uint8_t format, uint8_t * pOperatorName)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;
    uint32_t pOperatorNameSize;
    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgNwGetOperatorId *ipar;
    struct OPAR_CFW_CfgNwGetOperatorId *opar;
    char *ivar_ptr;
    uint32_t result;

    pOperatorNameSize = strlen((const char *)pOperatorName) + 1;
    ivar_size = ALIGNUP8(pOperatorNameSize);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgNwGetOperatorId) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgNwGetOperatorId) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgNwGetOperatorId *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgNwGetOperatorId *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgNwGetOperatorId);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgNwGetOperatorId;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->format = format;
    memcpy(ivar_ptr, pOperatorName, pOperatorNameSize);
    ivar_ptr += ALIGNUP8(pOperatorNameSize);
    ipar->pOperatorNameSize = pOperatorNameSize;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pOperatorId = opar->pOperatorId;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgNwGetOperatorIdWithIndex
uint32_t CFW_CfgNwGetOperatorIdWithIndex(uint8_t pOperatorId[6], uint8_t * pOperatorName, uint8_t format, uint32_t *nIndex)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;
    uint32_t pOperatorNameSize;
    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgNwGetOperatorIdWithIndex *ipar;
    struct OPAR_CFW_CfgNwGetOperatorIdWithIndex *opar;
    char *ivar_ptr;
    uint32_t result;

    pOperatorNameSize = strlen((const char *)pOperatorName) + 1;
    ivar_size = ALIGNUP8(pOperatorNameSize);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgNwGetOperatorIdWithIndex) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgNwGetOperatorIdWithIndex) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgNwGetOperatorIdWithIndex *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgNwGetOperatorIdWithIndex *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgNwGetOperatorIdWithIndex);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgNwGetOperatorIdWithIndex;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ivar_ptr, pOperatorName, pOperatorNameSize);
    ivar_ptr += ALIGNUP8(pOperatorNameSize);
    ipar->pOperatorNameSize = pOperatorNameSize;
    ipar->format = format;
    ipar->nIndex = *nIndex;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(pOperatorId, opar->pOperatorId, sizeof(opar->pOperatorId));
    *nIndex = opar->nIndex;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgNwGetOperatorName
uint32_t CFW_CfgNwGetOperatorName(uint8_t pOperatorId[6], uint8_t * *pOperatorName, uint8_t * *pOperatorShortName)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgNwGetOperatorName *ipar;
    struct OPAR_CFW_CfgNwGetOperatorName *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgNwGetOperatorName) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgNwGetOperatorName) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgNwGetOperatorName *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgNwGetOperatorName *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgNwGetOperatorName;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ipar->pOperatorId, pOperatorId, sizeof(ipar->pOperatorId));
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pOperatorName = opar->pOperatorName;
    *pOperatorShortName = opar->pOperatorShortName;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetNwOperDispFormat
uint32_t CFW_CfgSetNwOperDispFormat(uint8_t nFormat)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetNwOperDispFormat *ipar;
    struct OPAR_CFW_CfgSetNwOperDispFormat *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetNwOperDispFormat) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetNwOperDispFormat) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetNwOperDispFormat *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetNwOperDispFormat *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetNwOperDispFormat;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nFormat = nFormat;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetNwOperDispFormat
uint32_t CFW_CfgGetNwOperDispFormat(uint8_t *nFormat)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_CfgGetNwOperDispFormat *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetNwOperDispFormat) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_CfgGetNwOperDispFormat *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetNwOperDispFormat;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *nFormat = opar->nFormat;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetJammingDetectFlag
uint32_t CFW_SetJammingDetectFlag(uint8_t nFlag, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetJammingDetectFlag *ipar;
    struct OPAR_CFW_SetJammingDetectFlag *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetJammingDetectFlag) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetJammingDetectFlag) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetJammingDetectFlag *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetJammingDetectFlag *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetJammingDetectFlag;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nFlag = nFlag;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetJammingDetectParam
uint32_t CFW_SetJammingDetectParam(uint8_t nFlag, int16_t nLteThreshold, int16_t nGsmThreshold, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetJammingDetectParam *ipar;
    struct OPAR_CFW_SetJammingDetectParam *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetJammingDetectParam) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetJammingDetectParam) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetJammingDetectParam *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetJammingDetectParam *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetJammingDetectParam;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nFlag = nFlag;
    ipar->nLteThreshold = nLteThreshold;
    ipar->nGsmThreshold = nGsmThreshold;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwJammingRssiEnquiry
uint32_t CFW_NwJammingRssiEnquiry(uint8_t nMode, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwJammingRssiEnquiry *ipar;
    struct OPAR_CFW_NwJammingRssiEnquiry *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwJammingRssiEnquiry) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwJammingRssiEnquiry) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwJammingRssiEnquiry *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwJammingRssiEnquiry *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwJammingRssiEnquiry;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nMode = nMode;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetJammingDetect
uint32_t CFW_GetJammingDetect(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetJammingDetect *ipar;
    struct OPAR_CFW_GetJammingDetect *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetJammingDetect) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetJammingDetect) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetJammingDetect *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetJammingDetect *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetJammingDetect;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetJammingDetectParamEx
uint32_t CFW_SetJammingDetectParamEx(uint8_t bEnable, uint8_t detectPeriod, int16_t rssiThresholdLte, int16_t rsrpThreshold, int16_t rsrqThreshold, int16_t rssiThreshold, int16_t snrThreshold, uint16_t minCh, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetJammingDetectParamEx *ipar;
    struct OPAR_CFW_SetJammingDetectParamEx *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetJammingDetectParamEx) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetJammingDetectParamEx) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetJammingDetectParamEx *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetJammingDetectParamEx *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetJammingDetectParamEx;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->bEnable = bEnable;
    ipar->detectPeriod = detectPeriod;
    ipar->rssiThresholdLte = rssiThresholdLte;
    ipar->rsrpThreshold = rsrpThreshold;
    ipar->rsrqThreshold = rsrqThreshold;
    ipar->rssiThreshold = rssiThreshold;
    ipar->snrThreshold = snrThreshold;
    ipar->minCh = minCh;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetFreqScanInfo
uint32_t CFW_GetFreqScanInfo(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetFreqScanInfo *ipar;
    struct OPAR_CFW_GetFreqScanInfo *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetFreqScanInfo) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetFreqScanInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetFreqScanInfo *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetFreqScanInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetFreqScanInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetFreqScanEnd
uint32_t CFW_GetFreqScanEnd(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetFreqScanEnd *ipar;
    struct OPAR_CFW_GetFreqScanEnd *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetFreqScanEnd) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetFreqScanEnd) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetFreqScanEnd *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetFreqScanEnd *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetFreqScanEnd;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetFreqScanAllInfo
uint32_t CFW_GetFreqScanAllInfo(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetFreqScanAllInfo *ipar;
    struct OPAR_CFW_GetFreqScanAllInfo *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetFreqScanAllInfo) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetFreqScanAllInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetFreqScanAllInfo *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetFreqScanAllInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetFreqScanAllInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CheckSupportLteBand
bool CFW_CheckSupportLteBand(uint16_t nBand, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CheckSupportLteBand *ipar;
    struct OPAR_CFW_CheckSupportLteBand *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CheckSupportLteBand) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CheckSupportLteBand) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CheckSupportLteBand *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CheckSupportLteBand *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CheckSupportLteBand;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nBand = nBand;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CheckSupportLteFreq
bool CFW_CheckSupportLteFreq(uint32_t nFreq, uint8_t dlOrUl, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CheckSupportLteFreq *ipar;
    struct OPAR_CFW_CheckSupportLteFreq *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CheckSupportLteFreq) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CheckSupportLteFreq) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CheckSupportLteFreq *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CheckSupportLteFreq *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CheckSupportLteFreq;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nFreq = nFreq;
    ipar->dlOrUl = dlOrUl;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetSSN
uint32_t CFW_CfgSetSSN(uint8_t nCSSI, uint8_t nCSSU, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetSSN *ipar;
    struct OPAR_CFW_CfgSetSSN *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetSSN) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetSSN) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetSSN *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetSSN *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetSSN;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCSSI = nCSSI;
    ipar->nCSSU = nCSSU;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetSSN
uint32_t CFW_CfgGetSSN(uint8_t *nCSSI, uint8_t *nCSSU, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgGetSSN *ipar;
    struct OPAR_CFW_CfgGetSSN *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgGetSSN) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetSSN) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgGetSSN *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgGetSSN *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetSSN;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *nCSSI = opar->nCSSI;
    *nCSSU = opar->nCSSU;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetClir
uint32_t CFW_CfgSetClir(uint8_t nClir, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetClir *ipar;
    struct OPAR_CFW_CfgSetClir *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetClir) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetClir) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetClir *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetClir *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetClir;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nClir = nClir;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetClir
uint32_t CFW_CfgGetClir(uint8_t *nClir, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgGetClir *ipar;
    struct OPAR_CFW_CfgGetClir *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgGetClir) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetClir) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgGetClir *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgGetClir *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetClir;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *nClir = opar->nClir;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetClip
uint32_t CFW_CfgSetClip(uint8_t nEnable, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetClip *ipar;
    struct OPAR_CFW_CfgSetClip *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetClip) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetClip) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetClip *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetClip *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetClip;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nEnable = nEnable;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetClip
uint32_t CFW_CfgGetClip(uint8_t *nEnable, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgGetClip *ipar;
    struct OPAR_CFW_CfgGetClip *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgGetClip) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetClip) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgGetClip *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgGetClip *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetClip;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *nEnable = opar->nEnable;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetColp
uint32_t CFW_CfgSetColp(uint8_t n, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetColp *ipar;
    struct OPAR_CFW_CfgSetColp *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetColp) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetColp) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetColp *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetColp *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetColp;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->n = n;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetColp
uint32_t CFW_CfgGetColp(uint8_t *n, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgGetColp *ipar;
    struct OPAR_CFW_CfgGetColp *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgGetColp) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetColp) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgGetColp *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgGetColp *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetColp;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *n = opar->n;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetCallWaiting
uint32_t CFW_CfgSetCallWaiting(uint8_t n, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetCallWaiting *ipar;
    struct OPAR_CFW_CfgSetCallWaiting *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetCallWaiting) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetCallWaiting) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetCallWaiting *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetCallWaiting *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetCallWaiting;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->n = n;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetCallWaiting
uint32_t CFW_CfgGetCallWaiting(uint8_t *n, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgGetCallWaiting *ipar;
    struct OPAR_CFW_CfgGetCallWaiting *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgGetCallWaiting) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetCallWaiting) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgGetCallWaiting *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgGetCallWaiting *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetCallWaiting;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *n = opar->n;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetIMSI
uint32_t CFW_CfgGetIMSI(uint8_t pIMSI[15], CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgGetIMSI *ipar;
    struct OPAR_CFW_CfgGetIMSI *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgGetIMSI) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetIMSI) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgGetIMSI *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgGetIMSI *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetIMSI;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(pIMSI, opar->pIMSI, sizeof(opar->pIMSI));
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetIMSI
uint32_t CFW_CfgSetIMSI(uint8_t pIMSI[15], CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetIMSI *ipar;
    struct OPAR_CFW_CfgSetIMSI *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetIMSI) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetIMSI) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetIMSI *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetIMSI *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetIMSI;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ipar->pIMSI, pIMSI, sizeof(ipar->pIMSI));
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetCdmaImsi
uint32_t CFW_CfgGetCdmaImsi(uint8_t pCdmaImsi[10], CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgGetCdmaImsi *ipar;
    struct OPAR_CFW_CfgGetCdmaImsi *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgGetCdmaImsi) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetCdmaImsi) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgGetCdmaImsi *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgGetCdmaImsi *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetCdmaImsi;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ipar->pCdmaImsi, pCdmaImsi, sizeof(ipar->pCdmaImsi));
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#if defined(LTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_NwSetEpsMode
uint32_t CFW_NwSetEpsMode(uint8_t eps_mode, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwSetEpsMode *ipar;
    struct OPAR_CFW_NwSetEpsMode *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwSetEpsMode) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwSetEpsMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwSetEpsMode *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwSetEpsMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwSetEpsMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->eps_mode = eps_mode;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#ifndef DISABLE_RPC_CFW_CfgSetToneDuration
uint32_t CFW_CfgSetToneDuration(uint8_t nToneDuration)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetToneDuration *ipar;
    struct OPAR_CFW_CfgSetToneDuration *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetToneDuration) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetToneDuration) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetToneDuration *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetToneDuration *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetToneDuration;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nToneDuration = nToneDuration;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetToneDuration
uint32_t CFW_CfgGetToneDuration(uint8_t *pToneDuration)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_CfgGetToneDuration *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetToneDuration) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_CfgGetToneDuration *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetToneDuration;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pToneDuration = opar->pToneDuration;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetIncomingCallResultMode
uint32_t CFW_CfgSetIncomingCallResultMode(uint8_t nMode)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetIncomingCallResultMode *ipar;
    struct OPAR_CFW_CfgSetIncomingCallResultMode *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetIncomingCallResultMode) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetIncomingCallResultMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetIncomingCallResultMode *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetIncomingCallResultMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetIncomingCallResultMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nMode = nMode;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetIncomingCallResultMode
uint32_t CFW_CfgGetIncomingCallResultMode(uint8_t *nMode)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_CfgGetIncomingCallResultMode *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetIncomingCallResultMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_CfgGetIncomingCallResultMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetIncomingCallResultMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *nMode = opar->nMode;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetAudioOutputParam
uint32_t CFW_CfgSetAudioOutputParam(CFW_AUD_OUT_PARAMETER *pAudOutParam)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetAudioOutputParam *ipar;
    struct OPAR_CFW_CfgSetAudioOutputParam *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetAudioOutputParam) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetAudioOutputParam) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetAudioOutputParam *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetAudioOutputParam *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetAudioOutputParam;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pAudOutParam = *pAudOutParam;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetAudioOutputParam
uint32_t CFW_CfgGetAudioOutputParam(CFW_AUD_OUT_PARAMETER *pAudOutParam)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_CfgGetAudioOutputParam *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetAudioOutputParam) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_CfgGetAudioOutputParam *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetAudioOutputParam;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pAudOutParam = opar->pAudOutParam;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetAudioAudioMode
uint32_t CFW_CfgSetAudioAudioMode(uint8_t nAudioMode)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetAudioAudioMode *ipar;
    struct OPAR_CFW_CfgSetAudioAudioMode *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetAudioAudioMode) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetAudioAudioMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetAudioAudioMode *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetAudioAudioMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetAudioAudioMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nAudioMode = nAudioMode;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetAudioAudioMode
uint32_t CFW_CfgGetAudioAudioMode(uint8_t *pAudioMode)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_CfgGetAudioAudioMode *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetAudioAudioMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_CfgGetAudioAudioMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetAudioAudioMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pAudioMode = opar->pAudioMode;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetLoudspeakerVolumeLevel
uint32_t CFW_CfgSetLoudspeakerVolumeLevel(uint8_t nVolumeLevel)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetLoudspeakerVolumeLevel *ipar;
    struct OPAR_CFW_CfgSetLoudspeakerVolumeLevel *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetLoudspeakerVolumeLevel) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetLoudspeakerVolumeLevel) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetLoudspeakerVolumeLevel *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetLoudspeakerVolumeLevel *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetLoudspeakerVolumeLevel;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nVolumeLevel = nVolumeLevel;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetLoudspeakerVolumeLevel
uint32_t CFW_CfgGetLoudspeakerVolumeLevel(uint8_t *pVolumeLevel)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_CfgGetLoudspeakerVolumeLevel *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetLoudspeakerVolumeLevel) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_CfgGetLoudspeakerVolumeLevel *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetLoudspeakerVolumeLevel;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pVolumeLevel = opar->pVolumeLevel;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetLoudspeakerVolumeLevelRange
uint32_t CFW_CfgGetLoudspeakerVolumeLevelRange(uint8_t *pMinVolumeLevel, uint8_t *pMaxVolumeLevel)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_CfgGetLoudspeakerVolumeLevelRange *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetLoudspeakerVolumeLevelRange) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_CfgGetLoudspeakerVolumeLevelRange *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetLoudspeakerVolumeLevelRange;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pMinVolumeLevel = opar->pMinVolumeLevel;
    *pMaxVolumeLevel = opar->pMaxVolumeLevel;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#if defined(CFW_VOLTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_ImsInit
uint32_t CFW_ImsInit(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_ImsInit *ipar;
    struct OPAR_CFW_ImsInit *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_ImsInit) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_ImsInit) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_ImsInit *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_ImsInit *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ImsInit;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_VOLTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_ImsEnable
uint32_t CFW_ImsEnable(uint8_t isEmergency, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_ImsEnable *ipar;
    struct OPAR_CFW_ImsEnable *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_ImsEnable) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_ImsEnable) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_ImsEnable *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_ImsEnable *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ImsEnable;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->isEmergency = isEmergency;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_VOLTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_ImsDisable
uint32_t CFW_ImsDisable(uint8_t isEmergency, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_ImsDisable *ipar;
    struct OPAR_CFW_ImsDisable *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_ImsDisable) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_ImsDisable) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_ImsDisable *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_ImsDisable *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ImsDisable;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->isEmergency = isEmergency;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_VOLTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_ImsSuspend
uint32_t CFW_ImsSuspend(CFW_SIM_ID nSimID, CFW_IMS_SUSPEND_TYPE nType)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_ImsSuspend *ipar;
    struct OPAR_CFW_ImsSuspend *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_ImsSuspend) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_ImsSuspend) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_ImsSuspend *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_ImsSuspend *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ImsSuspend;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    ipar->nType = nType;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_VOLTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_ImsResume
uint32_t CFW_ImsResume(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_ImsResume *ipar;
    struct OPAR_CFW_ImsResume *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_ImsResume) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_ImsResume) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_ImsResume *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_ImsResume *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ImsResume;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#ifndef DISABLE_RPC_CFW_GprsGetNsapi
uint8_t CFW_GprsGetNsapi(uint8_t nCid, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsGetNsapi *ipar;
    struct OPAR_CFW_GprsGetNsapi *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsGetNsapi) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsGetNsapi) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsGetNsapi *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsGetNsapi *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsGetNsapi;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCid = nCid;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#if defined(CFW_VOLTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_ImsSetDapsCallback
uint32_t CFW_ImsSetDapsCallback(uint8_t nCid, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_ImsSetDapsCallback *ipar;
    struct OPAR_CFW_ImsSetDapsCallback *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_ImsSetDapsCallback) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_ImsSetDapsCallback) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_ImsSetDapsCallback *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_ImsSetDapsCallback *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ImsSetDapsCallback;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCid = nCid;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_VOLTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_ImsSetVolte
uint32_t CFW_ImsSetVolte(uint8_t bSet, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_ImsSetVolte *ipar;
    struct OPAR_CFW_ImsSetVolte *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_ImsSetVolte) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_ImsSetVolte) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_ImsSetVolte *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_ImsSetVolte *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ImsSetVolte;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->bSet = bSet;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_VOLTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_ImsSetCevdp
uint32_t CFW_ImsSetCevdp(uint8_t setting, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_ImsSetCevdp *ipar;
    struct OPAR_CFW_ImsSetCevdp *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_ImsSetCevdp) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_ImsSetCevdp) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_ImsSetCevdp *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_ImsSetCevdp *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ImsSetCevdp;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->setting = setting;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#ifndef DISABLE_RPC_CFW_ImsGetCevdp
uint8_t CFW_ImsGetCevdp(uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_ImsGetCevdp *ipar;
    struct OPAR_CFW_ImsGetCevdp *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_ImsGetCevdp) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_ImsGetCevdp) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_ImsGetCevdp *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_ImsGetCevdp *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ImsGetCevdp;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#if defined(CFW_VOLTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_ImsSetTerminalMode
uint32_t CFW_ImsSetTerminalMode(uint8_t setting, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_ImsSetTerminalMode *ipar;
    struct OPAR_CFW_ImsSetTerminalMode *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_ImsSetTerminalMode) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_ImsSetTerminalMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_ImsSetTerminalMode *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_ImsSetTerminalMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ImsSetTerminalMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->setting = setting;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_VOLTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_ImsGetTerminalMode
uint8_t CFW_ImsGetTerminalMode(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_ImsGetTerminalMode *ipar;
    struct OPAR_CFW_ImsGetTerminalMode *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_ImsGetTerminalMode) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_ImsGetTerminalMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_ImsGetTerminalMode *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_ImsGetTerminalMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ImsGetTerminalMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_VOLTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_ImsSetSrvccMode
uint32_t CFW_ImsSetSrvccMode(uint8_t ueSrvcc, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_ImsSetSrvccMode *ipar;
    struct OPAR_CFW_ImsSetSrvccMode *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_ImsSetSrvccMode) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_ImsSetSrvccMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_ImsSetSrvccMode *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_ImsSetSrvccMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ImsSetSrvccMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->ueSrvcc = ueSrvcc;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_VOLTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_ImsGetSrvccMode
uint8_t CFW_ImsGetSrvccMode(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_ImsGetSrvccMode *ipar;
    struct OPAR_CFW_ImsGetSrvccMode *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_ImsGetSrvccMode) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_ImsGetSrvccMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_ImsGetSrvccMode *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_ImsGetSrvccMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ImsGetSrvccMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_VOLTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_ImsIsSet
bool CFW_ImsIsSet(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_ImsIsSet *ipar;
    struct OPAR_CFW_ImsIsSet *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_ImsIsSet) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_ImsIsSet) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_ImsIsSet *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_ImsIsSet *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ImsIsSet;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_VOLTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_ImsFreeUti
uint8_t CFW_ImsFreeUti(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_ImsFreeUti *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_ImsFreeUti) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_ImsFreeUti *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ImsFreeUti;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_VOLTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_ImsActImsPdp
uint32_t CFW_ImsActImsPdp(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_ImsActImsPdp *ipar;
    struct OPAR_CFW_ImsActImsPdp *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_ImsActImsPdp) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_ImsActImsPdp) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_ImsActImsPdp *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_ImsActImsPdp *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ImsActImsPdp;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_VOLTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_ImsDoSavedEmcDail
uint32_t CFW_ImsDoSavedEmcDail(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_ImsDoSavedEmcDail *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_ImsDoSavedEmcDail) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_ImsDoSavedEmcDail *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ImsDoSavedEmcDail;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_VOLTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_ImsSetPdpStatus
uint32_t CFW_ImsSetPdpStatus(uint8_t nStatus, uint8_t isEmergency, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_ImsSetPdpStatus *ipar;
    struct OPAR_CFW_ImsSetPdpStatus *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_ImsSetPdpStatus) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_ImsSetPdpStatus) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_ImsSetPdpStatus *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_ImsSetPdpStatus *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ImsSetPdpStatus;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nStatus = nStatus;
    ipar->isEmergency = isEmergency;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_VOLTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_ImsGetPdpStatus
uint8_t CFW_ImsGetPdpStatus(uint8_t isEmergency, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_ImsGetPdpStatus *ipar;
    struct OPAR_CFW_ImsGetPdpStatus *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_ImsGetPdpStatus) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_ImsGetPdpStatus) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_ImsGetPdpStatus *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_ImsGetPdpStatus *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ImsGetPdpStatus;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->isEmergency = isEmergency;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_VOLTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_ImsCheckStatusAfterCc
uint32_t CFW_ImsCheckStatusAfterCc(uint8_t nCsImsFlag, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_ImsCheckStatusAfterCc *ipar;
    struct OPAR_CFW_ImsCheckStatusAfterCc *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_ImsCheckStatusAfterCc) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_ImsCheckStatusAfterCc) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_ImsCheckStatusAfterCc *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_ImsCheckStatusAfterCc *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ImsCheckStatusAfterCc;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCsImsFlag = nCsImsFlag;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_VOLTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_SsSetClip
uint32_t CFW_SsSetClip(uint8_t set, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SsSetClip *ipar;
    struct OPAR_CFW_SsSetClip *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SsSetClip) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SsSetClip) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SsSetClip *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SsSetClip *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SsSetClip;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->set = set;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_VOLTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_SsSetClir
uint32_t CFW_SsSetClir(uint8_t set, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SsSetClir *ipar;
    struct OPAR_CFW_SsSetClir *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SsSetClir) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SsSetClir) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SsSetClir *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SsSetClir *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SsSetClir;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->set = set;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_VOLTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_SsSetColp
uint32_t CFW_SsSetColp(uint8_t set, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SsSetColp *ipar;
    struct OPAR_CFW_SsSetColp *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SsSetColp) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SsSetColp) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SsSetColp *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SsSetColp *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SsSetColp;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->set = set;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_VOLTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_ImsIsRegistered
bool CFW_ImsIsRegistered(uint8_t isEmergency, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_ImsIsRegistered *ipar;
    struct OPAR_CFW_ImsIsRegistered *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_ImsIsRegistered) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_ImsIsRegistered) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_ImsIsRegistered *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_ImsIsRegistered *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ImsIsRegistered;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->isEmergency = isEmergency;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#ifndef DISABLE_RPC_CFW_NWSetRat
uint32_t CFW_NWSetRat(uint8_t nRat, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NWSetRat *ipar;
    struct OPAR_CFW_NWSetRat *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NWSetRat) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NWSetRat) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NWSetRat *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NWSetRat *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NWSetRat;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nRat = nRat;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NWGetRat
uint8_t CFW_NWGetRat(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NWGetRat *ipar;
    struct OPAR_CFW_NWGetRat *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NWGetRat) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NWGetRat) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NWGetRat *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NWGetRat *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NWGetRat;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NWSetStackRat
uint32_t CFW_NWSetStackRat(uint8_t nRat, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NWSetStackRat *ipar;
    struct OPAR_CFW_NWSetStackRat *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NWSetStackRat) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NWSetStackRat) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NWSetStackRat *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NWSetStackRat *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NWSetStackRat;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nRat = nRat;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NWGetStackRat
uint8_t CFW_NWGetStackRat(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NWGetStackRat *ipar;
    struct OPAR_CFW_NWGetStackRat *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NWGetStackRat) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NWGetStackRat) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NWGetStackRat *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NWGetStackRat *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NWGetStackRat;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwSetNetMode
uint32_t CFW_NwSetNetMode(uint8_t nNetMode, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwSetNetMode *ipar;
    struct OPAR_CFW_NwSetNetMode *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwSetNetMode) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwSetNetMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwSetNetMode *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwSetNetMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwSetNetMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nNetMode = nNetMode;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwGetAvailableOperators
uint32_t CFW_NwGetAvailableOperators(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwGetAvailableOperators *ipar;
    struct OPAR_CFW_NwGetAvailableOperators *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwGetAvailableOperators) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwGetAvailableOperators) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwGetAvailableOperators *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwGetAvailableOperators *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwGetAvailableOperators;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwGetAvailableOperators_V2
uint32_t CFW_NwGetAvailableOperators_V2(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwGetAvailableOperators_V2 *ipar;
    struct OPAR_CFW_NwGetAvailableOperators_V2 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwGetAvailableOperators_V2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwGetAvailableOperators_V2) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwGetAvailableOperators_V2 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwGetAvailableOperators_V2 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwGetAvailableOperators_V2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwGetCurrentOperator
uint32_t CFW_NwGetCurrentOperator(uint8_t OperatorId[6], uint8_t *pMode, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwGetCurrentOperator *ipar;
    struct OPAR_CFW_NwGetCurrentOperator *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwGetCurrentOperator) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwGetCurrentOperator) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwGetCurrentOperator *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwGetCurrentOperator *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwGetCurrentOperator;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(OperatorId, opar->OperatorId, sizeof(opar->OperatorId));
    *pMode = opar->pMode;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwGetImei
uint32_t CFW_NwGetImei(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwGetImei *ipar;
    struct OPAR_CFW_NwGetImei *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwGetImei) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwGetImei) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwGetImei *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwGetImei *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwGetImei;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwGetSignalQuality
uint32_t CFW_NwGetSignalQuality(uint8_t *pSignalLevel, uint8_t *pBitError, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwGetSignalQuality *ipar;
    struct OPAR_CFW_NwGetSignalQuality *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwGetSignalQuality) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwGetSignalQuality) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwGetSignalQuality *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwGetSignalQuality *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwGetSignalQuality;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pSignalLevel = opar->pSignalLevel;
    *pBitError = opar->pBitError;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwGetLteSignalQuality
uint32_t CFW_NwGetLteSignalQuality(uint8_t *pSignalLevel, uint8_t *pBitError, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwGetLteSignalQuality *ipar;
    struct OPAR_CFW_NwGetLteSignalQuality *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwGetLteSignalQuality) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwGetLteSignalQuality) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwGetLteSignalQuality *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwGetLteSignalQuality *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwGetLteSignalQuality;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pSignalLevel = opar->pSignalLevel;
    *pBitError = opar->pBitError;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwGetStatus
uint32_t CFW_NwGetStatus(CFW_NW_STATUS_INFO *pStatusInfo, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwGetStatus *ipar;
    struct OPAR_CFW_NwGetStatus *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwGetStatus) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwGetStatus) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwGetStatus *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwGetStatus *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwGetStatus;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pStatusInfo = opar->pStatusInfo;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwGetStatisticRpt
uint32_t CFW_NwGetStatisticRpt(CFW_ENG_STATIS_RPT *pEngStatisRpt, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwGetStatisticRpt *ipar;
    struct OPAR_CFW_NwGetStatisticRpt *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwGetStatisticRpt) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwGetStatisticRpt) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwGetStatisticRpt *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwGetStatisticRpt *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwGetStatisticRpt;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pEngStatisRpt = opar->pEngStatisRpt;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwSetRegistration
uint32_t CFW_NwSetRegistration(uint8_t nOperatorId[6], uint8_t nMode, uint8_t nRat, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwSetRegistration *ipar;
    struct OPAR_CFW_NwSetRegistration *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwSetRegistration) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwSetRegistration) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwSetRegistration *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwSetRegistration *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwSetRegistration;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ipar->nOperatorId, nOperatorId, sizeof(ipar->nOperatorId));
    ipar->nMode = nMode;
    ipar->nRat = nRat;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwDeRegister
uint32_t CFW_NwDeRegister(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwDeRegister *ipar;
    struct OPAR_CFW_NwDeRegister *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwDeRegister) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwDeRegister) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwDeRegister *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwDeRegister *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwDeRegister;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_DetachCSAndPS
uint32_t CFW_DetachCSAndPS(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_DetachCSAndPS *ipar;
    struct OPAR_CFW_DetachCSAndPS *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_DetachCSAndPS) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_DetachCSAndPS) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_DetachCSAndPS *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_DetachCSAndPS *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_DetachCSAndPS;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_AttachCSAndPS
uint32_t CFW_AttachCSAndPS(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_AttachCSAndPS *ipar;
    struct OPAR_CFW_AttachCSAndPS *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_AttachCSAndPS) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_AttachCSAndPS) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_AttachCSAndPS *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_AttachCSAndPS *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_AttachCSAndPS;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwGetAllDetach
uint32_t CFW_NwGetAllDetach(uint8_t *nAttDetach, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwGetAllDetach *ipar;
    struct OPAR_CFW_NwGetAllDetach *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwGetAllDetach) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwGetAllDetach) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwGetAllDetach *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwGetAllDetach *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwGetAllDetach;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *nAttDetach = opar->nAttDetach;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwGetHNBName
uint32_t CFW_NwGetHNBName(uint8_t *pLength, uint8_t pHNBName[48], CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwGetHNBName *ipar;
    struct OPAR_CFW_NwGetHNBName *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwGetHNBName) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwGetHNBName) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwGetHNBName *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwGetHNBName *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwGetHNBName;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pLength = opar->pLength;
    memcpy(pHNBName, opar->pHNBName, sizeof(opar->pHNBName));
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#if defined(CSG_SUPPORT)
#ifndef DISABLE_RPC_CFW_NwCSGSetRegistration
uint32_t CFW_NwCSGSetRegistration(uint8_t nOperatorId[6], uint8_t nMode, uint8_t nRat, uint32_t nCsgId, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwCSGSetRegistration *ipar;
    struct OPAR_CFW_NwCSGSetRegistration *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwCSGSetRegistration) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwCSGSetRegistration) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwCSGSetRegistration *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwCSGSetRegistration *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwCSGSetRegistration;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ipar->nOperatorId, nOperatorId, sizeof(ipar->nOperatorId));
    ipar->nMode = nMode;
    ipar->nRat = nRat;
    ipar->nCsgId = nCsgId;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CSG_SUPPORT)
#ifndef DISABLE_RPC_CFW_NwGetCsgOperators
uint32_t CFW_NwGetCsgOperators(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwGetCsgOperators *ipar;
    struct OPAR_CFW_NwGetCsgOperators *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwGetCsgOperators) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwGetCsgOperators) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwGetCsgOperators *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwGetCsgOperators *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwGetCsgOperators;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#ifndef DISABLE_RPC_CFW_SetComm
uint32_t CFW_SetComm(CFW_COMM_MODE nMode, uint8_t nStorageFlag, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetComm *ipar;
    struct OPAR_CFW_SetComm *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetComm) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetComm) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetComm *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetComm *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetComm;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nMode = nMode;
    ipar->nStorageFlag = nStorageFlag;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetComm
uint32_t CFW_GetComm(CFW_COMM_MODE *nMode, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetComm *ipar;
    struct OPAR_CFW_GetComm *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetComm) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetComm) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetComm *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetComm *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetComm;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *nMode = opar->nMode;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwSetCSMode
uint32_t CFW_NwSetCSMode(uint8_t nMode, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwSetCSMode *ipar;
    struct OPAR_CFW_NwSetCSMode *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwSetCSMode) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwSetCSMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwSetCSMode *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwSetCSMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwSetCSMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nMode = nMode;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwSetFrequencyBand
uint32_t CFW_NwSetFrequencyBand(uint8_t nBand, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwSetFrequencyBand *ipar;
    struct OPAR_CFW_NwSetFrequencyBand *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwSetFrequencyBand) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwSetFrequencyBand) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwSetFrequencyBand *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwSetFrequencyBand *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwSetFrequencyBand;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nBand = nBand;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwAbortListOperators
uint32_t CFW_NwAbortListOperators(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwAbortListOperators *ipar;
    struct OPAR_CFW_NwAbortListOperators *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwAbortListOperators) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwAbortListOperators) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwAbortListOperators *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwAbortListOperators *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwAbortListOperators;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetNWTimerOutFlag
bool CFW_GetNWTimerOutFlag(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetNWTimerOutFlag *ipar;
    struct OPAR_CFW_GetNWTimerOutFlag *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetNWTimerOutFlag) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetNWTimerOutFlag) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetNWTimerOutFlag *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetNWTimerOutFlag *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetNWTimerOutFlag;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetNWTimerOutFlag
void CFW_SetNWTimerOutFlag(bool bClear, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetNWTimerOutFlag *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetNWTimerOutFlag) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetNWTimerOutFlag *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetNWTimerOutFlag;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->bClear = bClear;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_CcAcceptSpeechCall
uint32_t CFW_CcAcceptSpeechCall(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CcAcceptSpeechCall *ipar;
    struct OPAR_CFW_CcAcceptSpeechCall *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CcAcceptSpeechCall) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CcAcceptSpeechCall) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CcAcceptSpeechCall *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CcAcceptSpeechCall *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CcAcceptSpeechCall;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CcGetCallStatus
uint32_t CFW_CcGetCallStatus(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CcGetCallStatus *ipar;
    struct OPAR_CFW_CcGetCallStatus *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CcGetCallStatus) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CcGetCallStatus) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CcGetCallStatus *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CcGetCallStatus *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CcGetCallStatus;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetCcCount
uint8_t CFW_GetCcCount(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetCcCount *ipar;
    struct OPAR_CFW_GetCcCount *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetCcCount) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetCcCount) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetCcCount *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetCcCount *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetCcCount;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CcGetCurrentCall
uint32_t CFW_CcGetCurrentCall(CFW_CC_CURRENT_CALL_INFO CallInfo[7], uint8_t *pCnt, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CcGetCurrentCall *ipar;
    struct OPAR_CFW_CcGetCurrentCall *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CcGetCurrentCall) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CcGetCurrentCall) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CcGetCurrentCall *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CcGetCurrentCall *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CcGetCurrentCall;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(CallInfo, opar->CallInfo, sizeof(opar->CallInfo));
    *pCnt = opar->pCnt;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CcGetCurrentCallV2
uint32_t CFW_CcGetCurrentCallV2(CFW_CC_CURRENT_CALL_INFO_V2 CallInfo[7], uint8_t *pCnt, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CcGetCurrentCallV2 *ipar;
    struct OPAR_CFW_CcGetCurrentCallV2 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CcGetCurrentCallV2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CcGetCurrentCallV2) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CcGetCurrentCallV2 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CcGetCurrentCallV2 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CcGetCurrentCallV2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(CallInfo, opar->CallInfo, sizeof(opar->CallInfo));
    *pCnt = opar->pCnt;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = 1;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CcCallHoldMultiparty
uint32_t CFW_CcCallHoldMultiparty(uint8_t nCmd, uint8_t nIndex, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CcCallHoldMultiparty *ipar;
    struct OPAR_CFW_CcCallHoldMultiparty *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CcCallHoldMultiparty) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CcCallHoldMultiparty) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CcCallHoldMultiparty *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CcCallHoldMultiparty *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CcCallHoldMultiparty;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCmd = nCmd;
    ipar->nIndex = nIndex;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CcCallHoldMultiparty_V2
uint32_t CFW_CcCallHoldMultiparty_V2(uint16_t nUTI, uint8_t nCmd, uint8_t nIndex, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CcCallHoldMultiparty_V2 *ipar;
    struct OPAR_CFW_CcCallHoldMultiparty_V2 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CcCallHoldMultiparty_V2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CcCallHoldMultiparty_V2) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CcCallHoldMultiparty_V2 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CcCallHoldMultiparty_V2 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CcCallHoldMultiparty_V2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nCmd = nCmd;
    ipar->nIndex = nIndex;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#if defined(LTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_CcReleaseCallX
uint32_t CFW_CcReleaseCallX(uint8_t nIndex, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CcReleaseCallX *ipar;
    struct OPAR_CFW_CcReleaseCallX *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CcReleaseCallX) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CcReleaseCallX) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CcReleaseCallX *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CcReleaseCallX *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CcReleaseCallX;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nIndex = nIndex;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(LTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_CcReleaseCallX_V2
uint32_t CFW_CcReleaseCallX_V2(uint16_t nUTI, uint8_t nIndex, uint8_t cause, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CcReleaseCallX_V2 *ipar;
    struct OPAR_CFW_CcReleaseCallX_V2 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CcReleaseCallX_V2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CcReleaseCallX_V2) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CcReleaseCallX_V2 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CcReleaseCallX_V2 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CcReleaseCallX_V2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nIndex = nIndex;
    ipar->cause = cause;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#ifndef DISABLE_RPC_CFW_CcInitiateSpeechCall_V2
uint32_t CFW_CcInitiateSpeechCall_V2(CFW_DIALNUMBER_V2 *pDialNumber, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CcInitiateSpeechCall_V2 *ipar;
    struct OPAR_CFW_CcInitiateSpeechCall_V2 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CcInitiateSpeechCall_V2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CcInitiateSpeechCall_V2) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CcInitiateSpeechCall_V2 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CcInitiateSpeechCall_V2 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CcInitiateSpeechCall_V2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pDialNumber = *pDialNumber;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CcInitiateSpeechCallEx_V2
uint32_t CFW_CcInitiateSpeechCallEx_V2(CFW_DIALNUMBER_V2 *pDialNumber, uint8_t *pIndex, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CcInitiateSpeechCallEx_V2 *ipar;
    struct OPAR_CFW_CcInitiateSpeechCallEx_V2 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CcInitiateSpeechCallEx_V2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CcInitiateSpeechCallEx_V2) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CcInitiateSpeechCallEx_V2 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CcInitiateSpeechCallEx_V2 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CcInitiateSpeechCallEx_V2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pDialNumber = *pDialNumber;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pIndex = opar->pIndex;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CcEmcDial
uint32_t CFW_CcEmcDial(uint8_t * pNumber, uint8_t nSize, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CcEmcDial *ipar;
    struct OPAR_CFW_CcEmcDial *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nSize+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CcEmcDial) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CcEmcDial) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CcEmcDial *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CcEmcDial *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CcEmcDial);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CcEmcDial;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ivar_ptr, pNumber, nSize);
    ivar_ptr[nSize] = (char)0;
    ivar_ptr += ALIGNUP8(nSize + 1);
    ipar->nSize = nSize;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CcEmcDialEx
uint32_t CFW_CcEmcDialEx(uint8_t * pDialNumber, uint8_t nDialNumberSize, uint8_t *pIndex, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CcEmcDialEx *ipar;
    struct OPAR_CFW_CcEmcDialEx *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nDialNumberSize+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CcEmcDialEx) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CcEmcDialEx) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CcEmcDialEx *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CcEmcDialEx *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CcEmcDialEx);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CcEmcDialEx;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ivar_ptr, pDialNumber, nDialNumberSize);
    ivar_ptr[nDialNumberSize] = (char)0;
    ivar_ptr += ALIGNUP8(nDialNumberSize + 1);
    ipar->nDialNumberSize = nDialNumberSize;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pIndex = opar->pIndex;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CcReleaseCall
uint32_t CFW_CcReleaseCall(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CcReleaseCall *ipar;
    struct OPAR_CFW_CcReleaseCall *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CcReleaseCall) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CcReleaseCall) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CcReleaseCall *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CcReleaseCall *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CcReleaseCall;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CcReleaseCall_V2
uint32_t CFW_CcReleaseCall_V2(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CcReleaseCall_V2 *ipar;
    struct OPAR_CFW_CcReleaseCall_V2 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CcReleaseCall_V2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CcReleaseCall_V2) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CcReleaseCall_V2 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CcReleaseCall_V2 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CcReleaseCall_V2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CcRejectCall
uint32_t CFW_CcRejectCall(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CcRejectCall *ipar;
    struct OPAR_CFW_CcRejectCall *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CcRejectCall) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CcRejectCall) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CcRejectCall *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CcRejectCall *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CcRejectCall;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CcPlayTone
uint32_t CFW_CcPlayTone(int8_t iTone, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CcPlayTone *ipar;
    struct OPAR_CFW_CcPlayTone *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CcPlayTone) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CcPlayTone) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CcPlayTone *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CcPlayTone *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CcPlayTone;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->iTone = iTone;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CcStopTone
uint32_t CFW_CcStopTone(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CcStopTone *ipar;
    struct OPAR_CFW_CcStopTone *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CcStopTone) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CcStopTone) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CcStopTone *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CcStopTone *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CcStopTone;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CcSetCsfbmtFlag
uint32_t CFW_CcSetCsfbmtFlag(uint8_t nFlag, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CcSetCsfbmtFlag *ipar;
    struct OPAR_CFW_CcSetCsfbmtFlag *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CcSetCsfbmtFlag) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CcSetCsfbmtFlag) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CcSetCsfbmtFlag *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CcSetCsfbmtFlag *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CcSetCsfbmtFlag;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nFlag = nFlag;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CcGetCsfbmtFlag
uint32_t CFW_CcGetCsfbmtFlag(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CcGetCsfbmtFlag *ipar;
    struct OPAR_CFW_CcGetCsfbmtFlag *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CcGetCsfbmtFlag) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CcGetCsfbmtFlag) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CcGetCsfbmtFlag *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CcGetCsfbmtFlag *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CcGetCsfbmtFlag;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SsQueryCallWaiting
uint32_t CFW_SsQueryCallWaiting(uint8_t nClass, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SsQueryCallWaiting *ipar;
    struct OPAR_CFW_SsQueryCallWaiting *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SsQueryCallWaiting) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SsQueryCallWaiting) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SsQueryCallWaiting *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SsQueryCallWaiting *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SsQueryCallWaiting;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nClass = nClass;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SsSetCallWaiting
uint32_t CFW_SsSetCallWaiting(uint8_t nMode, uint8_t nClass, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SsSetCallWaiting *ipar;
    struct OPAR_CFW_SsSetCallWaiting *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SsSetCallWaiting) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SsSetCallWaiting) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SsSetCallWaiting *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SsSetCallWaiting *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SsSetCallWaiting;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nMode = nMode;
    ipar->nClass = nClass;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SsSetCallForwarding
uint32_t CFW_SsSetCallForwarding(CFW_SS_SET_CALLFORWARDING_INFO *pCallForwarding, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SsSetCallForwarding *ipar;
    struct OPAR_CFW_SsSetCallForwarding *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SsSetCallForwarding) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SsSetCallForwarding) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SsSetCallForwarding *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SsSetCallForwarding *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SsSetCallForwarding;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pCallForwarding = *pCallForwarding;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SsQueryCallForwarding
uint32_t CFW_SsQueryCallForwarding(uint8_t nReason, uint8_t nClass, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SsQueryCallForwarding *ipar;
    struct OPAR_CFW_SsQueryCallForwarding *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SsQueryCallForwarding) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SsQueryCallForwarding) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SsQueryCallForwarding *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SsQueryCallForwarding *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SsQueryCallForwarding;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nReason = nReason;
    ipar->nClass = nClass;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SsSetFacilityLock
uint32_t CFW_SsSetFacilityLock(uint16_t nFac, uint8_t * nBufPwd, uint8_t nPwdSize, uint8_t nClass, uint8_t nMode, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SsSetFacilityLock *ipar;
    struct OPAR_CFW_SsSetFacilityLock *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nPwdSize+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SsSetFacilityLock) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SsSetFacilityLock) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SsSetFacilityLock *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SsSetFacilityLock *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SsSetFacilityLock);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SsSetFacilityLock;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nFac = nFac;
    memcpy(ivar_ptr, nBufPwd, nPwdSize);
    ivar_ptr[nPwdSize] = (char)0;
    ivar_ptr += ALIGNUP8(nPwdSize + 1);
    ipar->nPwdSize = nPwdSize;
    ipar->nClass = nClass;
    ipar->nMode = nMode;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SsQueryFacilityLock
uint32_t CFW_SsQueryFacilityLock(uint16_t nFac, uint8_t nClass, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SsQueryFacilityLock *ipar;
    struct OPAR_CFW_SsQueryFacilityLock *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SsQueryFacilityLock) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SsQueryFacilityLock) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SsQueryFacilityLock *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SsQueryFacilityLock *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SsQueryFacilityLock;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nFac = nFac;
    ipar->nClass = nClass;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SsChangePassword
uint32_t CFW_SsChangePassword(uint16_t nFac, uint8_t * pBufOldPwd, uint8_t nOldPwdSize, uint8_t * pBufNewPwd, uint8_t nNewPwdSize, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SsChangePassword *ipar;
    struct OPAR_CFW_SsChangePassword *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nOldPwdSize+1) + ALIGNUP8(nNewPwdSize+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SsChangePassword) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SsChangePassword) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SsChangePassword *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SsChangePassword *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SsChangePassword);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SsChangePassword;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nFac = nFac;
    memcpy(ivar_ptr, pBufOldPwd, nOldPwdSize);
    ivar_ptr[nOldPwdSize] = (char)0;
    ivar_ptr += ALIGNUP8(nOldPwdSize + 1);
    ipar->nOldPwdSize = nOldPwdSize;
    memcpy(ivar_ptr, pBufNewPwd, nNewPwdSize);
    ivar_ptr[nNewPwdSize] = (char)0;
    ivar_ptr += ALIGNUP8(nNewPwdSize + 1);
    ipar->nNewPwdSize = nNewPwdSize;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SsQueryClip
uint32_t CFW_SsQueryClip(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SsQueryClip *ipar;
    struct OPAR_CFW_SsQueryClip *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SsQueryClip) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SsQueryClip) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SsQueryClip *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SsQueryClip *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SsQueryClip;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SsQueryClir
uint32_t CFW_SsQueryClir(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SsQueryClir *ipar;
    struct OPAR_CFW_SsQueryClir *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SsQueryClir) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SsQueryClir) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SsQueryClir *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SsQueryClir *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SsQueryClir;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SsQueryColp
uint32_t CFW_SsQueryColp(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SsQueryColp *ipar;
    struct OPAR_CFW_SsQueryColp *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SsQueryColp) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SsQueryColp) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SsQueryColp *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SsQueryColp *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SsQueryColp;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SsQueryColr
uint32_t CFW_SsQueryColr(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SsQueryColr *ipar;
    struct OPAR_CFW_SsQueryColr *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SsQueryColr) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SsQueryColr) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SsQueryColr *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SsQueryColr *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SsQueryColr;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SsSendUSSD
uint32_t CFW_SsSendUSSD(uint8_t * pUsdString, uint8_t nUsdStringSize, uint8_t nOption, uint8_t nDcs, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SsSendUSSD *ipar;
    struct OPAR_CFW_SsSendUSSD *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nUsdStringSize+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SsSendUSSD) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SsSendUSSD) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SsSendUSSD *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SsSendUSSD *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SsSendUSSD);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SsSendUSSD;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ivar_ptr, pUsdString, nUsdStringSize);
    ivar_ptr[nUsdStringSize] = (char)0;
    ivar_ptr += ALIGNUP8(nUsdStringSize + 1);
    ipar->nUsdStringSize = nUsdStringSize;
    ipar->nOption = nOption;
    ipar->nDcs = nDcs;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SsSendUSSD_V2
uint32_t CFW_SsSendUSSD_V2(uint8_t * pUsdString, uint8_t nUsdStringSize, uint8_t nOption, uint8_t nDcs, uint16_t nUTI, uint16_t nTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SsSendUSSD_V2 *ipar;
    struct OPAR_CFW_SsSendUSSD_V2 *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nUsdStringSize+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SsSendUSSD_V2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SsSendUSSD_V2) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SsSendUSSD_V2 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SsSendUSSD_V2 *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SsSendUSSD_V2);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SsSendUSSD_V2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ivar_ptr, pUsdString, nUsdStringSize);
    ivar_ptr[nUsdStringSize] = (char)0;
    ivar_ptr += ALIGNUP8(nUsdStringSize + 1);
    ipar->nUsdStringSize = nUsdStringSize;
    ipar->nOption = nOption;
    ipar->nDcs = nDcs;
    ipar->nUTI = nUTI;
    ipar->nTI = nTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimChangePassword
uint32_t CFW_SimChangePassword(uint16_t nFac, uint8_t * pBufOldPwd, uint8_t nOldPwdSize, uint8_t * pBufNewPwd, uint8_t nNewPwdSize, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimChangePassword *ipar;
    struct OPAR_CFW_SimChangePassword *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nOldPwdSize+1) + ALIGNUP8(nNewPwdSize+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimChangePassword) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimChangePassword) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimChangePassword *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimChangePassword *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimChangePassword);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimChangePassword;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nFac = nFac;
    memcpy(ivar_ptr, pBufOldPwd, nOldPwdSize);
    ivar_ptr[nOldPwdSize] = (char)0;
    ivar_ptr += ALIGNUP8(nOldPwdSize + 1);
    ipar->nOldPwdSize = nOldPwdSize;
    memcpy(ivar_ptr, pBufNewPwd, nNewPwdSize);
    ivar_ptr[nNewPwdSize] = (char)0;
    ivar_ptr += ALIGNUP8(nNewPwdSize + 1);
    ipar->nNewPwdSize = nNewPwdSize;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimGetAuthenticationStatus
uint32_t CFW_SimGetAuthenticationStatus(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimGetAuthenticationStatus *ipar;
    struct OPAR_CFW_SimGetAuthenticationStatus *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimGetAuthenticationStatus) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimGetAuthenticationStatus) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimGetAuthenticationStatus *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimGetAuthenticationStatus *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimGetAuthenticationStatus;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimEnterAuthentication
uint32_t CFW_SimEnterAuthentication(uint8_t * pPin, uint8_t nPinSize, uint8_t * pNewPin, uint8_t nNewPinSize, uint8_t nOption, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimEnterAuthentication *ipar;
    struct OPAR_CFW_SimEnterAuthentication *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nPinSize+1) + ALIGNUP8(nNewPinSize+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimEnterAuthentication) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimEnterAuthentication) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimEnterAuthentication *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimEnterAuthentication *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimEnterAuthentication);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimEnterAuthentication;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ivar_ptr, pPin, nPinSize);
    ivar_ptr[nPinSize] = (char)0;
    ivar_ptr += ALIGNUP8(nPinSize + 1);
    ipar->nPinSize = nPinSize;
    memcpy(ivar_ptr, pNewPin, nNewPinSize);
    ivar_ptr[nNewPinSize] = (char)0;
    ivar_ptr += ALIGNUP8(nNewPinSize + 1);
    ipar->nNewPinSize = nNewPinSize;
    ipar->nOption = nOption;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimSetFacilityLock
uint32_t CFW_SimSetFacilityLock(uint16_t nFac, uint8_t * pBufPwd, uint8_t nPwdSize, uint8_t nMode, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimSetFacilityLock *ipar;
    struct OPAR_CFW_SimSetFacilityLock *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nPwdSize+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimSetFacilityLock) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimSetFacilityLock) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimSetFacilityLock *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimSetFacilityLock *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimSetFacilityLock);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimSetFacilityLock;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nFac = nFac;
    memcpy(ivar_ptr, pBufPwd, nPwdSize);
    ivar_ptr[nPwdSize] = (char)0;
    ivar_ptr += ALIGNUP8(nPwdSize + 1);
    ipar->nPwdSize = nPwdSize;
    ipar->nMode = nMode;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimGetFacilityLock
uint32_t CFW_SimGetFacilityLock(uint16_t nFac, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimGetFacilityLock *ipar;
    struct OPAR_CFW_SimGetFacilityLock *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimGetFacilityLock) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimGetFacilityLock) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimGetFacilityLock *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimGetFacilityLock *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimGetFacilityLock;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nFac = nFac;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimGetProviderId
uint32_t CFW_SimGetProviderId(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimGetProviderId *ipar;
    struct OPAR_CFW_SimGetProviderId *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimGetProviderId) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimGetProviderId) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimGetProviderId *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimGetProviderId *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimGetProviderId;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetCurrPreferPLMNList
void CFW_SetCurrPreferPLMNList(uint8_t iList, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetCurrPreferPLMNList *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetCurrPreferPLMNList) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetCurrPreferPLMNList *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetCurrPreferPLMNList;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->iList = iList;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_SimWritePreferPLMN
uint32_t CFW_SimWritePreferPLMN(uint8_t index, uint8_t * operator, uint8_t nSize, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimWritePreferPLMN *ipar;
    struct OPAR_CFW_SimWritePreferPLMN *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nSize+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimWritePreferPLMN) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimWritePreferPLMN) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimWritePreferPLMN *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimWritePreferPLMN *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimWritePreferPLMN);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimWritePreferPLMN;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->index = index;
    memcpy(ivar_ptr, operator, nSize);
    ivar_ptr[nSize] = (char)0;
    ivar_ptr += ALIGNUP8(nSize + 1);
    ipar->nSize = nSize;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimSetPrefOperatorList
uint32_t CFW_SimSetPrefOperatorList(uint8_t * pOperatorList, uint8_t nSize, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimSetPrefOperatorList *ipar;
    struct OPAR_CFW_SimSetPrefOperatorList *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nSize+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimSetPrefOperatorList) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimSetPrefOperatorList) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimSetPrefOperatorList *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimSetPrefOperatorList *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimSetPrefOperatorList);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimSetPrefOperatorList;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ivar_ptr, pOperatorList, nSize);
    ivar_ptr[nSize] = (char)0;
    ivar_ptr += ALIGNUP8(nSize + 1);
    ipar->nSize = nSize;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimReadPreferPLMN
uint32_t CFW_SimReadPreferPLMN(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimReadPreferPLMN *ipar;
    struct OPAR_CFW_SimReadPreferPLMN *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimReadPreferPLMN) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimReadPreferPLMN) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimReadPreferPLMN *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimReadPreferPLMN *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimReadPreferPLMN;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimGetPrefOperatorListMaxNum
uint32_t CFW_SimGetPrefOperatorListMaxNum(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimGetPrefOperatorListMaxNum *ipar;
    struct OPAR_CFW_SimGetPrefOperatorListMaxNum *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimGetPrefOperatorListMaxNum) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimGetPrefOperatorListMaxNum) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimGetPrefOperatorListMaxNum *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimGetPrefOperatorListMaxNum *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimGetPrefOperatorListMaxNum;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimGetPrefOperatorList
uint32_t CFW_SimGetPrefOperatorList(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimGetPrefOperatorList *ipar;
    struct OPAR_CFW_SimGetPrefOperatorList *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimGetPrefOperatorList) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimGetPrefOperatorList) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimGetPrefOperatorList *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimGetPrefOperatorList *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimGetPrefOperatorList;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimAddPbkEntry
uint32_t CFW_SimAddPbkEntry(uint8_t nStorage, CFW_SIM_PBK_ENTRY_INFO *pEntryInfo, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimAddPbkEntry *ipar;
    struct OPAR_CFW_SimAddPbkEntry *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimAddPbkEntry) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimAddPbkEntry) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimAddPbkEntry *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimAddPbkEntry *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimAddPbkEntry;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nStorage = nStorage;
    ipar->pEntryInfo = *pEntryInfo;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimAddPbkEntry_V2
uint32_t CFW_SimAddPbkEntry_V2(uint8_t nStorage, CFW_SIM_PBK_ENTRY_INFO_V2 *pEntryInfo, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimAddPbkEntry_V2 *ipar;
    struct OPAR_CFW_SimAddPbkEntry_V2 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimAddPbkEntry_V2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimAddPbkEntry_V2) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimAddPbkEntry_V2 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimAddPbkEntry_V2 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimAddPbkEntry_V2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nStorage = nStorage;
    ipar->pEntryInfo = *pEntryInfo;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimDeletePbkEntry
uint32_t CFW_SimDeletePbkEntry(uint8_t nStorage, uint16_t nIndex, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimDeletePbkEntry *ipar;
    struct OPAR_CFW_SimDeletePbkEntry *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimDeletePbkEntry) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimDeletePbkEntry) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimDeletePbkEntry *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimDeletePbkEntry *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimDeletePbkEntry;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nStorage = nStorage;
    ipar->nIndex = nIndex;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimGetPbkEntry
uint32_t CFW_SimGetPbkEntry(uint8_t nStorage, uint16_t nIndex, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimGetPbkEntry *ipar;
    struct OPAR_CFW_SimGetPbkEntry *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimGetPbkEntry) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimGetPbkEntry) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimGetPbkEntry *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimGetPbkEntry *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimGetPbkEntry;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nStorage = nStorage;
    ipar->nIndex = nIndex;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimListPbkEntries
uint32_t CFW_SimListPbkEntries(uint8_t nStorage, uint16_t nIndexStart, uint16_t nIndexEnd, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimListPbkEntries *ipar;
    struct OPAR_CFW_SimListPbkEntries *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimListPbkEntries) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimListPbkEntries) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimListPbkEntries *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimListPbkEntries *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimListPbkEntries;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nStorage = nStorage;
    ipar->nIndexStart = nIndexStart;
    ipar->nIndexEnd = nIndexEnd;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimListCountPbkEntries
uint32_t CFW_SimListCountPbkEntries(uint8_t nStorage, uint16_t nIndexStart, uint16_t nCount, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimListCountPbkEntries *ipar;
    struct OPAR_CFW_SimListCountPbkEntries *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimListCountPbkEntries) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimListCountPbkEntries) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimListCountPbkEntries *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimListCountPbkEntries *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimListCountPbkEntries;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nStorage = nStorage;
    ipar->nIndexStart = nIndexStart;
    ipar->nCount = nCount;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimGetPbkStrorageInfo
uint32_t CFW_SimGetPbkStrorageInfo(uint8_t nStorage, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimGetPbkStrorageInfo *ipar;
    struct OPAR_CFW_SimGetPbkStrorageInfo *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimGetPbkStrorageInfo) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimGetPbkStrorageInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimGetPbkStrorageInfo *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimGetPbkStrorageInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimGetPbkStrorageInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nStorage = nStorage;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimGetPbkStorage
uint32_t CFW_SimGetPbkStorage(uint8_t nStorage, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimGetPbkStorage *ipar;
    struct OPAR_CFW_SimGetPbkStorage *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimGetPbkStorage) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimGetPbkStorage) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimGetPbkStorage *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimGetPbkStorage *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimGetPbkStorage;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nStorage = nStorage;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatActivation
uint32_t CFW_SatActivation(uint8_t nMode, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatActivation *ipar;
    struct OPAR_CFW_SatActivation *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatActivation) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatActivation) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatActivation *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatActivation *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatActivation;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nMode = nMode;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatResponse
uint32_t CFW_SatResponse(uint8_t nCmdType, uint8_t nStatus, uint8_t nItemId, void * pInputString, uint8_t InputStrLen, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatResponse *ipar;
    struct OPAR_CFW_SatResponse *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(InputStrLen+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatResponse) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatResponse) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatResponse *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatResponse *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatResponse);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatResponse;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCmdType = nCmdType;
    ipar->nStatus = nStatus;
    ipar->nItemId = nItemId;
    memcpy(ivar_ptr, pInputString, InputStrLen);
    ivar_ptr[InputStrLen] = (char)0;
    ivar_ptr += ALIGNUP8(InputStrLen + 1);
    ipar->InputStrLen = InputStrLen;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatResponseV2
uint32_t CFW_SatResponseV2(uint8_t nCmdType, uint8_t nStatus, uint8_t nItemId, void * pInputString, uint16_t InputStrLen, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatResponseV2 *ipar;
    struct OPAR_CFW_SatResponseV2 *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(InputStrLen+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatResponseV2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatResponseV2) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatResponseV2 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatResponseV2 *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatResponseV2);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatResponseV2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCmdType = nCmdType;
    ipar->nStatus = nStatus;
    ipar->nItemId = nItemId;
    memcpy(ivar_ptr, pInputString, InputStrLen);
    ivar_ptr[InputStrLen] = (char)0;
    ivar_ptr += ALIGNUP8(InputStrLen + 1);
    ipar->InputStrLen = InputStrLen;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetCurCMD
uint8_t CFW_SatGetCurCMD(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetCurCMD *ipar;
    struct OPAR_CFW_SatGetCurCMD *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetCurCMD) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetCurCMD) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetCurCMD *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetCurCMD *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetCurCMD;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetMNCLen
void CFW_GetMNCLen(uint8_t *pLen, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetMNCLen *ipar;
    struct OPAR_CFW_GetMNCLen *opar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetMNCLen) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetMNCLen) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetMNCLen *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetMNCLen *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetMNCLen;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pLen = opar->pLen;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_CfgSimGetMeProfile
uint32_t CFW_CfgSimGetMeProfile(CFW_PROFILE *pMeProfile)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_CfgSimGetMeProfile *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSimGetMeProfile) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_CfgSimGetMeProfile *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSimGetMeProfile;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pMeProfile = opar->pMeProfile;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSimSetMeProfile
uint32_t CFW_CfgSimSetMeProfile(CFW_PROFILE *pMeProfile)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSimSetMeProfile *ipar;
    struct OPAR_CFW_CfgSimSetMeProfile *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSimSetMeProfile) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSimSetMeProfile) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSimSetMeProfile *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSimSetMeProfile *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSimSetMeProfile;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pMeProfile = *pMeProfile;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimGetICCID
uint32_t CFW_SimGetICCID(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimGetICCID *ipar;
    struct OPAR_CFW_SimGetICCID *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimGetICCID) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimGetICCID) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimGetICCID *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimGetICCID *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimGetICCID;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SmsAbortSendMessage
uint32_t CFW_SmsAbortSendMessage(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SmsAbortSendMessage *ipar;
    struct OPAR_CFW_SmsAbortSendMessage *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SmsAbortSendMessage) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SmsAbortSendMessage) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SmsAbortSendMessage *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SmsAbortSendMessage *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SmsAbortSendMessage;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SmsDeleteMessage
uint32_t CFW_SmsDeleteMessage(uint16_t nIndex, uint8_t nStatus, uint8_t nStorage, uint8_t nType, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SmsDeleteMessage *ipar;
    struct OPAR_CFW_SmsDeleteMessage *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SmsDeleteMessage) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SmsDeleteMessage) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SmsDeleteMessage *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SmsDeleteMessage *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SmsDeleteMessage;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nIndex = nIndex;
    ipar->nStatus = nStatus;
    ipar->nStorage = nStorage;
    ipar->nType = nType;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SmsSetUnRead2Read
uint32_t CFW_SmsSetUnRead2Read(uint8_t nStorage, uint8_t nType, uint16_t nIndex, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SmsSetUnRead2Read *ipar;
    struct OPAR_CFW_SmsSetUnRead2Read *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SmsSetUnRead2Read) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SmsSetUnRead2Read) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SmsSetUnRead2Read *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SmsSetUnRead2Read *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SmsSetUnRead2Read;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nStorage = nStorage;
    ipar->nType = nType;
    ipar->nIndex = nIndex;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SmsListMessages
uint32_t CFW_SmsListMessages(CFW_SMS_LIST *pListInfo, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SmsListMessages *ipar;
    struct OPAR_CFW_SmsListMessages *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SmsListMessages) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SmsListMessages) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SmsListMessages *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SmsListMessages *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SmsListMessages;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pListInfo = *pListInfo;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SmsReadMessage
uint32_t CFW_SmsReadMessage(uint8_t nStorage, uint8_t nType, uint16_t nIndex, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SmsReadMessage *ipar;
    struct OPAR_CFW_SmsReadMessage *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SmsReadMessage) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SmsReadMessage) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SmsReadMessage *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SmsReadMessage *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SmsReadMessage;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nStorage = nStorage;
    ipar->nType = nType;
    ipar->nIndex = nIndex;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimGetServiceProviderName
uint32_t CFW_SimGetServiceProviderName(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimGetServiceProviderName *ipar;
    struct OPAR_CFW_SimGetServiceProviderName *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimGetServiceProviderName) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimGetServiceProviderName) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimGetServiceProviderName *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimGetServiceProviderName *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimGetServiceProviderName;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SmsSetRead2UnRead
uint32_t CFW_SmsSetRead2UnRead(uint8_t nStorage, uint8_t nType, uint16_t nIndex, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SmsSetRead2UnRead *ipar;
    struct OPAR_CFW_SmsSetRead2UnRead *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SmsSetRead2UnRead) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SmsSetRead2UnRead) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SmsSetRead2UnRead *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SmsSetRead2UnRead *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SmsSetRead2UnRead;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nStorage = nStorage;
    ipar->nType = nType;
    ipar->nIndex = nIndex;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CheckIfAllowedRecvSms
void CFW_CheckIfAllowedRecvSms(bool bIfAllowed, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CheckIfAllowedRecvSms *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CheckIfAllowedRecvSms) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CheckIfAllowedRecvSms *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CheckIfAllowedRecvSms;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->bIfAllowed = bIfAllowed;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_SmsSendPduMessage
uint32_t CFW_SmsSendPduMessage(uint8_t * pData, uint16_t nDataSize, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SmsSendPduMessage *ipar;
    struct OPAR_CFW_SmsSendPduMessage *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nDataSize+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SmsSendPduMessage) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SmsSendPduMessage) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SmsSendPduMessage *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SmsSendPduMessage *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SmsSendPduMessage);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SmsSendPduMessage;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ivar_ptr, pData, nDataSize);
    ivar_ptr[nDataSize] = (char)0;
    ivar_ptr += ALIGNUP8(nDataSize + 1);
    ipar->nDataSize = nDataSize;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SmsSendMessage_V2
uint32_t CFW_SmsSendMessage_V2(CFW_DIALNUMBER_V2 *pNumber, uint8_t * pData, uint16_t nDataSize, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SmsSendMessage_V2 *ipar;
    struct OPAR_CFW_SmsSendMessage_V2 *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nDataSize+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SmsSendMessage_V2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SmsSendMessage_V2) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SmsSendMessage_V2 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SmsSendMessage_V2 *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SmsSendMessage_V2);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SmsSendMessage_V2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pNumber = *pNumber;
    memcpy(ivar_ptr, pData, nDataSize);
    ivar_ptr[nDataSize] = (char)0;
    ivar_ptr += ALIGNUP8(nDataSize + 1);
    ipar->nDataSize = nDataSize;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SmsSendMessage_V3
uint32_t CFW_SmsSendMessage_V3(CFW_DIALNUMBER_V2 *pNumber, uint8_t * pData, uint16_t nDataSize, uint16_t nUTI, CFW_SIM_ID nSimID, uint8_t nFlag)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SmsSendMessage_V3 *ipar;
    struct OPAR_CFW_SmsSendMessage_V3 *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nDataSize+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SmsSendMessage_V3) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SmsSendMessage_V3) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SmsSendMessage_V3 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SmsSendMessage_V3 *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SmsSendMessage_V3);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SmsSendMessage_V3;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pNumber = *pNumber;
    memcpy(ivar_ptr, pData, nDataSize);
    ivar_ptr[nDataSize] = (char)0;
    ivar_ptr += ALIGNUP8(nDataSize + 1);
    ipar->nDataSize = nDataSize;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    ipar->nFlag = nFlag;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = 1;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SmsWriteMessage_V2
uint32_t CFW_SmsWriteMessage_V2(CFW_DIALNUMBER_V2 *pNumber, uint8_t * pData, uint16_t nDataSize, uint16_t nIndex, uint8_t nStorage, uint8_t nType, uint8_t nStatus, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SmsWriteMessage_V2 *ipar;
    struct OPAR_CFW_SmsWriteMessage_V2 *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nDataSize+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SmsWriteMessage_V2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SmsWriteMessage_V2) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SmsWriteMessage_V2 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SmsWriteMessage_V2 *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SmsWriteMessage_V2);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SmsWriteMessage_V2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pNumber = *pNumber;
    memcpy(ivar_ptr, pData, nDataSize);
    ivar_ptr[nDataSize] = (char)0;
    ivar_ptr += ALIGNUP8(nDataSize + 1);
    ipar->nDataSize = nDataSize;
    ipar->nIndex = nIndex;
    ipar->nStorage = nStorage;
    ipar->nType = nType;
    ipar->nStatus = nStatus;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SmsSetUnSent2Sent
uint32_t CFW_SmsSetUnSent2Sent(uint8_t nStorage, uint8_t nType, uint16_t nIndex, uint8_t nSendStatus, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SmsSetUnSent2Sent *ipar;
    struct OPAR_CFW_SmsSetUnSent2Sent *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SmsSetUnSent2Sent) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SmsSetUnSent2Sent) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SmsSetUnSent2Sent *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SmsSetUnSent2Sent *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SmsSetUnSent2Sent;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nStorage = nStorage;
    ipar->nType = nType;
    ipar->nIndex = nIndex;
    ipar->nSendStatus = nSendStatus;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SmsGetMessageNodeEx
uint32_t CFW_SmsGetMessageNodeEx(void * pListResult, uint16_t nIndex, CFW_SMS_NODE_EX *pNode, CFW_SIM_ID nSimId)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SmsGetMessageNodeEx *ipar;
    struct OPAR_CFW_SmsGetMessageNodeEx *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SmsGetMessageNodeEx) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SmsGetMessageNodeEx) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SmsGetMessageNodeEx *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SmsGetMessageNodeEx *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SmsGetMessageNodeEx;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pListResult = pListResult;
    ipar->nIndex = nIndex;
    ipar->nSimId = nSimId;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pNode = opar->pNode;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SmsGetMessageNodeV2
uint32_t CFW_SmsGetMessageNodeV2(void * pListResult, uint16_t nIndex, CFW_SMS_NODE_EX *pNode, uint8_t nFormat, CFW_SIM_ID nSimId)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SmsGetMessageNodeV2 *ipar;
    struct OPAR_CFW_SmsGetMessageNodeV2 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SmsGetMessageNodeV2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SmsGetMessageNodeV2) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SmsGetMessageNodeV2 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SmsGetMessageNodeV2 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SmsGetMessageNodeV2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pListResult = pListResult;
    ipar->nIndex = nIndex;
    ipar->nFormat = nFormat;
    ipar->nSimId = nSimId;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pNode = opar->pNode;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SmsInitComplete
uint32_t CFW_SmsInitComplete(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SmsInitComplete *ipar;
    struct OPAR_CFW_SmsInitComplete *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SmsInitComplete) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SmsInitComplete) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SmsInitComplete *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SmsInitComplete *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SmsInitComplete;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetSMSConcat
uint32_t CFW_SetSMSConcat(bool bConcat, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetSMSConcat *ipar;
    struct OPAR_CFW_SetSMSConcat *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetSMSConcat) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetSMSConcat) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetSMSConcat *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetSMSConcat *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetSMSConcat;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->bConcat = bConcat;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetSMSConcat
bool CFW_GetSMSConcat(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetSMSConcat *ipar;
    struct OPAR_CFW_GetSMSConcat *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetSMSConcat) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetSMSConcat) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetSMSConcat *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetSMSConcat *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetSMSConcat;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimReadMessage
uint32_t CFW_SimReadMessage(uint16_t nLocation, uint32_t nIndex, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimReadMessage *ipar;
    struct OPAR_CFW_SimReadMessage *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimReadMessage) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimReadMessage) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimReadMessage *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimReadMessage *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimReadMessage;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nLocation = nLocation;
    ipar->nIndex = nIndex;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimWriteMessage
uint32_t CFW_SimWriteMessage(uint16_t nLocation, uint32_t nIndex, uint8_t * pData, uint8_t nDataSize, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimWriteMessage *ipar;
    struct OPAR_CFW_SimWriteMessage *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nDataSize+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimWriteMessage) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimWriteMessage) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimWriteMessage *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimWriteMessage *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimWriteMessage);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimWriteMessage;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nLocation = nLocation;
    ipar->nIndex = nIndex;
    memcpy(ivar_ptr, pData, nDataSize);
    ivar_ptr[nDataSize] = (char)0;
    ivar_ptr += ALIGNUP8(nDataSize + 1);
    ipar->nDataSize = nDataSize;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsSetPdpCxtV2
uint32_t CFW_GprsSetPdpCxtV2(uint8_t nCid, const CFW_GPRS_PDPCONT_INFO_V2 *pPdpCont, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsSetPdpCxtV2 *ipar;
    struct OPAR_CFW_GprsSetPdpCxtV2 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsSetPdpCxtV2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsSetPdpCxtV2) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsSetPdpCxtV2 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsSetPdpCxtV2 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsSetPdpCxtV2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCid = nCid;
    ipar->pPdpCont = *pPdpCont;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsGetDefaultPdnInfo
uint8_t CFW_GprsGetDefaultPdnInfo(CFW_GPRS_PDPCONT_DFTPDN_INFO *PdnInfo, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsGetDefaultPdnInfo *ipar;
    struct OPAR_CFW_GprsGetDefaultPdnInfo *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsGetDefaultPdnInfo) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsGetDefaultPdnInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsGetDefaultPdnInfo *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsGetDefaultPdnInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsGetDefaultPdnInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *PdnInfo = opar->PdnInfo;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsGetPdpCxtV2
uint32_t CFW_GprsGetPdpCxtV2(uint8_t nCid, CFW_GPRS_PDPCONT_INFO_V2 *pPdpCont, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsGetPdpCxtV2 *ipar;
    struct OPAR_CFW_GprsGetPdpCxtV2 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsGetPdpCxtV2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsGetPdpCxtV2) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsGetPdpCxtV2 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsGetPdpCxtV2 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsGetPdpCxtV2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCid = nCid;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pPdpCont = opar->pPdpCont;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsSetDefaultPdnMode
void CFW_GprsSetDefaultPdnMode(uint32_t mode, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsSetDefaultPdnMode *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsSetDefaultPdnMode) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsSetDefaultPdnMode *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsSetDefaultPdnMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->mode = mode;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsGetDefaultPdnMode
uint32_t CFW_GprsGetDefaultPdnMode(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsGetDefaultPdnMode *ipar;
    struct OPAR_CFW_GprsGetDefaultPdnMode *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsGetDefaultPdnMode) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsGetDefaultPdnMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsGetDefaultPdnMode *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsGetDefaultPdnMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsGetDefaultPdnMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = 0xffffffff;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsRemovePdpCxt
uint32_t CFW_GprsRemovePdpCxt(uint8_t nCid, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsRemovePdpCxt *ipar;
    struct OPAR_CFW_GprsRemovePdpCxt *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsRemovePdpCxt) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsRemovePdpCxt) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsRemovePdpCxt *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsRemovePdpCxt *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsRemovePdpCxt;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCid = nCid;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsSetMinQos
uint32_t CFW_GprsSetMinQos(uint8_t nCid, CFW_GPRS_QOS *pQos, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsSetMinQos *ipar;
    struct OPAR_CFW_GprsSetMinQos *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsSetMinQos) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsSetMinQos) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsSetMinQos *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsSetMinQos *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsSetMinQos;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCid = nCid;
    ipar->pQos = *pQos;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsGetMInQos
uint32_t CFW_GprsGetMInQos(uint8_t nCid, CFW_GPRS_QOS *pQos, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsGetMInQos *ipar;
    struct OPAR_CFW_GprsGetMInQos *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsGetMInQos) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsGetMInQos) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsGetMInQos *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsGetMInQos *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsGetMInQos;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCid = nCid;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pQos = opar->pQos;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsSetReqQos
uint32_t CFW_GprsSetReqQos(uint8_t nCid, CFW_GPRS_QOS *pQos, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsSetReqQos *ipar;
    struct OPAR_CFW_GprsSetReqQos *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsSetReqQos) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsSetReqQos) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsSetReqQos *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsSetReqQos *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsSetReqQos;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCid = nCid;
    ipar->pQos = *pQos;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsGetReqQos
uint32_t CFW_GprsGetReqQos(uint8_t nCid, CFW_GPRS_QOS *pQos, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsGetReqQos *ipar;
    struct OPAR_CFW_GprsGetReqQos *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsGetReqQos) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsGetReqQos) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsGetReqQos *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsGetReqQos *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsGetReqQos;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCid = nCid;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pQos = opar->pQos;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsSetReqQosUmts
uint32_t CFW_GprsSetReqQosUmts(uint8_t nCid, CFW_GPRS_QOS *pQos, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsSetReqQosUmts *ipar;
    struct OPAR_CFW_GprsSetReqQosUmts *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsSetReqQosUmts) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsSetReqQosUmts) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsSetReqQosUmts *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsSetReqQosUmts *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsSetReqQosUmts;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCid = nCid;
    ipar->pQos = *pQos;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsGetReqQosUmts
uint32_t CFW_GprsGetReqQosUmts(uint8_t nCid, CFW_GPRS_QOS *pQos, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsGetReqQosUmts *ipar;
    struct OPAR_CFW_GprsGetReqQosUmts *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsGetReqQosUmts) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsGetReqQosUmts) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsGetReqQosUmts *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsGetReqQosUmts *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsGetReqQosUmts;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCid = nCid;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pQos = opar->pQos;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsGetPdpAddr
uint32_t CFW_GprsGetPdpAddr(uint8_t nCid, uint8_t *nLength, uint8_t pPdpAdd[THE_PDP_ADDR_MAX_LEN], CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsGetPdpAddr *ipar;
    struct OPAR_CFW_GprsGetPdpAddr *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsGetPdpAddr) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsGetPdpAddr) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsGetPdpAddr *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsGetPdpAddr *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsGetPdpAddr;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCid = nCid;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *nLength = opar->nLength;
    memcpy(pPdpAdd, opar->pPdpAdd, sizeof(opar->pPdpAdd));
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsGetPdpIpv4Addr
uint32_t CFW_GprsGetPdpIpv4Addr(uint8_t nCid, uint8_t *nLength, uint8_t ipv4Addr[THE_PDP_ADDR_MAX_LEN], CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsGetPdpIpv4Addr *ipar;
    struct OPAR_CFW_GprsGetPdpIpv4Addr *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsGetPdpIpv4Addr) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsGetPdpIpv4Addr) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsGetPdpIpv4Addr *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsGetPdpIpv4Addr *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsGetPdpIpv4Addr;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCid = nCid;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *nLength = opar->nLength;
    memcpy(ipv4Addr, opar->ipv4Addr, sizeof(opar->ipv4Addr));
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsGetPdpIpv6Addr
uint32_t CFW_GprsGetPdpIpv6Addr(uint8_t nCid, uint8_t *nLength, uint8_t ipv6Addr[THE_PDP_ADDR_MAX_LEN], CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsGetPdpIpv6Addr *ipar;
    struct OPAR_CFW_GprsGetPdpIpv6Addr *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsGetPdpIpv6Addr) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsGetPdpIpv6Addr) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsGetPdpIpv6Addr *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsGetPdpIpv6Addr *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsGetPdpIpv6Addr;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCid = nCid;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *nLength = opar->nLength;
    memcpy(ipv6Addr, opar->ipv6Addr, sizeof(opar->ipv6Addr));
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsGetstatus
uint32_t CFW_GprsGetstatus(CFW_NW_STATUS_INFO *pStatus, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsGetstatus *ipar;
    struct OPAR_CFW_GprsGetstatus *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsGetstatus) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsGetstatus) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsGetstatus *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsGetstatus *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsGetstatus;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pStatus = opar->pStatus;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsSetstatus
uint32_t CFW_GprsSetstatus(CFW_NW_STATUS_INFO *pStatus, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsSetstatus *ipar;
    struct OPAR_CFW_GprsSetstatus *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsSetstatus) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsSetstatus) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsSetstatus *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsSetstatus *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsSetstatus;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pStatus = *pStatus;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GetGprsAttState
uint32_t CFW_GetGprsAttState(uint8_t *pState, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetGprsAttState *ipar;
    struct OPAR_CFW_GetGprsAttState *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetGprsAttState) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetGprsAttState) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetGprsAttState *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetGprsAttState *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetGprsAttState;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pState = opar->pState;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GetGprsActState
uint32_t CFW_GetGprsActState(uint8_t nCid, uint8_t *pState, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetGprsActState *ipar;
    struct OPAR_CFW_GetGprsActState *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetGprsActState) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetGprsActState) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetGprsActState *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetGprsActState *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetGprsActState;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCid = nCid;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pState = opar->pState;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsAct
uint32_t CFW_GprsAct(uint8_t nState, uint8_t nCid, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsAct *ipar;
    struct OPAR_CFW_GprsAct *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsAct) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsAct) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsAct *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsAct *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsAct;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nState = nState;
    ipar->nCid = nCid;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsActEx
uint32_t CFW_GprsActEx(uint8_t nState, uint8_t nCid, uint16_t nUTI, CFW_SIM_ID nSimID, bool SavedInApp)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsActEx *ipar;
    struct OPAR_CFW_GprsActEx *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsActEx) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsActEx) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsActEx *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsActEx *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsActEx;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nState = nState;
    ipar->nCid = nCid;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    ipar->SavedInApp = SavedInApp;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_AttDetach
uint32_t CFW_AttDetach(uint8_t nState, uint16_t nUTI, uint8_t AttDetachType, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_AttDetach *ipar;
    struct OPAR_CFW_AttDetach *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_AttDetach) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_AttDetach) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_AttDetach *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_AttDetach *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_AttDetach;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nState = nState;
    ipar->nUTI = nUTI;
    ipar->AttDetachType = AttDetachType;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT) && defined(LTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsSecPdpAct
uint32_t CFW_GprsSecPdpAct(uint8_t nState, uint8_t nCid, uint8_t nPCid, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsSecPdpAct *ipar;
    struct OPAR_CFW_GprsSecPdpAct *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsSecPdpAct) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsSecPdpAct) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsSecPdpAct *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsSecPdpAct *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsSecPdpAct;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nState = nState;
    ipar->nCid = nCid;
    ipar->nPCid = nPCid;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT) && defined(LTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsSetPsm
uint32_t CFW_GprsSetPsm(uint8_t psmEnable, uint8_t bitmap, uint8_t t3324, uint8_t t3412, uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsSetPsm *ipar;
    struct OPAR_CFW_GprsSetPsm *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsSetPsm) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsSetPsm) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsSetPsm *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsSetPsm *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsSetPsm;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->psmEnable = psmEnable;
    ipar->bitmap = bitmap;
    ipar->t3324 = t3324;
    ipar->t3412 = t3412;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT) && defined(LTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsSetEdrx
uint32_t CFW_GprsSetEdrx(uint8_t edrxEnable, uint8_t edrxType, uint8_t edrxValue, uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsSetEdrx *ipar;
    struct OPAR_CFW_GprsSetEdrx *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsSetEdrx) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsSetEdrx) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsSetEdrx *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsSetEdrx *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsSetEdrx;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->edrxEnable = edrxEnable;
    ipar->edrxType = edrxType;
    ipar->edrxValue = edrxValue;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT) && defined(LTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsSetCtxTFT
uint32_t CFW_GprsSetCtxTFT(uint8_t nCid, CFW_TFT_SET *pTft, uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsSetCtxTFT *ipar;
    struct OPAR_CFW_GprsSetCtxTFT *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsSetCtxTFT) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsSetCtxTFT) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsSetCtxTFT *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsSetCtxTFT *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsSetCtxTFT;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCid = nCid;
    ipar->pTft = *pTft;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT) && defined(LTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsSetCtxEQos
uint32_t CFW_GprsSetCtxEQos(uint8_t nCid, CFW_EQOS *pQos, uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsSetCtxEQos *ipar;
    struct OPAR_CFW_GprsSetCtxEQos *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsSetCtxEQos) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsSetCtxEQos) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsSetCtxEQos *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsSetCtxEQos *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsSetCtxEQos;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCid = nCid;
    ipar->pQos = *pQos;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT) && defined(LTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsGetCtxEQos
uint32_t CFW_GprsGetCtxEQos(uint8_t nCid, CFW_EQOS *pQos, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsGetCtxEQos *ipar;
    struct OPAR_CFW_GprsGetCtxEQos *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsGetCtxEQos) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsGetCtxEQos) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsGetCtxEQos *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsGetCtxEQos *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsGetCtxEQos;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCid = nCid;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pQos = opar->pQos;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT) && defined(LTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsGetNetEQos
uint32_t CFW_GprsGetNetEQos(uint8_t nCid, CFW_EQOS *pQos, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsGetNetEQos *ipar;
    struct OPAR_CFW_GprsGetNetEQos *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsGetNetEQos) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsGetNetEQos) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsGetNetEQos *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsGetNetEQos *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsGetNetEQos;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCid = nCid;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pQos = opar->pQos;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT) && defined(LTE_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsCtxEpsModify
uint32_t CFW_GprsCtxEpsModify(uint16_t nUTI, uint8_t nCid, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsCtxEpsModify *ipar;
    struct OPAR_CFW_GprsCtxEpsModify *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsCtxEpsModify) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsCtxEpsModify) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsCtxEpsModify *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsCtxEpsModify *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsCtxEpsModify;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nCid = nCid;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsManualAcc
uint32_t CFW_GprsManualAcc(uint16_t nUTI, uint8_t nCid, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsManualAcc *ipar;
    struct OPAR_CFW_GprsManualAcc *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsManualAcc) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsManualAcc) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsManualAcc *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsManualAcc *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsManualAcc;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nCid = nCid;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsManualRej
uint32_t CFW_GprsManualRej(uint16_t nUTI, uint8_t nCid, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsManualRej *ipar;
    struct OPAR_CFW_GprsManualRej *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsManualRej) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsManualRej) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsManualRej *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsManualRej *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsManualRej;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nCid = nCid;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsCtxModify
uint32_t CFW_GprsCtxModify(uint16_t nUTI, uint8_t nCid, CFW_GPRS_QOS *Qos, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsCtxModify *ipar;
    struct OPAR_CFW_GprsCtxModify *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsCtxModify) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsCtxModify) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsCtxModify *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsCtxModify *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsCtxModify;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nCid = nCid;
    ipar->Qos = *Qos;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsCtxModifyAcc
uint32_t CFW_GprsCtxModifyAcc(uint16_t nUTI, uint8_t nCid, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsCtxModifyAcc *ipar;
    struct OPAR_CFW_GprsCtxModifyAcc *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsCtxModifyAcc) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsCtxModifyAcc) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsCtxModifyAcc *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsCtxModifyAcc *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsCtxModifyAcc;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nCid = nCid;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsCtxModifyRej
uint32_t CFW_GprsCtxModifyRej(uint16_t nUTI, uint8_t nCid, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsCtxModifyRej *ipar;
    struct OPAR_CFW_GprsCtxModifyRej *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsCtxModifyRej) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsCtxModifyRej) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsCtxModifyRej *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsCtxModifyRej *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsCtxModifyRej;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nCid = nCid;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsSendData
uint32_t CFW_GprsSendData(uint8_t nCid, CFW_GPRS_DATA* pGprsData, uint8_t rai, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsSendData *ipar;
    struct OPAR_CFW_GprsSendData *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(sizeof(CFW_GPRS_DATA) + pGprsData->nDataLength+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsSendData) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsSendData) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsSendData *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsSendData *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsSendData);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsSendData;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCid = nCid;
    memcpy(ivar_ptr, pGprsData, sizeof(CFW_GPRS_DATA) + pGprsData->nDataLength);
    ivar_ptr[sizeof(CFW_GPRS_DATA) + pGprsData->nDataLength] = (char)0;
    ivar_ptr += ALIGNUP8(sizeof(CFW_GPRS_DATA) + pGprsData->nDataLength + 1);
    ipar->rai = rai;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsSendDataV2
uint32_t CFW_GprsSendDataV2(uint8_t nSim, uint8_t nCid, uint16_t nDataLen)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsSendDataV2 *ipar;
    struct OPAR_CFW_GprsSendDataV2 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsSendDataV2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsSendDataV2) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsSendDataV2 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsSendDataV2 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsSendDataV2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSim = nSim;
    ipar->nCid = nCid;
    ipar->nDataLen = nDataLen;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsAtt
uint32_t CFW_GprsAtt(uint8_t nState, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsAtt *ipar;
    struct OPAR_CFW_GprsAtt *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsAtt) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsAtt) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsAtt *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsAtt *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsAtt;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nState = nState;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GetGprsSum
uint32_t CFW_GetGprsSum(int32_t *upsum, int32_t *downsum, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetGprsSum *ipar;
    struct OPAR_CFW_GetGprsSum *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetGprsSum) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetGprsSum) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetGprsSum *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetGprsSum *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetGprsSum;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *upsum = opar->upsum;
    *downsum = opar->downsum;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_ClearGprsSum
uint32_t CFW_ClearGprsSum(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_ClearGprsSum *ipar;
    struct OPAR_CFW_ClearGprsSum *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_ClearGprsSum) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_ClearGprsSum) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_ClearGprsSum *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_ClearGprsSum *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ClearGprsSum;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_CheckTestSim
uint32_t CFW_CheckTestSim(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CheckTestSim *ipar;
    struct OPAR_CFW_CheckTestSim *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CheckTestSim) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CheckTestSim) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CheckTestSim *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CheckTestSim *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CheckTestSim;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsSetSmsSeviceMode
uint8_t CFW_GprsSetSmsSeviceMode(uint8_t nService)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsSetSmsSeviceMode *ipar;
    struct OPAR_CFW_GprsSetSmsSeviceMode *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsSetSmsSeviceMode) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsSetSmsSeviceMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsSetSmsSeviceMode *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsSetSmsSeviceMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsSetSmsSeviceMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nService = nService;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GprsGetSmsSeviceMode
uint8_t CFW_GprsGetSmsSeviceMode(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_GprsGetSmsSeviceMode *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsGetSmsSeviceMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_GprsGetSmsSeviceMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsGetSmsSeviceMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_SetDnsServerbyPdp
uint32_t CFW_SetDnsServerbyPdp(uint8_t nCid, uint8_t nSimID, uint8_t Pro_DnsIp[4], uint8_t Sec_DnsIp[4])
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetDnsServerbyPdp *ipar;
    struct OPAR_CFW_SetDnsServerbyPdp *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetDnsServerbyPdp) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetDnsServerbyPdp) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetDnsServerbyPdp *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetDnsServerbyPdp *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetDnsServerbyPdp;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCid = nCid;
    ipar->nSimID = nSimID;
    memcpy(ipar->Pro_DnsIp, Pro_DnsIp, sizeof(ipar->Pro_DnsIp));
    memcpy(ipar->Sec_DnsIp, Sec_DnsIp, sizeof(ipar->Sec_DnsIp));
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_SetDnsServerbyPdpV2
uint32_t CFW_SetDnsServerbyPdpV2(uint8_t nCid, uint8_t nSimID, uint8_t Pro_DnsIp[16], uint8_t Sec_DnsIp[16])
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetDnsServerbyPdpV2 *ipar;
    struct OPAR_CFW_SetDnsServerbyPdpV2 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetDnsServerbyPdpV2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetDnsServerbyPdpV2) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetDnsServerbyPdpV2 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetDnsServerbyPdpV2 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetDnsServerbyPdpV2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCid = nCid;
    ipar->nSimID = nSimID;
    memcpy(ipar->Pro_DnsIp, Pro_DnsIp, sizeof(ipar->Pro_DnsIp));
    memcpy(ipar->Sec_DnsIp, Sec_DnsIp, sizeof(ipar->Sec_DnsIp));
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_getDnsServerbyPdp
uint32_t CFW_getDnsServerbyPdp(uint8_t nCid, uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_getDnsServerbyPdp *ipar;
    struct OPAR_CFW_getDnsServerbyPdp *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_getDnsServerbyPdp) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_getDnsServerbyPdp) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_getDnsServerbyPdp *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_getDnsServerbyPdp *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_getDnsServerbyPdp;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCid = nCid;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_getDNSServer
uint32_t* getDNSServer(uint8_t nCid, uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_getDNSServer *ipar;
    struct OPAR_getDNSServer *opar;
    uint32_t* result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_getDNSServer) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_getDNSServer) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_getDNSServer *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_getDNSServer *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_getDNSServer;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCid = nCid;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#ifndef DISABLE_RPC_CFW_EmodGetBatteryInfo
bool CFW_EmodGetBatteryInfo(CFW_EMOD_BATTERY_INFO *pBatInfo)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_EmodGetBatteryInfo *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodGetBatteryInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_EmodGetBatteryInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodGetBatteryInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pBatInfo = opar->pBatInfo;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodAudioTestStart
void CFW_EmodAudioTestStart(uint8_t type)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodAudioTestStart *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodAudioTestStart) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodAudioTestStart *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodAudioTestStart;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->type = type;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_EmodAudioTestEnd
void CFW_EmodAudioTestEnd(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;



    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodAudioTestEnd;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_EmodClearUserInfo
bool CFW_EmodClearUserInfo(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_EmodClearUserInfo *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodClearUserInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_EmodClearUserInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodClearUserInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodGetIMEI
void CFW_EmodGetIMEI(uint8_t pImei[16], uint8_t *pImeiLen, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodGetIMEI *ipar;
    struct OPAR_CFW_EmodGetIMEI *opar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodGetIMEI) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodGetIMEI) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodGetIMEI *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EmodGetIMEI *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodGetIMEI;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(pImei, opar->pImei, sizeof(opar->pImei));
    *pImeiLen = opar->pImeiLen;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_EmodSaveIMEI
void CFW_EmodSaveIMEI(uint8_t * pImei, uint8_t pImeiLen, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodSaveIMEI *ipar;
    char *ivar_ptr;


    ivar_size = ALIGNUP8(pImeiLen+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodSaveIMEI) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodSaveIMEI *)((char *)mem + sizeof(rpcCallHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodSaveIMEI);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodSaveIMEI;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ivar_ptr, pImei, pImeiLen);
    ivar_ptr[pImeiLen] = (char)0;
    ivar_ptr += ALIGNUP8(pImeiLen + 1);
    ipar->pImeiLen = pImeiLen;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_EmodGetNvVersion
uint32_t CFW_EmodGetNvVersion(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_EmodGetNvVersion *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodGetNvVersion) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_EmodGetNvVersion *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodGetNvVersion;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodGetBaseBandVersionV1
uint8_t * CFW_EmodGetBaseBandVersionV1(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_EmodGetBaseBandVersionV1 *opar;
    uint8_t * result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodGetBaseBandVersionV1) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_EmodGetBaseBandVersionV1 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodGetBaseBandVersionV1;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodGetNvData
uint8_t * CFW_EmodGetNvData(uint8_t dataType, uint8_t nSim)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodGetNvData *ipar;
    struct OPAR_CFW_EmodGetNvData *opar;
    uint8_t * result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodGetNvData) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodGetNvData) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodGetNvData *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EmodGetNvData *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodGetNvData;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->dataType = dataType;
    ipar->nSim = nSim;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodSetNvData
int32_t CFW_EmodSetNvData(uint8_t dataType, uint16_t offset, uint16_t dataLength, uint8_t * data, uint8_t nSim)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodSetNvData *ipar;
    struct OPAR_CFW_EmodSetNvData *opar;
    char *ivar_ptr;
    int32_t result;


    ivar_size = ALIGNUP8(dataLength+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodSetNvData) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodSetNvData) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodSetNvData *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EmodSetNvData *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodSetNvData);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodSetNvData;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->dataType = dataType;
    ipar->offset = offset;
    ipar->dataLength = dataLength;
    memcpy(ivar_ptr, data, dataLength);
    ivar_ptr[dataLength] = (char)0;
    ivar_ptr += ALIGNUP8(dataLength + 1);
    ipar->nSim = nSim;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodSaveNvData
int32_t CFW_EmodSaveNvData(uint8_t dataType, uint8_t nSim)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodSaveNvData *ipar;
    struct OPAR_CFW_EmodSaveNvData *opar;
    int32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodSaveNvData) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodSaveNvData) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodSaveNvData *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EmodSaveNvData *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodSaveNvData;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->dataType = dataType;
    ipar->nSim = nSim;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodSpecialNvProcess
int32_t CFW_EmodSpecialNvProcess(uint8_t operType, uint8_t dataType, uint16_t offset, uint16_t dataLength, uint8_t * data, uint8_t nSim)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodSpecialNvProcess *ipar;
    struct OPAR_CFW_EmodSpecialNvProcess *opar;
    char *ivar_ptr;
    int32_t result;


    ivar_size = ALIGNUP8(dataLength+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodSpecialNvProcess) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodSpecialNvProcess) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodSpecialNvProcess *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EmodSpecialNvProcess *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodSpecialNvProcess);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodSpecialNvProcess;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->operType = operType;
    ipar->dataType = dataType;
    ipar->offset = offset;
    ipar->dataLength = dataLength;
    memcpy(ivar_ptr, data, dataLength);
    ivar_ptr[dataLength] = (char)0;
    ivar_ptr += ALIGNUP8(dataLength + 1);
    ipar->nSim = nSim;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodEngineerCmd
uint32_t CFW_EmodEngineerCmd(uint32_t module, uint32_t cmd, uint32_t v1, uint32_t v2, uint32_t v3)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodEngineerCmd *ipar;
    struct OPAR_CFW_EmodEngineerCmd *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodEngineerCmd) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodEngineerCmd) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodEngineerCmd *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EmodEngineerCmd *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodEngineerCmd;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->module = module;
    ipar->cmd = cmd;
    ipar->v1 = v1;
    ipar->v2 = v2;
    ipar->v3 = v3;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodReadBindSIM
void CFW_EmodReadBindSIM(CFW_EMOD_READ_BIND_SIM *pReadBindSim)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_EmodReadBindSIM *opar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodReadBindSIM) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_EmodReadBindSIM *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodReadBindSIM;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pReadBindSim = opar->pReadBindSim;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_EmodReadBindNW
void CFW_EmodReadBindNW(CFW_EMOD_READ_BIND_NW *pReadBindNw)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_EmodReadBindNW *opar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodReadBindNW) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_EmodReadBindNW *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodReadBindNW;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pReadBindNw = opar->pReadBindNw;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_EmodGetBindInfo
void CFW_EmodGetBindInfo(bool *bSim, bool *bNetWork)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_EmodGetBindInfo *opar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodGetBindInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_EmodGetBindInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodGetBindInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *bSim = opar->bSim;
    *bNetWork = opar->bNetWork;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_EmodSetBindInfo
uint32_t CFW_EmodSetBindInfo(bool bSim, bool bNetWork)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodSetBindInfo *ipar;
    struct OPAR_CFW_EmodSetBindInfo *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodSetBindInfo) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodSetBindInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodSetBindInfo *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EmodSetBindInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodSetBindInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->bSim = bSim;
    ipar->bNetWork = bNetWork;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodUpdateSimBind
CFW_EMOD_UPDATE_RETURN CFW_EmodUpdateSimBind(uint8_t nIndex, uint8_t * pBindSimNum, uint8_t nLen)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodUpdateSimBind *ipar;
    struct OPAR_CFW_EmodUpdateSimBind *opar;
    char *ivar_ptr;
    CFW_EMOD_UPDATE_RETURN result;


    ivar_size = ALIGNUP8(nLen+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodUpdateSimBind) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodUpdateSimBind) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodUpdateSimBind *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EmodUpdateSimBind *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodUpdateSimBind);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodUpdateSimBind;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nIndex = nIndex;
    memcpy(ivar_ptr, pBindSimNum, nLen);
    ivar_ptr[nLen] = (char)0;
    ivar_ptr += ALIGNUP8(nLen + 1);
    ipar->nLen = nLen;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodUpdateNwBind
CFW_EMOD_UPDATE_RETURN CFW_EmodUpdateNwBind(uint8_t nIndex, uint8_t * pBindNwNum, uint8_t nLen)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodUpdateNwBind *ipar;
    struct OPAR_CFW_EmodUpdateNwBind *opar;
    char *ivar_ptr;
    CFW_EMOD_UPDATE_RETURN result;


    ivar_size = ALIGNUP8(nLen+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodUpdateNwBind) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodUpdateNwBind) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodUpdateNwBind *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EmodUpdateNwBind *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodUpdateNwBind);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodUpdateNwBind;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nIndex = nIndex;
    memcpy(ivar_ptr, pBindNwNum, nLen);
    ivar_ptr[nLen] = (char)0;
    ivar_ptr += ALIGNUP8(nLen + 1);
    ipar->nLen = nLen;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodGetProductInfo
void CFW_EmodGetProductInfo(CFW_EMOD_LOCT_PRODUCT_INFO *pProduct)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_EmodGetProductInfo *opar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodGetProductInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_EmodGetProductInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodGetProductInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pProduct = opar->pProduct;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_EmodGetRFCalibrationInfo
void CFW_EmodGetRFCalibrationInfo(CFW_EMOD_RF_CALIB_INFO *pRfCalib)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_EmodGetRFCalibrationInfo *opar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodGetRFCalibrationInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_EmodGetRFCalibrationInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodGetRFCalibrationInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pRfCalib = opar->pRfCalib;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_EmodOutfieldTestStart
uint32_t CFW_EmodOutfieldTestStart(CFW_TSM_FUNCTION_SELECT *pSelecFUN, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodOutfieldTestStart *ipar;
    struct OPAR_CFW_EmodOutfieldTestStart *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodOutfieldTestStart) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodOutfieldTestStart) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodOutfieldTestStart *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EmodOutfieldTestStart *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodOutfieldTestStart;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pSelecFUN = *pSelecFUN;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodOutfieldTestStartV2
uint32_t CFW_EmodOutfieldTestStartV2(CFW_TSM_FUNCTION_SELECT *pSelecFUN, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodOutfieldTestStartV2 *ipar;
    struct OPAR_CFW_EmodOutfieldTestStartV2 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodOutfieldTestStartV2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodOutfieldTestStartV2) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodOutfieldTestStartV2 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EmodOutfieldTestStartV2 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodOutfieldTestStartV2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pSelecFUN = *pSelecFUN;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodOutfieldTestEnd
uint32_t CFW_EmodOutfieldTestEnd(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodOutfieldTestEnd *ipar;
    struct OPAR_CFW_EmodOutfieldTestEnd *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodOutfieldTestEnd) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodOutfieldTestEnd) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodOutfieldTestEnd *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EmodOutfieldTestEnd *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodOutfieldTestEnd;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetCellInfo
uint32_t CFW_GetCellInfo(CFW_TSM_CURR_CELL_INFO *pCurrCellInfo, CFW_TSM_ALL_NEBCELL_INFO *pNeighborCellInfo, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetCellInfo *ipar;
    struct OPAR_CFW_GetCellInfo *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetCellInfo) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetCellInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetCellInfo *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetCellInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetCellInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pCurrCellInfo = opar->pCurrCellInfo;
    *pNeighborCellInfo = opar->pNeighborCellInfo;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetCellInfoV2
uint32_t CFW_GetCellInfoV2(CFW_TSM_CURR_CELL_INFO_V2 *pCurrCellInfo, CFW_TSM_ALL_NEBCELL_INFO_V2 *pNeighborCellInfo, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetCellInfoV2 *ipar;
    struct OPAR_CFW_GetCellInfoV2 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetCellInfoV2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetCellInfoV2) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetCellInfoV2 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetCellInfoV2 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetCellInfoV2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pCurrCellInfo = opar->pCurrCellInfo;
    *pNeighborCellInfo = opar->pNeighborCellInfo;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodSyncInfoTest
uint32_t CFW_EmodSyncInfoTest(bool bStart, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodSyncInfoTest *ipar;
    struct OPAR_CFW_EmodSyncInfoTest *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodSyncInfoTest) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodSyncInfoTest) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodSyncInfoTest *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EmodSyncInfoTest *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodSyncInfoTest;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->bStart = bStart;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetFreeCID
uint32_t CFW_GetFreeCID(uint8_t *pCID, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetFreeCID *ipar;
    struct OPAR_CFW_GetFreeCID *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetFreeCID) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetFreeCID) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetFreeCID *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetFreeCID *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetFreeCID;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pCID = opar->pCID;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_ReleaseCID
uint32_t CFW_ReleaseCID(uint8_t nCID, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_ReleaseCID *ipar;
    struct OPAR_CFW_ReleaseCID *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_ReleaseCID) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_ReleaseCID) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_ReleaseCID *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_ReleaseCID *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ReleaseCID;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCID = nCID;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetCID
uint32_t CFW_SetCID(uint8_t nCID, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetCID *ipar;
    struct OPAR_CFW_SetCID *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetCID) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetCID) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetCID *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetCID *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetCID;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCID = nCID;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_isPdpActiveAvailable
uint8_t CFW_isPdpActiveAvailable(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_isPdpActiveAvailable *ipar;
    struct OPAR_CFW_isPdpActiveAvailable *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_isPdpActiveAvailable) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_isPdpActiveAvailable) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_isPdpActiveAvailable *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_isPdpActiveAvailable *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_isPdpActiveAvailable;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_cfw_SimReadElementaryFile
uint32_t cfw_SimReadElementaryFile(uint16_t nUTI, uint32_t fileId, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_cfw_SimReadElementaryFile *ipar;
    struct OPAR_cfw_SimReadElementaryFile *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_cfw_SimReadElementaryFile) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_cfw_SimReadElementaryFile) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_cfw_SimReadElementaryFile *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_cfw_SimReadElementaryFile *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_cfw_SimReadElementaryFile;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->fileId = fileId;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimGetACMMax
uint32_t CFW_SimGetACMMax(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimGetACMMax *ipar;
    struct OPAR_CFW_SimGetACMMax *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimGetACMMax) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimGetACMMax) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimGetACMMax *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimGetACMMax *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimGetACMMax;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimSetACMMax
uint32_t CFW_SimSetACMMax(uint32_t iACMMaxValue, uint8_t * pPin2, uint8_t nPinSize, uint16_t Nuti, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimSetACMMax *ipar;
    struct OPAR_CFW_SimSetACMMax *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nPinSize+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimSetACMMax) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimSetACMMax) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimSetACMMax *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimSetACMMax *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimSetACMMax);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimSetACMMax;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->iACMMaxValue = iACMMaxValue;
    memcpy(ivar_ptr, pPin2, nPinSize);
    ivar_ptr[nPinSize] = (char)0;
    ivar_ptr += ALIGNUP8(nPinSize + 1);
    ipar->nPinSize = nPinSize;
    ipar->Nuti = Nuti;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimGetACM
uint32_t CFW_SimGetACM(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimGetACM *ipar;
    struct OPAR_CFW_SimGetACM *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimGetACM) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimGetACM) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimGetACM *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimGetACM *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimGetACM;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimSetACM
uint32_t CFW_SimSetACM(uint32_t iCurValue, uint8_t * pPin2, uint8_t nPinSize, uint16_t Nuti, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimSetACM *ipar;
    struct OPAR_CFW_SimSetACM *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nPinSize+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimSetACM) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimSetACM) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimSetACM *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimSetACM *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimSetACM);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimSetACM;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->iCurValue = iCurValue;
    memcpy(ivar_ptr, pPin2, nPinSize);
    ivar_ptr[nPinSize] = (char)0;
    ivar_ptr += ALIGNUP8(nPinSize + 1);
    ipar->nPinSize = nPinSize;
    ipar->Nuti = Nuti;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimGetPUCT
uint32_t CFW_SimGetPUCT(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimGetPUCT *ipar;
    struct OPAR_CFW_SimGetPUCT *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimGetPUCT) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimGetPUCT) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimGetPUCT *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimGetPUCT *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimGetPUCT;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimSetPUCT
uint32_t CFW_SimSetPUCT(CFW_SIM_PUCT_INFO *pPUCT, uint8_t * pPin2, uint8_t nPinSize, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimSetPUCT *ipar;
    struct OPAR_CFW_SimSetPUCT *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nPinSize+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimSetPUCT) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimSetPUCT) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimSetPUCT *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimSetPUCT *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimSetPUCT);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimSetPUCT;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pPUCT = *pPUCT;
    memcpy(ivar_ptr, pPin2, nPinSize);
    ivar_ptr[nPinSize] = (char)0;
    ivar_ptr += ALIGNUP8(nPinSize + 1);
    ipar->nPinSize = nPinSize;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodSetLteLockFreq
void CFW_EmodSetLteLockFreq(uint8_t number, uint32_t * freq, CFW_SIM_ID nSimId)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodSetLteLockFreq *ipar;
    char *ivar_ptr;


    ivar_size = ALIGNUP8(number*sizeof(uint32_t)+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodSetLteLockFreq) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodSetLteLockFreq *)((char *)mem + sizeof(rpcCallHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodSetLteLockFreq);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodSetLteLockFreq;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->number = number;
    memcpy(ivar_ptr, freq, number*sizeof(uint32_t));
    ivar_ptr[number*sizeof(uint32_t)] = (char)0;
    ivar_ptr += ALIGNUP8(number*sizeof(uint32_t) + 1);
    ipar->nSimId = nSimId;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_EmodGetLteLockFreq
void CFW_EmodGetLteLockFreq(uint8_t *number, uint32_t freq[9], CFW_SIM_ID nSimId)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodGetLteLockFreq *ipar;
    struct OPAR_CFW_EmodGetLteLockFreq *opar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodGetLteLockFreq) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodGetLteLockFreq) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodGetLteLockFreq *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EmodGetLteLockFreq *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodGetLteLockFreq;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ipar->freq, freq, sizeof(ipar->freq));
    ipar->nSimId = nSimId;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *number = opar->number;
    memcpy(freq, opar->freq, sizeof(opar->freq));
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_EmodSetLteLockBand
void CFW_EmodSetLteLockBand(uint8_t number, uint16_t * band, CFW_SIM_ID nSimId)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodSetLteLockBand *ipar;
    char *ivar_ptr;


    ivar_size = ALIGNUP8(number*sizeof(uint16_t)+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodSetLteLockBand) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodSetLteLockBand *)((char *)mem + sizeof(rpcCallHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodSetLteLockBand);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodSetLteLockBand;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->number = number;
    memcpy(ivar_ptr, band, number*sizeof(uint16_t));
    ivar_ptr[number*sizeof(uint16_t)] = (char)0;
    ivar_ptr += ALIGNUP8(number*sizeof(uint16_t) + 1);
    ipar->nSimId = nSimId;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_EmodGetLteLockBand
void CFW_EmodGetLteLockBand(uint8_t *number, uint16_t band[20], CFW_SIM_ID nSimId)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodGetLteLockBand *ipar;
    struct OPAR_CFW_EmodGetLteLockBand *opar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodGetLteLockBand) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodGetLteLockBand) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodGetLteLockBand *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EmodGetLteLockBand *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodGetLteLockBand;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimId = nSimId;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *number = opar->number;
    memcpy(band, opar->band, sizeof(opar->band));
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_EmodSetLteLockCell
void CFW_EmodSetLteLockCell(uint16_t Cell, CFW_SIM_ID nSimId)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodSetLteLockCell *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodSetLteLockCell) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodSetLteLockCell *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodSetLteLockCell;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->Cell = Cell;
    ipar->nSimId = nSimId;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_EmodGetLteLockCell
void CFW_EmodGetLteLockCell(uint16_t *Cell, CFW_SIM_ID nSimId)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodGetLteLockCell *ipar;
    struct OPAR_CFW_EmodGetLteLockCell *opar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodGetLteLockCell) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodGetLteLockCell) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodGetLteLockCell *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EmodGetLteLockCell *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodGetLteLockCell;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimId = nSimId;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *Cell = opar->Cell;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_EmodSetLteLockBandV2
void CFW_EmodSetLteLockBandV2(uint8_t number, uint16_t * band, CFW_SIM_ID nSimId)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodSetLteLockBandV2 *ipar;
    char *ivar_ptr;


    ivar_size = ALIGNUP8(number*sizeof(uint16_t)+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodSetLteLockBandV2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodSetLteLockBandV2 *)((char *)mem + sizeof(rpcCallHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodSetLteLockBandV2);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodSetLteLockBandV2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->number = number;
    memcpy(ivar_ptr, band, number*sizeof(uint16_t));
    ivar_ptr[number*sizeof(uint16_t)] = (char)0;
    ivar_ptr += ALIGNUP8(number*sizeof(uint16_t) + 1);
    ipar->nSimId = nSimId;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_GetBandFromFreq
uint16_t CFW_GetBandFromFreq(uint32_t freq)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetBandFromFreq *ipar;
    struct OPAR_CFW_GetBandFromFreq *opar;
    uint16_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetBandFromFreq) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetBandFromFreq) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetBandFromFreq *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetBandFromFreq *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetBandFromFreq;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->freq = freq;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodGetLteLockBandV2
void CFW_EmodGetLteLockBandV2(uint8_t *number, uint16_t band[20], CFW_SIM_ID nSimId)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodGetLteLockBandV2 *ipar;
    struct OPAR_CFW_EmodGetLteLockBandV2 *opar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodGetLteLockBandV2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodGetLteLockBandV2) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodGetLteLockBandV2 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EmodGetLteLockBandV2 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodGetLteLockBandV2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimId = nSimId;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *number = opar->number;
    memcpy(band, opar->band, sizeof(opar->band));
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_EmodGetLteLockTddOrFdd
void CFW_EmodGetLteLockTddOrFdd(uint8_t *tddfdd, CFW_SIM_ID nSimId)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodGetLteLockTddOrFdd *ipar;
    struct OPAR_CFW_EmodGetLteLockTddOrFdd *opar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodGetLteLockTddOrFdd) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodGetLteLockTddOrFdd) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodGetLteLockTddOrFdd *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EmodGetLteLockTddOrFdd *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodGetLteLockTddOrFdd;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimId = nSimId;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *tddfdd = opar->tddfdd;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_EmodSetLteLockTddOrFdd
void CFW_EmodSetLteLockTddOrFdd(uint8_t tddfdd, CFW_SIM_ID nSimId)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodSetLteLockTddOrFdd *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodSetLteLockTddOrFdd) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodSetLteLockTddOrFdd *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodSetLteLockTddOrFdd;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->tddfdd = tddfdd;
    ipar->nSimId = nSimId;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_EmodGetCEMode
void CFW_EmodGetCEMode(uint8_t *pMode, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodGetCEMode *ipar;
    struct OPAR_CFW_EmodGetCEMode *opar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodGetCEMode) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodGetCEMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodGetCEMode *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EmodGetCEMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodGetCEMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pMode = opar->pMode;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_EmodSetCEMode
void CFW_EmodSetCEMode(uint8_t nMode, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodSetCEMode *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodSetCEMode) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodSetCEMode *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodSetCEMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nMode = nMode;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_EmodGetVoicePrefer
void CFW_EmodGetVoicePrefer(uint8_t *pVoicePrefer, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodGetVoicePrefer *ipar;
    struct OPAR_CFW_EmodGetVoicePrefer *opar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodGetVoicePrefer) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodGetVoicePrefer) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodGetVoicePrefer *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EmodGetVoicePrefer *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodGetVoicePrefer;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pVoicePrefer = opar->pVoicePrefer;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_EmodSetVoicePrefer
void CFW_EmodSetVoicePrefer(uint8_t nVoicePrefer, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodSetVoicePrefer *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodSetVoicePrefer) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodSetVoicePrefer *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodSetVoicePrefer;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nVoicePrefer = nVoicePrefer;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

//#if defined(_SIM_HOT_PLUG_)
#ifndef DISABLE_RPC_CFW_SetPollingTimer
void CFW_SetPollingTimer(uint8_t PollingInterval, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetPollingTimer *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetPollingTimer) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetPollingTimer *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetPollingTimer;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->PollingInterval = PollingInterval;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

//#endif

//#if defined(_SIM_HOT_PLUG_)
#ifndef DISABLE_RPC_CFW_GetPollingTimer
void CFW_GetPollingTimer(uint8_t *PollingInterval, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetPollingTimer *ipar;
    struct OPAR_CFW_GetPollingTimer *opar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetPollingTimer) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetPollingTimer) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetPollingTimer *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetPollingTimer *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetPollingTimer;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *PollingInterval = opar->PollingInterval;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

//#endif

#ifndef DISABLE_RPC_CSW_SetAudioCodecCalibParam
uint32_t CSW_SetAudioCodecCalibParam(uint8_t *resultcode, uint8_t *hasMsg, uint8_t resultMsg[900], uint8_t nMode, uint8_t nPath, uint8_t nCtrl, uint8_t * nParam, uint16_t nParamLength)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CSW_SetAudioCodecCalibParam *ipar;
    struct OPAR_CSW_SetAudioCodecCalibParam *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nParamLength+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CSW_SetAudioCodecCalibParam) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CSW_SetAudioCodecCalibParam) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CSW_SetAudioCodecCalibParam *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CSW_SetAudioCodecCalibParam *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CSW_SetAudioCodecCalibParam);
    call->h.size = call_size;
    call->api_tag = TAG_CSW_SetAudioCodecCalibParam;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nMode = nMode;
    ipar->nPath = nPath;
    ipar->nCtrl = nCtrl;
    memcpy(ivar_ptr, nParam, nParamLength);
    ivar_ptr[nParamLength] = (char)0;
    ivar_ptr += ALIGNUP8(nParamLength + 1);
    ipar->nParamLength = nParamLength;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *resultcode = opar->resultcode;
    *hasMsg = opar->hasMsg;
    memcpy(resultMsg, opar->resultMsg, sizeof(opar->resultMsg));
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CSW_SetAudioZspVqeCalibParam
uint32_t CSW_SetAudioZspVqeCalibParam(uint8_t *resultcode, uint8_t *hasMsg, uint8_t resultMsg[900], uint8_t nMode, uint8_t nPath, uint8_t nCtrl, uint8_t * nParam, uint16_t nParamLength)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CSW_SetAudioZspVqeCalibParam *ipar;
    struct OPAR_CSW_SetAudioZspVqeCalibParam *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nParamLength+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CSW_SetAudioZspVqeCalibParam) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CSW_SetAudioZspVqeCalibParam) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CSW_SetAudioZspVqeCalibParam *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CSW_SetAudioZspVqeCalibParam *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CSW_SetAudioZspVqeCalibParam);
    call->h.size = call_size;
    call->api_tag = TAG_CSW_SetAudioZspVqeCalibParam;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nMode = nMode;
    ipar->nPath = nPath;
    ipar->nCtrl = nCtrl;
    memcpy(ivar_ptr, nParam, nParamLength);
    ivar_ptr[nParamLength] = (char)0;
    ivar_ptr += ALIGNUP8(nParamLength + 1);
    ipar->nParamLength = nParamLength;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *resultcode = opar->resultcode;
    *hasMsg = opar->hasMsg;
    memcpy(resultMsg, opar->resultMsg, sizeof(opar->resultMsg));
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CSW_SetAudioZspPreProcessCalibParam
uint32_t CSW_SetAudioZspPreProcessCalibParam(uint8_t *resultcode, uint8_t *hasMsg, uint8_t resultMsg[900], uint8_t nMode, uint8_t nPath, uint8_t nCtrl, uint8_t * nParam, uint16_t nParamLength)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CSW_SetAudioZspPreProcessCalibParam *ipar;
    struct OPAR_CSW_SetAudioZspPreProcessCalibParam *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nParamLength+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CSW_SetAudioZspPreProcessCalibParam) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CSW_SetAudioZspPreProcessCalibParam) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CSW_SetAudioZspPreProcessCalibParam *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CSW_SetAudioZspPreProcessCalibParam *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CSW_SetAudioZspPreProcessCalibParam);
    call->h.size = call_size;
    call->api_tag = TAG_CSW_SetAudioZspPreProcessCalibParam;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nMode = nMode;
    ipar->nPath = nPath;
    ipar->nCtrl = nCtrl;
    memcpy(ivar_ptr, nParam, nParamLength);
    ivar_ptr[nParamLength] = (char)0;
    ivar_ptr += ALIGNUP8(nParamLength + 1);
    ipar->nParamLength = nParamLength;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *resultcode = opar->resultcode;
    *hasMsg = opar->hasMsg;
    memcpy(resultMsg, opar->resultMsg, sizeof(opar->resultMsg));
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CSW_SetAudioZspPostProcessCalibParam
uint32_t CSW_SetAudioZspPostProcessCalibParam(uint8_t *resultcode, uint8_t *hasMsg, uint8_t resultMsg[900], uint8_t nMode, uint8_t nPath, uint8_t nCtrl, uint8_t * nParam, uint16_t nParamLength)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CSW_SetAudioZspPostProcessCalibParam *ipar;
    struct OPAR_CSW_SetAudioZspPostProcessCalibParam *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nParamLength+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CSW_SetAudioZspPostProcessCalibParam) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CSW_SetAudioZspPostProcessCalibParam) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CSW_SetAudioZspPostProcessCalibParam *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CSW_SetAudioZspPostProcessCalibParam *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CSW_SetAudioZspPostProcessCalibParam);
    call->h.size = call_size;
    call->api_tag = TAG_CSW_SetAudioZspPostProcessCalibParam;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nMode = nMode;
    ipar->nPath = nPath;
    ipar->nCtrl = nCtrl;
    memcpy(ivar_ptr, nParam, nParamLength);
    ivar_ptr[nParamLength] = (char)0;
    ivar_ptr += ALIGNUP8(nParamLength + 1);
    ipar->nParamLength = nParamLength;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *resultcode = opar->resultcode;
    *hasMsg = opar->hasMsg;
    memcpy(resultMsg, opar->resultMsg, sizeof(opar->resultMsg));
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CSW_WriteCalibParamToFlash
uint32_t CSW_WriteCalibParamToFlash(uint8_t *resultcode, uint8_t *hasMsg, uint8_t resultMsg[900], uint8_t nPath, uint8_t nCtrl, uint8_t * nParam, uint16_t nParamLength)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CSW_WriteCalibParamToFlash *ipar;
    struct OPAR_CSW_WriteCalibParamToFlash *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nParamLength+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CSW_WriteCalibParamToFlash) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CSW_WriteCalibParamToFlash) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CSW_WriteCalibParamToFlash *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CSW_WriteCalibParamToFlash *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CSW_WriteCalibParamToFlash);
    call->h.size = call_size;
    call->api_tag = TAG_CSW_WriteCalibParamToFlash;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nPath = nPath;
    ipar->nCtrl = nCtrl;
    memcpy(ivar_ptr, nParam, nParamLength);
    ivar_ptr[nParamLength] = (char)0;
    ivar_ptr += ALIGNUP8(nParamLength + 1);
    ipar->nParamLength = nParamLength;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *resultcode = opar->resultcode;
    *hasMsg = opar->hasMsg;
    memcpy(resultMsg, opar->resultMsg, sizeof(opar->resultMsg));
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CSW_ExportCalibOrImportCalibFlashParam
uint32_t CSW_ExportCalibOrImportCalibFlashParam(uint8_t *resultcode, uint8_t *hasMsg, uint8_t resultMsg[900], uint8_t nPath, uint8_t nCtrl, uint16_t nOffset, uint16_t nlength, uint8_t * nParam, uint16_t nParamLength)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CSW_ExportCalibOrImportCalibFlashParam *ipar;
    struct OPAR_CSW_ExportCalibOrImportCalibFlashParam *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nParamLength+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CSW_ExportCalibOrImportCalibFlashParam) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CSW_ExportCalibOrImportCalibFlashParam) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CSW_ExportCalibOrImportCalibFlashParam *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CSW_ExportCalibOrImportCalibFlashParam *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CSW_ExportCalibOrImportCalibFlashParam);
    call->h.size = call_size;
    call->api_tag = TAG_CSW_ExportCalibOrImportCalibFlashParam;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nPath = nPath;
    ipar->nCtrl = nCtrl;
    ipar->nOffset = nOffset;
    ipar->nlength = nlength;
    memcpy(ivar_ptr, nParam, nParamLength);
    ivar_ptr[nParamLength] = (char)0;
    ivar_ptr += ALIGNUP8(nParamLength + 1);
    ipar->nParamLength = nParamLength;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *resultcode = opar->resultcode;
    *hasMsg = opar->hasMsg;
    memcpy(resultMsg, opar->resultMsg, sizeof(opar->resultMsg));
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CSW_DumpPcmDataToTflash
uint32_t CSW_DumpPcmDataToTflash(uint8_t *resultcode, uint8_t *hasMsg, uint8_t resultMsg[900], uint8_t nPath, uint8_t nCtrl, uint8_t * nParam, uint16_t nParamLength)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CSW_DumpPcmDataToTflash *ipar;
    struct OPAR_CSW_DumpPcmDataToTflash *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nParamLength+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CSW_DumpPcmDataToTflash) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CSW_DumpPcmDataToTflash) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CSW_DumpPcmDataToTflash *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CSW_DumpPcmDataToTflash *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CSW_DumpPcmDataToTflash);
    call->h.size = call_size;
    call->api_tag = TAG_CSW_DumpPcmDataToTflash;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nPath = nPath;
    ipar->nCtrl = nCtrl;
    memcpy(ivar_ptr, nParam, nParamLength);
    ivar_ptr[nParamLength] = (char)0;
    ivar_ptr += ALIGNUP8(nParamLength + 1);
    ipar->nParamLength = nParamLength;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *resultcode = opar->resultcode;
    *hasMsg = opar->hasMsg;
    memcpy(resultMsg, opar->resultMsg, sizeof(opar->resultMsg));
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CSW_VersionControl
uint32_t CSW_VersionControl(uint8_t *resultcode, uint8_t *hasMsg, uint8_t resultMsg[900], uint8_t nPath, uint8_t nCtrl, uint8_t * nParam, uint16_t nParamLength)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CSW_VersionControl *ipar;
    struct OPAR_CSW_VersionControl *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nParamLength+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CSW_VersionControl) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CSW_VersionControl) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CSW_VersionControl *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CSW_VersionControl *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CSW_VersionControl);
    call->h.size = call_size;
    call->api_tag = TAG_CSW_VersionControl;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nPath = nPath;
    ipar->nCtrl = nCtrl;
    memcpy(ivar_ptr, nParam, nParamLength);
    ivar_ptr[nParamLength] = (char)0;
    ivar_ptr += ALIGNUP8(nParamLength + 1);
    ipar->nParamLength = nParamLength;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *resultcode = opar->resultcode;
    *hasMsg = opar->hasMsg;
    memcpy(resultMsg, opar->resultMsg, sizeof(opar->resultMsg));
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CSW_SetAudioZspNxpCalibParam
uint32_t CSW_SetAudioZspNxpCalibParam(uint8_t *resultcode, uint8_t *hasMsg, uint8_t resultMsg[900], uint8_t nMode, uint8_t nPath, uint8_t nCtrl, uint8_t * nParam, uint16_t nParamLength)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CSW_SetAudioZspNxpCalibParam *ipar;
    struct OPAR_CSW_SetAudioZspNxpCalibParam *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nParamLength+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CSW_SetAudioZspNxpCalibParam) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CSW_SetAudioZspNxpCalibParam) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CSW_SetAudioZspNxpCalibParam *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CSW_SetAudioZspNxpCalibParam *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CSW_SetAudioZspNxpCalibParam);
    call->h.size = call_size;
    call->api_tag = TAG_CSW_SetAudioZspNxpCalibParam;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nMode = nMode;
    ipar->nPath = nPath;
    ipar->nCtrl = nCtrl;
    memcpy(ivar_ptr, nParam, nParamLength);
    ivar_ptr[nParamLength] = (char)0;
    ivar_ptr += ALIGNUP8(nParamLength + 1);
    ipar->nParamLength = nParamLength;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *resultcode = opar->resultcode;
    *hasMsg = opar->hasMsg;
    memcpy(resultMsg, opar->resultMsg, sizeof(opar->resultMsg));
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwSetFTA
uint32_t CFW_NwSetFTA(uint8_t nFta, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwSetFTA *ipar;
    struct OPAR_CFW_NwSetFTA *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwSetFTA) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwSetFTA) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwSetFTA *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwSetFTA *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwSetFTA;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nFta = nFta;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwSetnSecurityUsedFlag
uint32_t CFW_NwSetnSecurityUsedFlag(uint8_t nSecurityUsedFlag, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwSetnSecurityUsedFlag *ipar;
    struct OPAR_CFW_NwSetnSecurityUsedFlag *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwSetnSecurityUsedFlag) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwSetnSecurityUsedFlag) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwSetnSecurityUsedFlag *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwSetnSecurityUsedFlag *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwSetnSecurityUsedFlag;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSecurityUsedFlag = nSecurityUsedFlag;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GprsIpDnsInfo
uint32_t CFW_GprsIpDnsInfo(uint8_t nCid, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsIpDnsInfo *ipar;
    struct OPAR_CFW_GprsIpDnsInfo *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsIpDnsInfo) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsIpDnsInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsIpDnsInfo *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsIpDnsInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsIpDnsInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCid = nCid;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwSetBlackWhiteList
uint32_t CFW_NwSetBlackWhiteList(CFW_BLACK_WHITE_LIST *pBlackWhiteList, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwSetBlackWhiteList *ipar;
    struct OPAR_CFW_NwSetBlackWhiteList *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwSetBlackWhiteList) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwSetBlackWhiteList) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwSetBlackWhiteList *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwSetBlackWhiteList *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwSetBlackWhiteList;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pBlackWhiteList = *pBlackWhiteList;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetSimAdnId
uint8_t CFW_GetSimAdnId(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetSimAdnId *ipar;
    struct OPAR_CFW_GetSimAdnId *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetSimAdnId) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetSimAdnId) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetSimAdnId *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetSimAdnId *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetSimAdnId;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GprsClrIpDns
uint32_t CFW_GprsClrIpDns(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_GprsClrIpDns *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsClrIpDns) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_GprsClrIpDns *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsClrIpDns;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetICCID
uint8_t * CFW_GetICCID(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetICCID *ipar;
    struct OPAR_CFW_GetICCID *opar;
    uint8_t * result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetICCID) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetICCID) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetICCID *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetICCID *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetICCID;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_hal_WriteGsmCalib
void hal_WriteGsmCalib(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;



    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    call->h.size = call_size;
    call->api_tag = TAG_hal_WriteGsmCalib;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_hal_WriteLteCalib
void hal_WriteLteCalib(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;



    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    call->h.size = call_size;
    call->api_tag = TAG_hal_WriteLteCalib;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_CcCallMultipartyFunction
uint32_t CFW_CcCallMultipartyFunction(uint8_t nFun, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CcCallMultipartyFunction *ipar;
    struct OPAR_CFW_CcCallMultipartyFunction *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CcCallMultipartyFunction) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CcCallMultipartyFunction) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CcCallMultipartyFunction *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CcCallMultipartyFunction *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CcCallMultipartyFunction;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nFun = nFun;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimReadVoiceMailInfo
uint32_t CFW_SimReadVoiceMailInfo(uint8_t nLineId, CFW_VOICE_MAIL_TYPE_E nType, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimReadVoiceMailInfo *ipar;
    struct OPAR_CFW_SimReadVoiceMailInfo *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimReadVoiceMailInfo) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimReadVoiceMailInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimReadVoiceMailInfo *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimReadVoiceMailInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimReadVoiceMailInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nLineId = nLineId;
    ipar->nType = nType;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimUpdateVoiceMailInfo
uint32_t CFW_SimUpdateVoiceMailInfo(uint8_t nLineId, CFW_VOICE_MAIL_TYPE_E nType, CFW_SIM_INFO_VOICEMAIL *pVoiceMail, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimUpdateVoiceMailInfo *ipar;
    struct OPAR_CFW_SimUpdateVoiceMailInfo *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimUpdateVoiceMailInfo) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimUpdateVoiceMailInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimUpdateVoiceMailInfo *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimUpdateVoiceMailInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimUpdateVoiceMailInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nLineId = nLineId;
    ipar->nType = nType;
    ipar->pVoiceMail = *pVoiceMail;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CbSetContext
uint32_t CFW_CbSetContext(uint8_t CtxData[sizeof(CB_CTX_T)], CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CbSetContext *ipar;
    struct OPAR_CFW_CbSetContext *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CbSetContext) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CbSetContext) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CbSetContext *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CbSetContext *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CbSetContext;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ipar->CtxData, CtxData, sizeof(ipar->CtxData));
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CbGetContext
uint32_t CFW_CbGetContext(uint8_t CtxData[sizeof(CB_CTX_T)], CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CbGetContext *ipar;
    struct OPAR_CFW_CbGetContext *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CbGetContext) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CbGetContext) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CbGetContext *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CbGetContext *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CbGetContext;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ipar->CtxData, CtxData, sizeof(ipar->CtxData));
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CbWriteContext
uint32_t CFW_CbWriteContext(CB_CTX_T CtxData, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CbWriteContext *ipar;
    struct OPAR_CFW_CbWriteContext *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CbWriteContext) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CbWriteContext) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CbWriteContext *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CbWriteContext *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CbWriteContext;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->CtxData = CtxData;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CbReadContext
uint32_t CFW_CbReadContext(CB_CTX_T *CtxData, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CbReadContext *ipar;
    struct OPAR_CFW_CbReadContext *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CbReadContext) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CbReadContext) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CbReadContext *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CbReadContext *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CbReadContext;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *CtxData = opar->CtxData;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetPsDataAttribute
void CFW_SetPsDataAttribute(CFW_DATA_ATTRIBUTE_T *pAttribute, uint8_t rai, uint8_t exception_data, uint16_t exempted_service_type)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetPsDataAttribute *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetPsDataAttribute) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetPsDataAttribute *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetPsDataAttribute;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pAttribute = *pAttribute;
    ipar->rai = rai;
    ipar->exception_data = exception_data;
    ipar->exempted_service_type = exempted_service_type;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_CbSetType
uint32_t CFW_CbSetType(uint8_t nCbType, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CbSetType *ipar;
    struct OPAR_CFW_CbSetType *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CbSetType) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CbSetType) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CbSetType *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CbSetType *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CbSetType;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCbType = nCbType;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CbAct
uint32_t CFW_CbAct(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CbAct *ipar;
    struct OPAR_CFW_CbAct *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CbAct) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CbAct) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CbAct *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CbAct *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CbAct;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CbDeAct
uint32_t CFW_CbDeAct(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CbDeAct *ipar;
    struct OPAR_CFW_CbDeAct *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CbDeAct) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CbDeAct) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CbDeAct *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CbDeAct *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CbDeAct;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetPowerOffFlag
uint32_t CFW_SetPowerOffFlag(uint8_t bOff, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetPowerOffFlag *ipar;
    struct OPAR_CFW_SetPowerOffFlag *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetPowerOffFlag) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetPowerOffFlag) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetPowerOffFlag *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetPowerOffFlag *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetPowerOffFlag;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->bOff = bOff;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwSysConfig
uint32_t CFW_NwSysConfig(uint8_t nMode, uint8_t nAcqorder, uint8_t nRoam, uint8_t nSrvdomain, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwSysConfig *ipar;
    struct OPAR_CFW_NwSysConfig *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwSysConfig) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwSysConfig) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwSysConfig *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwSysConfig *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwSysConfig;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nMode = nMode;
    ipar->nAcqorder = nAcqorder;
    ipar->nRoam = nRoam;
    ipar->nSrvdomain = nSrvdomain;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwGetSysConfig
uint32_t CFW_NwGetSysConfig(uint8_t *pMode, uint8_t *pAcqorder, uint8_t *pRoam, uint8_t *pSrvdomain, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwGetSysConfig *ipar;
    struct OPAR_CFW_NwGetSysConfig *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwGetSysConfig) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwGetSysConfig) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwGetSysConfig *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwGetSysConfig *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwGetSysConfig;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pMode = opar->pMode;
    *pAcqorder = opar->pAcqorder;
    *pRoam = opar->pRoam;
    *pSrvdomain = opar->pSrvdomain;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimGetSmsParameters
uint32_t CFW_SimGetSmsParameters(uint8_t nIndex, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimGetSmsParameters *ipar;
    struct OPAR_CFW_SimGetSmsParameters *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimGetSmsParameters) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimGetSmsParameters) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimGetSmsParameters *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimGetSmsParameters *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimGetSmsParameters;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nIndex = nIndex;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimSetSmsParameters
uint32_t CFW_SimSetSmsParameters(CFW_SIM_SMS_PARAMETERS *pSmsParamArray, uint8_t nArrayCount, uint8_t nIndex, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimSetSmsParameters *ipar;
    struct OPAR_CFW_SimSetSmsParameters *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimSetSmsParameters) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimSetSmsParameters) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimSetSmsParameters *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimSetSmsParameters *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimSetSmsParameters;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pSmsParamArray = *pSmsParamArray;
    ipar->nArrayCount = nArrayCount;
    ipar->nIndex = nIndex;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimDeleteMessage
uint32_t CFW_SimDeleteMessage(uint16_t nLocation, uint16_t nIndex, uint16_t nStatus, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimDeleteMessage *ipar;
    struct OPAR_CFW_SimDeleteMessage *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimDeleteMessage) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimDeleteMessage) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimDeleteMessage *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimDeleteMessage *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimDeleteMessage;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nLocation = nLocation;
    ipar->nIndex = nIndex;
    ipar->nStatus = nStatus;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodSpLteDummyPara
uint32_t CFW_EmodSpLteDummyPara(CFW_EmodSpLteDummyPara_t para, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodSpLteDummyPara *ipar;
    struct OPAR_CFW_EmodSpLteDummyPara *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodSpLteDummyPara) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodSpLteDummyPara) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodSpLteDummyPara *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EmodSpLteDummyPara *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodSpLteDummyPara;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->para = para;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodRrtmParam
uint32_t CFW_EmodRrtmParam(CFW_EmodRrtmParam_t para, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodRrtmParam *ipar;
    struct OPAR_CFW_EmodRrtmParam *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodRrtmParam) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodRrtmParam) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodRrtmParam *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EmodRrtmParam *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodRrtmParam;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->para = para;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodGrrLteFreq
uint32_t CFW_EmodGrrLteFreq(CFW_EmodGrrLteFreq_t para, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodGrrLteFreq *ipar;
    struct OPAR_CFW_EmodGrrLteFreq *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodGrrLteFreq) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodGrrLteFreq) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodGrrLteFreq *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EmodGrrLteFreq *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodGrrLteFreq;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->para = para;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodRrdmParam
uint32_t CFW_EmodRrdmParam(CFW_EmodRrdmParam_t para, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodRrdmParam *ipar;
    struct OPAR_CFW_EmodRrdmParam *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodRrdmParam) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodRrdmParam) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodRrdmParam *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EmodRrdmParam *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodRrdmParam;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->para = para;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodL1Param
uint32_t CFW_EmodL1Param(CFW_EmodL1Param_t para, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodL1Param *ipar;
    struct OPAR_CFW_EmodL1Param *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodL1Param) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodL1Param) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodL1Param *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EmodL1Param *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodL1Param;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->para = para;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodSpCleanInfo
uint32_t CFW_EmodSpCleanInfo(CFW_EmodSpCleanInfo_t para, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodSpCleanInfo *ipar;
    struct OPAR_CFW_EmodSpCleanInfo *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodSpCleanInfo) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodSpCleanInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodSpCleanInfo *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EmodSpCleanInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodSpCleanInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->para = para;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodGetGsmCalibInfo
uint32_t CFW_EmodGetGsmCalibInfo(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_EmodGetGsmCalibInfo *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodGetGsmCalibInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_EmodGetGsmCalibInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodGetGsmCalibInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodGetLteCalibInfo
uint32_t CFW_EmodGetLteCalibInfo(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_EmodGetLteCalibInfo *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodGetLteCalibInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_EmodGetLteCalibInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodGetLteCalibInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwSetXCAP
uint32_t CFW_NwSetXCAP(uint8_t * pXCAP, uint32_t nLength, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwSetXCAP *ipar;
    struct OPAR_CFW_NwSetXCAP *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nLength+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwSetXCAP) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwSetXCAP) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwSetXCAP *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwSetXCAP *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwSetXCAP);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwSetXCAP;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ivar_ptr, pXCAP, nLength);
    ivar_ptr[nLength] = (char)0;
    ivar_ptr += ALIGNUP8(nLength + 1);
    ipar->nLength = nLength;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwSetBSF
uint32_t CFW_NwSetBSF(uint8_t * pBSF, uint32_t nLength, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwSetBSF *ipar;
    struct OPAR_CFW_NwSetBSF *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nLength+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwSetBSF) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwSetBSF) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwSetBSF *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwSetBSF *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwSetBSF);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwSetBSF;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ivar_ptr, pBSF, nLength);
    ivar_ptr[nLength] = (char)0;
    ivar_ptr += ALIGNUP8(nLength + 1);
    ipar->nLength = nLength;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodSetTracePort
void CFW_EmodSetTracePort(uint8_t port)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodSetTracePort *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodSetTracePort) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodSetTracePort *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodSetTracePort;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->port = port;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_EmodGetTracePort
uint8_t CFW_EmodGetTracePort(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_EmodGetTracePort *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodGetTracePort) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_EmodGetTracePort *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodGetTracePort;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = 0;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodSetTraceFlag
void CFW_EmodSetTraceFlag(uint8_t bStop)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodSetTraceFlag *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodSetTraceFlag) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodSetTraceFlag *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodSetTraceFlag;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->bStop = bStop;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_EmodGetTraceFlag
uint8_t CFW_EmodGetTraceFlag(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_EmodGetTraceFlag *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodGetTraceFlag) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_EmodGetTraceFlag *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodGetTraceFlag;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = 0;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_ImsSrvccCapSet
uint32_t CFW_ImsSrvccCapSet(uint8_t bSupport, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_ImsSrvccCapSet *ipar;
    struct OPAR_CFW_ImsSrvccCapSet *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_ImsSrvccCapSet) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_ImsSrvccCapSet) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_ImsSrvccCapSet *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_ImsSrvccCapSet *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ImsSrvccCapSet;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->bSupport = bSupport;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_ImsGetSrvccCap
uint8_t CFW_ImsGetSrvccCap(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_ImsGetSrvccCap *ipar;
    struct OPAR_CFW_ImsGetSrvccCap *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_ImsGetSrvccCap) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_ImsGetSrvccCap) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_ImsGetSrvccCap *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_ImsGetSrvccCap *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ImsGetSrvccCap;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetSmsSeviceMode
uint8_t CFW_SetSmsSeviceMode(uint8_t service)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetSmsSeviceMode *ipar;
    struct OPAR_CFW_SetSmsSeviceMode *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetSmsSeviceMode) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetSmsSeviceMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetSmsSeviceMode *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetSmsSeviceMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetSmsSeviceMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->service = service;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetSmsSeviceMode
uint8_t CFW_GetSmsSeviceMode(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_GetSmsSeviceMode *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetSmsSeviceMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_GetSmsSeviceMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetSmsSeviceMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_TM_KillAlarm
bool TM_KillAlarm(uint8_t nIndex)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_TM_KillAlarm *ipar;
    struct OPAR_TM_KillAlarm *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_TM_KillAlarm) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_TM_KillAlarm) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_TM_KillAlarm *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_TM_KillAlarm *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_TM_KillAlarm;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nIndex = nIndex;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_TM_ListAlarm
bool TM_ListAlarm(uint8_t *pArrayCnt, TM_ALARM * *pAlarmArray)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_TM_ListAlarm *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_TM_ListAlarm) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_TM_ListAlarm *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_TM_ListAlarm;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pArrayCnt = opar->pArrayCnt;
    *pAlarmArray = opar->pAlarmArray;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwChangeRat
uint32_t CFW_NwChangeRat(uint8_t nRat, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwChangeRat *ipar;
    struct OPAR_CFW_NwChangeRat *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwChangeRat) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwChangeRat) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwChangeRat *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwChangeRat *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwChangeRat;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nRat = nRat;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetNetinfo
uint32_t CFW_GetNetinfo(CFW_NET_INFO_T *pNetinfo, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetNetinfo *ipar;
    struct OPAR_CFW_GetNetinfo *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetNetinfo) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetNetinfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetNetinfo *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetNetinfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetNetinfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pNetinfo = opar->pNetinfo;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetLETRealTimeInfo
uint32_t CFW_GetLETRealTimeInfo(CFW_NET_INFO_T *pNetinfo, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetLETRealTimeInfo *ipar;
    struct OPAR_CFW_GetLETRealTimeInfo *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetLETRealTimeInfo) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetLETRealTimeInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetLETRealTimeInfo *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetLETRealTimeInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetLETRealTimeInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pNetinfo = opar->pNetinfo;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetLETRealTimeInfoV2
uint32_t CFW_GetLETRealTimeInfoV2(CFW_NET_INFO_T_V2 *pNetinfo, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetLETRealTimeInfoV2 *ipar;
    struct OPAR_CFW_GetLETRealTimeInfoV2 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetLETRealTimeInfoV2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetLETRealTimeInfoV2) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetLETRealTimeInfoV2 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetLETRealTimeInfoV2 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetLETRealTimeInfoV2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pNetinfo = opar->pNetinfo;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetNetinfoStatistic
uint32_t CFW_GetNetinfoStatistic(CFW_NET_INFO_STATISTIC_T *pNetinfoStatistic, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetNetinfoStatistic *ipar;
    struct OPAR_CFW_GetNetinfoStatistic *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetNetinfoStatistic) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetNetinfoStatistic) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetNetinfoStatistic *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetNetinfoStatistic *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetNetinfoStatistic;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pNetinfoStatistic = opar->pNetinfoStatistic;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetInitWithSim
void CFW_SetInitWithSim(bool bWith, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetInitWithSim *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetInitWithSim) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetInitWithSim *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetInitWithSim;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->bWith = bWith;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_GetSimSPN
uint32_t CFW_GetSimSPN(CFW_SIM_ID nSimID, CFW_SPN_INFO *pSPNInfo)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetSimSPN *ipar;
    struct OPAR_CFW_GetSimSPN *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetSimSPN) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetSimSPN) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetSimSPN *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetSimSPN *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetSimSPN;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pSPNInfo = opar->pSPNInfo;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetAntenna
uint32_t CFW_CfgSetAntenna(uint8_t * data, uint16_t len)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetAntenna *ipar;
    struct OPAR_CFW_CfgSetAntenna *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(len+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetAntenna) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetAntenna) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetAntenna *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetAntenna *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetAntenna);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetAntenna;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ivar_ptr, data, len);
    ivar_ptr[len] = (char)0;
    ivar_ptr += ALIGNUP8(len + 1);
    ipar->len = len;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_ImsEnVolte
uint32_t CFW_ImsEnVolte(uint8_t bEn, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_ImsEnVolte *ipar;
    struct OPAR_CFW_ImsEnVolte *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_ImsEnVolte) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_ImsEnVolte) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_ImsEnVolte *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_ImsEnVolte *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ImsEnVolte;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->bEn = bEn;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SwitchUSBShareNetwork
uint32_t CFW_SwitchUSBShareNetwork(bool flag)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SwitchUSBShareNetwork *ipar;
    struct OPAR_CFW_SwitchUSBShareNetwork *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SwitchUSBShareNetwork) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SwitchUSBShareNetwork) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SwitchUSBShareNetwork *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SwitchUSBShareNetwork *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SwitchUSBShareNetwork;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->flag = flag;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwGetQualReport
uint32_t CFW_NwGetQualReport(CFW_NW_QUAL_INFO *pQualReport, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwGetQualReport *ipar;
    struct OPAR_CFW_NwGetQualReport *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwGetQualReport) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwGetQualReport) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwGetQualReport *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwGetQualReport *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwGetQualReport;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pQualReport = opar->pQualReport;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_nvGetPsmEnable
uint8_t CFW_nvGetPsmEnable(uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvGetPsmEnable *ipar;
    struct OPAR_CFW_nvGetPsmEnable *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvGetPsmEnable) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_nvGetPsmEnable) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvGetPsmEnable *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_nvGetPsmEnable *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvGetPsmEnable;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_nvGetPsmT3412
uint8_t CFW_nvGetPsmT3412(uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvGetPsmT3412 *ipar;
    struct OPAR_CFW_nvGetPsmT3412 *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvGetPsmT3412) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_nvGetPsmT3412) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvGetPsmT3412 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_nvGetPsmT3412 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvGetPsmT3412;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_nvGetPsmT3324
uint8_t CFW_nvGetPsmT3324(uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvGetPsmT3324 *ipar;
    struct OPAR_CFW_nvGetPsmT3324 *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvGetPsmT3324) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_nvGetPsmT3324) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvGetPsmT3324 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_nvGetPsmT3324 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvGetPsmT3324;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_nvSetPsmEnable
void CFW_nvSetPsmEnable(uint8_t psmEnable, uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvSetPsmEnable *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvSetPsmEnable) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvSetPsmEnable *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvSetPsmEnable;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->psmEnable = psmEnable;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_nvSetPsmT3412
void CFW_nvSetPsmT3412(uint8_t psmEnable, uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvSetPsmT3412 *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvSetPsmT3412) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvSetPsmT3412 *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvSetPsmT3412;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->psmEnable = psmEnable;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_nvSetPsmT3324
void CFW_nvSetPsmT3324(uint8_t psmEnable, uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvSetPsmT3324 *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvSetPsmT3324) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvSetPsmT3324 *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvSetPsmT3324;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->psmEnable = psmEnable;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_nvGetEdrxEnable
uint8_t CFW_nvGetEdrxEnable(uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvGetEdrxEnable *ipar;
    struct OPAR_CFW_nvGetEdrxEnable *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvGetEdrxEnable) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_nvGetEdrxEnable) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvGetEdrxEnable *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_nvGetEdrxEnable *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvGetEdrxEnable;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_nvGetEdrxValue
uint8_t CFW_nvGetEdrxValue(uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvGetEdrxValue *ipar;
    struct OPAR_CFW_nvGetEdrxValue *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvGetEdrxValue) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_nvGetEdrxValue) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvGetEdrxValue *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_nvGetEdrxValue *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvGetEdrxValue;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_nvGetEdrxPtw
uint8_t CFW_nvGetEdrxPtw(uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvGetEdrxPtw *ipar;
    struct OPAR_CFW_nvGetEdrxPtw *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvGetEdrxPtw) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_nvGetEdrxPtw) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvGetEdrxPtw *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_nvGetEdrxPtw *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvGetEdrxPtw;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_nvSetEdrxEnable
void CFW_nvSetEdrxEnable(uint8_t psmEnable, uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvSetEdrxEnable *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvSetEdrxEnable) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvSetEdrxEnable *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvSetEdrxEnable;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->psmEnable = psmEnable;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_nvSetEdrxValue
void CFW_nvSetEdrxValue(uint8_t psmEnable, uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvSetEdrxValue *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvSetEdrxValue) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvSetEdrxValue *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvSetEdrxValue;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->psmEnable = psmEnable;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_nvSetEdrxPtw
void CFW_nvSetEdrxPtw(uint8_t psmEnable, uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvSetEdrxPtw *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvSetEdrxPtw) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvSetEdrxPtw *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvSetEdrxPtw;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->psmEnable = psmEnable;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_SimGetStatus
CFW_SIMSTATUS CFW_SimGetStatus(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimGetStatus *ipar;
    struct OPAR_CFW_SimGetStatus *opar;
    CFW_SIMSTATUS result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimGetStatus) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimGetStatus) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimGetStatus *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimGetStatus *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimGetStatus;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_nvSetCiotNonip
void CFW_nvSetCiotNonip(uint8_t nonip, uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvSetCiotNonip *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvSetCiotNonip) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvSetCiotNonip *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvSetCiotNonip;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nonip = nonip;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_nvSetCiotCpciot
void CFW_nvSetCiotCpciot(uint8_t cpciot, uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvSetCiotCpciot *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvSetCiotCpciot) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvSetCiotCpciot *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvSetCiotCpciot;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->cpciot = cpciot;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_nvSetCiotUpciot
void CFW_nvSetCiotUpciot(uint8_t upciot, uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvSetCiotUpciot *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvSetCiotUpciot) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvSetCiotUpciot *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvSetCiotUpciot;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->upciot = upciot;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_nvSetCiotErwopdn
void CFW_nvSetCiotErwopdn(uint8_t erwopdn, uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvSetCiotErwopdn *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvSetCiotErwopdn) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvSetCiotErwopdn *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvSetCiotErwopdn;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->erwopdn = erwopdn;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_nvSetCiotSmsWoCombAtt
void CFW_nvSetCiotSmsWoCombAtt(uint8_t sms_wo_comb_att, uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvSetCiotSmsWoCombAtt *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvSetCiotSmsWoCombAtt) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvSetCiotSmsWoCombAtt *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvSetCiotSmsWoCombAtt;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->sms_wo_comb_att = sms_wo_comb_att;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_nvSetCiotApnRateCtrl
void CFW_nvSetCiotApnRateCtrl(uint8_t apn_rate_control, uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvSetCiotApnRateCtrl *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvSetCiotApnRateCtrl) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvSetCiotApnRateCtrl *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvSetCiotApnRateCtrl;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->apn_rate_control = apn_rate_control;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_nvmWriteStatic
void CFW_nvmWriteStatic(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvmWriteStatic *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvmWriteStatic) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvmWriteStatic *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvmWriteStatic;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_nvGetCiotNonip
uint8_t CFW_nvGetCiotNonip(uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvGetCiotNonip *ipar;
    struct OPAR_CFW_nvGetCiotNonip *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvGetCiotNonip) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_nvGetCiotNonip) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvGetCiotNonip *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_nvGetCiotNonip *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvGetCiotNonip;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_nvGetCiotCpciot
uint8_t CFW_nvGetCiotCpciot(uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvGetCiotCpciot *ipar;
    struct OPAR_CFW_nvGetCiotCpciot *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvGetCiotCpciot) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_nvGetCiotCpciot) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvGetCiotCpciot *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_nvGetCiotCpciot *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvGetCiotCpciot;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_nvGetCiotUpciot
uint8_t CFW_nvGetCiotUpciot(uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvGetCiotUpciot *ipar;
    struct OPAR_CFW_nvGetCiotUpciot *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvGetCiotUpciot) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_nvGetCiotUpciot) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvGetCiotUpciot *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_nvGetCiotUpciot *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvGetCiotUpciot;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_nvGetCiotErwopdn
uint8_t CFW_nvGetCiotErwopdn(uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvGetCiotErwopdn *ipar;
    struct OPAR_CFW_nvGetCiotErwopdn *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvGetCiotErwopdn) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_nvGetCiotErwopdn) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvGetCiotErwopdn *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_nvGetCiotErwopdn *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvGetCiotErwopdn;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_nvGetCiotSmsWoCombAtt
uint8_t CFW_nvGetCiotSmsWoCombAtt(uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvGetCiotSmsWoCombAtt *ipar;
    struct OPAR_CFW_nvGetCiotSmsWoCombAtt *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvGetCiotSmsWoCombAtt) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_nvGetCiotSmsWoCombAtt) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvGetCiotSmsWoCombAtt *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_nvGetCiotSmsWoCombAtt *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvGetCiotSmsWoCombAtt;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_nvGetCiotApnRateCtrl
uint8_t CFW_nvGetCiotApnRateCtrl(uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvGetCiotApnRateCtrl *ipar;
    struct OPAR_CFW_nvGetCiotApnRateCtrl *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvGetCiotApnRateCtrl) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_nvGetCiotApnRateCtrl) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvGetCiotApnRateCtrl *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_nvGetCiotApnRateCtrl *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvGetCiotApnRateCtrl;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimReadFiles
uint32_t CFW_SimReadFiles(uint8_t * pSimFile, uint8_t nSimFile, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimReadFiles *ipar;
    struct OPAR_CFW_SimReadFiles *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nSimFile+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimReadFiles) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimReadFiles) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimReadFiles *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimReadFiles *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimReadFiles);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimReadFiles;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ivar_ptr, pSimFile, nSimFile);
    ivar_ptr[nSimFile] = (char)0;
    ivar_ptr += ALIGNUP8(nSimFile + 1);
    ipar->nSimFile = nSimFile;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimGetOperatorName
uint32_t CFW_SimGetOperatorName(uint8_t pOperatorId[6], uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimGetOperatorName *ipar;
    struct OPAR_CFW_SimGetOperatorName *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimGetOperatorName) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimGetOperatorName) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimGetOperatorName *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimGetOperatorName *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimGetOperatorName;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ipar->pOperatorId, pOperatorId, sizeof(ipar->pOperatorId));
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwSetLockBCCH
uint32_t CFW_NwSetLockBCCH(bool bLock, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwSetLockBCCH *ipar;
    struct OPAR_CFW_NwSetLockBCCH *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwSetLockBCCH) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwSetLockBCCH) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwSetLockBCCH *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwSetLockBCCH *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwSetLockBCCH;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->bLock = bLock;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwGetLockBCCH
bool CFW_NwGetLockBCCH(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_NwGetLockBCCH *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwGetLockBCCH) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_NwGetLockBCCH *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwGetLockBCCH;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatRefreshFileChange
uint32_t CFW_SatRefreshFileChange(CFW_SAT_REFRESH_FILE_CHG_REQ_T FileChangeReq, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatRefreshFileChange *ipar;
    struct OPAR_CFW_SatRefreshFileChange *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatRefreshFileChange) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatRefreshFileChange) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatRefreshFileChange *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatRefreshFileChange *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatRefreshFileChange;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->FileChangeReq = FileChangeReq;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatRefreshImsiChange
uint32_t CFW_SatRefreshImsiChange(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatRefreshImsiChange *ipar;
    struct OPAR_CFW_SatRefreshImsiChange *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatRefreshImsiChange) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatRefreshImsiChange) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatRefreshImsiChange *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatRefreshImsiChange *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatRefreshImsiChange;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SSCheckTestSim
uint32_t CFW_SSCheckTestSim(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SSCheckTestSim *ipar;
    struct OPAR_CFW_SSCheckTestSim *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SSCheckTestSim) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SSCheckTestSim) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SSCheckTestSim *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SSCheckTestSim *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SSCheckTestSim;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CcAcceptSpeechCallEx
uint32_t CFW_CcAcceptSpeechCallEx(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CcAcceptSpeechCallEx *ipar;
    struct OPAR_CFW_CcAcceptSpeechCallEx *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CcAcceptSpeechCallEx) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CcAcceptSpeechCallEx) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CcAcceptSpeechCallEx *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CcAcceptSpeechCallEx *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CcAcceptSpeechCallEx;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SmsMtSmsPPAckReq
uint32_t CFW_SmsMtSmsPPAckReq(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SmsMtSmsPPAckReq *ipar;
    struct OPAR_CFW_SmsMtSmsPPAckReq *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SmsMtSmsPPAckReq) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SmsMtSmsPPAckReq) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SmsMtSmsPPAckReq *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SmsMtSmsPPAckReq *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SmsMtSmsPPAckReq;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SmsMtSmsPPAckReqWithData
uint32_t CFW_SmsMtSmsPPAckReqWithData(uint8_t* data, uint16_t length, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SmsMtSmsPPAckReqWithData *ipar;
    struct OPAR_CFW_SmsMtSmsPPAckReqWithData *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(length+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SmsMtSmsPPAckReqWithData) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SmsMtSmsPPAckReqWithData) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SmsMtSmsPPAckReqWithData *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SmsMtSmsPPAckReqWithData *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SmsMtSmsPPAckReqWithData);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SmsMtSmsPPAckReqWithData;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ivar_ptr, data, length);
    ivar_ptr[length] = (char)0;
    ivar_ptr += ALIGNUP8(length + 1);
    ipar->length = length;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimReset
uint32_t CFW_SimReset(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimReset *ipar;
    struct OPAR_CFW_SimReset *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimReset) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimReset) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimReset *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimReset *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimReset;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimWakeup
uint32_t CFW_SimWakeup(uint16_t nUTI, CFW_SIM_ID nSimID, bool flag)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimWakeup *ipar;
    struct OPAR_CFW_SimWakeup *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimWakeup) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimWakeup) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimWakeup *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimWakeup *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimWakeup;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    ipar->flag = flag;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimCloseEx
uint32_t CFW_SimCloseEx(uint16_t nUTI, CFW_SIM_ID nSimID, bool flag)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimCloseEx *ipar;
    struct OPAR_CFW_SimCloseEx *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimCloseEx) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimCloseEx) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimCloseEx *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimCloseEx *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimCloseEx;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    ipar->flag = flag;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SmsMemoryFullReq
uint32_t CFW_SmsMemoryFullReq(uint8_t nCause, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SmsMemoryFullReq *ipar;
    struct OPAR_CFW_SmsMemoryFullReq *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SmsMemoryFullReq) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SmsMemoryFullReq) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SmsMemoryFullReq *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SmsMemoryFullReq *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SmsMemoryFullReq;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCause = nCause;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SmsMMAReq
uint32_t CFW_SmsMMAReq(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SmsMMAReq *ipar;
    struct OPAR_CFW_SmsMMAReq *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SmsMMAReq) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SmsMMAReq) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SmsMMAReq *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SmsMMAReq *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SmsMMAReq;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GprsSendDataAvaliable
bool CFW_GprsSendDataAvaliable(uint8_t nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsSendDataAvaliable *ipar;
    struct OPAR_CFW_GprsSendDataAvaliable *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsSendDataAvaliable) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsSendDataAvaliable) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsSendDataAvaliable *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsSendDataAvaliable *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsSendDataAvaliable;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwGetFTA
uint8_t CFW_NwGetFTA(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwGetFTA *ipar;
    struct OPAR_CFW_NwGetFTA *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwGetFTA) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwGetFTA) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwGetFTA *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwGetFTA *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwGetFTA;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwSetAutoAttachFlag
uint32_t CFW_NwSetAutoAttachFlag(uint8_t flag, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwSetAutoAttachFlag *ipar;
    struct OPAR_CFW_NwSetAutoAttachFlag *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwSetAutoAttachFlag) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwSetAutoAttachFlag) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwSetAutoAttachFlag *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwSetAutoAttachFlag *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwSetAutoAttachFlag;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->flag = flag;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwGetAutoAttachFlag
uint8_t CFW_NwGetAutoAttachFlag(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwGetAutoAttachFlag *ipar;
    struct OPAR_CFW_NwGetAutoAttachFlag *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwGetAutoAttachFlag) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwGetAutoAttachFlag) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwGetAutoAttachFlag *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwGetAutoAttachFlag *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwGetAutoAttachFlag;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetStatusInfo
void CFW_GetStatusInfo(CFW_TUE_STATUS_INFO *nStatusInfo, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetStatusInfo *ipar;
    struct OPAR_CFW_GetStatusInfo *opar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetStatusInfo) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetStatusInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetStatusInfo *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetStatusInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetStatusInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *nStatusInfo = opar->nStatusInfo;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_GetScanRssiInfo
bool CFW_GetScanRssiInfo(uint8_t band, uint8_t index, uint16_t *pFreqsNums, int16_t rssi[400], CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetScanRssiInfo *ipar;
    struct OPAR_CFW_GetScanRssiInfo *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetScanRssiInfo) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetScanRssiInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetScanRssiInfo *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetScanRssiInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetScanRssiInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->band = band;
    ipar->index = index;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pFreqsNums = opar->pFreqsNums;
    memcpy(rssi, opar->rssi, sizeof(opar->rssi));
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GprsSetInternalPdpCtx
uint32_t CFW_GprsSetInternalPdpCtx(CFW_INTERNAL_PDP_CTX_TYPE nType, const CFW_GPRS_PDPCONT_INFO_V2 *pPdpCont, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsSetInternalPdpCtx *ipar;
    struct OPAR_CFW_GprsSetInternalPdpCtx *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsSetInternalPdpCtx) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsSetInternalPdpCtx) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsSetInternalPdpCtx *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsSetInternalPdpCtx *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsSetInternalPdpCtx;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nType = nType;
    ipar->pPdpCont = *pPdpCont;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GprsGetInternalPdpCtx
CFW_GPRS_PDPCONT_INFO_V2* CFW_GprsGetInternalPdpCtx(CFW_INTERNAL_PDP_CTX_TYPE nType, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsGetInternalPdpCtx *ipar;
    struct OPAR_CFW_GprsGetInternalPdpCtx *opar;
    CFW_GPRS_PDPCONT_INFO_V2* result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsGetInternalPdpCtx) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsGetInternalPdpCtx) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsGetInternalPdpCtx *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsGetInternalPdpCtx *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsGetInternalPdpCtx;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nType = nType;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodImsNvParamSet
uint32_t CFW_EmodImsNvParamSet(uint16_t param_id, uint8_t * value_ptr, uint16_t value_len, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodImsNvParamSet *ipar;
    struct OPAR_CFW_EmodImsNvParamSet *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(value_len*sizeof(uint8_t)+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodImsNvParamSet) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodImsNvParamSet) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodImsNvParamSet *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EmodImsNvParamSet *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodImsNvParamSet);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodImsNvParamSet;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->param_id = param_id;
    memcpy(ivar_ptr, value_ptr, value_len*sizeof(uint8_t));
    ivar_ptr[value_len*sizeof(uint8_t)] = (char)0;
    ivar_ptr += ALIGNUP8(value_len*sizeof(uint8_t) + 1);
    ipar->value_len = value_len;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodImsNvParamGet
uint32_t CFW_EmodImsNvParamGet(uint16_t param_id, uint8_t value_ptr[256], CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodImsNvParamGet *ipar;
    struct OPAR_CFW_EmodImsNvParamGet *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodImsNvParamGet) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodImsNvParamGet) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodImsNvParamGet *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EmodImsNvParamGet *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodImsNvParamGet;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->param_id = param_id;
    memcpy(ipar->value_ptr, value_ptr, sizeof(ipar->value_ptr));
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(value_ptr, opar->value_ptr, sizeof(opar->value_ptr));
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_ImsSetUaVersionInfo
void CFW_ImsSetUaVersionInfo(int8_t * pVersionInfo, uint8_t nLen)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_ImsSetUaVersionInfo *ipar;
    char *ivar_ptr;


    ivar_size = ALIGNUP8(nLen+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_ImsSetUaVersionInfo) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_ImsSetUaVersionInfo *)((char *)mem + sizeof(rpcCallHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_ImsSetUaVersionInfo);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ImsSetUaVersionInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ivar_ptr, pVersionInfo, nLen);
    ivar_ptr[nLen] = (char)0;
    ivar_ptr += ALIGNUP8(nLen + 1);
    ipar->nLen = nLen;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_SaveSsimFileInfo
uint32_t CFW_SaveSsimFileInfo(CFW_SSIM_FILE_INFO_T ssim_file_info, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SaveSsimFileInfo *ipar;
    struct OPAR_CFW_SaveSsimFileInfo *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SaveSsimFileInfo) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SaveSsimFileInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SaveSsimFileInfo *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SaveSsimFileInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SaveSsimFileInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->ssim_file_info = ssim_file_info;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodResetImsDelta
uint32_t CFW_EmodResetImsDelta(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_EmodResetImsDelta *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodResetImsDelta) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_EmodResetImsDelta *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodResetImsDelta;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CcEmcDialEx_V2
uint32_t CFW_CcEmcDialEx_V2(uint8_t * pDialNumber, uint8_t nDialNumberSize, uint8_t *pIndex, CFW_CcEmergCateg emergCateg, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CcEmcDialEx_V2 *ipar;
    struct OPAR_CFW_CcEmcDialEx_V2 *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nDialNumberSize+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CcEmcDialEx_V2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CcEmcDialEx_V2) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CcEmcDialEx_V2 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CcEmcDialEx_V2 *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CcEmcDialEx_V2);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CcEmcDialEx_V2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ivar_ptr, pDialNumber, nDialNumberSize);
    ivar_ptr[nDialNumberSize] = (char)0;
    ivar_ptr += ALIGNUP8(nDialNumberSize + 1);
    ipar->nDialNumberSize = nDialNumberSize;
    ipar->emergCateg = emergCateg;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pIndex = opar->pIndex;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimDeleteMessage_V2
uint32_t CFW_SimDeleteMessage_V2(uint16_t nLocation, uint16_t nTotal, uint16_t nIndex, uint16_t nStatus, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimDeleteMessage_V2 *ipar;
    struct OPAR_CFW_SimDeleteMessage_V2 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimDeleteMessage_V2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimDeleteMessage_V2) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimDeleteMessage_V2 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimDeleteMessage_V2 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimDeleteMessage_V2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nLocation = nLocation;
    ipar->nTotal = nTotal;
    ipar->nIndex = nIndex;
    ipar->nStatus = nStatus;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GenerateSoftSimImsi
uint32_t CFW_GenerateSoftSimImsi(uint8_t nPlmn[7], uint8_t nImei[16], uint8_t nImsi[16], uint8_t nKey[33])
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GenerateSoftSimImsi *ipar;
    struct OPAR_CFW_GenerateSoftSimImsi *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GenerateSoftSimImsi) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GenerateSoftSimImsi) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GenerateSoftSimImsi *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GenerateSoftSimImsi *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GenerateSoftSimImsi;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ipar->nPlmn, nPlmn, sizeof(ipar->nPlmn));
    memcpy(ipar->nImei, nImei, sizeof(ipar->nImei));
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(nImsi, opar->nImsi, sizeof(opar->nImsi));
    memcpy(nKey, opar->nKey, sizeof(opar->nKey));
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetGcfTest
uint32_t CFW_SetGcfTest(CFW_SIM_ID nSimID, bool nFlag)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetGcfTest *ipar;
    struct OPAR_CFW_SetGcfTest *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetGcfTest) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetGcfTest) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetGcfTest *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetGcfTest *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetGcfTest;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    ipar->nFlag = nFlag;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SmsGetSmsType
uint8_t CFW_SmsGetSmsType(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SmsGetSmsType *ipar;
    struct OPAR_CFW_SmsGetSmsType *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SmsGetSmsType) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SmsGetSmsType) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SmsGetSmsType *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SmsGetSmsType *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SmsGetSmsType;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SwitchPort
uint32_t CFW_SwitchPort(uint8_t nFlag)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SwitchPort *ipar;
    struct OPAR_CFW_SwitchPort *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SwitchPort) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SwitchPort) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SwitchPort *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SwitchPort *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SwitchPort;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nFlag = nFlag;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimSelectApplication
uint32_t CFW_SimSelectApplication(uint8_t* aid, uint8_t length, uint8_t channel, uint16_t nUIT, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimSelectApplication *ipar;
    struct OPAR_CFW_SimSelectApplication *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(length+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimSelectApplication) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimSelectApplication) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimSelectApplication *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimSelectApplication *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimSelectApplication);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimSelectApplication;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ivar_ptr, aid, length);
    ivar_ptr[length] = (char)0;
    ivar_ptr += ALIGNUP8(length + 1);
    ipar->length = length;
    ipar->channel = channel;
    ipar->nUIT = nUIT;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimManageChannel
uint32_t CFW_SimManageChannel(uint8_t command, uint8_t channel, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimManageChannel *ipar;
    struct OPAR_CFW_SimManageChannel *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimManageChannel) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimManageChannel) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimManageChannel *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimManageChannel *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimManageChannel;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->command = command;
    ipar->channel = channel;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimTPDUCommand
uint32_t CFW_SimTPDUCommand(uint8_t* TPDU, uint16_t length, uint8_t channel, uint16_t nUIT, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimTPDUCommand *ipar;
    struct OPAR_CFW_SimTPDUCommand *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(length+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimTPDUCommand) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimTPDUCommand) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimTPDUCommand *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimTPDUCommand *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimTPDUCommand);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimTPDUCommand;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ivar_ptr, TPDU, length);
    ivar_ptr[length] = (char)0;
    ivar_ptr += ALIGNUP8(length + 1);
    ipar->length = length;
    ipar->channel = channel;
    ipar->nUIT = nUIT;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetRFTemperature
uint32_t CFW_GetRFTemperature(uint32_t *temp)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_GetRFTemperature *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetRFTemperature) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_GetRFTemperature *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetRFTemperature;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *temp = opar->temp;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetLTEFreqPwrRange
uint32_t CFW_SetLTEFreqPwrRange(uint16_t freqlow, uint16_t freqhigh, uint16_t power)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetLTEFreqPwrRange *ipar;
    struct OPAR_CFW_SetLTEFreqPwrRange *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetLTEFreqPwrRange) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetLTEFreqPwrRange) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetLTEFreqPwrRange *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetLTEFreqPwrRange *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetLTEFreqPwrRange;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->freqlow = freqlow;
    ipar->freqhigh = freqhigh;
    ipar->power = power;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetRFFreqPwrRange
uint32_t CFW_SetRFFreqPwrRange(uint16_t mode, uint16_t band, uint16_t powerlow, uint16_t powerhigh)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetRFFreqPwrRange *ipar;
    struct OPAR_CFW_SetRFFreqPwrRange *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetRFFreqPwrRange) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetRFFreqPwrRange) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetRFFreqPwrRange *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetRFFreqPwrRange *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetRFFreqPwrRange;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->mode = mode;
    ipar->band = band;
    ipar->powerlow = powerlow;
    ipar->powerhigh = powerhigh;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwSetBlackList
uint32_t CFW_NwSetBlackList(CFW_BlackCellList nBlackCellList, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwSetBlackList *ipar;
    struct OPAR_CFW_NwSetBlackList *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwSetBlackList) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwSetBlackList) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwSetBlackList *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwSetBlackList *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwSetBlackList;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nBlackCellList = nBlackCellList;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwSetBlackList_V2
uint32_t CFW_NwSetBlackList_V2(CFW_BlackCellList_V2 nBlackCellList, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwSetBlackList_V2 *ipar;
    struct OPAR_CFW_NwSetBlackList_V2 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwSetBlackList_V2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwSetBlackList_V2) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwSetBlackList_V2 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwSetBlackList_V2 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwSetBlackList_V2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nBlackCellList = nBlackCellList;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_nvGetBlackListEnable
uint32_t CFW_nvGetBlackListEnable(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvGetBlackListEnable *ipar;
    struct OPAR_CFW_nvGetBlackListEnable *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvGetBlackListEnable) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_nvGetBlackListEnable) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvGetBlackListEnable *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_nvGetBlackListEnable *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvGetBlackListEnable;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_nvSetBlackListEnable
uint8_t CFW_nvSetBlackListEnable(uint8_t BlacklistEnable, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvSetBlackListEnable *ipar;
    struct OPAR_CFW_nvSetBlackListEnable *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvSetBlackListEnable) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_nvSetBlackListEnable) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvSetBlackListEnable *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_nvSetBlackListEnable *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvSetBlackListEnable;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->BlacklistEnable = BlacklistEnable;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_SetPdnActTimerAndMaxCount
uint32_t CFW_SetPdnActTimerAndMaxCount(CFW_PDN_TIMER_MAXCOUNT_INFO pdnTimerAndMaxCount, uint8_t nRat, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetPdnActTimerAndMaxCount *ipar;
    struct OPAR_CFW_SetPdnActTimerAndMaxCount *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetPdnActTimerAndMaxCount) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetPdnActTimerAndMaxCount) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetPdnActTimerAndMaxCount *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetPdnActTimerAndMaxCount *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetPdnActTimerAndMaxCount;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pdnTimerAndMaxCount = pdnTimerAndMaxCount;
    ipar->nRat = nRat;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GetPdnActTimerAndMaxCount
uint32_t CFW_GetPdnActTimerAndMaxCount(CFW_PDN_TIMER_MAXCOUNT_INFO *pdnTimerAndMaxCount, uint8_t nRat, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetPdnActTimerAndMaxCount *ipar;
    struct OPAR_CFW_GetPdnActTimerAndMaxCount *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetPdnActTimerAndMaxCount) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetPdnActTimerAndMaxCount) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetPdnActTimerAndMaxCount *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetPdnActTimerAndMaxCount *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetPdnActTimerAndMaxCount;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nRat = nRat;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pdnTimerAndMaxCount = opar->pdnTimerAndMaxCount;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_SetPdnDeactTimerAndMaxCount
uint32_t CFW_SetPdnDeactTimerAndMaxCount(CFW_PDN_TIMER_MAXCOUNT_INFO pdnTimerAndMaxCount, uint8_t nRat, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetPdnDeactTimerAndMaxCount *ipar;
    struct OPAR_CFW_SetPdnDeactTimerAndMaxCount *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetPdnDeactTimerAndMaxCount) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetPdnDeactTimerAndMaxCount) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetPdnDeactTimerAndMaxCount *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetPdnDeactTimerAndMaxCount *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetPdnDeactTimerAndMaxCount;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pdnTimerAndMaxCount = pdnTimerAndMaxCount;
    ipar->nRat = nRat;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CFW_GPRS_SUPPORT)
#ifndef DISABLE_RPC_CFW_GetPdnDeactTimerAndMaxCount
uint32_t CFW_GetPdnDeactTimerAndMaxCount(CFW_PDN_TIMER_MAXCOUNT_INFO *pdnTimerAndMaxCount, uint8_t nRat, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetPdnDeactTimerAndMaxCount *ipar;
    struct OPAR_CFW_GetPdnDeactTimerAndMaxCount *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetPdnDeactTimerAndMaxCount) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetPdnDeactTimerAndMaxCount) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetPdnDeactTimerAndMaxCount *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetPdnDeactTimerAndMaxCount *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetPdnDeactTimerAndMaxCount;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nRat = nRat;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pdnTimerAndMaxCount = opar->pdnTimerAndMaxCount;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#ifndef DISABLE_RPC_CFW_SetCSPagingFlag
uint32_t CFW_SetCSPagingFlag(bool nFlag, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetCSPagingFlag *ipar;
    struct OPAR_CFW_SetCSPagingFlag *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetCSPagingFlag) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetCSPagingFlag) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetCSPagingFlag *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetCSPagingFlag *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetCSPagingFlag;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nFlag = nFlag;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetCSPagingFlag
uint32_t CFW_GetCSPagingFlag(uint8_t *nFlag, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetCSPagingFlag *ipar;
    struct OPAR_CFW_GetCSPagingFlag *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetCSPagingFlag) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetCSPagingFlag) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetCSPagingFlag *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetCSPagingFlag *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetCSPagingFlag;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *nFlag = opar->nFlag;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetSimFileUpdateCountMode
uint32_t CFW_SetSimFileUpdateCountMode(uint8_t op_mode, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetSimFileUpdateCountMode *ipar;
    struct OPAR_CFW_SetSimFileUpdateCountMode *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetSimFileUpdateCountMode) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetSimFileUpdateCountMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetSimFileUpdateCountMode *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetSimFileUpdateCountMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetSimFileUpdateCountMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->op_mode = op_mode;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetSimFileUpdateCount
uint16_t CFW_GetSimFileUpdateCount(uint8_t nFileID, uint8_t bReal, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetSimFileUpdateCount *ipar;
    struct OPAR_CFW_GetSimFileUpdateCount *opar;
    uint16_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetSimFileUpdateCount) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetSimFileUpdateCount) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetSimFileUpdateCount *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetSimFileUpdateCount *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetSimFileUpdateCount;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nFileID = nFileID;
    ipar->bReal = bReal;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GprsSendCtxCfg_V2
uint32_t CFW_GprsSendCtxCfg_V2(CFW_GPRS_DFTPDN_INFO *pDftPdn, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsSendCtxCfg_V2 *ipar;
    struct OPAR_CFW_GprsSendCtxCfg_V2 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsSendCtxCfg_V2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsSendCtxCfg_V2) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsSendCtxCfg_V2 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsSendCtxCfg_V2 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsSendCtxCfg_V2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pDftPdn = *pDftPdn;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetAoHandle
uint32_t CFW_GetAoHandle(uint8_t nIndex, uint32_t nState, uint32_t nServiceId, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetAoHandle *ipar;
    struct OPAR_CFW_GetAoHandle *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetAoHandle) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetAoHandle) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetAoHandle *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetAoHandle *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetAoHandle;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nIndex = nIndex;
    ipar->nState = nState;
    ipar->nServiceId = nServiceId;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SendMtSmsAckPPError
uint32_t CFW_SendMtSmsAckPPError(uint8_t nCause, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SendMtSmsAckPPError *ipar;
    struct OPAR_CFW_SendMtSmsAckPPError *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SendMtSmsAckPPError) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SendMtSmsAckPPError) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SendMtSmsAckPPError *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SendMtSmsAckPPError *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SendMtSmsAckPPError;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCause = nCause;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetNewSmsOptionMT
uint32_t CFW_CfgSetNewSmsOptionMT(uint8_t nOption, uint8_t nNewSmsStorage, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetNewSmsOptionMT *ipar;
    struct OPAR_CFW_CfgSetNewSmsOptionMT *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetNewSmsOptionMT) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetNewSmsOptionMT) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetNewSmsOptionMT *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetNewSmsOptionMT *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetNewSmsOptionMT;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nOption = nOption;
    ipar->nNewSmsStorage = nNewSmsStorage;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetNewSmsOptionMT
uint32_t CFW_CfgGetNewSmsOptionMT(uint8_t *nOption, uint8_t *nNewSmsStorage, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgGetNewSmsOptionMT *ipar;
    struct OPAR_CFW_CfgGetNewSmsOptionMT *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgGetNewSmsOptionMT) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetNewSmsOptionMT) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgGetNewSmsOptionMT *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgGetNewSmsOptionMT *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetNewSmsOptionMT;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *nOption = opar->nOption;
    *nNewSmsStorage = opar->nNewSmsStorage;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_StartNstMode
int32_t CFW_StartNstMode(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_StartNstMode *ipar;
    struct OPAR_CFW_StartNstMode *opar;
    int32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_StartNstMode) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_StartNstMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_StartNstMode *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_StartNstMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_StartNstMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_StopNstMode
int32_t CFW_StopNstMode(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_StopNstMode *ipar;
    struct OPAR_CFW_StopNstMode *opar;
    int32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_StopNstMode) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_StopNstMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_StopNstMode *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_StopNstMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_StopNstMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NstConfig
int32_t CFW_NstConfig(CFW_NW_NST_TX_PARA_CONFIG *nst_para_config, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NstConfig *ipar;
    struct OPAR_CFW_NstConfig *opar;
    int32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NstConfig) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NstConfig) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NstConfig *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NstConfig *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NstConfig;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nst_para_config = *nst_para_config;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NstGetrssi
int32_t CFW_NstGetrssi(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_NstGetrssi *opar;
    int32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NstGetrssi) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_NstGetrssi *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NstGetrssi;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetStaticScene
uint32_t CFW_SetStaticScene(uint8_t iScene, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetStaticScene *ipar;
    struct OPAR_CFW_SetStaticScene *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetStaticScene) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetStaticScene) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetStaticScene *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetStaticScene *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetStaticScene;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->iScene = iScene;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetStaticScene
uint32_t CFW_GetStaticScene(uint8_t *iScene, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetStaticScene *ipar;
    struct OPAR_CFW_GetStaticScene *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetStaticScene) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetStaticScene) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetStaticScene *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetStaticScene *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetStaticScene;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *iScene = opar->iScene;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetRatePriority
uint32_t CFW_SetRatePriority(uint8_t iPriority, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetRatePriority *ipar;
    struct OPAR_CFW_SetRatePriority *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetRatePriority) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetRatePriority) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetRatePriority *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetRatePriority *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetRatePriority;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->iPriority = iPriority;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetRatePriority
uint32_t CFW_GetRatePriority(uint8_t *iPriority, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetRatePriority *ipar;
    struct OPAR_CFW_GetRatePriority *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetRatePriority) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetRatePriority) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetRatePriority *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetRatePriority *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetRatePriority;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *iPriority = opar->iPriority;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GprsGetDynamicAPN
uint32_t CFW_GprsGetDynamicAPN(uint8_t nCid, CFW_GPRS_DYNAMIC_APN_INFO *pPdpCont, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsGetDynamicAPN *ipar;
    struct OPAR_CFW_GprsGetDynamicAPN *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsGetDynamicAPN) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsGetDynamicAPN) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsGetDynamicAPN *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsGetDynamicAPN *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsGetDynamicAPN;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCid = nCid;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pPdpCont = opar->pPdpCont;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GprsGetDynamicIP
uint32_t CFW_GprsGetDynamicIP(uint8_t nCid, CFW_GPRS_DYNAMIC_IP_INFO *pDyncIP, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsGetDynamicIP *ipar;
    struct OPAR_CFW_GprsGetDynamicIP *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsGetDynamicIP) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsGetDynamicIP) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsGetDynamicIP *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsGetDynamicIP *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsGetDynamicIP;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCid = nCid;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pDyncIP = opar->pDyncIP;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetT3302
uint32_t CFW_SetT3302(uint32_t value, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetT3302 *ipar;
    struct OPAR_CFW_SetT3302 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetT3302) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetT3302) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetT3302 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetT3302 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetT3302;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->value = value;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetT3302
uint32_t CFW_GetT3302(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetT3302 *ipar;
    struct OPAR_CFW_GetT3302 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetT3302) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetT3302) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetT3302 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetT3302 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetT3302;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetRRCRel
uint32_t CFW_SetRRCRel(uint32_t value, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetRRCRel *ipar;
    struct OPAR_CFW_SetRRCRel *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetRRCRel) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetRRCRel) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetRRCRel *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetRRCRel *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetRRCRel;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->value = value;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetRRCRel
uint32_t CFW_GetRRCRel(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetRRCRel *ipar;
    struct OPAR_CFW_GetRRCRel *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetRRCRel) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetRRCRel) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetRRCRel *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetRRCRel *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetRRCRel;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetRRCRelEx
uint32_t CFW_SetRRCRelEx(uint32_t value, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetRRCRelEx *ipar;
    struct OPAR_CFW_SetRRCRelEx *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetRRCRelEx) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetRRCRelEx) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetRRCRelEx *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetRRCRelEx *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetRRCRelEx;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->value = value;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = 0xffffffff;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetRRCRelEx
uint32_t CFW_GetRRCRelEx(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetRRCRelEx *ipar;
    struct OPAR_CFW_GetRRCRelEx *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetRRCRelEx) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetRRCRelEx) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetRRCRelEx *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetRRCRelEx *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetRRCRelEx;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = 0xffffffff;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetDrxCyc
uint16_t CFW_GetDrxCyc(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetDrxCyc *ipar;
    struct OPAR_CFW_GetDrxCyc *opar;
    uint16_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetDrxCyc) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetDrxCyc) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetDrxCyc *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetDrxCyc *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetDrxCyc;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CSW_SetAndGetMicGain
uint32_t CSW_SetAndGetMicGain(uint8_t *resultcode, uint8_t *hasMsg, uint8_t resultMsg[16], uint8_t mode, uint8_t nPath, uint8_t nCtrl, uint8_t * nParam, uint16_t nParamLength)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CSW_SetAndGetMicGain *ipar;
    struct OPAR_CSW_SetAndGetMicGain *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nParamLength+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CSW_SetAndGetMicGain) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CSW_SetAndGetMicGain) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CSW_SetAndGetMicGain *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CSW_SetAndGetMicGain *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CSW_SetAndGetMicGain);
    call->h.size = call_size;
    call->api_tag = TAG_CSW_SetAndGetMicGain;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->mode = mode;
    ipar->nPath = nPath;
    ipar->nCtrl = nCtrl;
    memcpy(ivar_ptr, nParam, nParamLength);
    ivar_ptr[nParamLength] = (char)0;
    ivar_ptr += ALIGNUP8(nParamLength + 1);
    ipar->nParamLength = nParamLength;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *resultcode = opar->resultcode;
    *hasMsg = opar->hasMsg;
    memcpy(resultMsg, opar->resultMsg, sizeof(opar->resultMsg));
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimGetMeProfile
uint32_t CFW_SimGetMeProfile(CFW_PROFILE *pMeProfile, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimGetMeProfile *ipar;
    struct OPAR_CFW_SimGetMeProfile *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimGetMeProfile) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimGetMeProfile) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimGetMeProfile *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimGetMeProfile *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimGetMeProfile;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pMeProfile = opar->pMeProfile;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_SimSelectApplicationReqV2
uint32_t SimSelectApplicationReqV2(uint8_t * AID, uint8_t AIDLength, uint8_t ChannelID, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_SimSelectApplicationReqV2 *ipar;
    struct OPAR_SimSelectApplicationReqV2 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_SimSelectApplicationReqV2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_SimSelectApplicationReqV2) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_SimSelectApplicationReqV2 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_SimSelectApplicationReqV2 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_SimSelectApplicationReqV2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->AID = AID;
    ipar->AIDLength = AIDLength;
    ipar->ChannelID = ChannelID;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_SimSelectApplicationReq
uint32_t SimSelectApplicationReq(uint8_t * AID, uint8_t AIDLength, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_SimSelectApplicationReq *ipar;
    struct OPAR_SimSelectApplicationReq *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_SimSelectApplicationReq) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_SimSelectApplicationReq) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_SimSelectApplicationReq *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_SimSelectApplicationReq *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_SimSelectApplicationReq;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->AID = AID;
    ipar->AIDLength = AIDLength;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_InvalideTmsiPTmis
void CFW_InvalideTmsiPTmis(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_InvalideTmsiPTmis *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_InvalideTmsiPTmis) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_InvalideTmsiPTmis *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_InvalideTmsiPTmis;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_SimInitStage1
uint32_t CFW_SimInitStage1(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimInitStage1 *ipar;
    struct OPAR_CFW_SimInitStage1 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimInitStage1) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimInitStage1) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimInitStage1 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimInitStage1 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimInitStage1;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimInitStage3
uint32_t CFW_SimInitStage3(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimInitStage3 *ipar;
    struct OPAR_CFW_SimInitStage3 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimInitStage3) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimInitStage3) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimInitStage3 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimInitStage3 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimInitStage3;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_SimPollReq
uint32_t SimPollReq(uint8_t nTimerOut, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_SimPollReq *ipar;
    struct OPAR_SimPollReq *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_SimPollReq) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_SimPollReq) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_SimPollReq *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_SimPollReq *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_SimPollReq;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nTimerOut = nTimerOut;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_SimPollOffReq
uint32_t SimPollOffReq(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_SimPollOffReq *ipar;
    struct OPAR_SimPollOffReq *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_SimPollOffReq) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_SimPollOffReq) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_SimPollOffReq *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_SimPollOffReq *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_SimPollOffReq;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetUsimAID
void CFW_GetUsimAID(uint8_t aid[20], uint8_t length[1], CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetUsimAID *ipar;
    struct OPAR_CFW_GetUsimAID *opar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetUsimAID) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetUsimAID) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetUsimAID *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetUsimAID *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetUsimAID;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ipar->length, length, sizeof(ipar->length));
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(aid, opar->aid, sizeof(opar->aid));
    memcpy(length, opar->length, sizeof(opar->length));
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_SatGetCurrentCmd
bool CFW_SatGetCurrentCmd(uint8_t *nCmd, uint8_t *nQualifier, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetCurrentCmd *ipar;
    struct OPAR_CFW_SatGetCurrentCmd *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetCurrentCmd) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetCurrentCmd) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetCurrentCmd *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetCurrentCmd *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetCurrentCmd;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *nCmd = opar->nCmd;
    *nQualifier = opar->nQualifier;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetSetupEventList
uint8_t CFW_SatGetSetupEventList(uint8_t pEventList[32], uint8_t pNum[1], CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetSetupEventList *ipar;
    struct OPAR_CFW_SatGetSetupEventList *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetSetupEventList) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetSetupEventList) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetSetupEventList *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetSetupEventList *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetSetupEventList;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ipar->pNum, pNum, sizeof(ipar->pNum));
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(pEventList, opar->pEventList, sizeof(opar->pEventList));
    memcpy(pNum, opar->pNum, sizeof(opar->pNum));
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatSetEventList
void CFW_SatSetEventList(uint32_t event_list, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatSetEventList *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatSetEventList) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatSetEventList *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatSetEventList;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->event_list = event_list;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_SatGetEventList
uint32_t CFW_SatGetEventList(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetEventList *ipar;
    struct OPAR_CFW_SatGetEventList *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetEventList) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetEventList) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetEventList *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetEventList *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetEventList;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetSendSmsData
bool CFW_SatGetSendSmsData(uint8_t pPduData[255], uint8_t pDataLen[1], CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetSendSmsData *ipar;
    struct OPAR_CFW_SatGetSendSmsData *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetSendSmsData) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetSendSmsData) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetSendSmsData *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetSendSmsData *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetSendSmsData;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ipar->pDataLen, pDataLen, sizeof(ipar->pDataLen));
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(pPduData, opar->pPduData, sizeof(opar->pPduData));
    memcpy(pDataLen, opar->pDataLen, sizeof(opar->pDataLen));
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetSendSmsSCInfo
bool CFW_SatGetSendSmsSCInfo(uint8_t pSCAddress[32], uint8_t pSCLen[1], uint8_t pType[1], CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetSendSmsSCInfo *ipar;
    struct OPAR_CFW_SatGetSendSmsSCInfo *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetSendSmsSCInfo) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetSendSmsSCInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetSendSmsSCInfo *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetSendSmsSCInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetSendSmsSCInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ipar->pSCLen, pSCLen, sizeof(ipar->pSCLen));
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(pSCAddress, opar->pSCAddress, sizeof(opar->pSCAddress));
    memcpy(pSCLen, opar->pSCLen, sizeof(opar->pSCLen));
    memcpy(pType, opar->pType, sizeof(opar->pType));
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetRefreshFilesList
bool CFW_SatGetRefreshFilesList(uint8_t pFilesList[32], uint8_t pFileNum[1], CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetRefreshFilesList *ipar;
    struct OPAR_CFW_SatGetRefreshFilesList *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetRefreshFilesList) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetRefreshFilesList) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetRefreshFilesList *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetRefreshFilesList *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetRefreshFilesList;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ipar->pFileNum, pFileNum, sizeof(ipar->pFileNum));
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(pFilesList, opar->pFilesList, sizeof(opar->pFilesList));
    memcpy(pFileNum, opar->pFileNum, sizeof(opar->pFileNum));
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetSATIndFormate
bool CFW_GetSATIndFormate(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_GetSATIndFormate *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetSATIndFormate) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_GetSATIndFormate *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetSATIndFormate;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimRefreshFiles
uint32_t CFW_SimRefreshFiles(uint8_t pFiles[32], uint8_t nFileNum, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimRefreshFiles *ipar;
    struct OPAR_CFW_SimRefreshFiles *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimRefreshFiles) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimRefreshFiles) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimRefreshFiles *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimRefreshFiles *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimRefreshFiles;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ipar->pFiles, pFiles, sizeof(ipar->pFiles));
    ipar->nFileNum = nFileNum;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimGetLanguage
bool CFW_SimGetLanguage(uint8_t pLanguage[8], uint8_t *pNum, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimGetLanguage *ipar;
    struct OPAR_CFW_SimGetLanguage *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimGetLanguage) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimGetLanguage) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimGetLanguage *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimGetLanguage *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimGetLanguage;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pNum = *pNum;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(pLanguage, opar->pLanguage, sizeof(opar->pLanguage));
    *pNum = opar->pNum;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetSetupIdleModeText
bool CFW_SatGetSetupIdleModeText(uint8_t pText[64], uint8_t *pLength, uint8_t *pScheme, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetSetupIdleModeText *ipar;
    struct OPAR_CFW_SatGetSetupIdleModeText *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetSetupIdleModeText) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetSetupIdleModeText) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetSetupIdleModeText *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetSetupIdleModeText *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetSetupIdleModeText;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pLength = *pLength;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(pText, opar->pText, sizeof(opar->pText));
    *pLength = opar->pLength;
    *pScheme = opar->pScheme;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetPlayToneText
bool CFW_SatGetPlayToneText(uint8_t pText[64], uint8_t *pLength, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetPlayToneText *ipar;
    struct OPAR_CFW_SatGetPlayToneText *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetPlayToneText) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetPlayToneText) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetPlayToneText *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetPlayToneText *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetPlayToneText;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pLength = *pLength;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(pText, opar->pText, sizeof(opar->pText));
    *pLength = opar->pLength;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetPlayToneDuration
bool CFW_SatGetPlayToneDuration(uint8_t *pTone, uint8_t *pUnit, uint8_t *pInterval, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetPlayToneDuration *ipar;
    struct OPAR_CFW_SatGetPlayToneDuration *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetPlayToneDuration) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetPlayToneDuration) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetPlayToneDuration *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetPlayToneDuration *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetPlayToneDuration;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pTone = opar->pTone;
    *pUnit = opar->pUnit;
    *pInterval = opar->pInterval;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetPollIntervalDuration
bool CFW_SatGetPollIntervalDuration(uint8_t *pUnit, uint8_t *pInterval, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetPollIntervalDuration *ipar;
    struct OPAR_CFW_SatGetPollIntervalDuration *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetPollIntervalDuration) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetPollIntervalDuration) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetPollIntervalDuration *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetPollIntervalDuration *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetPollIntervalDuration;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pUnit = opar->pUnit;
    *pInterval = opar->pInterval;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetTimerManagement
bool CFW_SatGetTimerManagement(uint8_t *pTimerID, uint8_t *pHour, uint8_t *pMinute, uint8_t *pSecond, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetTimerManagement *ipar;
    struct OPAR_CFW_SatGetTimerManagement *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetTimerManagement) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetTimerManagement) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetTimerManagement *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetTimerManagement *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetTimerManagement;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pTimerID = opar->pTimerID;
    *pHour = opar->pHour;
    *pMinute = opar->pMinute;
    *pSecond = opar->pSecond;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetReceiveData
bool CFW_SatGetReceiveData(uint8_t *pChannelDataLength, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetReceiveData *ipar;
    struct OPAR_CFW_SatGetReceiveData *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetReceiveData) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetReceiveData) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetReceiveData *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetReceiveData *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetReceiveData;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pChannelDataLength = opar->pChannelDataLength;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetSendData
bool CFW_SatGetSendData(uint8_t pData[255], uint8_t *pDataLength, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetSendData *ipar;
    struct OPAR_CFW_SatGetSendData *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetSendData) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetSendData) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetSendData *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetSendData *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetSendData;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pDataLength = *pDataLength;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(pData, opar->pData, sizeof(opar->pData));
    *pDataLength = opar->pDataLength;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetOpenChannelUserInfo
bool CFW_SatGetOpenChannelUserInfo(uint8_t pUser[50], uint8_t *pUserLen, uint8_t pPasswd[32], uint8_t *pPasswdLen, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetOpenChannelUserInfo *ipar;
    struct OPAR_CFW_SatGetOpenChannelUserInfo *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetOpenChannelUserInfo) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetOpenChannelUserInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetOpenChannelUserInfo *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetOpenChannelUserInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetOpenChannelUserInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pUserLen = *pUserLen;
    ipar->pPasswdLen = *pPasswdLen;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(pUser, opar->pUser, sizeof(opar->pUser));
    *pUserLen = opar->pUserLen;
    memcpy(pPasswd, opar->pPasswd, sizeof(opar->pPasswd));
    *pPasswdLen = opar->pPasswdLen;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetOpenChannelAPN
bool CFW_SatGetOpenChannelAPN(uint8_t pAPN[50], uint8_t *pApnLen, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetOpenChannelAPN *ipar;
    struct OPAR_CFW_SatGetOpenChannelAPN *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetOpenChannelAPN) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetOpenChannelAPN) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetOpenChannelAPN *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetOpenChannelAPN *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetOpenChannelAPN;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pApnLen = *pApnLen;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(pAPN, opar->pAPN, sizeof(opar->pAPN));
    *pApnLen = opar->pApnLen;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetOpenChannelDestAddress
bool CFW_SatGetOpenChannelDestAddress(uint8_t pAddress[16], uint8_t *pAddressLen, uint8_t *pAddressType, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetOpenChannelDestAddress *ipar;
    struct OPAR_CFW_SatGetOpenChannelDestAddress *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetOpenChannelDestAddress) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetOpenChannelDestAddress) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetOpenChannelDestAddress *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetOpenChannelDestAddress *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetOpenChannelDestAddress;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pAddressLen = *pAddressLen;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(pAddress, opar->pAddress, sizeof(opar->pAddress));
    *pAddressLen = opar->pAddressLen;
    *pAddressType = opar->pAddressType;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetOpenChannelNetInfoV2
bool CFW_SatGetOpenChannelNetInfoV2(uint16_t *pBufferSize, uint8_t *pBearerType, uint8_t *pTranType, uint16_t *pTranPort, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetOpenChannelNetInfoV2 *ipar;
    struct OPAR_CFW_SatGetOpenChannelNetInfoV2 *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetOpenChannelNetInfoV2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetOpenChannelNetInfoV2) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetOpenChannelNetInfoV2 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetOpenChannelNetInfoV2 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetOpenChannelNetInfoV2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pBufferSize = opar->pBufferSize;
    *pBearerType = opar->pBearerType;
    *pTranType = opar->pTranType;
    *pTranPort = opar->pTranPort;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = false;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetOpenChannelNetInfo
bool CFW_SatGetOpenChannelNetInfo(uint8_t *pBufferSize, uint8_t *pBearerType, uint8_t *pTranType, uint8_t *pTranPort, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetOpenChannelNetInfo *ipar;
    struct OPAR_CFW_SatGetOpenChannelNetInfo *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetOpenChannelNetInfo) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetOpenChannelNetInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetOpenChannelNetInfo *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetOpenChannelNetInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetOpenChannelNetInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pBufferSize = opar->pBufferSize;
    *pBearerType = opar->pBearerType;
    *pTranType = opar->pTranType;
    *pTranPort = opar->pTranPort;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetEleFence
uint32_t CFW_GetEleFence(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetEleFence *ipar;
    struct OPAR_CFW_GetEleFence *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetEleFence) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetEleFence) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetEleFence *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetEleFence *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetEleFence;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetEleFence
uint32_t CFW_SetEleFence(uint8_t value, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetEleFence *ipar;
    struct OPAR_CFW_SetEleFence *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetEleFence) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetEleFence) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetEleFence *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetEleFence *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetEleFence;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->value = value;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetEleFenceTimer
uint32_t CFW_GetEleFenceTimer(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetEleFenceTimer *ipar;
    struct OPAR_CFW_GetEleFenceTimer *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetEleFenceTimer) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetEleFenceTimer) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetEleFenceTimer *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetEleFenceTimer *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetEleFenceTimer;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetEleFenceTimer
uint32_t CFW_SetEleFenceTimer(uint8_t value, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetEleFenceTimer *ipar;
    struct OPAR_CFW_SetEleFenceTimer *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetEleFenceTimer) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetEleFenceTimer) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetEleFenceTimer *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetEleFenceTimer *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetEleFenceTimer;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->value = value;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimGetEID
uint32_t CFW_SimGetEID(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimGetEID *ipar;
    struct OPAR_CFW_SimGetEID *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimGetEID) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimGetEID) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimGetEID *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimGetEID *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimGetEID;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SendMtSmsAckPPErrorWithData
uint32_t CFW_SendMtSmsAckPPErrorWithData(uint8_t nCause, uint8_t* data, uint16_t length, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SendMtSmsAckPPErrorWithData *ipar;
    struct OPAR_CFW_SendMtSmsAckPPErrorWithData *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(length+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SendMtSmsAckPPErrorWithData) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SendMtSmsAckPPErrorWithData) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SendMtSmsAckPPErrorWithData *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SendMtSmsAckPPErrorWithData *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SendMtSmsAckPPErrorWithData);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SendMtSmsAckPPErrorWithData;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCause = nCause;
    memcpy(ivar_ptr, data, length);
    ivar_ptr[length] = (char)0;
    ivar_ptr += ALIGNUP8(length + 1);
    ipar->length = length;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GprsHostAddress
uint32_t CFW_GprsHostAddress(uint8_t pIPAddress[21], uint8_t *nLength, uint8_t *nIPType, uint8_t nCid, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GprsHostAddress *ipar;
    struct OPAR_CFW_GprsHostAddress *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GprsHostAddress) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GprsHostAddress) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GprsHostAddress *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GprsHostAddress *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GprsHostAddress;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nLength = *nLength;
    ipar->nIPType = *nIPType;
    ipar->nCid = nCid;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(pIPAddress, opar->pIPAddress, sizeof(opar->pIPAddress));
    *nLength = opar->nLength;
    *nIPType = opar->nIPType;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_SimSendStatusReq
uint32_t SimSendStatusReq(uint8_t nMode, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_SimSendStatusReq *ipar;
    struct OPAR_SimSendStatusReq *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_SimSendStatusReq) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_SimSendStatusReq) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_SimSendStatusReq *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_SimSendStatusReq *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_SimSendStatusReq;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nMode = nMode;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_Cfw_SetTimezone
bool Cfw_SetTimezone(int8_t timezone)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_Cfw_SetTimezone *ipar;
    struct OPAR_Cfw_SetTimezone *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_Cfw_SetTimezone) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_Cfw_SetTimezone) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_Cfw_SetTimezone *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_Cfw_SetTimezone *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_Cfw_SetTimezone;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->timezone = timezone;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CcGetMptyNum
uint32_t CFW_CcGetMptyNum(uint8_t *pMptyCnt, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CcGetMptyNum *ipar;
    struct OPAR_CFW_CcGetMptyNum *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CcGetMptyNum) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CcGetMptyNum) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CcGetMptyNum *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CcGetMptyNum *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CcGetMptyNum;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pMptyCnt = opar->pMptyCnt;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CcExtConfCallDial
uint32_t CFW_CcExtConfCallDial(CFW_DIAL_EXT_CONF_CT *pExtConfCxt, uint8_t *pIndex, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CcExtConfCallDial *ipar;
    struct OPAR_CFW_CcExtConfCallDial *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CcExtConfCallDial) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CcExtConfCallDial) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CcExtConfCallDial *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CcExtConfCallDial *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CcExtConfCallDial;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pExtConfCxt = *pExtConfCxt;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pIndex = opar->pIndex;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CcExtConfCallAdd
uint32_t CFW_CcExtConfCallAdd(CFW_DIAL_EXT_CONF_CT *pExtConfCxt, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CcExtConfCallAdd *ipar;
    struct OPAR_CFW_CcExtConfCallAdd *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CcExtConfCallAdd) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CcExtConfCallAdd) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CcExtConfCallAdd *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CcExtConfCallAdd *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CcExtConfCallAdd;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pExtConfCxt = *pExtConfCxt;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwSetBlackListTimer
uint32_t CFW_NwSetBlackListTimer(CFW_BlackListCntReq nBlackListCnt, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwSetBlackListTimer *ipar;
    struct OPAR_CFW_NwSetBlackListTimer *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwSetBlackListTimer) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwSetBlackListTimer) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwSetBlackListTimer *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwSetBlackListTimer *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwSetBlackListTimer;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nBlackListCnt = nBlackListCnt;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetPlmn
uint32_t CFW_SetPlmn(CFW_NV_PLMN nNvPlmn, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetPlmn *ipar;
    struct OPAR_CFW_SetPlmn *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetPlmn) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetPlmn) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetPlmn *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetPlmn *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetPlmn;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nNvPlmn = nNvPlmn;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetPlmn
uint32_t CFW_GetPlmn(CFW_NV_PLMN *nNvPlmn, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetPlmn *ipar;
    struct OPAR_CFW_GetPlmn *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetPlmn) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetPlmn) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetPlmn *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetPlmn *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetPlmn;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *nNvPlmn = opar->nNvPlmn;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SmsListFree
uint32_t CFW_SmsListFree(void * pListResult, uint8_t nCount, uint8_t nIndex, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SmsListFree *ipar;
    struct OPAR_CFW_SmsListFree *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SmsListFree) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SmsListFree) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SmsListFree *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SmsListFree *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SmsListFree;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pListResult = pListResult;
    ipar->nCount = nCount;
    ipar->nIndex = nIndex;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetPocEnable
uint32_t CFW_CfgSetPocEnable(uint8_t bEnable)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetPocEnable *ipar;
    struct OPAR_CFW_CfgSetPocEnable *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetPocEnable) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetPocEnable) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetPocEnable *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetPocEnable *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetPocEnable;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->bEnable = bEnable;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetPocEnable
uint8_t CFW_CfgGetPocEnable(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_CfgGetPocEnable *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetPocEnable) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_CfgGetPocEnable *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetPocEnable;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = 0;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetEnhancePwrSweepNonCE
uint32_t CFW_CfgSetEnhancePwrSweepNonCE(uint8_t bEnable, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetEnhancePwrSweepNonCE *ipar;
    struct OPAR_CFW_CfgSetEnhancePwrSweepNonCE *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetEnhancePwrSweepNonCE) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetEnhancePwrSweepNonCE) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetEnhancePwrSweepNonCE *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetEnhancePwrSweepNonCE *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetEnhancePwrSweepNonCE;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->bEnable = bEnable;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetEnhancePwrSweepNonCE
uint8_t CFW_CfgGetEnhancePwrSweepNonCE(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgGetEnhancePwrSweepNonCE *ipar;
    struct OPAR_CFW_CfgGetEnhancePwrSweepNonCE *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgGetEnhancePwrSweepNonCE) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetEnhancePwrSweepNonCE) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgGetEnhancePwrSweepNonCE *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgGetEnhancePwrSweepNonCE *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetEnhancePwrSweepNonCE;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = 0;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwSetSimSwich
uint32_t CFW_NwSetSimSwich(uint8_t bOnGoing)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwSetSimSwich *ipar;
    struct OPAR_CFW_NwSetSimSwich *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwSetSimSwich) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwSetSimSwich) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwSetSimSwich *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwSetSimSwich *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwSetSimSwich;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->bOnGoing = bOnGoing;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwGetSimSwitch
uint8_t CFW_NwGetSimSwitch(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_NwGetSimSwitch *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwGetSimSwitch) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_NwGetSimSwitch *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwGetSimSwitch;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwSetPocSimIndex
uint32_t CFW_NwSetPocSimIndex(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwSetPocSimIndex *ipar;
    struct OPAR_CFW_NwSetPocSimIndex *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwSetPocSimIndex) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwSetPocSimIndex) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwSetPocSimIndex *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwSetPocSimIndex *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwSetPocSimIndex;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetSignalQuatityFirst
uint32_t CFW_SetSignalQuatityFirst(uint32_t signalQuatityFirst, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetSignalQuatityFirst *ipar;
    struct OPAR_CFW_SetSignalQuatityFirst *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetSignalQuatityFirst) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetSignalQuatityFirst) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetSignalQuatityFirst *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetSignalQuatityFirst *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetSignalQuatityFirst;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->signalQuatityFirst = signalQuatityFirst;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetSignalQuatityFirst
uint32_t CFW_GetSignalQuatityFirst(uint32_t *signalQuatityFirst, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetSignalQuatityFirst *ipar;
    struct OPAR_CFW_GetSignalQuatityFirst *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetSignalQuatityFirst) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetSignalQuatityFirst) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetSignalQuatityFirst *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetSignalQuatityFirst *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetSignalQuatityFirst;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *signalQuatityFirst = opar->signalQuatityFirst;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EnableLpsLock
uint32_t CFW_EnableLpsLock(bool nEnable, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EnableLpsLock *ipar;
    struct OPAR_CFW_EnableLpsLock *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EnableLpsLock) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EnableLpsLock) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EnableLpsLock *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EnableLpsLock *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EnableLpsLock;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nEnable = nEnable;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodSetPowerMode
uint32_t CFW_EmodSetPowerMode(CSCLK_PM_ENUM nValue, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodSetPowerMode *ipar;
    struct OPAR_CFW_EmodSetPowerMode *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodSetPowerMode) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodSetPowerMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodSetPowerMode *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EmodSetPowerMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodSetPowerMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nValue = nValue;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = 0xffffffff;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_UpdateNV
bool CFW_UpdateNV(bool bForce)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_UpdateNV *ipar;
    struct OPAR_CFW_UpdateNV *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_UpdateNV) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_UpdateNV) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_UpdateNV *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_UpdateNV *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_UpdateNV;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->bForce = bForce;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetNvUpdateFlag
uint32_t CFW_SetNvUpdateFlag(uint32_t nFlag, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetNvUpdateFlag *ipar;
    struct OPAR_CFW_SetNvUpdateFlag *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetNvUpdateFlag) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetNvUpdateFlag) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetNvUpdateFlag *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetNvUpdateFlag *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetNvUpdateFlag;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nFlag = nFlag;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#if defined(RPM_SUPPORT)
#ifndef DISABLE_RPC_CFW_RpmNvGetDefaultPdnSettingApn
uint32_t CFW_RpmNvGetDefaultPdnSettingApn(uint8_t outputApn[30], uint8_t *outApnLen, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_RpmNvGetDefaultPdnSettingApn *ipar;
    struct OPAR_CFW_RpmNvGetDefaultPdnSettingApn *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_RpmNvGetDefaultPdnSettingApn) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_RpmNvGetDefaultPdnSettingApn) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_RpmNvGetDefaultPdnSettingApn *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_RpmNvGetDefaultPdnSettingApn *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_RpmNvGetDefaultPdnSettingApn;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(outputApn, opar->outputApn, sizeof(opar->outputApn));
    *outApnLen = opar->outApnLen;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(RPM_SUPPORT)
#ifndef DISABLE_RPC_CFW_RpmCheckAllowRebootingPdpActiving
uint32_t CFW_RpmCheckAllowRebootingPdpActiving(bool *outFlag, uint8_t apn[30], uint32_t apnLen, uint8_t trb, uint8_t addFx, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_RpmCheckAllowRebootingPdpActiving *ipar;
    struct OPAR_CFW_RpmCheckAllowRebootingPdpActiving *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_RpmCheckAllowRebootingPdpActiving) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_RpmCheckAllowRebootingPdpActiving) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_RpmCheckAllowRebootingPdpActiving *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_RpmCheckAllowRebootingPdpActiving *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_RpmCheckAllowRebootingPdpActiving;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ipar->apn, apn, sizeof(ipar->apn));
    ipar->apnLen = apnLen;
    ipar->trb = trb;
    ipar->addFx = addFx;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *outFlag = opar->outFlag;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(RPM_SUPPORT)
#ifndef DISABLE_RPC_CFW_RpmAllowPdpActivating
uint32_t CFW_RpmAllowPdpActivating(bool *outFlag, uint8_t apn[30], uint32_t apnLen, uint8_t trb, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_RpmAllowPdpActivating *ipar;
    struct OPAR_CFW_RpmAllowPdpActivating *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_RpmAllowPdpActivating) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_RpmAllowPdpActivating) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_RpmAllowPdpActivating *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_RpmAllowPdpActivating *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_RpmAllowPdpActivating;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ipar->apn, apn, sizeof(ipar->apn));
    ipar->apnLen = apnLen;
    ipar->trb = trb;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *outFlag = opar->outFlag;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(RPM_SUPPORT)
#ifndef DISABLE_RPC_CFW_RpmGetRpmFlag
uint32_t CFW_RpmGetRpmFlag(uint8_t *outFlag, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_RpmGetRpmFlag *ipar;
    struct OPAR_CFW_RpmGetRpmFlag *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_RpmGetRpmFlag) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_RpmGetRpmFlag) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_RpmGetRpmFlag *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_RpmGetRpmFlag *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_RpmGetRpmFlag;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *outFlag = opar->outFlag;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(RPM_SUPPORT)
#ifndef DISABLE_RPC_CFW_RpmSetRpmFlag
uint32_t CFW_RpmSetRpmFlag(uint8_t rpmFlag, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_RpmSetRpmFlag *ipar;
    struct OPAR_CFW_RpmSetRpmFlag *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_RpmSetRpmFlag) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_RpmSetRpmFlag) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_RpmSetRpmFlag *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_RpmSetRpmFlag *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_RpmSetRpmFlag;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->rpmFlag = rpmFlag;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(RPM_SUPPORT)
#ifndef DISABLE_RPC_CFW_RpmWriteStatic
uint32_t CFW_RpmWriteStatic(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_RpmWriteStatic *ipar;
    struct OPAR_CFW_RpmWriteStatic *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_RpmWriteStatic) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_RpmWriteStatic) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_RpmWriteStatic *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_RpmWriteStatic *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_RpmWriteStatic;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(RPM_SUPPORT)
#ifndef DISABLE_RPC_CFW_RpmWriteDynamic
uint32_t CFW_RpmWriteDynamic(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_RpmWriteDynamic *ipar;
    struct OPAR_CFW_RpmWriteDynamic *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_RpmWriteDynamic) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_RpmWriteDynamic) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_RpmWriteDynamic *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_RpmWriteDynamic *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_RpmWriteDynamic;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(RPM_SUPPORT)
#ifndef DISABLE_RPC_CFW_RpmWriteDynamicEx
uint32_t CFW_RpmWriteDynamicEx(int32_t BeReBoot, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_RpmWriteDynamicEx *ipar;
    struct OPAR_CFW_RpmWriteDynamicEx *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_RpmWriteDynamicEx) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_RpmWriteDynamicEx) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_RpmWriteDynamicEx *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_RpmWriteDynamicEx *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_RpmWriteDynamicEx;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->BeReBoot = BeReBoot;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(RPM_SUPPORT)
#ifndef DISABLE_RPC_CFW_RpmResetRpmFunction
uint32_t CFW_RpmResetRpmFunction(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_RpmResetRpmFunction *ipar;
    struct OPAR_CFW_RpmResetRpmFunction *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_RpmResetRpmFunction) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_RpmResetRpmFunction) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_RpmResetRpmFunction *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_RpmResetRpmFunction *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_RpmResetRpmFunction;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(RPM_SUPPORT)
#ifndef DISABLE_RPC_CFW_RpmGetRpmN1
uint32_t CFW_RpmGetRpmN1(uint8_t *rpmN1, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_RpmGetRpmN1 *ipar;
    struct OPAR_CFW_RpmGetRpmN1 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_RpmGetRpmN1) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_RpmGetRpmN1) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_RpmGetRpmN1 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_RpmGetRpmN1 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_RpmGetRpmN1;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *rpmN1 = opar->rpmN1;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(RPM_SUPPORT)
#ifndef DISABLE_RPC_CFW_RpmSetRpmN1
uint32_t CFW_RpmSetRpmN1(uint8_t rpmN1, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_RpmSetRpmN1 *ipar;
    struct OPAR_CFW_RpmSetRpmN1 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_RpmSetRpmN1) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_RpmSetRpmN1) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_RpmSetRpmN1 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_RpmSetRpmN1 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_RpmSetRpmN1;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->rpmN1 = rpmN1;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(RPM_SUPPORT)
#ifndef DISABLE_RPC_CFW_RpmGetRpmT1
uint32_t CFW_RpmGetRpmT1(uint8_t *rpmT1, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_RpmGetRpmT1 *ipar;
    struct OPAR_CFW_RpmGetRpmT1 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_RpmGetRpmT1) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_RpmGetRpmT1) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_RpmGetRpmT1 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_RpmGetRpmT1 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_RpmGetRpmT1;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *rpmT1 = opar->rpmT1;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(RPM_SUPPORT)
#ifndef DISABLE_RPC_CFW_RpmSetRpmT1
uint32_t CFW_RpmSetRpmT1(uint8_t rpmT1, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_RpmSetRpmT1 *ipar;
    struct OPAR_CFW_RpmSetRpmT1 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_RpmSetRpmT1) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_RpmSetRpmT1) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_RpmSetRpmT1 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_RpmSetRpmT1 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_RpmSetRpmT1;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->rpmT1 = rpmT1;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(RPM_SUPPORT)
#ifndef DISABLE_RPC_CFW_RpmGetRpmFx
uint32_t CFW_RpmGetRpmFx(uint8_t *rpmFx, uint8_t fx, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_RpmGetRpmFx *ipar;
    struct OPAR_CFW_RpmGetRpmFx *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_RpmGetRpmFx) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_RpmGetRpmFx) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_RpmGetRpmFx *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_RpmGetRpmFx *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_RpmGetRpmFx;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->fx = fx;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *rpmFx = opar->rpmFx;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(RPM_SUPPORT)
#ifndef DISABLE_RPC_CFW_RpmSetRpmFx
uint32_t CFW_RpmSetRpmFx(uint8_t fx, uint8_t rpmValue, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_RpmSetRpmFx *ipar;
    struct OPAR_CFW_RpmSetRpmFx *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_RpmSetRpmFx) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_RpmSetRpmFx) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_RpmSetRpmFx *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_RpmSetRpmFx *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_RpmSetRpmFx;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->fx = fx;
    ipar->rpmValue = rpmValue;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(RPM_SUPPORT)
#ifndef DISABLE_RPC_CFW_RpmGetRpmLRX
uint32_t CFW_RpmGetRpmLRX(uint8_t *rpmLRX, uint8_t lrx, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_RpmGetRpmLRX *ipar;
    struct OPAR_CFW_RpmGetRpmLRX *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_RpmGetRpmLRX) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_RpmGetRpmLRX) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_RpmGetRpmLRX *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_RpmGetRpmLRX *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_RpmGetRpmLRX;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->lrx = lrx;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *rpmLRX = opar->rpmLRX;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(RPM_SUPPORT)
#ifndef DISABLE_RPC_CFW_RpmSetRpmLRX
uint32_t CFW_RpmSetRpmLRX(uint8_t lrx, uint8_t rpmValue, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_RpmSetRpmLRX *ipar;
    struct OPAR_CFW_RpmSetRpmLRX *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_RpmSetRpmLRX) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_RpmSetRpmLRX) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_RpmSetRpmLRX *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_RpmSetRpmLRX *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_RpmSetRpmLRX;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->lrx = lrx;
    ipar->rpmValue = rpmValue;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(RPM_SUPPORT)
#ifndef DISABLE_RPC_CFW_RpmGetRpmCBR1
uint32_t CFW_RpmGetRpmCBR1(uint8_t *rpmCBR1, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_RpmGetRpmCBR1 *ipar;
    struct OPAR_CFW_RpmGetRpmCBR1 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_RpmGetRpmCBR1) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_RpmGetRpmCBR1) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_RpmGetRpmCBR1 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_RpmGetRpmCBR1 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_RpmGetRpmCBR1;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *rpmCBR1 = opar->rpmCBR1;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(RPM_SUPPORT)
#ifndef DISABLE_RPC_CFW_RpmGetRpmCR1
uint32_t CFW_RpmGetRpmCR1(uint8_t *rpmCR1, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_RpmGetRpmCR1 *ipar;
    struct OPAR_CFW_RpmGetRpmCR1 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_RpmGetRpmCR1) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_RpmGetRpmCR1) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_RpmGetRpmCR1 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_RpmGetRpmCR1 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_RpmGetRpmCR1;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *rpmCR1 = opar->rpmCR1;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(RPM_SUPPORT)
#ifndef DISABLE_RPC_CFW_RpmSetRpmCR1
uint32_t CFW_RpmSetRpmCR1(uint8_t value, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_RpmSetRpmCR1 *ipar;
    struct OPAR_CFW_RpmSetRpmCR1 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_RpmSetRpmCR1) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_RpmSetRpmCR1) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_RpmSetRpmCR1 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_RpmSetRpmCR1 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_RpmSetRpmCR1;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->value = value;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(RPM_SUPPORT)
#ifndef DISABLE_RPC_CFW_RpmGetRpmCpdpx
uint32_t CFW_RpmGetRpmCpdpx(uint8_t apn[30], uint8_t apnLen, uint8_t *cpdp1, uint8_t *cpdp2, uint8_t *cpdp3, uint8_t *cpdp4, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_RpmGetRpmCpdpx *ipar;
    struct OPAR_CFW_RpmGetRpmCpdpx *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_RpmGetRpmCpdpx) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_RpmGetRpmCpdpx) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_RpmGetRpmCpdpx *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_RpmGetRpmCpdpx *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_RpmGetRpmCpdpx;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ipar->apn, apn, sizeof(ipar->apn));
    ipar->apnLen = apnLen;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *cpdp1 = opar->cpdp1;
    *cpdp2 = opar->cpdp2;
    *cpdp3 = opar->cpdp3;
    *cpdp4 = opar->cpdp4;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(RPM_SUPPORT)
#ifndef DISABLE_RPC_CFW_rpmNvGetLastRat
uint32_t CFW_rpmNvGetLastRat(uint8_t *nLastRat, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_rpmNvGetLastRat *ipar;
    struct OPAR_CFW_rpmNvGetLastRat *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_rpmNvGetLastRat) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_rpmNvGetLastRat) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_rpmNvGetLastRat *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_rpmNvGetLastRat *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_rpmNvGetLastRat;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *nLastRat = opar->nLastRat;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(RPM_SUPPORT)
#ifndef DISABLE_RPC_CFW_rpmNvSetLastRat
uint32_t CFW_rpmNvSetLastRat(uint8_t rat, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_rpmNvSetLastRat *ipar;
    struct OPAR_CFW_rpmNvSetLastRat *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_rpmNvSetLastRat) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_rpmNvSetLastRat) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_rpmNvSetLastRat *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_rpmNvSetLastRat *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_rpmNvSetLastRat;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->rat = rat;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#ifndef DISABLE_RPC_CFW_SetRauAfterCallFlag
uint16_t CFW_SetRauAfterCallFlag(uint16_t flag)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetRauAfterCallFlag *ipar;
    struct OPAR_CFW_SetRauAfterCallFlag *opar;
    uint16_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetRauAfterCallFlag) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetRauAfterCallFlag) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetRauAfterCallFlag *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetRauAfterCallFlag *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetRauAfterCallFlag;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->flag = flag;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetRauAfterCallFlag
uint16_t CFW_GetRauAfterCallFlag(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_GetRauAfterCallFlag *opar;
    uint16_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetRauAfterCallFlag) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_GetRauAfterCallFlag *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetRauAfterCallFlag;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodGetPocPara
uint32_t CFW_EmodGetPocPara(CFW_EMOD_POC_PARA_T *pParam, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodGetPocPara *ipar;
    struct OPAR_CFW_EmodGetPocPara *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodGetPocPara) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodGetPocPara) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodGetPocPara *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EmodGetPocPara *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodGetPocPara;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pParam = opar->pParam;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodSetPocPara
uint32_t CFW_EmodSetPocPara(CFW_EMOD_POC_PARA_T *pParam, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodSetPocPara *ipar;
    struct OPAR_CFW_EmodSetPocPara *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodSetPocPara) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodSetPocPara) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodSetPocPara *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_EmodSetPocPara *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodSetPocPara;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pParam = *pParam;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodSetPSMThd
void CFW_EmodSetPSMThd(uint32_t nMinute)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_EmodSetPSMThd *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_EmodSetPSMThd) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_EmodSetPSMThd *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodSetPSMThd;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nMinute = nMinute;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_EmodGetPSMThd
uint32_t CFW_EmodGetPSMThd(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_EmodGetPSMThd *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodGetPSMThd) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_EmodGetPSMThd *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodGetPSMThd;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_EmodGetLpsFlag
uint16_t CFW_EmodGetLpsFlag(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_EmodGetLpsFlag *opar;
    uint16_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_EmodGetLpsFlag) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_EmodGetLpsFlag *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_EmodGetLpsFlag;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetOpenChannelBearerDes
bool CFW_SatGetOpenChannelBearerDes(CFW_GPRS_QOS *qos, uint8_t *pdp_type, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetOpenChannelBearerDes *ipar;
    struct OPAR_CFW_SatGetOpenChannelBearerDes *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetOpenChannelBearerDes) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetOpenChannelBearerDes) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetOpenChannelBearerDes *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetOpenChannelBearerDes *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetOpenChannelBearerDes;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *qos = opar->qos;
    *pdp_type = opar->pdp_type;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetChannelID
bool CFW_SatGetChannelID(uint8_t *channel, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetChannelID *ipar;
    struct OPAR_CFW_SatGetChannelID *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetChannelID) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetChannelID) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetChannelID *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetChannelID *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetChannelID;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *channel = opar->channel;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimPollReq
uint32_t CFW_SimPollReq(uint32_t nTimerOut, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimPollReq *ipar;
    struct OPAR_CFW_SimPollReq *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimPollReq) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimPollReq) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimPollReq *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimPollReq *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimPollReq;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nTimerOut = nTimerOut;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetLCTimerEx
uint32_t CFW_SetLCTimerEx(uint32_t value, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetLCTimerEx *ipar;
    struct OPAR_CFW_SetLCTimerEx *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetLCTimerEx) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetLCTimerEx) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetLCTimerEx *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetLCTimerEx *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetLCTimerEx;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->value = value;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = 1;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetLCTimerEx
uint32_t CFW_GetLCTimerEx(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetLCTimerEx *ipar;
    struct OPAR_CFW_GetLCTimerEx *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetLCTimerEx) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetLCTimerEx) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetLCTimerEx *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetLCTimerEx *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetLCTimerEx;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = 1;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetLimiteTimer
uint32_t CFW_GetLimiteTimer(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetLimiteTimer *ipar;
    struct OPAR_CFW_GetLimiteTimer *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetLimiteTimer) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetLimiteTimer) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetLimiteTimer *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetLimiteTimer *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetLimiteTimer;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = 1;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetLimiteTimer
uint32_t CFW_SetLimiteTimer(uint32_t value, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetLimiteTimer *ipar;
    struct OPAR_CFW_SetLimiteTimer *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetLimiteTimer) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetLimiteTimer) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetLimiteTimer *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetLimiteTimer *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetLimiteTimer;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->value = value;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = 1;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetLctLoopCout
uint32_t CFW_GetLctLoopCout(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetLctLoopCout *ipar;
    struct OPAR_CFW_GetLctLoopCout *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetLctLoopCout) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetLctLoopCout) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetLctLoopCout *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetLctLoopCout *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetLctLoopCout;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = 1;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetLctLoopCout
uint32_t CFW_SetLctLoopCout(uint32_t value, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetLctLoopCout *ipar;
    struct OPAR_CFW_SetLctLoopCout *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetLctLoopCout) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetLctLoopCout) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetLctLoopCout *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetLctLoopCout *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetLctLoopCout;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->value = value;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = 1;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetLmtLoopCout
uint32_t CFW_GetLmtLoopCout(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetLmtLoopCout *ipar;
    struct OPAR_CFW_GetLmtLoopCout *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetLmtLoopCout) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetLmtLoopCout) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetLmtLoopCout *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetLmtLoopCout *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetLmtLoopCout;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = 1;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetLmtLoopCout
uint32_t CFW_SetLmtLoopCout(uint32_t value, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetLmtLoopCout *ipar;
    struct OPAR_CFW_SetLmtLoopCout *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetLmtLoopCout) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetLmtLoopCout) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetLmtLoopCout *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetLmtLoopCout *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetLmtLoopCout;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->value = value;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = 1;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetLctMaxLen
uint32_t CFW_GetLctMaxLen(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetLctMaxLen *ipar;
    struct OPAR_CFW_GetLctMaxLen *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetLctMaxLen) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetLctMaxLen) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetLctMaxLen *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetLctMaxLen *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetLctMaxLen;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = 1;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetLctMaxLen
uint32_t CFW_SetLctMaxLen(uint32_t value, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetLctMaxLen *ipar;
    struct OPAR_CFW_SetLctMaxLen *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetLctMaxLen) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetLctMaxLen) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetLctMaxLen *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetLctMaxLen *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetLctMaxLen;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->value = value;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = 1;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetLmtMaxLen
uint32_t CFW_GetLmtMaxLen(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetLmtMaxLen *ipar;
    struct OPAR_CFW_GetLmtMaxLen *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetLmtMaxLen) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetLmtMaxLen) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetLmtMaxLen *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetLmtMaxLen *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetLmtMaxLen;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = 1;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetLmtMaxLen
uint32_t CFW_SetLmtMaxLen(uint32_t value, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetLmtMaxLen *ipar;
    struct OPAR_CFW_SetLmtMaxLen *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetLmtMaxLen) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetLmtMaxLen) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetLmtMaxLen *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetLmtMaxLen *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetLmtMaxLen;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->value = value;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = 1;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetCdrxNoSleepEnable
uint32_t CFW_CfgSetCdrxNoSleepEnable(uint8_t bEnable, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetCdrxNoSleepEnable *ipar;
    struct OPAR_CFW_CfgSetCdrxNoSleepEnable *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetCdrxNoSleepEnable) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetCdrxNoSleepEnable) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetCdrxNoSleepEnable *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetCdrxNoSleepEnable *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetCdrxNoSleepEnable;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->bEnable = bEnable;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetCdrxNoSleepEnable
uint8_t CFW_CfgGetCdrxNoSleepEnable(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgGetCdrxNoSleepEnable *ipar;
    struct OPAR_CFW_CfgGetCdrxNoSleepEnable *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgGetCdrxNoSleepEnable) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetCdrxNoSleepEnable) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgGetCdrxNoSleepEnable *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgGetCdrxNoSleepEnable *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetCdrxNoSleepEnable;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgSetPeriodTauAftLocalRel
uint32_t CFW_CfgSetPeriodTauAftLocalRel(uint8_t bEnable, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgSetPeriodTauAftLocalRel *ipar;
    struct OPAR_CFW_CfgSetPeriodTauAftLocalRel *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgSetPeriodTauAftLocalRel) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgSetPeriodTauAftLocalRel) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgSetPeriodTauAftLocalRel *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgSetPeriodTauAftLocalRel *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgSetPeriodTauAftLocalRel;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->bEnable = bEnable;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CfgGetPeriodTauAftLocalRel
uint8_t CFW_CfgGetPeriodTauAftLocalRel(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CfgGetPeriodTauAftLocalRel *ipar;
    struct OPAR_CFW_CfgGetPeriodTauAftLocalRel *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CfgGetPeriodTauAftLocalRel) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CfgGetPeriodTauAftLocalRel) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CfgGetPeriodTauAftLocalRel *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CfgGetPeriodTauAftLocalRel *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CfgGetPeriodTauAftLocalRel;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_WifiScanStart
uint32_t CFW_WifiScanStart(CFW_WIFISCAN_REQ wifiscan_param, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_WifiScanStart *ipar;
    struct OPAR_CFW_WifiScanStart *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_WifiScanStart) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_WifiScanStart) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_WifiScanStart *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_WifiScanStart *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_WifiScanStart;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->wifiscan_param = wifiscan_param;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_WifiScanStop
uint32_t CFW_WifiScanStop(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_WifiScanStop *ipar;
    struct OPAR_CFW_WifiScanStop *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_WifiScanStop) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_WifiScanStop) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_WifiScanStop *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_WifiScanStop *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_WifiScanStop;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GnssStartHandshakeStack
uint32_t CFW_GnssStartHandshakeStack(uint8_t nServiceType, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GnssStartHandshakeStack *ipar;
    struct OPAR_CFW_GnssStartHandshakeStack *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GnssStartHandshakeStack) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GnssStartHandshakeStack) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GnssStartHandshakeStack *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GnssStartHandshakeStack *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GnssStartHandshakeStack;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nServiceType = nServiceType;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GnssStopHandshakeStack
uint32_t CFW_GnssStopHandshakeStack(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GnssStopHandshakeStack *ipar;
    struct OPAR_CFW_GnssStopHandshakeStack *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GnssStopHandshakeStack) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GnssStopHandshakeStack) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GnssStopHandshakeStack *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GnssStopHandshakeStack *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GnssStopHandshakeStack;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_nvSetLocPriority
void CFW_nvSetLocPriority(uint8_t locPriority, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvSetLocPriority *ipar;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvSetLocPriority) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvSetLocPriority *)((char *)mem + sizeof(rpcCallHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvSetLocPriority;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->locPriority = locPriority;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_nvSetLocPriority_V2
uint32_t CFW_nvSetLocPriority_V2(uint8_t locPriority, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvSetLocPriority_V2 *ipar;
    struct OPAR_CFW_nvSetLocPriority_V2 *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvSetLocPriority_V2) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_nvSetLocPriority_V2) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvSetLocPriority_V2 *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_nvSetLocPriority_V2 *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvSetLocPriority_V2;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->locPriority = locPriority;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_nvGetLocPriority
uint8_t CFW_nvGetLocPriority(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvGetLocPriority *ipar;
    struct OPAR_CFW_nvGetLocPriority *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvGetLocPriority) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_nvGetLocPriority) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvGetLocPriority *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_nvGetLocPriority *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvGetLocPriority;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_LocGetWifiscanRes
uint32_t CFW_LocGetWifiscanRes(void * listAddr, uint8_t index, uint8_t end, CFW_WIFISCAN_AP_RESULT *scan_result)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_LocGetWifiscanRes *ipar;
    struct OPAR_CFW_LocGetWifiscanRes *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_LocGetWifiscanRes) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_LocGetWifiscanRes) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_LocGetWifiscanRes *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_LocGetWifiscanRes *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_LocGetWifiscanRes;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->listAddr = listAddr;
    ipar->index = index;
    ipar->end = end;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *scan_result = opar->scan_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_LcsMolrReq
uint32_t CFW_LcsMolrReq(CFW_LCS_MOLR_INFO *molrInfo, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_LcsMolrReq *ipar;
    struct OPAR_CFW_LcsMolrReq *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_LcsMolrReq) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_LcsMolrReq) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_LcsMolrReq *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_LcsMolrReq *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_LcsMolrReq;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->molrInfo = *molrInfo;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_LcsMtlrRsp
uint32_t CFW_LcsMtlrRsp(uint8_t handle_id, uint8_t response, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_LcsMtlrRsp *ipar;
    struct OPAR_CFW_LcsMtlrRsp *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_LcsMtlrRsp) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_LcsMtlrRsp) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_LcsMtlrRsp *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_LcsMtlrRsp *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_LcsMtlrRsp;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->handle_id = handle_id;
    ipar->response = response;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_WifiSentestOn
void CFW_WifiSentestOn(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;



    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    call->h.size = call_size;
    call->api_tag = TAG_CFW_WifiSentestOn;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_WifiSentestOff
void CFW_WifiSentestOff(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;



    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + 0 + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    call->h.size = call_size;
    call->api_tag = TAG_CFW_WifiSentestOff;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;

    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);

}
#endif

#ifndef DISABLE_RPC_CFW_WifiSentestSetParam
uint32_t CFW_WifiSentestSetParam(CFW_WIFISENTEST_PARAM *sentest_cfg)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_WifiSentestSetParam *ipar;
    struct OPAR_CFW_WifiSentestSetParam *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_WifiSentestSetParam) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_WifiSentestSetParam) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_WifiSentestSetParam *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_WifiSentestSetParam *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_WifiSentestSetParam;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->sentest_cfg = *sentest_cfg;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_WifiSentestGetSingleRes
uint32_t CFW_WifiSentestGetSingleRes(CFW_WIFISENTEST_RES *sentest_res)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_WifiSentestGetSingleRes *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_WifiSentestGetSingleRes) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_WifiSentestGetSingleRes *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_WifiSentestGetSingleRes;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *sentest_res = opar->sentest_res;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_nvSetNasTimer
uint32_t CFW_nvSetNasTimer(uint8_t nType, uint8_t nName, uint16_t nValue, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvSetNasTimer *ipar;
    struct OPAR_CFW_nvSetNasTimer *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvSetNasTimer) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_nvSetNasTimer) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvSetNasTimer *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_nvSetNasTimer *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvSetNasTimer;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nType = nType;
    ipar->nName = nName;
    ipar->nValue = nValue;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_nvGetNasTimer
uint32_t CFW_nvGetNasTimer(uint8_t nType, uint8_t nName, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvGetNasTimer *ipar;
    struct OPAR_CFW_nvGetNasTimer *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvGetNasTimer) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_nvGetNasTimer) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvGetNasTimer *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_nvGetNasTimer *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvGetNasTimer;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nType = nType;
    ipar->nName = nName;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_nvSetNwSearchPrior
uint32_t CFW_nvSetNwSearchPrior(uint8_t mode, uint32_t enable, uint8_t band_num, uint8_t band_list[20], CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvSetNwSearchPrior *ipar;
    struct OPAR_CFW_nvSetNwSearchPrior *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvSetNwSearchPrior) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_nvSetNwSearchPrior) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvSetNwSearchPrior *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_nvSetNwSearchPrior *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvSetNwSearchPrior;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->mode = mode;
    ipar->enable = enable;
    ipar->band_num = band_num;
    memcpy(ipar->band_list, band_list, sizeof(ipar->band_list));
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_nvGetNwSearchPrior
uint32_t CFW_nvGetNwSearchPrior(uint32_t *enable, uint8_t *band_num, uint8_t band_list[20], CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvGetNwSearchPrior *ipar;
    struct OPAR_CFW_nvGetNwSearchPrior *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvGetNwSearchPrior) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_nvGetNwSearchPrior) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvGetNwSearchPrior *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_nvGetNwSearchPrior *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvGetNwSearchPrior;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *enable = opar->enable;
    *band_num = opar->band_num;
    memcpy(band_list, opar->band_list, sizeof(opar->band_list));
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_ErrcSetMeasThreshold
uint32_t CFW_ErrcSetMeasThreshold(CFW_MEAS_OFFSET_T meas_cfg, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_ErrcSetMeasThreshold *ipar;
    struct OPAR_CFW_ErrcSetMeasThreshold *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_ErrcSetMeasThreshold) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_ErrcSetMeasThreshold) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_ErrcSetMeasThreshold *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_ErrcSetMeasThreshold *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ErrcSetMeasThreshold;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->meas_cfg = meas_cfg;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_ErrcGetMeasThreshold
uint32_t CFW_ErrcGetMeasThreshold(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_ErrcGetMeasThreshold *ipar;
    struct OPAR_CFW_ErrcGetMeasThreshold *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_ErrcGetMeasThreshold) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_ErrcGetMeasThreshold) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_ErrcGetMeasThreshold *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_ErrcGetMeasThreshold *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_ErrcGetMeasThreshold;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwErrcStatisCfg
uint32_t CFW_NwErrcStatisCfg(CFW_STATIS_INFO_CFG_RPT cfg_rpt, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwErrcStatisCfg *ipar;
    struct OPAR_CFW_NwErrcStatisCfg *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwErrcStatisCfg) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwErrcStatisCfg) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwErrcStatisCfg *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwErrcStatisCfg *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwErrcStatisCfg;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->cfg_rpt = cfg_rpt;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimSetResume
uint32_t CFW_SimSetResume(uint8_t nResumeToken[8], uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimSetResume *ipar;
    struct OPAR_CFW_SimSetResume *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimSetResume) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimSetResume) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimSetResume *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimSetResume *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimSetResume;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ipar->nResumeToken, nResumeToken, sizeof(ipar->nResumeToken));
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimSetSuspend
uint32_t CFW_SimSetSuspend(CFW_SUSP_FUNC_SELECT *pSelecFUN, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimSetSuspend *ipar;
    struct OPAR_CFW_SimSetSuspend *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimSetSuspend) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimSetSuspend) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimSetSuspend *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimSetSuspend *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimSetSuspend;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pSelecFUN = *pSelecFUN;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwSetLocalRelease
uint32_t CFW_NwSetLocalRelease(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwSetLocalRelease *ipar;
    struct OPAR_CFW_NwSetLocalRelease *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwSetLocalRelease) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwSetLocalRelease) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwSetLocalRelease *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwSetLocalRelease *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwSetLocalRelease;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetRawData
bool CFW_SatGetRawData(uint8_t pRawData[260], uint16_t *nRawDataLen, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetRawData *ipar;
    struct OPAR_CFW_SatGetRawData *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetRawData) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetRawData) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetRawData *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetRawData *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetRawData;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nRawDataLen = *nRawDataLen;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(pRawData, opar->pRawData, sizeof(opar->pRawData));
    *nRawDataLen = opar->nRawDataLen;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatTerminalResponse
uint32_t CFW_SatTerminalResponse(uint8_t* data, uint16_t length, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatTerminalResponse *ipar;
    struct OPAR_CFW_SatTerminalResponse *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(length+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatTerminalResponse) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatTerminalResponse) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatTerminalResponse *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatTerminalResponse *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatTerminalResponse);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatTerminalResponse;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ivar_ptr, data, length);
    ivar_ptr[length] = (char)0;
    ivar_ptr += ALIGNUP8(length + 1);
    ipar->length = length;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatTerminalEnvelope
uint32_t CFW_SatTerminalEnvelope(uint8_t* data, uint16_t length, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatTerminalEnvelope *ipar;
    struct OPAR_CFW_SatTerminalEnvelope *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(length+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatTerminalEnvelope) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatTerminalEnvelope) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatTerminalEnvelope *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatTerminalEnvelope *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatTerminalEnvelope);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatTerminalEnvelope;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ivar_ptr, data, length);
    ivar_ptr[length] = (char)0;
    ivar_ptr += ALIGNUP8(length + 1);
    ipar->length = length;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimSetMeProfile
uint32_t CFW_SimSetMeProfile(CFW_PROFILE *pMeProfile, uint8_t uicc_type)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimSetMeProfile *ipar;
    struct OPAR_CFW_SimSetMeProfile *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimSetMeProfile) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimSetMeProfile) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimSetMeProfile *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimSetMeProfile *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimSetMeProfile;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pMeProfile = *pMeProfile;
    ipar->uicc_type = uicc_type;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatSetFacility
uint32_t CFW_SatSetFacility(uint8_t status, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatSetFacility *ipar;
    struct OPAR_CFW_SatSetFacility *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatSetFacility) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatSetFacility) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatSetFacility *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatSetFacility *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatSetFacility;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->status = status;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetFacility
uint8_t CFW_SatGetFacility(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetFacility *ipar;
    struct OPAR_CFW_SatGetFacility *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetFacility) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetFacility) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetFacility *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetFacility *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetFacility;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_StackInit
uint32_t CFW_StackInit(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_StackInit *ipar;
    struct OPAR_CFW_StackInit *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_StackInit) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_StackInit) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_StackInit *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_StackInit *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_StackInit;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#if defined(FUNC_SUPPORT_SIMLOCK)
#ifndef DISABLE_RPC_CFW_SimlockDataProcess
uint32_t CFW_SimlockDataProcess(char * pData, uint16_t nDataSize, uint8_t nFlag, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimlockDataProcess *ipar;
    struct OPAR_CFW_SimlockDataProcess *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nDataSize+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimlockDataProcess) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimlockDataProcess) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimlockDataProcess *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimlockDataProcess *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimlockDataProcess);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimlockDataProcess;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ivar_ptr, pData, nDataSize);
    ivar_ptr[nDataSize] = (char)0;
    ivar_ptr += ALIGNUP8(nDataSize + 1);
    ipar->nDataSize = nDataSize;
    ipar->nFlag = nFlag;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(FUNC_SUPPORT_SIMLOCK)
#ifndef DISABLE_RPC_CFW_SimlockEncryptKeys
uint32_t CFW_SimlockEncryptKeys(char * pData, uint16_t nDataSize, char encrypt_data[800], uint16_t en_len, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimlockEncryptKeys *ipar;
    struct OPAR_CFW_SimlockEncryptKeys *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nDataSize+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimlockEncryptKeys) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimlockEncryptKeys) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimlockEncryptKeys *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimlockEncryptKeys *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimlockEncryptKeys);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimlockEncryptKeys;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ivar_ptr, pData, nDataSize);
    ivar_ptr[nDataSize] = (char)0;
    ivar_ptr += ALIGNUP8(nDataSize + 1);
    ipar->nDataSize = nDataSize;
    ipar->en_len = en_len;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(encrypt_data, opar->encrypt_data, sizeof(opar->encrypt_data));
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(FUNC_SUPPORT_SIMLOCK)
#ifndef DISABLE_RPC_CFW_SimlockImeiProcess
uint32_t CFW_SimlockImeiProcess(char * pData, uint16_t nDataSize, uint8_t nFlag, uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimlockImeiProcess *ipar;
    struct OPAR_CFW_SimlockImeiProcess *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nDataSize+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimlockImeiProcess) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimlockImeiProcess) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimlockImeiProcess *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimlockImeiProcess *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimlockImeiProcess);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimlockImeiProcess;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ivar_ptr, pData, nDataSize);
    ivar_ptr[nDataSize] = (char)0;
    ivar_ptr += ALIGNUP8(nDataSize + 1);
    ipar->nDataSize = nDataSize;
    ipar->nFlag = nFlag;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(FUNC_SUPPORT_SIMLOCK)
#ifndef DISABLE_RPC_CFW_SimlockSetHuk
uint32_t CFW_SimlockSetHuk(char * pData, uint16_t nDataSize, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimlockSetHuk *ipar;
    struct OPAR_CFW_SimlockSetHuk *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nDataSize+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimlockSetHuk) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimlockSetHuk) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimlockSetHuk *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimlockSetHuk *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimlockSetHuk);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimlockSetHuk;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ivar_ptr, pData, nDataSize);
    ivar_ptr[nDataSize] = (char)0;
    ivar_ptr += ALIGNUP8(nDataSize + 1);
    ipar->nDataSize = nDataSize;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(FUNC_SUPPORT_SIMLOCK)
#ifndef DISABLE_RPC_CFW_SimlockFacauthPubkey
uint32_t CFW_SimlockFacauthPubkey(char * pubkey, uint16_t nPubkeySize, char * sign, uint16_t nSignSize, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimlockFacauthPubkey *ipar;
    struct OPAR_CFW_SimlockFacauthPubkey *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(nPubkeySize+1) + ALIGNUP8(nSignSize+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimlockFacauthPubkey) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimlockFacauthPubkey) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimlockFacauthPubkey *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimlockFacauthPubkey *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimlockFacauthPubkey);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimlockFacauthPubkey;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ivar_ptr, pubkey, nPubkeySize);
    ivar_ptr[nPubkeySize] = (char)0;
    ivar_ptr += ALIGNUP8(nPubkeySize + 1);
    ipar->nPubkeySize = nPubkeySize;
    memcpy(ivar_ptr, sign, nSignSize);
    ivar_ptr[nSignSize] = (char)0;
    ivar_ptr += ALIGNUP8(nSignSize + 1);
    ipar->nSignSize = nSignSize;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(FUNC_SUPPORT_SIMLOCK)
#ifndef DISABLE_RPC_CFW_SimlockAuthStart
uint32_t CFW_SimlockAuthStart(char data[512], uint32_t *len, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimlockAuthStart *ipar;
    struct OPAR_CFW_SimlockAuthStart *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimlockAuthStart) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimlockAuthStart) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimlockAuthStart *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimlockAuthStart *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimlockAuthStart;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->len = *len;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(data, opar->data, sizeof(opar->data));
    *len = opar->len;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(FUNC_SUPPORT_SIMLOCK)
#ifndef DISABLE_RPC_CFW_SimlockAuthEnd
uint32_t CFW_SimlockAuthEnd(char * data, uint32_t len, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimlockAuthEnd *ipar;
    struct OPAR_CFW_SimlockAuthEnd *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(len+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimlockAuthEnd) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimlockAuthEnd) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimlockAuthEnd *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimlockAuthEnd *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimlockAuthEnd);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimlockAuthEnd;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ivar_ptr, data, len);
    ivar_ptr[len] = (char)0;
    ivar_ptr += ALIGNUP8(len + 1);
    ipar->len = len;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(FUNC_SUPPORT_SIMLOCK)
#ifndef DISABLE_RPC_CFW_SimlockToolGetUid
uint32_t CFW_SimlockToolGetUid(uint8_t uidData[128], uint8_t len, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimlockToolGetUid *ipar;
    struct OPAR_CFW_SimlockToolGetUid *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimlockToolGetUid) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimlockToolGetUid) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimlockToolGetUid *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimlockToolGetUid *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimlockToolGetUid;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->len = len;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(uidData, opar->uidData, sizeof(opar->uidData));
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(FUNC_SUPPORT_SIMLOCK)
#ifndef DISABLE_RPC_CFW_SimlockDataCheckUnlock
uint32_t CFW_SimlockDataCheckUnlock(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimlockDataCheckUnlock *ipar;
    struct OPAR_CFW_SimlockDataCheckUnlock *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimlockDataCheckUnlock) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimlockDataCheckUnlock) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimlockDataCheckUnlock *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimlockDataCheckUnlock *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimlockDataCheckUnlock;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(FUNC_SUPPORT_SIMLOCK)
#ifndef DISABLE_RPC_CFW_SimlockDataCheckLock
uint32_t CFW_SimlockDataCheckLock(char * data, uint16_t len, uint8_t nFlag, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimlockDataCheckLock *ipar;
    struct OPAR_CFW_SimlockDataCheckLock *opar;
    char *ivar_ptr;
    uint32_t result;


    ivar_size = ALIGNUP8(len+1);
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimlockDataCheckLock) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimlockDataCheckLock) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimlockDataCheckLock *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimlockDataCheckLock *)((char *)mem + sizeof(rpcRespHeader_t));
    ivar_ptr = (char *)mem + sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimlockDataCheckLock);
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimlockDataCheckLock;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ivar_ptr, data, len);
    ivar_ptr[len] = (char)0;
    ivar_ptr += ALIGNUP8(len + 1);
    ipar->len = len;
    ipar->nFlag = nFlag;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(FUNC_SUPPORT_SIMLOCK)
#ifndef DISABLE_RPC_CFW_SimlockImeiVerify
uint32_t CFW_SimlockImeiVerify(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimlockImeiVerify *ipar;
    struct OPAR_CFW_SimlockImeiVerify *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimlockImeiVerify) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimlockImeiVerify) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimlockImeiVerify *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimlockImeiVerify *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimlockImeiVerify;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(FUNC_SUPPORT_SIMLOCK)
#ifndef DISABLE_RPC_CFW_SimlockSetVersion
uint32_t CFW_SimlockSetVersion(char * data, uint16_t len, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimlockSetVersion *ipar;
    struct OPAR_CFW_SimlockSetVersion *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimlockSetVersion) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimlockSetVersion) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimlockSetVersion *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimlockSetVersion *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimlockSetVersion;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->data = data;
    ipar->len = len;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#ifndef DISABLE_RPC_CFW_SetMoSmsRetryCount
uint32_t CFW_SetMoSmsRetryCount(uint8_t smc_count, uint8_t smr_count, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetMoSmsRetryCount *ipar;
    struct OPAR_CFW_SetMoSmsRetryCount *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetMoSmsRetryCount) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetMoSmsRetryCount) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetMoSmsRetryCount *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetMoSmsRetryCount *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetMoSmsRetryCount;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->smc_count = smc_count;
    ipar->smr_count = smr_count;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_DecodeCDMAImsi
bool CFW_DecodeCDMAImsi(uint8_t pImsi[15], uint8_t pCdmaImsiM[10])
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_DecodeCDMAImsi *ipar;
    struct OPAR_CFW_DecodeCDMAImsi *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_DecodeCDMAImsi) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_DecodeCDMAImsi) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_DecodeCDMAImsi *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_DecodeCDMAImsi *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_DecodeCDMAImsi;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ipar->pCdmaImsiM, pCdmaImsiM, sizeof(ipar->pCdmaImsiM));
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(pImsi, opar->pImsi, sizeof(opar->pImsi));
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = false;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SimGetCdmaImsi
uint32_t CFW_SimGetCdmaImsi(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SimGetCdmaImsi *ipar;
    struct OPAR_CFW_SimGetCdmaImsi *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SimGetCdmaImsi) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SimGetCdmaImsi) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SimGetCdmaImsi *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SimGetCdmaImsi *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SimGetCdmaImsi;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetNMR
uint32_t CFW_GetNMR(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetNMR *ipar;
    struct OPAR_CFW_GetNMR *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetNMR) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetNMR) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetNMR *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetNMR *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetNMR;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SmsCbGetNode
uint32_t CFW_SmsCbGetNode(void * pCBList, uint8_t nIndex, uint8_t nCount, CFW_SMS_CB_MSG_NODE_T *pNode, CFW_SIM_ID nSimId)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SmsCbGetNode *ipar;
    struct OPAR_CFW_SmsCbGetNode *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SmsCbGetNode) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SmsCbGetNode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SmsCbGetNode *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SmsCbGetNode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SmsCbGetNode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pCBList = pCBList;
    ipar->nIndex = nIndex;
    ipar->nCount = nCount;
    ipar->nSimId = nSimId;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pNode = opar->pNode;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetGsmBlkList
uint32_t CFW_GetGsmBlkList(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetGsmBlkList *ipar;
    struct OPAR_CFW_GetGsmBlkList *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetGsmBlkList) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetGsmBlkList) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetGsmBlkList *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetGsmBlkList *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetGsmBlkList;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_CusPrivatePsm
uint32_t CFW_CusPrivatePsm(uint8_t flag, uint16_t time, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_CusPrivatePsm *ipar;
    struct OPAR_CFW_CusPrivatePsm *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_CusPrivatePsm) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_CusPrivatePsm) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_CusPrivatePsm *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_CusPrivatePsm *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_CusPrivatePsm;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->flag = flag;
    ipar->time = time;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetCDACValue
uint32_t CFW_SetCDACValue(uint8_t nCdac, bool bSaveFlag)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetCDACValue *ipar;
    struct OPAR_CFW_SetCDACValue *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetCDACValue) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetCDACValue) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetCDACValue *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetCDACValue *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetCDACValue;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nCdac = nCdac;
    ipar->bSaveFlag = bSaveFlag;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetCDACValue
uint32_t CFW_GetCDACValue(uint8_t *pCdac)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_GetCDACValue *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetCDACValue) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_GetCDACValue *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetCDACValue;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pCdac = opar->pCdac;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetNetDLPsmParam
uint32_t CFW_GetNetDLPsmParam(uint16_t nUti, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetNetDLPsmParam *ipar;
    struct OPAR_CFW_GetNetDLPsmParam *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetNetDLPsmParam) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetNetDLPsmParam) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetNetDLPsmParam *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetNetDLPsmParam *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetNetDLPsmParam;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUti = nUti;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetLteBlkList
uint32_t CFW_GetLteBlkList(uint16_t nUTI, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetLteBlkList *ipar;
    struct OPAR_CFW_GetLteBlkList *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetLteBlkList) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetLteBlkList) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetLteBlkList *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetLteBlkList *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetLteBlkList;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nUTI = nUTI;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_NwSetNetTAU
uint32_t CFW_NwSetNetTAU(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwSetNetTAU *ipar;
    struct OPAR_CFW_NwSetNetTAU *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwSetNetTAU) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwSetNetTAU) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwSetNetTAU *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwSetNetTAU *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwSetNetTAU;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetGsmGprsOnly
uint32_t CFW_SetGsmGprsOnly(uint8_t value, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetGsmGprsOnly *ipar;
    struct OPAR_CFW_SetGsmGprsOnly *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetGsmGprsOnly) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetGsmGprsOnly) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetGsmGprsOnly *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetGsmGprsOnly *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetGsmGprsOnly;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->value = value;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetGsmGprsOnly
uint32_t CFW_GetGsmGprsOnly(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetGsmGprsOnly *ipar;
    struct OPAR_CFW_GetGsmGprsOnly *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetGsmGprsOnly) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetGsmGprsOnly) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetGsmGprsOnly *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetGsmGprsOnly *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetGsmGprsOnly;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetUsrHisFreqInfo
uint32_t CFW_GetUsrHisFreqInfo(CFW_UsrHisFreqInfo *pHisFreqInfo, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetUsrHisFreqInfo *ipar;
    struct OPAR_CFW_GetUsrHisFreqInfo *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetUsrHisFreqInfo) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetUsrHisFreqInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetUsrHisFreqInfo *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetUsrHisFreqInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetUsrHisFreqInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *pHisFreqInfo = opar->pHisFreqInfo;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetUsrHisFreqInfo
uint32_t CFW_SetUsrHisFreqInfo(CFW_StoredUsrFreqInfo pHisFreqInfo, uint8_t bOperFlag, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetUsrHisFreqInfo *ipar;
    struct OPAR_CFW_SetUsrHisFreqInfo *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetUsrHisFreqInfo) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetUsrHisFreqInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetUsrHisFreqInfo *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetUsrHisFreqInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetUsrHisFreqInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->pHisFreqInfo = pHisFreqInfo;
    ipar->bOperFlag = bOperFlag;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetMenuTitle
bool CFW_SatGetMenuTitle(uint8_t title[255], uint8_t *title_length, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetMenuTitle *ipar;
    struct OPAR_CFW_SatGetMenuTitle *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetMenuTitle) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetMenuTitle) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetMenuTitle *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetMenuTitle *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetMenuTitle;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->title_length = *title_length;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(title, opar->title, sizeof(opar->title));
    *title_length = opar->title_length;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetMenuItemByID
bool CFW_SatGetMenuItemByID(uint8_t item_id, uint8_t item[255], uint8_t *item_length, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetMenuItemByID *ipar;
    struct OPAR_CFW_SatGetMenuItemByID *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetMenuItemByID) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetMenuItemByID) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetMenuItemByID *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetMenuItemByID *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetMenuItemByID;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->item_id = item_id;
    ipar->item_length = *item_length;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(item, opar->item, sizeof(opar->item));
    *item_length = opar->item_length;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetMenuCurrentItem
bool CFW_SatGetMenuCurrentItem(uint8_t item[255], uint8_t *item_length, uint8_t *item_id, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetMenuCurrentItem *ipar;
    struct OPAR_CFW_SatGetMenuCurrentItem *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetMenuCurrentItem) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetMenuCurrentItem) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetMenuCurrentItem *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetMenuCurrentItem *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetMenuCurrentItem;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->item_length = *item_length;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(item, opar->item, sizeof(opar->item));
    *item_length = opar->item_length;
    *item_id = opar->item_id;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetMenuFirstItem
bool CFW_SatGetMenuFirstItem(uint8_t item[255], uint8_t *item_length, uint8_t *item_id, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetMenuFirstItem *ipar;
    struct OPAR_CFW_SatGetMenuFirstItem *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetMenuFirstItem) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetMenuFirstItem) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetMenuFirstItem *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetMenuFirstItem *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetMenuFirstItem;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->item_length = *item_length;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(item, opar->item, sizeof(opar->item));
    *item_length = opar->item_length;
    *item_id = opar->item_id;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetMenuNextItem
bool CFW_SatGetMenuNextItem(uint8_t item[255], uint8_t *item_length, uint8_t *item_id, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetMenuNextItem *ipar;
    struct OPAR_CFW_SatGetMenuNextItem *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetMenuNextItem) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetMenuNextItem) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetMenuNextItem *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetMenuNextItem *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetMenuNextItem;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->item_length = *item_length;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(item, opar->item, sizeof(opar->item));
    *item_length = opar->item_length;
    *item_id = opar->item_id;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetSubMenuTitle
bool CFW_SatGetSubMenuTitle(uint8_t title[255], uint8_t *title_length, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetSubMenuTitle *ipar;
    struct OPAR_CFW_SatGetSubMenuTitle *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetSubMenuTitle) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetSubMenuTitle) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetSubMenuTitle *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetSubMenuTitle *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetSubMenuTitle;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->title_length = *title_length;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(title, opar->title, sizeof(opar->title));
    *title_length = opar->title_length;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetSubMenuItemByID
bool CFW_SatGetSubMenuItemByID(uint8_t item_id, uint8_t item[255], uint8_t *item_length, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetSubMenuItemByID *ipar;
    struct OPAR_CFW_SatGetSubMenuItemByID *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetSubMenuItemByID) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetSubMenuItemByID) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetSubMenuItemByID *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetSubMenuItemByID *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetSubMenuItemByID;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->item_id = item_id;
    ipar->item_length = *item_length;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(item, opar->item, sizeof(opar->item));
    *item_length = opar->item_length;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetSubMenuCurrentItem
bool CFW_SatGetSubMenuCurrentItem(uint8_t item[255], uint8_t *item_length, uint8_t *item_id, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetSubMenuCurrentItem *ipar;
    struct OPAR_CFW_SatGetSubMenuCurrentItem *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetSubMenuCurrentItem) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetSubMenuCurrentItem) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetSubMenuCurrentItem *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetSubMenuCurrentItem *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetSubMenuCurrentItem;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->item_length = *item_length;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(item, opar->item, sizeof(opar->item));
    *item_length = opar->item_length;
    *item_id = opar->item_id;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetSubMenuFirstItem
bool CFW_SatGetSubMenuFirstItem(uint8_t item[255], uint8_t *item_length, uint8_t *item_id, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetSubMenuFirstItem *ipar;
    struct OPAR_CFW_SatGetSubMenuFirstItem *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetSubMenuFirstItem) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetSubMenuFirstItem) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetSubMenuFirstItem *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetSubMenuFirstItem *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetSubMenuFirstItem;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->item_length = *item_length;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(item, opar->item, sizeof(opar->item));
    *item_length = opar->item_length;
    *item_id = opar->item_id;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetSubMenuNextItem
bool CFW_SatGetSubMenuNextItem(uint8_t item[255], uint8_t *item_length, uint8_t *item_id, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetSubMenuNextItem *ipar;
    struct OPAR_CFW_SatGetSubMenuNextItem *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetSubMenuNextItem) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetSubMenuNextItem) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetSubMenuNextItem *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetSubMenuNextItem *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetSubMenuNextItem;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->item_length = *item_length;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(item, opar->item, sizeof(opar->item));
    *item_length = opar->item_length;
    *item_id = opar->item_id;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetSendSmsServiceCenterAddr
bool CFW_SatGetSendSmsServiceCenterAddr(uint8_t addr[255], uint8_t *addr_length, uint8_t *addr_type, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetSendSmsServiceCenterAddr *ipar;
    struct OPAR_CFW_SatGetSendSmsServiceCenterAddr *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetSendSmsServiceCenterAddr) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetSendSmsServiceCenterAddr) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetSendSmsServiceCenterAddr *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetSendSmsServiceCenterAddr *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetSendSmsServiceCenterAddr;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->addr_length = *addr_length;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(addr, opar->addr, sizeof(opar->addr));
    *addr_length = opar->addr_length;
    *addr_type = opar->addr_type;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetSendSmsTPDU
bool CFW_SatGetSendSmsTPDU(uint8_t tpdu[255], uint8_t *tpdu_length, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetSendSmsTPDU *ipar;
    struct OPAR_CFW_SatGetSendSmsTPDU *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetSendSmsTPDU) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetSendSmsTPDU) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetSendSmsTPDU *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetSendSmsTPDU *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetSendSmsTPDU;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->tpdu_length = *tpdu_length;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(tpdu, opar->tpdu, sizeof(opar->tpdu));
    *tpdu_length = opar->tpdu_length;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetSendSmsAlpha
bool CFW_SatGetSendSmsAlpha(uint8_t alpha[255], uint8_t *alpha_length, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetSendSmsAlpha *ipar;
    struct OPAR_CFW_SatGetSendSmsAlpha *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetSendSmsAlpha) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetSendSmsAlpha) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetSendSmsAlpha *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetSendSmsAlpha *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetSendSmsAlpha;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->alpha_length = *alpha_length;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(alpha, opar->alpha, sizeof(opar->alpha));
    *alpha_length = opar->alpha_length;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetDisplayText
bool CFW_SatGetDisplayText(uint8_t text[255], uint8_t *text_length, uint8_t *dcs, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetDisplayText *ipar;
    struct OPAR_CFW_SatGetDisplayText *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetDisplayText) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetDisplayText) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetDisplayText *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetDisplayText *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetDisplayText;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->text_length = *text_length;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(text, opar->text, sizeof(opar->text));
    *text_length = opar->text_length;
    *dcs = opar->dcs;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetGetInKeyText
bool CFW_SatGetGetInKeyText(uint8_t text[255], uint8_t *text_length, uint8_t *dcs, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetGetInKeyText *ipar;
    struct OPAR_CFW_SatGetGetInKeyText *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetGetInKeyText) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetGetInKeyText) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetGetInKeyText *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetGetInKeyText *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetGetInKeyText;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->text_length = *text_length;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(text, opar->text, sizeof(opar->text));
    *text_length = opar->text_length;
    *dcs = opar->dcs;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetGetInputText
bool CFW_SatGetGetInputText(uint8_t text[255], uint8_t *text_length, uint8_t *dcs, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetGetInputText *ipar;
    struct OPAR_CFW_SatGetGetInputText *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetGetInputText) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetGetInputText) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetGetInputText *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetGetInputText *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetGetInputText;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->text_length = *text_length;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(text, opar->text, sizeof(opar->text));
    *text_length = opar->text_length;
    *dcs = opar->dcs;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetGetInputLengthRange
bool CFW_SatGetGetInputLengthRange(uint8_t *max_len, uint8_t *min_len, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetGetInputLengthRange *ipar;
    struct OPAR_CFW_SatGetGetInputLengthRange *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetGetInputLengthRange) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetGetInputLengthRange) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetGetInputLengthRange *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetGetInputLengthRange *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetGetInputLengthRange;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *max_len = opar->max_len;
    *min_len = opar->min_len;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetGetInputDefaultText
bool CFW_SatGetGetInputDefaultText(uint8_t text[255], uint8_t *text_length, uint8_t *dcs, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetGetInputDefaultText *ipar;
    struct OPAR_CFW_SatGetGetInputDefaultText *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetGetInputDefaultText) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetGetInputDefaultText) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetGetInputDefaultText *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetGetInputDefaultText *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetGetInputDefaultText;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->text_length = *text_length;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(text, opar->text, sizeof(opar->text));
    *text_length = opar->text_length;
    *dcs = opar->dcs;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetSetupCallText
bool CFW_SatGetSetupCallText(uint8_t stage, uint8_t text[255], uint8_t *text_length, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetSetupCallText *ipar;
    struct OPAR_CFW_SatGetSetupCallText *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetSetupCallText) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetSetupCallText) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetSetupCallText *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetSetupCallText *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetSetupCallText;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->stage = stage;
    ipar->text_length = *text_length;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(text, opar->text, sizeof(opar->text));
    *text_length = opar->text_length;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetSetupCallAddr
bool CFW_SatGetSetupCallAddr(uint8_t which, uint8_t addr[255], uint8_t *addr_length, uint8_t *addr_type, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetSetupCallAddr *ipar;
    struct OPAR_CFW_SatGetSetupCallAddr *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetSetupCallAddr) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetSetupCallAddr) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetSetupCallAddr *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetSetupCallAddr *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetSetupCallAddr;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->which = which;
    ipar->addr_length = *addr_length;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(addr, opar->addr, sizeof(opar->addr));
    *addr_length = opar->addr_length;
    *addr_type = opar->addr_type;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetSetupCallCapCfg
bool CFW_SatGetSetupCallCapCfg(uint8_t cfg[255], uint8_t *cfg_length, uint8_t *unit, uint8_t *interval, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetSetupCallCapCfg *ipar;
    struct OPAR_CFW_SatGetSetupCallCapCfg *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetSetupCallCapCfg) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetSetupCallCapCfg) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetSetupCallCapCfg *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetSetupCallCapCfg *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetSetupCallCapCfg;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->cfg_length = *cfg_length;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(cfg, opar->cfg, sizeof(opar->cfg));
    *cfg_length = opar->cfg_length;
    *unit = opar->unit;
    *interval = opar->interval;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetSendSSDisplayInfo
bool CFW_SatGetSendSSDisplayInfo(uint8_t text[255], uint8_t *text_length, uint8_t *icon_identifier, uint8_t *icon_qualifier, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetSendSSDisplayInfo *ipar;
    struct OPAR_CFW_SatGetSendSSDisplayInfo *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetSendSSDisplayInfo) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetSendSSDisplayInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetSendSSDisplayInfo *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetSendSSDisplayInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetSendSSDisplayInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->text_length = *text_length;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(text, opar->text, sizeof(opar->text));
    *text_length = opar->text_length;
    *icon_identifier = opar->icon_identifier;
    *icon_qualifier = opar->icon_qualifier;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetSendSSInfo
bool CFW_SatGetSendSSInfo(uint8_t ss[255], uint8_t *ss_length, uint8_t *ss_type, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetSendSSInfo *ipar;
    struct OPAR_CFW_SatGetSendSSInfo *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetSendSSInfo) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetSendSSInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetSendSSInfo *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetSendSSInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetSendSSInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->ss_length = *ss_length;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(ss, opar->ss, sizeof(opar->ss));
    *ss_length = opar->ss_length;
    *ss_type = opar->ss_type;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetSendUSSDDisplayInfo
bool CFW_SatGetSendUSSDDisplayInfo(uint8_t text[255], uint8_t *text_length, uint8_t *icon_identifier, uint8_t *icon_qualifier, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetSendUSSDDisplayInfo *ipar;
    struct OPAR_CFW_SatGetSendUSSDDisplayInfo *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetSendUSSDDisplayInfo) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetSendUSSDDisplayInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetSendUSSDDisplayInfo *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetSendUSSDDisplayInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetSendUSSDDisplayInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->text_length = *text_length;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(text, opar->text, sizeof(opar->text));
    *text_length = opar->text_length;
    *icon_identifier = opar->icon_identifier;
    *icon_qualifier = opar->icon_qualifier;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetSendUSSDInfo
bool CFW_SatGetSendUSSDInfo(uint8_t ussd[255], uint8_t *ussd_length, uint8_t *dcs, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetSendUSSDInfo *ipar;
    struct OPAR_CFW_SatGetSendUSSDInfo *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetSendUSSDInfo) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetSendUSSDInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetSendUSSDInfo *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetSendUSSDInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetSendUSSDInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->ussd_length = *ussd_length;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(ussd, opar->ussd, sizeof(opar->ussd));
    *ussd_length = opar->ussd_length;
    *dcs = opar->dcs;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetSendDTMFInfo
bool CFW_SatGetSendDTMFInfo(uint8_t text[255], uint8_t *text_length, uint8_t dtmf[255], uint8_t *dtmf_length, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetSendDTMFInfo *ipar;
    struct OPAR_CFW_SatGetSendDTMFInfo *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetSendDTMFInfo) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetSendDTMFInfo) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetSendDTMFInfo *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetSendDTMFInfo *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetSendDTMFInfo;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->text_length = *text_length;
    ipar->dtmf_length = *dtmf_length;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(text, opar->text, sizeof(opar->text));
    *text_length = opar->text_length;
    memcpy(dtmf, opar->dtmf, sizeof(opar->dtmf));
    *dtmf_length = opar->dtmf_length;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetSendDTMFText
bool CFW_SatGetSendDTMFText(uint8_t text[255], uint8_t *text_length, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetSendDTMFText *ipar;
    struct OPAR_CFW_SatGetSendDTMFText *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetSendDTMFText) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetSendDTMFText) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetSendDTMFText *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetSendDTMFText *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetSendDTMFText;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->text_length = *text_length;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(text, opar->text, sizeof(opar->text));
    *text_length = opar->text_length;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetSendDTMF
bool CFW_SatGetSendDTMF(uint8_t dtmf[255], uint8_t *dtmf_length, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetSendDTMF *ipar;
    struct OPAR_CFW_SatGetSendDTMF *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetSendDTMF) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetSendDTMF) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetSendDTMF *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetSendDTMF *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetSendDTMF;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->dtmf_length = *dtmf_length;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(dtmf, opar->dtmf, sizeof(opar->dtmf));
    *dtmf_length = opar->dtmf_length;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetSetupIdleMode
bool CFW_SatGetSetupIdleMode(uint8_t mode_text[255], uint8_t *mode_text_length, uint8_t *dcs, uint8_t *icon_identifier, uint8_t *icon_qualifier, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetSetupIdleMode *ipar;
    struct OPAR_CFW_SatGetSetupIdleMode *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetSetupIdleMode) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetSetupIdleMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetSetupIdleMode *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetSetupIdleMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetSetupIdleMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->mode_text_length = *mode_text_length;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(mode_text, opar->mode_text, sizeof(opar->mode_text));
    *mode_text_length = opar->mode_text_length;
    *dcs = opar->dcs;
    *icon_identifier = opar->icon_identifier;
    *icon_qualifier = opar->icon_qualifier;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetLanguageNotification
bool CFW_SatGetLanguageNotification(uint8_t language[2], CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetLanguageNotification *ipar;
    struct OPAR_CFW_SatGetLanguageNotification *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetLanguageNotification) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetLanguageNotification) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetLanguageNotification *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetLanguageNotification *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetLanguageNotification;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    memcpy(language, opar->language, sizeof(opar->language));
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SatGetPlayTone
bool CFW_SatGetPlayTone(uint8_t *tone, uint8_t *unit, uint8_t *interval, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SatGetPlayTone *ipar;
    struct OPAR_CFW_SatGetPlayTone *opar;
    bool result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SatGetPlayTone) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SatGetPlayTone) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SatGetPlayTone *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SatGetPlayTone *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SatGetPlayTone;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    *tone = opar->tone;
    *unit = opar->unit;
    *interval = opar->interval;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_nvSetCopsTimer
uint32_t CFW_nvSetCopsTimer(uint8_t nValue)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_nvSetCopsTimer *ipar;
    struct OPAR_CFW_nvSetCopsTimer *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_nvSetCopsTimer) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_nvSetCopsTimer) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_nvSetCopsTimer *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_nvSetCopsTimer *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvSetCopsTimer;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nValue = nValue;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_nvGetCopsTimer
uint32_t CFW_nvGetCopsTimer(void)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct OPAR_CFW_nvGetCopsTimer *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + 0 + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_nvGetCopsTimer) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    opar = (struct OPAR_CFW_nvGetCopsTimer *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_nvGetCopsTimer;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;

    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#if defined(CSG_SUPPORT)
#ifndef DISABLE_RPC_CFW_NwSetCsgMode
uint32_t CFW_NwSetCsgMode(uint8_t nMode, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwSetCsgMode *ipar;
    struct OPAR_CFW_NwSetCsgMode *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwSetCsgMode) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwSetCsgMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwSetCsgMode *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwSetCsgMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwSetCsgMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nMode = nMode;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#if defined(CSG_SUPPORT)
#ifndef DISABLE_RPC_CFW_NwGetCsgMode
uint32_t CFW_NwGetCsgMode(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwGetCsgMode *ipar;
    struct OPAR_CFW_NwGetCsgMode *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwGetCsgMode) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwGetCsgMode) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwGetCsgMode *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwGetCsgMode *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwGetCsgMode;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#endif

#ifndef DISABLE_RPC_CFW_NwSetMaxAttFailForIratReq
uint32_t CFW_NwSetMaxAttFailForIratReq(uint8_t nMaxNum, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_NwSetMaxAttFailForIratReq *ipar;
    struct OPAR_CFW_NwSetMaxAttFailForIratReq *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_NwSetMaxAttFailForIratReq) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_NwSetMaxAttFailForIratReq) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_NwSetMaxAttFailForIratReq *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_NwSetMaxAttFailForIratReq *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_NwSetMaxAttFailForIratReq;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nMaxNum = nMaxNum;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_GetDefaultPcoControl
uint8_t CFW_GetDefaultPcoControl(CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_GetDefaultPcoControl *ipar;
    struct OPAR_CFW_GetDefaultPcoControl *opar;
    uint8_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_GetDefaultPcoControl) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_GetDefaultPcoControl) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_GetDefaultPcoControl *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_GetDefaultPcoControl *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_GetDefaultPcoControl;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_CFW_SetDefaultPcoControl
uint32_t CFW_SetDefaultPcoControl(uint8_t nValue, CFW_SIM_ID nSimID)
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_CFW_SetDefaultPcoControl *ipar;
    struct OPAR_CFW_SetDefaultPcoControl *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_CFW_SetDefaultPcoControl) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_CFW_SetDefaultPcoControl) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_CFW_SetDefaultPcoControl *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_CFW_SetDefaultPcoControl *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_CFW_SetDefaultPcoControl;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    ipar->nValue = nValue;
    ipar->nSimID = nSimID;
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

#ifndef DISABLE_RPC_PCNgisYfirev
uint32_t PCNgisYfirev(uint8_t input[50])
{
    uint32_t ivar_size, ovar_size, call_size, rsp_size, mem_size;

    void *mem;
    rpcCallHeader_t *call;
    int rpc_result;
    struct IPAR_PCNgisYfirev *ipar;
    struct OPAR_PCNgisYfirev *opar;
    uint32_t result;


    ivar_size = 0;
    ovar_size = 0;
    call_size = sizeof(rpcCallHeader_t) + sizeof(struct IPAR_PCNgisYfirev) + ivar_size;
    rsp_size = sizeof(rpcRespHeader_t) + sizeof(struct OPAR_PCNgisYfirev) + ovar_size;
    mem_size = (call_size > rsp_size) ? call_size : rsp_size;
    mem = (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT) ? malloc(mem_size) : alloca(mem_size);
    call = (rpcCallHeader_t *)mem;
    ipar = (struct IPAR_PCNgisYfirev *)((char *)mem + sizeof(rpcCallHeader_t));
    opar = (struct OPAR_PCNgisYfirev *)((char *)mem + sizeof(rpcRespHeader_t));
    call->h.size = call_size;
    call->api_tag = TAG_PCNgisYfirev;
    call->caller_rsp_ptr = (uint32_t)mem;
    call->rsp_size = rsp_size;
    memcpy(ipar->input, input, sizeof(ipar->input));
    rpc_result = rpcSendCall(RPC_CHANNEL, call);
    (void)rpc_result;
    result = opar->result;
    if (rpc_result == -2 /*ENOENT*/)
        result = ERR_NOT_SUPPORT;
    if (mem_size > CONFIG_RPC_SEND_STACK_ALLOCA_LIMIT)
        free(mem);
    return result;
}
#endif

// AUTO GENERATED END
